<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Patience Sorted</title>
<description>&lt;p&gt;I gave a lightning talk today about patience sorting and its application to the longest increasing subsequence problem. It&amp;#8217;s a subject I&amp;#8217;ve &lt;a href="http://wordaligned.org/articles/patience-sort.html" title="Patience sort and the longest increasing subsequence"&gt;written about&lt;/a&gt; before. My computer has been put through several million simulations. I&amp;#8217;ve even coded up a &lt;a href="http://wordaligned.org/pages/psort"&gt;javascript demo&lt;/a&gt; which deals out virtual playing cards and sorts them at the click of a button.
&lt;/p&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
var zz = 0;

var xtop  = ["330px", "302px", "275px", "255px", "234px", "209px", "187px", "158px", "128px", "99px", "70px", "43px", "15px"];
var ytop  = ["26px", "30px", "28px", "29px", "31px", "28px", "27px", "28px", "28px", "30px", "26px", "30px", "29px"];
var xpile = ["10px", "13px", "12px", "115px", "14px", "220px", "220px", "319px", "15px", "216px", "118px", "118px", "321px"];
var ypile = ["205px", "233px", "266px", "206px", "295px", "206px", "236px", "209px", "325px", "267px", "235px", "263px", "234px"];
var result = ["#card7", "#card6", "#card3", "#card2"];

function reset_cards() {
    jQuery("img").stop();
    zz += 13;
    for (var j = 0; j != 13; ++j, --zz) {
        jQuery("#card" + j)
        .css({"z-index":zz, "margin-left":xtop[j], "margin-top":ytop[j], "border-width":0});
    }
    zz += 13;
}

function lis(j) {
    var it = jQuery(result[j]);
    if (it.length &gt; 0) {
        it.animate({borderWidth : "5px"}, "slow", 0, function(){lis(++j);});
    }
}

function psort(j) {
    var it = jQuery("#card"+j);
    if (it.length != 0) {
        it
        .animate({marginLeft : xpile[j], marginTop: ypile[j]}, "slow", 0, function(){psort(++j);})
        .css({"z-index" : ++zz});
    } else {
        lis(0);
    }
}

function animate() {
    reset_cards();
    psort(0);
}
&lt;/script&gt;

&lt;div class="cardtable" style="background-color: #093; width:440px; height:480px;"&gt;
&lt;img id="card0" style="border: 0 orange solid; position: absolute; margin-left: 330px; margin-top: 27px; z-index: 13;" src="http://wordaligned.org/images/cards/1s.png" alt="Ace of Spades"/&gt;
&lt;img id="card1" style="border: 0 orange solid; position: absolute; margin-left: 302px; margin-top: 27px; z-index: 12;" src="http://wordaligned.org/images/cards/10s.png" alt="10 of Spades"/&gt;
&lt;img id="card2" style="border: 0 orange solid; position: absolute; margin-left: 275px; margin-top: 27px; z-index: 11;" src="http://wordaligned.org/images/cards/6s.png" alt="6 of Spades"/&gt;
&lt;img id="card3" style="border: 0 orange solid; position: absolute; margin-left: 255px; margin-top: 26px; z-index: 10;" src="http://wordaligned.org/images/cards/7s.png" alt="7 of Spades"/&gt;
&lt;img id="card4" style="border: 0 orange solid; position: absolute; margin-left: 234px; margin-top: 28px; z-index: 9;" src="http://wordaligned.org/images/cards/5s.png" alt="5 of Spades"/&gt;
&lt;img id="card5" style="border: 0 orange solid; position: absolute; margin-left: 209px; margin-top: 26px; z-index: 8;" src="http://wordaligned.org/images/cards/13s.png" alt="King of Spades"/&gt;
&lt;img id="card6" style="border: 0 orange solid; position: absolute; margin-left: 187px; margin-top: 31px; z-index: 7;" src="http://wordaligned.org/images/cards/9s.png" alt="9 of Spades"/&gt;
&lt;img id="card7" style="border: 0 orange solid; position: absolute; margin-left: 158px; margin-top: 27px; z-index: 6;" src="http://wordaligned.org/images/cards/12s.png" alt="Queen of Spades"/&gt;
&lt;img id="card8" style="border: 0 orange solid; position: absolute; margin-left: 128px; margin-top: 29px; z-index: 5;" src="http://wordaligned.org/images/cards/2s.png" alt="2 of Spades"/&gt;
&lt;img id="card9" style="border: 0 orange solid; position: absolute; margin-left: 99px; margin-top: 29px; z-index: 4;" src="http://wordaligned.org/images/cards/8s.png" alt="8 of Spades"/&gt;
&lt;img id="card10" style="border: 0 orange solid; position: absolute; margin-left: 70px; margin-top: 26px; z-index: 3;" src="http://wordaligned.org/images/cards/4s.png" alt="4 of Spades"/&gt;
&lt;img id="card11" style="border: 0 orange solid; position: absolute; margin-left: 43px; margin-top: 27px; z-index: 2;" src="http://wordaligned.org/images/cards/3s.png" alt="3 of Spades"/&gt;
&lt;img id="card12" style="border: 0 orange solid; position: absolute; margin-left: 15px; margin-top: 28px; z-index: 1;" src="http://wordaligned.org/images/cards/11s.png" alt="Knave of Spades"/&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;button onclick="reset_cards();"&gt;Reset&lt;/button&gt;&lt;button onclick="animate();"&gt;Play&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Today I used real playing cards; a linen-finished standard deck. For any talk it&amp;#8217;s nice to have a prop.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/8558343442/" title="Rock &amp;amp; Pop Legends by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm9.staticflickr.com/8100/8558343442_0402f04e83.jpg" width="500" height="361" alt="Rock &amp;amp; Pop Legends"&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Now, I &lt;strong&gt;thought&lt;/strong&gt; I understood the patience sort algorithm but until yesterday I&amp;#8217;d never actually played it with real cards. I&amp;#8217;ve been surprised by how much this physical dimension has developed my understanding.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ll be testing my new cards on some other sorting algorithms; I have high hopes. It would be good to find a similarly simple prop for linked data structures so I can balance trees, flip lists and walk graphs.
&lt;/p&gt;</description>
<dc:date>2013-03-14</dc:date>
<guid>http://wordaligned.org/articles/patience-sorted</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/patience-sorted</link>
<category>Algorithms</category>
</item>

<item>
<title>Singly Linked Lists in C++</title>
<description>&lt;p&gt;In a &lt;a href="http://wordaligned.org/articles/two-star-programming.html"&gt;recent post&lt;/a&gt; I wrote about removing items from a singly linked list. I presented a couple of alternative implementations, and in the comments section readers suggested yet more versions.
&lt;/p&gt;
&lt;p&gt;My implementations were written in C: the post was inspired by something &lt;a href="http://meta.slashdot.org/story/12/10/11/0030249/linus-torvalds-answers-your-questions"&gt;Linus Torvalds had said&lt;/a&gt; about low-level programming skills, and I&amp;#8217;m guessing he meant C programming skills. The fact is, C programmers are condemned to reimplement these basic functions on this basic structure because the C standard library has nothing to say about singly linked lists. Until recently the C++ standard library was similarly silent on the subject, only offering a doubly linked list.
&lt;/p&gt;

&lt;h3&gt;C++ introduces &amp;#8230; the linked list!&lt;/h3&gt;
&lt;p&gt;That&amp;#8217;s all changed now with the introduction of &lt;code&gt;std::forward_list&lt;/code&gt;. The &lt;a href="http://en.cppreference.com/w/cpp/container/forward_list"&gt;class interface&lt;/a&gt; doesn&amp;#8217;t mention links or pointers but a quick glance through its contents makes it clear that if you imagine the container to be a templated version of a classic singly-linked list, you won&amp;#8217;t go far wrong.
&lt;/p&gt;
&lt;p&gt;This gives &lt;code&gt;forward_list&lt;/code&gt; some members you won&amp;#8217;t find elsewhere in the &lt;code&gt;std::&lt;/code&gt; namespace. For example, &lt;code&gt;std::forward_list::before_begin()&lt;/code&gt;, which returns an iterator just before the beginning of the list &amp;#8212; much as the more familiar &lt;code&gt;end()&lt;/code&gt; is just past the end.
&lt;/p&gt;
&lt;p&gt;Why is &lt;code&gt;before_begin()&lt;/code&gt; necessary? You can&amp;#8217;t dereference it and you can&amp;#8217;t reverse through a forward list till you get to it. Well, since forward list iterators can only go forwards, instead of the familiar sequence &lt;code&gt;insert()&lt;/code&gt;, &lt;code&gt;erase()&lt;/code&gt; and &lt;code&gt;emplace()&lt;/code&gt; methods we have &lt;code&gt;insert_after()&lt;/code&gt;, &lt;code&gt;erase_after()&lt;/code&gt; and &lt;code&gt;emplace_after()&lt;/code&gt;, not to mention &lt;code&gt;splice_after()&lt;/code&gt;. The before-the-beginning iterator allows you to use these operations to modify the node at the head of the list.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quick question&lt;/strong&gt;: what&amp;#8217;s the complexity of &lt;code&gt;std::list::size()&lt;/code&gt;?
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Trick question&lt;/strong&gt;: and how about &lt;code&gt;std::forward_list::size()&lt;/code&gt;?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Remove_if for forward lists&lt;/h3&gt;
&lt;p&gt;Using pointers-to-pointers to modify linked lists gives this elegant and compact C implementation of &lt;code&gt;remove_if()&lt;/code&gt;, which de-lists all nodes which match a supplied predicate.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;void remove_if(node ** head, remove_fn rm)
{
    for (node** curr = head; *curr; )
    {
        node * entry = *curr;
        if (rm(entry))
        {
            *curr = entry-&amp;gt;next;
            free(entry);
        }
        else
            curr = &amp;amp;entry-&amp;gt;next;
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How does the C++ standard library support this algorithm?
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.cppreference.com/w/cpp/algorithm/remove"&gt;&lt;code&gt;Std::remove_if()&lt;/code&gt;&lt;/a&gt; operates on an iterator range, &lt;code&gt;remove_if(first, last, pred)&lt;/code&gt;. All it requires is that the iterators are forward iterators so it should just work on a &lt;code&gt;forward_list&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Hang on though: what if &lt;code&gt;pred(*first)&lt;/code&gt; is true? How can a node be removed from a linked list without reference to its predecessor? Actually, the node isn&amp;#8217;t removed &amp;#8212; the value it contains gets overwritten by the value in the first node (if any!) for which the predicate returns false. In fact, &lt;code&gt;remove_if&lt;/code&gt; &lt;strong&gt;doesn&amp;#8217;t remove anything&lt;/strong&gt; from the container! What it does is return an iterator, call it &lt;code&gt;new_last&lt;/code&gt;, such that the range &lt;code&gt;(first, new_last)&lt;/code&gt; holds the elements which have been kept, and &lt;code&gt;(new_last, last)&lt;/code&gt; holds those which have been &amp;#8220;removed&amp;#8221;, which is to say they can still be dereferenced but their value is implementation dependent.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Remove_if&lt;/code&gt; usually pairs up with erase:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;container.erase(remove_if(first, last, pred), last);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;There is no &lt;code&gt;std::forward_list::erase(iterator)&lt;/code&gt; &amp;#8212; remember, we can only erase &lt;strong&gt;after&lt;/strong&gt; &amp;#8212; so the usual remove_if algorithm is of little use for forward lists.
&lt;/p&gt;

&lt;h3&gt;Forward_list::remove_if()&lt;/h3&gt;
&lt;p&gt;As usual, we should &lt;a href="http://www.informit.com/articles/article.aspx?p=21851" title="Scott Meyers, Effective STL"&gt;prefer member functions to algorithms with the same names&lt;/a&gt;. C++&amp;#8217;s &lt;code&gt;forward_list&lt;/code&gt; has its very own &lt;code&gt;remove_if&lt;/code&gt; which manipulates pointers rather than moves values, and which really does remove and destroy items.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.cppreference.com/w/cpp/container/forward_list/remove"&gt;&lt;code&gt;Forward_list::remove_if()&lt;/code&gt;&lt;/a&gt; operates on the list as a whole, not an iterator range &amp;#8212; as we&amp;#8217;ve seen, an iterator cannot remove itself. I took a look at a couple of implementations of this function to see how it&amp;#8217;s done.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s LLVM&amp;#8217;s libc++ &lt;a href="http://llvm.org/svn/llvm-project/libcxx/trunk/include/forward_list"&gt;implementation&lt;/a&gt;:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;class _Tp, class _Alloc&amp;gt;
template &amp;lt;class _Predicate&amp;gt;
void
forward_list&amp;lt;_Tp, _Alloc&amp;gt;::remove_if(_Predicate __pred)
{
    iterator __e = end();
    for (iterator __i = before_begin(); __i.__ptr_-&amp;gt;__next_ != nullptr;)
    {
        if (__pred(__i.__ptr_-&amp;gt;__next_-&amp;gt;__value_))
        {
            iterator __j = _VSTD::next(__i, 2);
            for (; __j != __e &amp;amp;&amp;amp; __pred(*__j); ++__j)
                ;
            erase_after(__i, __j);
            if (__j == __e)
                break;
            __i = __j;
        }
        else
            ++__i;
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;There&amp;#8217;s no need for any special treatment of the first list node here, since we have its predecessor, the &lt;code&gt;before_begin()&lt;/code&gt; node. The function does double back though, figuring out the next range to erase before going back to erase it &amp;#8212; and the erase function isn&amp;#8217;t pretty.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;class _Tp, class _Alloc&amp;gt;
typename forward_list&amp;lt;_Tp, _Alloc&amp;gt;::iterator
forward_list&amp;lt;_Tp, _Alloc&amp;gt;::erase_after(const_iterator __f, const_iterator __l)
{
    __node_pointer __e = const_cast&amp;lt;__node_pointer&amp;gt;(__l.__ptr_);
    if (__f != __l)
    {
        __node_pointer __p = const_cast&amp;lt;__node_pointer&amp;gt;(__f.__ptr_);
        __node_pointer __n = __p-&amp;gt;__next_;
        if (__n != __e)
        {
            __p-&amp;gt;__next_ = __e;
            __node_allocator&amp;amp; __a = base::__alloc();
            do
            {
                __p = __n-&amp;gt;__next_;
                __node_traits::destroy(__a, _VSTD::addressof(__n-&amp;gt;__value_));
                __node_traits::deallocate(__a, __n, 1);
                __n = __p;
            } while (__n != __e);
        }
    }
    return iterator(__e);
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;For comparison, here&amp;#8217;s how GCC&amp;#8217;s &lt;a href="http://gcc.gnu.org/viewcvs/trunk/libstdc%2B%2B-v3/include/bits/forward_list.tcc?view=markup"&gt;libstdc++ does the same thing&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename _Tp, typename _Alloc&amp;gt;
    template&amp;lt;typename _Pred&amp;gt;
      void
      forward_list&amp;lt;_Tp, _Alloc&amp;gt;::
      remove_if(_Pred __pred)
      {
	_Node* __curr = static_cast&amp;lt;_Node*&amp;gt;(&amp;amp;this-&amp;gt;_M_impl._M_head);
        while (_Node* __tmp = static_cast&amp;lt;_Node*&amp;gt;(__curr-&amp;gt;_M_next))
          {
            if (__pred(*__tmp-&amp;gt;_M_valptr()))
              this-&amp;gt;_M_erase_after(__curr);
            else
              __curr = static_cast&amp;lt;_Node*&amp;gt;(__curr-&amp;gt;_M_next);
          }
      }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, erasing (after a) node reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename _Tp, typename _Alloc&amp;gt;
    _Fwd_list_node_base*
    _Fwd_list_base&amp;lt;_Tp, _Alloc&amp;gt;::
    _M_erase_after(_Fwd_list_node_base* __pos)
    {
      _Node* __curr = static_cast&amp;lt;_Node*&amp;gt;(__pos-&amp;gt;_M_next);
      __pos-&amp;gt;_M_next = __curr-&amp;gt;_M_next;
      _Tp_alloc_type __a(_M_get_Node_allocator());
      allocator_traits&amp;lt;_Tp_alloc_type&amp;gt;::destroy(__a, __curr-&amp;gt;_M_valptr());
      __curr-&amp;gt;~_Node();
      _M_put_node(__curr);
      return __pos-&amp;gt;_M_next;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This version walks through the list removing nodes which match the predicate as it finds them. Don&amp;#8217;t be confused by &lt;code&gt;&amp;amp;this-&amp;gt;_M_impl._M_head&lt;/code&gt;: it&amp;#8217;s not the node at the head of the list, it&amp;#8217;s the one before.
&lt;/p&gt;

&lt;h3&gt;Lessons from C++&lt;/h3&gt;
&lt;p&gt;Maybe this code wouldn&amp;#8217;t persaude Linus Torvalds to rethink &lt;a href="http://harmful.cat-v.org/software/c++/linus" title="C++ is a horrible language"&gt;his opinion of C++&lt;/a&gt;, but if you can see past the angle brackets, underscores and allocators, it&amp;#8217;s simple enough.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s also:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     subtle, so I&amp;#8217;m glad someone else has written and checked it
 &lt;/li&gt;

 &lt;li&gt;
     generic, so I can put what I want in a list without casting or indirection
 &lt;/li&gt;

 &lt;li&gt;
     standard, so I know what to expect
 &lt;/li&gt;

 &lt;li&gt;
     supported
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The before-begin node idea serves &lt;a href="http://wordaligned.org/articles/two-star-programming.html#comment-760751047"&gt;equally well in C&lt;/a&gt;, enabling list modifiers which have no need of double indirection or special case code for the list head.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;void remove_after(node * prev, remove_fn rm)
{
    while (prev-&amp;gt;next != NULL)
    {
        node * curr = prev-&amp;gt;next;
        if (rm(curr))
        {
            prev-&amp;gt;next = curr-&amp;gt;next;
            free(curr);
        }
        else
            prev = curr;
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Pass this function the before-begin node to remove all items from the list which match the predicate. 
&lt;/p&gt;</description>
<dc:date>2013-02-07</dc:date>
<guid>http://wordaligned.org/articles/singly-linked-lists-in-c++</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/singly-linked-lists-in-c++</link>
<category>Algorithms</category>
</item>

<item>
<title>Two star programming</title>
<description>&lt;p&gt;A few weeks ago &lt;a href="http://meta.slashdot.org/story/12/10/11/0030249/linus-torvalds-answers-your-questions"&gt;Linus Torvalds answered some questions&lt;/a&gt; on slashdot. All his responses make good reading but one in particular caught my eye. Asked to describe his favourite kernel hack, Torvalds grumbles he rarely looks at code these days &amp;#8212; unless it&amp;#8217;s to sort out someone else&amp;#8217;s mess. He then pauses to admit he&amp;#8217;s proud of the kernel&amp;#8217;s fiendishly cunning filename lookup cache before continuing to moan about incompetence.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;At the opposite end of the spectrum, I actually wish more people understood the really core low-level kind of coding. Not big, complex stuff like the lockless name lookup, but simply good use of pointers-to-pointers etc. For example, I&amp;#8217;ve seen too many people who delete a singly-linked list entry by keeping track of the &lt;code&gt;prev&lt;/code&gt; entry, and then to delete the entry, doing something like
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (prev)
    prev-&amp;gt;next = entry-&amp;gt;next;
else
    list_head = entry-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and whenever I see code like that, I just go &amp;#8220;This person doesn&amp;#8217;t understand pointers&amp;#8221;. And it&amp;#8217;s sadly quite common.
&lt;/p&gt;
&lt;p&gt;People who understand pointers just use a &amp;#8220;pointer to the entry pointer&amp;#8221;, and initialize that with the address of the list_head. And then as they traverse the list, they can remove the entry without using any conditionals, by just doing a &lt;code&gt;*pp = entry-&amp;gt;next&lt;/code&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Well I &lt;em&gt;thought&lt;/em&gt; I understood pointers but, sad to say, if asked to implement a list removal function I too would have kept track of the previous list node. Here&amp;#8217;s a sketch of the code:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;This person doesn&amp;#8217;t understand pointers&lt;/div&gt;

&lt;pre class="prettyprint"&gt;typedef struct node
{
    struct node * next;
    ....
} node;

typedef bool (* remove_fn)(node const * v);

// Remove all nodes from the supplied list for which the 
// supplied remove function returns true.
// Returns the new head of the list.
node * remove_if(node * head, remove_fn rm)
{
    for (node * prev = NULL, * curr = head; curr != NULL; )
    {
        node * const next = curr-&amp;gt;next;
        if (rm(curr))
        {
            if (prev)
                prev-&amp;gt;next = next;
            else
                head = next;
            free(curr);
        }
        else
            prev = curr;
        curr = next;
    }
    return head;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The linked list is a simple but perfectly-formed structure built from nothing more than a pointer-per-node and a sentinel value, but the code to modify such lists can be subtle. No wonder linked lists feature in so many &lt;a href="https://www.google.com/search?q=linked+list+interview+questions" title="Search for linked list interview questions"&gt;interview questions&lt;/a&gt;!
&lt;/p&gt;
&lt;p&gt;The subtlety in the implementation shown above is the conditional required to handle any nodes removed from the head of the list.
&lt;/p&gt;
&lt;p&gt;Now let&amp;#8217;s look at the implementation Linus Torvalds had in mind. In this case we pass in a pointer to the list head, and the list traversal and modification is done using a pointer to the next pointers.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Two star programming&lt;/div&gt;

&lt;pre class="prettyprint"&gt;void remove_if(node ** head, remove_fn rm)
{
    for (node** curr = head; *curr; )
    {
        node * entry = *curr;
        if (rm(entry))
        {
            *curr = entry-&amp;gt;next;
            free(entry);
        }
        else
            curr = &amp;amp;entry-&amp;gt;next;
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Much better! The key insight is that the links in a linked list are pointers and so &lt;strong&gt;pointers to pointers&lt;/strong&gt; are the prime candidates for modifying such a list.
&lt;/p&gt;
&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;The improved version of &lt;code&gt;remove_if()&lt;/code&gt; is an example of two star programming: the doubled-up asterisks indicate two levels of indirection. A &lt;a href="http://c2.com/cgi/wiki?ThreeStarProgrammer"&gt;third star&lt;/a&gt; would be one too many.
&lt;/p&gt;</description>
<dc:date>2013-01-08</dc:date>
<guid>http://wordaligned.org/articles/two-star-programming</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/two-star-programming</link>
<category>Algorithms</category>
</item>

<item>
<title>Life goes on</title>
<description>&lt;p&gt;&lt;a href="http://www.flickr.com/photos/anachrocomputer/6951474448/" title="Testing the Wincor-Nixdorf Customer Display by anachrocomputer, on Flickr"&gt;&lt;img src="http://farm6.staticflickr.com/5340/6951474448_f83069b7cf.jpg" width="500" height="333" alt="Testing the Wincor-Nixdorf Customer Display"&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;In my &lt;a href="http://wordaligned.org/articles/life-on-canvas.html" title="Game of life"&gt;previous post&lt;/a&gt; I described John Conway&amp;#8217;s Game of Life as a &lt;a href="http://programmer.97things.oreilly.com/wiki/index.php/Learn_to_say_Hello_World" title="Learn to say 'Hello, World'"&gt;hello world&lt;/a&gt; for computer graphics. Actually, it goes beyond that. Hello world is a complete program, a proof the toolchain works, but it&amp;#8217;s not a particularly interesting program. An implementation of the game of life does more than demonstrate you can put pixels on screens: the evolution of those pixel colonies turns out to be a subject &lt;a href="http://pentadecathlon.com/lifeNews/2010/02/prime_numbers.html" title="A Life pattern to calculate prime numbers"&gt;worth studying&lt;/a&gt; in itself.
&lt;/p&gt;
&lt;p&gt;That said, I&amp;#8217;m primarily interested in Life as an exercise in learning new things. I&amp;#8217;ve continued to develop my &lt;a href="http://diveintohtml5.info/canvas.html" title="Mark Pilgrim dives into HTML5's canvas element"&gt;canvas&lt;/a&gt; implementation, adding some &lt;a href="http://jqueryui.com" title="The official jQuery user interface library"&gt;jQuery UI&lt;/a&gt; effects. The code is on &lt;a href="https://github.com/wordaligned/game-of-life.git" title="Wordaligned's game-of-life repository on Github"&gt;Github&lt;/a&gt; &amp;#8212; yes, it&amp;#8217;s high time I learned about that too &amp;#8212; though note there are dependencies on jQuery, jQuery UI, Imagemagick, and on pattern files downloaded from &lt;a href="http://www.conwaylife.com/wiki/Main_Page"&gt;conwaylife.com&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;A working version can be found at &lt;a href="http://wordaligned.org/life.html" title="Life on Canvas"&gt;wordaligned.org/life&lt;/a&gt;. Click the graphic below to give it a go. Your web client does support HTML5 Canvas, right?
&lt;/p&gt;
&lt;div style="border:1px solid #333"&gt;&lt;a href="http://wordaligned.org/life" title="Play the game of life"&gt;&lt;img src="http://wordaligned.org/images/life-on-canvas.png" alt="Play the game of life"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;hr /&gt;
   Thanks, &lt;a href="http://www.flickr.com/photos/anachrocomputer" title="anachrocomputer's photostream"&gt;anachrocomputer&lt;/a&gt;, for the delightful hello world photo
&lt;/p&gt;</description>
<dc:date>2012-06-29</dc:date>
<guid>http://wordaligned.org/articles/life-goes-on</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/life-goes-on</link>
<category>Algorithms</category>
</item>

<item>
<title>Life on Canvas</title>
<description>&lt;p&gt;I was lucky enough to be taught maths by &lt;a href="http://www.math.princeton.edu/directory/john-conway" title="John Conway, now at Princeton University"&gt;John Horton Conway&lt;/a&gt;, if only for an hour a week for a single term. He was lucky enough to be teaching number theory: a subject packed with treasures picked from the full history of mathematics.
&lt;/p&gt;
&lt;p&gt;I remember him as animated and unkempt. He bustled into that first lecture with a carrier bag and started pulling out groceries one by one. How many items were in the bag, he wondered? Could he count them all &amp;#8212; it was a &lt;em&gt;very&lt;/em&gt; large bag &amp;#8212; and what exactly did &lt;a href="http://mathworld.wolfram.com/Aleph-0.html" title="The 'small' infinite set of integers"&gt;infinity&lt;/a&gt; mean? Later I would see him pacing along Kings Parade dragging a shopping tolley, lost in thought.
&lt;/p&gt;
&lt;p&gt;Number theory may be as old as mathematics but it remains very much alive. Some 40 years ago Professor Conway discovered a primitive and novel mathematical life form: the Game of Life. 
&lt;/p&gt;
&lt;p&gt;The rules are simple. A colony of cells inhabits a two dimensional grid. At any one time each cell is either alive or dead, and as time advances the fate of a cell is determined entirely by its immediate 8 neighbours:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     reproduction: a dead cell with exactly 3 live neighbours becomes alive
 &lt;/li&gt;

 &lt;li&gt;
     survival: a live cell with 2 or 3 live neighbours lives on
 &lt;/li&gt;

 &lt;li&gt;
     overcrowding or loneliness: in all other cases the cell dies or stays dead
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In code, we might represent the colony as a two dimensional array filled with &lt;code&gt;1&lt;/code&gt;&amp;#8217;s and &lt;code&gt;0&lt;/code&gt;&amp;#8217;s for live and dead cells and code up the rules like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;// Determine the fate of cell i, j in the next generation.
// Return 1 for "lives", 0 for "dies"
function fate(cells, i, j) {
    var neighbours = [[-1,-1],[-1,0],[-1,1],
                      [0,-1],        [0,1],
                      [1,-1], [1,0], [1,1]];
        live_neighbours = 0;
    neighbours.forEach(function(n) { 
        live_neighbours += cells[i + n[0]][j + n[1]];
    });
    return (live_neighbours == 3 || 
            cells[i][j] == 1 &amp;amp;&amp;amp; live_neighbours == 2) ? 1 : 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It turns out these simple rules generate an astonishing ecosystem. Simple patterns flourish, evolving into complex patterns which, many generations later may decay into stable forms and repeating patterns, or, occasionally, become extinct. 
&lt;/p&gt;
&lt;p&gt;Can a finite pattern grow indefinitely? Conway originally conjectured no, this was impossible, offering $50 to the first person who could prove or disprove the his conjecture before the end of 1970. In November of that year a team from MIT led by Bill Gosper claimed the prize, disproving the conjecture with a glider gun pattern which spits out a new spaceship every 30 generations.
&lt;/p&gt;
&lt;img src=http://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif alt="Gosper's glider gun, Wikimedia commons" style="border:1px solid black;"&gt;

&lt;span id="continue-reading"/&gt;

&lt;p&gt;A 2 dimensional array can naturally be represented on the most basic computer screen &amp;#8212; think raster graphics, pixels &amp;#8212; and the parallel emergence and development of the personal computer helps explain life&amp;#8217;s continuing appeal&lt;a id="fn1link" href="http://wordaligned.org/articles/life-on-canvas#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;. The game of life has become the &lt;a href="http://programmer.97things.oreilly.com/wiki/index.php/Learn_to_Say_%22Hello%2C_World%22" title="Laern to say Hello, world"&gt;hello world&lt;/a&gt; of graphics frameworks. In 2012 we can use the HTML5 canvas, a 2 dimensional surface for drawing on.
&lt;/p&gt;
&lt;p&gt;&lt;canvas id="lifecanvas" width="480" height="320" style="border:1px solid black;"&gt;Unfortunately your client does not support the &lt;a href="http://www.w3.org/TR/html5/the-canvas-element.html#the-canvas-element"&gt;HTML5 canvas element&lt;/a&gt;. If you are using a feed reader, try visiting the &lt;a href="http://wordaligned.org/articles/life-on-canvas.html"&gt;original page&lt;/a&gt;.&lt;/canvas&gt;
   &lt;div&gt;
   &lt;button type="button" id="random" title="Random pattern" style="vertical-align:top;width:50px;height:50px;"&gt;&lt;img src="http://wordaligned.org/images/glyphicons_322_playing_dices.png" /&gt;&lt;/button&gt;
   &lt;button type="button" id="clear" title="Clear screen" style="vertical-align:top;width:50px;height:50px;"&gt;&lt;img src="http://wordaligned.org/images/glyphicons_192_circle_remove.png" /&gt;&lt;/button&gt;
   &lt;button type="button" id="toggle" title="Play/Pause" style="vertical-align:top;width:50px;height:50px;"&gt;&lt;img src="http://wordaligned.org/images/glyphicons_174_pause.png" /&gt;&lt;/button&gt;
   &lt;button type="button" id="step" title="Single step" style="vertical-align:top;width:50px;height:50px;"&gt;&lt;img src="http://wordaligned.org/images/glyphicons_178_step_forward.png" /&gt;&lt;/button&gt;
   &lt;button type="button" id="info" title="Help" style="vertical-align:top;width:50px;height:50px;"&gt;&lt;img src="http://wordaligned.org/images/glyphicons_195_circle_info.png" /&gt;&lt;/button&gt;
   &lt;/div&gt;
   &lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"&gt;&lt;/script&gt;
   &lt;script type="text/javascript" src="http://wordaligned.org/scripts/simple-life.js"&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;After a little experimentation you&amp;#8217;re sure to uncover life&amp;#8217;s three main domains: still lives, which remain unchanged; oscillators, which repeat; and spaceships, which move across the board. Then there are methuselahs, puffers, guns &amp;#8230;
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a pulsar, an oscillator with period 3.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/images/pulsar.gif" alt="Pulsar"/&gt;

&lt;p&gt;And here&amp;#8217;s a glider, classed as a diagonal spaceship, &lt;a href="http://www.catb.org/hacker-emblem/" title="When you put the glider emblem on your web page, or wear it on clothing, or display it in some other way, you are visibly associating yourself with the hacker culture"&gt;a pattern chosen&lt;/a&gt; by Eric S Raymond as a hackers&amp;#8217; emblem.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/images/glider.gif" alt="Glider, an orthogonal spaceship"/&gt;

&lt;p&gt;Here&amp;#8217;s another 5 cell pattern &amp;#8212; the R-pentomino. Clear the canvas, pick out an R-pentomino cluster of cells with the mouse, click play, and watch what evolves!
&lt;/p&gt;
&lt;img src="http://wordaligned.org/images/Rpentomino.png" alt="Rpentomino"/&gt;

&lt;p&gt;&lt;a href="http://www.conwaylife.com/wiki/Turtle" title="An orthogonal c/3 spaceship"&gt;Turtle&lt;/a&gt;, &lt;a href="http://www.conwaylife.com/wiki/Garden_of_Eden" title="A pattern that has no parents and thus can only occur in generation 0"&gt;garden&lt;/a&gt;, &lt;a href="http://www.conwaylife.com/wiki/Unicycle" title="Unicycle is a period 6 oscillator made up of four copies of unix"&gt;unicycle&lt;/a&gt;: animal, vegetable, mineral. The kingdom of life is inclusive and extensive, a delight for naturalists and taxonomists alike. It&amp;#8217;s seduced logophiles and lexicographers too: reading through Stephen A. Silver&amp;#8217;s comprehensive &lt;a href="http://www.argentum.freeserve.co.uk/lex.htm" title="A lexicon of terms relating to John Horton Conway's Game of Life, by Stephen Silver"&gt;Life Lexicon&lt;/a&gt;, I learned that an anteater consumes ants, a &lt;a href="http://www.argentum.freeserve.co.uk/lex_c.htm#caterpillar"&gt;caterpillar&lt;/a&gt; works by laying tracks at its front end, a baker&amp;#8217;s dozen is a loaf &lt;a href="http://www.argentum.freeserve.co.uk/lex_h.htm#hassler"&gt;hassled&lt;/a&gt; by two blocks and two caterers, and an &lt;a href="http://www.argentum.freeserve.co.uk/lex_a.htm#ak47reaction"&gt;AK47&lt;/a&gt; reaction occurs when a honey farm predecessor, catalysed by an eater and a block, reappears at another location 47 generations later, having produced a glider and a traffic light. I could go on&amp;#8230;
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/life-on-canvas#fn1link"&gt;[1]&lt;/a&gt;: I&amp;#8217;m glossing over details here. The true game of life is played out on an infinite grid, and patterns such as &lt;a href="http://en.wikipedia.org/wiki/Gun_(cellular_automaton)"&gt;Gosper&amp;#8217;s glider gun&lt;/a&gt; show that it really does have to be infinite. Computers have trouble with such an unconstrained requirement, and a computer animation might try and adapt the screen as the pattern grows, or limit the region of interest. Another approach is to wrap the canvas, left to right, top to bottom, so the game of life is played out on what&amp;#8217;s topologically a toriodal surface. That&amp;#8217;s what the canvas shown here does.
&lt;/p&gt;
&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;The icons used on this page were downloaded from &lt;a href="http://glyphicons.com"&gt;http://glyphicons.com&lt;/a&gt; and are licensed under the &lt;a href=http://creativecommons.org/licenses/by/3.0/deed.en&gt;CC BY 3.0&lt;/a&gt; terms. The animated gifs were placed in the public domain by their authors.
&lt;/p&gt;</description>
<dc:date>2012-06-27</dc:date>
<guid>http://wordaligned.org/articles/life-on-canvas</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/life-on-canvas</link>
<category>Algorithms</category>
</item>

<item>
<title>Equality and Equivalence</title>
<description>&lt;p&gt;&lt;a href="http://oracleofbacon.org"&gt;&lt;img style="float:right;" src="http://wordaligned.org/images/kevin-bacon.jpg" alt="Kevin Bacon mugshot"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;If A &amp;lt;= B and B &amp;lt;= A then A and B must be equal, right?
&lt;/p&gt;
&lt;p&gt;Wrong, actually.
&lt;/p&gt;
&lt;p&gt;We could rank actors according to their Bacon number, for example. Hugh Grant and Daniel Day-Lewis both have a &lt;a href="http://oracleofbacon.org" title="so says the Oracle of Bacon"&gt;Bacon number of 2&lt;/a&gt;, but that doesn&amp;#8217;t make them equal!
&lt;/p&gt;
&lt;p&gt;I think most programmers get the distinction between ordering and equality, but it&amp;#8217;s easy to forget.
&lt;/p&gt;
&lt;p&gt;Part of the problem is the less-than-or-&lt;strong&gt;equal&lt;/strong&gt;-to and greater-than-or-&lt;strong&gt;equal&lt;/strong&gt;-to operators both mention &lt;strong&gt;equal&lt;/strong&gt;. The standard programming representation of these operators includes a single equals symbol, whil the representation of equality has two equals symbols. Symbolically we might assume:
&lt;/p&gt;
&lt;pre style="font-size:400%"&gt;&amp;lt;= &lt;span style="color:#930;"&gt;&amp;and;&lt;/span&gt; &amp;gt;= &lt;span style="color:#930;"&gt;&amp;rArr;&lt;/span&gt; == &lt;/pre&gt;

&lt;p&gt;Wrong!
&lt;/p&gt;
&lt;div style="font-size:800%"&gt;&amp;#x2620;&lt;/div&gt;

&lt;p&gt;Another part of the problem is that we tend to think of numbers as archetypal objects: &lt;a href="http://www.google.com/search?q=%22when+in+doubt+do+as+the+ints+do%22" title="Scott Meyers advice"&gt;when in doubt, do as the ints do&lt;/a&gt;. For integers, it&amp;#8217;s true, equality and equivalence are the same. The same is true of real numbers, but what about their &lt;a href="http://docs.sun.com/source/806-3568/ncg_goldberg.html" title="What Every Computer Scientist Should Know About Floating-Point Arithmetic"&gt;floating point representations&lt;/a&gt;? A &lt;code&gt;NaN&lt;/code&gt; doesn&amp;#8217;t even equal itself. Complex numbers have no standard comparison operators.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; 3+4j == 4j+3
True
&amp;gt;&amp;gt;&amp;gt; 3+4j &amp;lt;= 4j+3
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
TypeError: no ordering relation is defined for complex numbers

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To avoid trouble, remember that the &lt;strong&gt;equal&lt;/strong&gt; in less-than-or-&lt;strong&gt;equal&lt;/strong&gt;-to should really be &lt;strong&gt;equivalent&lt;/strong&gt;. 
&lt;/p&gt;
&lt;p&gt;Oh, and please don&amp;#8217;t confuse equality with assignment.
&lt;/p&gt;</description>
<dc:date>2010-06-09</dc:date>
<guid>http://wordaligned.org/articles/equals-equals</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/equals-equals</link>
<category>Algorithms</category>
</item>

<item>
<title>Binary search revisited</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocrecap" name="toc0" id="toc0"&gt;Recap&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocthe-problem" name="toc1" id="toc1"&gt;The Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocinput-iterators" name="toc2" id="toc2"&gt;Input iterators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocfind" name="toc3" id="toc3"&gt;Find&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocrewrite-the-file" name="toc4" id="toc4"&gt;Rewrite the file!&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocadapting-iterators" name="toc5" id="toc5"&gt;Adapting iterators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocmultipass-iterator" name="toc6" id="toc6"&gt;Multipass iterator&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocnot-so-fast" name="toc7" id="toc7"&gt;Not so fast&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocbetter-than-find" name="toc8" id="toc8"&gt;Better than find&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocimplementation" name="toc9" id="toc9"&gt;Implementation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tochardware-used" name="toc10" id="toc10"&gt;Hardware used&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocconclusions" name="toc11" id="toc11"&gt;Conclusions&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc0" name="tocrecap" id="tocrecap"&gt;Recap&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recently &lt;a href="http://wordaligned.org/articles/binary-search.html"&gt;I wrote&lt;/a&gt; about C++&amp;#8217;s standard binary search algorithms (yes, four of them!) which do such a fine job of:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     specifying exactly what kind of range a binary search requires
 &lt;/li&gt;

 &lt;li&gt;
     separating the core algorithm from the details of the range it&amp;#8217;s working on
 &lt;/li&gt;

 &lt;li&gt;
     delivering precise results
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To support these claims I included an implementation of a file iterator, suitable for use with &lt;code&gt;std::binary_search()&lt;/code&gt; etc. to efficiently locate values in very large files.
&lt;/p&gt;
&lt;p&gt;Now, there are a couple of issues with this approach:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     we had to write a lot of code to make a file iterator suitable for use with standard algorithms
 &lt;/li&gt;

 &lt;li&gt;
     this file iterator only works on highly structured files, where each value occupies a fixed number of bytes
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this follow up article we&amp;#8217;ll consider each of these issues in a little more depth by working through two very different solutions to a related problem.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc1" name="tocthe-problem" id="tocthe-problem"&gt;The Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose, once again, that we have a large file, a few gigabytes, say. The file contains numbers, in order, and we&amp;#8217;re interested in testing if this file contains a given number. This time, though, the file is a text file, where the numbers are represented in the usual way as sequences of digits separated by whitespace.
&lt;/p&gt;
&lt;pre&gt;
$ less lots-of-numbers
...
10346  11467 11469 11472  11501 
  11662    12204 12290
...
&lt;/pre&gt;

&lt;p&gt;Note that a number in this file does not occupy a fixed number of bytes. If we jump to a new position in the file using a seek operation, we cannot expect to land exactly where a number starts. Thus the random access file iterator we developed last time won&amp;#8217;t work.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc2" name="tocinput-iterators" id="tocinput-iterators"&gt;Input iterators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In C++ an input file is an example of an input stream, and the standard library gives us &lt;code&gt;istream_iterators&lt;/code&gt; which perform formatted input. In our case, an &lt;code&gt;istream_iterator&amp;lt;int&amp;gt;&lt;/code&gt; effectively converts the file into a stream of numbers.
&lt;/p&gt;
&lt;p&gt;Istream iterators are &lt;a href="http://www.sgi.com/tech/stl/InputIterator.html" title="InputIterator, SGI STL documentation"&gt;input iterators&lt;/a&gt;. They progress through the input stream, item by item, with no repeating or rewinding allowed. Despite their limitations, the C++ standard library provides some algorithms which require nothing more than basic input iterators. For example, to count up even numbers in the file whose name is supplied on the command line we might use &lt;code&gt;std::count_if&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iterator&amp;gt;

bool is_even(int x)
{
    return x % 2 == 0;
}

int main(int argc, char * argv[])
{
    typedef std::istream_iterator&amp;lt;int&amp;gt; i_iter;
    typedef std::ostream_iterator&amp;lt;int&amp;gt; o_iter;
    std::ifstream in(argv[1]);
    
    std::cout &amp;lt;&amp;lt; std::count_if(i_iter(in), i_iter(), is_even) &amp;lt;&amp;lt; '\n';
    
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The next version of C++ supports lambda functions, so you&amp;#8217;ll be able to put &lt;code&gt;is_even&lt;/code&gt; right where it&amp;#8217;s used, in the &lt;code&gt;count_if()&lt;/code&gt; function call. Or, with the current version of C++, you could write:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Ouch!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;    ....
    std::count_if(i_iter(in), i_iter(),
                 std::not1(std::bind2nd(std::modulus&amp;lt;int&amp;gt;(), 2)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Maybe not!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc3" name="tocfind" id="tocfind"&gt;Find&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The very simplest search algorithm, &lt;code&gt;std::find&lt;/code&gt;, needs nothing more than an input iterator. To determine if a number is in a file, we &lt;strong&gt;could&lt;/strong&gt; just invoke &lt;code&gt;std::find&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef std::istream_iterator&amp;lt;int&amp;gt; i_iter;

bool 
is_number_in_file(char const * filename, int n)
{
    std::ifstream in(filename);
    i_iter begin(in);
    i_iter end;
    return std::find(begin, end, n) != end;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the find algorithm advances through the numbers in the file, from start to finish, stopping as soon as it hits one equal to the supplied value, &lt;code&gt;n&lt;/code&gt;. We can expect this function to be light on memory use &amp;#8212; there will be some buffering at the lower levels of the file access, but nothing more &amp;#8212; and the function is evidently correct.
&lt;/p&gt;
&lt;p&gt;It would be correct even if our file was unsorted, however. Is there any way we can do better?
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc4" name="tocrewrite-the-file" id="tocrewrite-the-file"&gt;Rewrite the file!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In the previous article we developed a random access iterator for accessing binary files, and usable for efficient binary searches of sorted binary files. Now would be a good time to question the problem specification. Is this a one off? Or are we going to be testing the presence of more numbers in the file in future? And if so, can we convert the file to binary to save time in the long run? 
&lt;/p&gt;
&lt;p&gt;Although I&amp;#8217;m not going to pursue this option here, it may well be the best approach. For now, though, let&amp;#8217;s assume we have a one-off problem to solve, and that we aren&amp;#8217;t allowed to tinker with the input.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc5" name="tocadapting-iterators" id="tocadapting-iterators"&gt;Adapting iterators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If we want to use &lt;code&gt;std::binary_search&lt;/code&gt; we need, as a minimum, &lt;a href="http://www.sgi.com/tech/stl/ForwardIterator.html" title="ForwardIterator, SGI STL documentation"&gt;forward iterators&lt;/a&gt;. Like input iterators, forward iterators advance, one step at a time. Unlike input iterators, you can copy a forward iterator and dereference or advance that copy in future, independently of the original.
&lt;/p&gt;
&lt;p&gt;Forward iterators are suitable for multipass algorithms, such as &lt;code&gt;std::search&lt;/code&gt;, which looks for the first occurrence of a sequence within a sequence (a generalised &lt;code&gt;strstr&lt;/code&gt;, if you like), or &lt;code&gt;std::adjacent_find&lt;/code&gt; and &lt;code&gt;std::search_n&lt;/code&gt; which look for repeated elements; and of course &lt;code&gt;std::binary_search&lt;/code&gt;, which is our immediate interest.
&lt;/p&gt;
&lt;p&gt;Wouldn&amp;#8217;t it be nice if we could convert our istream iterators into forwards iterators? Then we could plug them directly into all these algorithms.
&lt;/p&gt;
&lt;p&gt;Other languages allow this. You can replicate streams in the Unix shell with &lt;code&gt;tee&lt;/code&gt;. And you can do something similar in Python, thanks to one of the standard &lt;a href="http://docs.python.org/py3k/library/itertools.html"&gt;iterator tools&lt;/a&gt;. Independent iterators over the same sequence needed? &lt;tt&gt;&lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.tee
"&gt;Itertools.tee&lt;/a&gt;&lt;/tt&gt; is your friend. The example below codes up adjacent find in Python.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import tee
import sys

def adjacent_find(xs):
    '''Does the supplied iterable contain any adjacent repeats?
    
    Returns True if xs contains two consecutive, equal items,
    False otherwise. 
    '''
    try:
        curr, next_ = tee(xs)
        next(next_)
        return any(c == n for c, n in zip(curr, next_))
    except StopIteration:
        return False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.jezuk.co.uk/mango" title="Mango: iterators, algorithms, functions, for Java, by Jez Higgins"&gt;&lt;img src="http://www.jezuk.co.uk/files/mango-header.png" alt="Mango: iterators, algorithms, functions, for Java, by Jez Higgins"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Why, even Java has an iterator adaptors, courtesy of Jez Higgins&amp;#8217; &lt;a href="http://www.jezuk.co.uk/mango" title="Mango: iterators, algorithms, functions, for Java, by Jez Higgins"&gt;Mango library&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;What about C++? I couldn&amp;#8217;t find any such iterator adaptors in the standard library, but I turned up something in the standard library research and development unit, also known as &lt;a href="http://www.boost.org" title="Free, peer-reviewed, portable C++ source libraries"&gt;Boost&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://boost.org"&gt;&lt;img src="http://www.boost.org/doc/libs/1_43_0/boost.png" alt="Boost logo"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc6" name="tocmultipass-iterator" id="tocmultipass-iterator"&gt;Multipass iterator&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/index.html"&gt;Boost.Spirit&lt;/a&gt; is a remarkable C++ parser framework, which uses operator overloading to represent parsers directly as EBNF grammars in C++. Somewhere in its depths it tracks back, and hence must adapt input iterators into forward iterators &amp;#8212; or &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/spirit/support/multi_pass.html"&gt;multipass iterators&lt;/a&gt;, to use its own term.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The &lt;code&gt;multi_pass&lt;/code&gt; iterator will convert any input iterator into a forward iterator suitable for use with Spirit.Qi. &lt;code&gt;multi_pass&lt;/code&gt; will buffer data when needed and will discard the buffer when its contents is not needed anymore. This happens either if only one copy of the iterator exists or if no backtracking can occur.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;What&amp;#8217;s good enough for parsing is more than good enough for searching. Here&amp;#8217;s a function which detects whether a number is in a file. Most of the code here just includes the right headers and defines some typedefs. By leaning on high quality support libraries we&amp;#8217;ve overcome our first issue: we no longer have to write loads of code just to call binary search!
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Boost spirit multipass iterators&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;algorithm&amp;gt;

#include &amp;lt;boost/spirit/include/support_multi_pass.hpp&amp;gt;

namespace spirit = boost::spirit;

typedef long long number;
typedef std::istream_iterator&amp;lt;number&amp;gt; in_it;
typedef spirit::multi_pass&amp;lt;in_it&amp;gt; fwd_it;

/*
  Returns true if the input number can be found in the named 
  file, false otherwise. The file must contain ordered, 
  whitespace separated numbers.
*/
bool
is_number_in_file(number n, char const * filename)
{
    std::ifstream in(filename);
    
    fwd_it begin = spirit::make_default_multi_pass(in_it(in));
    fwd_it end = spirit::make_default_multi_pass(in_it());
    
    return std::binary_search(begin, end, n);
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc7" name="tocnot-so-fast" id="tocnot-so-fast"&gt;Not so fast&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If this library-based solution looks too good to be true, that&amp;#8217;s because it is! As we noted &lt;a href="http://wordaligned.org/articles/binary-search.html#tocstdbinarysearch-requirements"&gt;before&lt;/a&gt;, the standard binary search algorithm may indeed work with forward iterators, but it works far better with random access iterators. There&amp;#8217;s no point reducing the number of integer comparisons to &lt;code&gt;O(log(N))&lt;/code&gt; if we&amp;#8217;re going to advance our iterators &lt;code&gt;O(N)&lt;/code&gt; times.
&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s worse, these multipass iterators aren&amp;#8217;t magic. Did you read the smallprint concerning Python&amp;#8217;s &lt;tt&gt;&lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.tee"&gt;tee&lt;/a&gt;&lt;/tt&gt; iterator?
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;This itertool may require significant auxiliary storage (depending on how much temporary data needs to be stored).
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;If teed iterators diverge, intervening values have to be stored somewhere, and the same appears to be true of our inscrutable multipass iterators. Huge chunks of our large input file are buffered into memory. When I ran this function to confirm the presence of a single number somewhere near the middle of a 4.4GB input file, it took over 19 minutes.
&lt;/p&gt;
&lt;pre&gt;
real	19m13.675s
user	5m19.219s
sys	1m26.278s
&lt;/pre&gt;

&lt;p&gt;Much of this time was spent paging.
&lt;/p&gt;
&lt;p&gt;As a comparison, testing for the same value using &lt;code&gt;find&lt;/code&gt; took just under 3 minutes.
&lt;/p&gt;
&lt;pre&gt;
real	2m48.139s
user	2m21.336s
sys	0m7.252s
&lt;/pre&gt;

&lt;p&gt;You&amp;#8217;ll have noticed that we used default multipass iterators. These iterators permit multi-dimensional &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/spirit/support/multi_pass.html"&gt;customisation&lt;/a&gt;. I wasn&amp;#8217;t feeling brave enough to attempt a template storage policy class, and I very much doubt I could have beaten a simple linear find anyway; anything built on a generic input iterator is unlikely to solve our problem efficiently.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc8" name="tocbetter-than-find" id="tocbetter-than-find"&gt;Better than find&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We can beat &lt;code&gt;std::find&lt;/code&gt; with a bit of ingenuity. Standard istream iterators are useful but, in this case, not a good starting point. A better idea is to create a novel iterator which uses file seek operations to advance through the file, then fine-tunes the file position to point at a number.
&lt;/p&gt;
&lt;p&gt;Consider an imagine an iterator which can be positioned at any seekable position in the file, and which we dereference to be the first number in the file which ends at or after that position. The graphic below shows a file with 11 seekable positions, 0 through 10 inclusive. 
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     positions 0 and 1 dereference to the number 42  &lt;br /&gt;
 &lt;/li&gt;

 &lt;li&gt;
     positions 2, 3, 4 and 5 dereference to the number 57
 &lt;/li&gt;

 &lt;li&gt;
     positions 6, 7, 8 and 9 dereference to the number 133
 &lt;/li&gt;

 &lt;li&gt;
     it is an error to try and dereference position 10, at the end of the file
 &lt;/li&gt;
&lt;/ul&gt;
&lt;img src="http://wordaligned.org/images/text-file-iterator.png" alt="Text file iterator"/&gt;

&lt;p&gt;Now, this is a rather unusual iterator. It iterates over the numbers in the file, but each number gets repeated for every byte in the file it occupies. Despite this duality it&amp;#8217;s perfectly usable &amp;#8212; so long as we keep a clear head. Binary searches are fine.
&lt;/p&gt;
&lt;p&gt;How does this version perform?
&lt;/p&gt;
&lt;p&gt;Recall, a linear search for a single value in the middle of a 4.4GB took nearly 3 minutes. Running 10 binary searches through the same file took just 40 milliseconds &amp;#8212; that&amp;#8217;s a rate of 25 searches a second!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc9" name="tocimplementation" id="tocimplementation"&gt;Implementation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s our weird new iterator. It should be usable on files containing whitespace separated items of any type for which the stream read &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; has been defined.
&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s quite a lot of code here, but much of it is random access iterator scaffolding. The interesting functions are the private implementation details towards the end of the class.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;fstream&amp;gt;
#include &amp;lt;ios&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;stdexcept&amp;gt;

#include &amp;lt;ctype.h&amp;gt;

// File read error, thrown when low level file access fails.
class file_read_error : public std::runtime_error
{
public:
    file_read_error(std::string const &amp;amp; what)
        : std::runtime_error(what)
    {
    }
};

/*
  Here's an unusual iterator which can be used to binary search
  for whitespace-separated items in a text file.
  
  It masquerades as a random access iterator but a file
  is not usually a random access device. Nonetheless, file seek
  operations are quicker than stepping through the file item by
  item.
  
  The unusual thing is that the iterators correspond to 
  file offsets rather than items within the file.
  
  Here's a short example where the items are numbers.
  
  +---+---+---+---+---+---+---+---+---+---+
  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
  +---+---+---+---+---+---+---+---+---+---+
  |'4'|'2'|   |   |'5'|'7'|   |'1'|'3'|'3'|
  +---+---+---+---+---+---+---+---+---+---+
  
  The graphic shows a text file which contains 3 numbers,
  42, 57, 133, separated by whitespace.
  
  The file itself is 10 bytes long, and hence there are 11
  iterators over the file, corresponding to actual file positions
  (including the one-past-the end position). To dereference an
  iterator, we step back through the file until we reach either
  whitespace or the start of the file. Then we look forwards 
  again and read in the next item.
  
  In the graphic above:
  
   - Iterators 0 and 1 point to number 42
   - Iterators 2, 3, 4 and 5 point to number 57
   - Iterators 6, 7, 8, 9 point to number 133
   - Iterator 10 is the end, and must not be dereferenced
  
  Dereferencing an iterator always returns an item which is in
  the file, and all items in the file have iterators pointing to
  them, so std::binary_search based on these iterators is valid.
  
  The iterators also expose their underlying file positions
  directory (via the getpos() member function), and with a
  little thought we can make use of std::lower_bound() and
  std::upper_bound().
*/
template &amp;lt;typename item&amp;gt;
class text_file_item_iter
{
    typedef text_file_item_iter&amp;lt;item&amp;gt; iter;
    
private: // Sanity
    
    // Check things are OK, throwing an error on failure.
    void check(bool ok, std::string const &amp;amp; what)
    {
        if (!ok)
        {
            throw file_read_error(what);          
        }
    }
    
public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef item value_type;
    typedef std::streamoff difference_type;
    typedef item * pointer;
    typedef item &amp;amp; reference;
    
    enum start_pos { begin, end };
    
public: // Lifecycle
    text_file_item_iter(iter const &amp;amp; other)
        : fname(other.fname)
    {
        open();
        setpos(other.pos);
    }
    
    text_file_item_iter()
        : pos(-1)
    {
    }
    
    text_file_item_iter(std::string const &amp;amp; fname,
                        start_pos where = begin)
        : fname(fname)
        , pos(-1)
    {
        open();
        if (where == end)
        {
            seek_end();
        }
    }
    
    ~text_file_item_iter()
    {
        close();
    }
    
    iter &amp;amp; operator=(iter const &amp;amp; other)
    {
        close();
        fname = other.fname;
        open();
        setpos(other.pos);
        return *this;
    } 
    
public: // Comparison
        // Note: it's an error to compare iterators over different files.
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }
    
    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }
    
    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }
    
public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }
    
    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }
    
    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }
    
    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }
    
public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }
    
    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }
    
    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }
    
    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }
    
public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return pos - other.pos;
    }
    
public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }
    
    value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }
    
    // Allow direct access to the underlying stream position
    std::streampos getpos()
    {
        std::streampos pos_ = in.tellg();
        check(in, "getpos failed");
        return pos_;
    }
    
private: // Implementation details
    void open()
    {
        in.open(fname.c_str(), std::ios::binary);
        check(in, "open failed");
        pos = getpos();
    }
    
    void close()
    {
        if (in.is_open())
        {
            in.close();
            check(in, "close failed");
        }
    }
    
    void advance(difference_type n)
    {
        check(in.seekg(n, std::ios_base::cur), "advance failed");
        pos = getpos();
    }
    
    void seek_end()
    {
        check(in.seekg(0, std::ios_base::end), "seek_end failed");
        chop_whitespace();
        pos = getpos();
    }
    
    void chop_whitespace()
    {
        do
        {
            in.unget();
        } while (isspace(in.peek()));
        in.get();
        in.clear();
    }
    
    void setpos(std::streampos newpos)
    {
        check(in.seekg(newpos), "setpos failed");
        pos = newpos;
    }
    
    // Return the item at the current position
    value_type read()
    {
        item n = 0;
        // Reverse till we hit whitespace or the start of the file
        while (in &amp;amp;&amp;amp; !isspace(in.peek()))
        {
            in.unget();
        }
        in.clear();
        check(in &amp;gt;&amp;gt; n, "read failed");
        return n;
    }
    
private: // State
    std::string fname;
    std::ifstream in;
    std::streampos pos;
};

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc10" name="tochardware-used" id="tochardware-used"&gt;Hardware used&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;
  Model Name:	            MacBook
  Model Identifier:	    MacBook1,1
  Processor Name:           Intel Core Duo
  Processor Speed:          2 GHz
  Number Of Processors:	    1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://www.flickr.com/photos/photobunny_earl/1008279066" title="Mushroom, by photobunny"&gt;&lt;img src="http://farm2.static.flickr.com/1440/1008279066_847d73c90d.jpg" alt="Mushroom, by photobunny"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc11" name="tocconclusions" id="tocconclusions"&gt;Conclusions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Initially the Boost.Spirit solution looked promising but we pushed it too hard. Suitable abstractions can remove complexity; but they can also hide it. When efficiency matters, we need a handle on what&amp;#8217;s going on.
&lt;/p&gt;
&lt;p&gt;After this false start we &lt;strong&gt;did&lt;/strong&gt; find a way to create a file iterator suitable for use with the standard binary search algorithms. Use it with care, though!
&lt;/p&gt;</description>
<dc:date>2010-05-26</dc:date>
<guid>http://wordaligned.org/articles/binary-search-revisited</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/binary-search-revisited</link>
<category>Algorithms</category>
</item>

<item>
<title>Binary search returns &#8230; ?</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#tocbsearch-in-c" name="toc0" id="toc0"&gt;Bsearch in C&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#tocbinary-search-in-c" name="toc1" id="toc1"&gt;Binary search in C++&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#tocstdbinarysearch-requirements" name="toc2" id="toc2"&gt;Std::binary_search() requirements&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#tocstdbinarysearch-limitations" name="toc3" id="toc3"&gt;Std::binary_search() limitations&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toclocating-missing-elements" name="toc4" id="toc4"&gt;Locating missing elements&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toclowerbound" name="toc5" id="toc5"&gt;Lower_bound&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#tocbinary-search-variants" name="toc6" id="toc6"&gt;Binary search variants&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#tociterating-over-numbers-in-a-file" name="toc7" id="toc7"&gt;Iterating over numbers in a file&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toctriple-fail" name="toc8" id="toc8"&gt;Triple fail&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search#tocthanks" name="toc9" id="toc9"&gt;Thanks&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;In an article inspired by Jon Bentley&amp;#8217;s classic book, &lt;a href="http://www.cs.bell-labs.com/cm/cs/pearls/"&gt;Programming Pearls&lt;/a&gt;, Mike Taylor &lt;a href="http://reprog.wordpress.com/2010/04/19/are-you-one-of-the-10-percent/" title="Are you one of the 10% of programmers who can write a binary search?"&gt;invites his readers&lt;/a&gt; to implement the binary search algorithm. To spice things up, he requests we work:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     without reference to any existing implementation
 &lt;/li&gt;

 &lt;li&gt;
     without calling any library routine, such as &lt;code&gt;bsearch&lt;/code&gt;
 &lt;/li&gt;

 &lt;li&gt;
     without writing tests.
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Mike Taylor doesn&amp;#8217;t formally specify the problem. He&amp;#8217;s confident his readers will know what a binary search is, and if not, the description he quotes from Programming Pearls should suffice:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Binary search solves the problem [of searching within a pre-sorted array] by keeping track of a range within the array in which T [i.e. the sought value] must be if it is anywhere in the array.  Initially, the range is the entire array.  The range is shrunk by comparing its middle element to T and discarding half the range.  The process continues until T is discovered in the array, or until the range in which it must lie is known to be empty.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;So could our binary search implementation simply return a binary result, &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is in the array, &lt;code&gt;false&lt;/code&gt; otherwise? Well, Yes. And No. A binary search can provide more information, as Mike Taylor hints when he mentions &lt;code&gt;bsearch&lt;/code&gt;. 
&lt;/p&gt;
&lt;p&gt;Jon Bentley and Mike Taylor are primarily interested in how often programmers  make a mess of what appears to be a simple assignment and in how to avoid this mess. In this article, I&amp;#8217;d like to point out that the problem specification needs attention too.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/pinprick/2547648374"&gt;&lt;img src="http://farm4.static.flickr.com/3066/2547648374_587dbe8f4b_m.jpg" alt="unwrapped morbier"/&gt;&lt;/a&gt;
   &lt;a href="http://www.flickr.com/photos/pinprick/2546825997"&gt;&lt;img src="http://farm4.static.flickr.com/3083/2546825997_c28af1da65_m.jpg" alt="cut morbier"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc0" name="tocbsearch-in-c" id="tocbsearch-in-c"&gt;Bsearch in C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The C library&amp;#8217;s &lt;code&gt;bsearch&lt;/code&gt; function returns the location of &lt;code&gt;T&lt;/code&gt;, if found, or a sentinel value otherwise. We might use the array index of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt; as location and sentinel. Standard C uses pointers:
&lt;/p&gt;
&lt;pre&gt;
&lt;b&gt;NAME&lt;/b&gt;
    &lt;b&gt;bsearch&lt;/b&gt; -- binary search of a sorted table
    
&lt;b&gt;SYNOPSIS&lt;/b&gt;
    #include &amp;lt;stdlib.h&amp;gt;
    
    void *
    &lt;b&gt;bsearch&lt;/b&gt;(const void *key, const void *base, size_t nel, 
        size_t width,
        int (*compar) (const void *, const void *));
    
&lt;b&gt;DESCRIPTION&lt;/b&gt; 
    The &lt;b&gt;bsearch()&lt;/b&gt; function searches an array of `nel` objects, 
    the initial member of which is pointed to by `base`, for a member
    that matches the  object pointed to by `key`.  The size (in bytes)
    of each member of the array is specified by `width`.
    
    The contents of the array should be in ascending sorted order 
    according to the comparison function referenced by `compar`.  The 
    `compar` routine is expected to have two arguments which point to
    the `key` object and to an array member, in that order.  It should 
    return an integer which is less than, equal to, or greater than
    zero if the `key` object is found, respectively, to be less than,
    to match, or be greater than the array member.

&lt;b&gt;RETURN VALUES&lt;/b&gt;
    The &lt;b&gt;bsearch()&lt;/b&gt; function returns a pointer to a matching member
    of the array, or a null pointer if no match is found.  If two members
    compare as equal, which member is matched is unspecified.
&lt;/pre&gt;

&lt;p&gt;Void pointers, function pointers, raw memory &amp;#8212; generic functions in C aren&amp;#8217;t pretty. How would this function look in a language with better support for generic programming?
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc1" name="tocbinary-search-in-c" id="tocbinary-search-in-c"&gt;Binary search in C++&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;C++ programmers can of course use &lt;code&gt;bsearch&lt;/code&gt; directly since C++ includes the standard C library. The C++ counterpart would seem to be &lt;a href="http://www.sgi.com/tech/stl/binary_search.html"&gt;&lt;code&gt;std::binary_search&lt;/code&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;At first glance &lt;code&gt;std::binary_search&lt;/code&gt; appears to be a weakened version of &lt;code&gt;bsearch&lt;/code&gt;. Like &lt;code&gt;bsearch&lt;/code&gt;, it searches for a value. Unlike &lt;code&gt;bsearch&lt;/code&gt;, it simply returns a boolean result: &lt;code&gt;true&lt;/code&gt; if the value is found, &lt;code&gt;false&lt;/code&gt; otherwise. Nonetheless, it can tell us more than &lt;code&gt;bsearch&lt;/code&gt; in some circumstances.
&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s return to Mike Taylor&amp;#8217;s second constraint, the one about implementing functions which already exist in standard libraries. In a &lt;a href="http://reprog.wordpress.com/2010/04/21/binary-search-redux-part-1/" title="Mike Taylor discusses his binary search challenge"&gt;follow up article&lt;/a&gt; he explains:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; sometimes you do need to write a binary search, and the library routines won&amp;#8217;t get the job done.  Or if they will, they&amp;#8217;re grotesquely inefficient.  For example, suppose you have a 64-bit integer, and you need to find out whether it&amp;#8217;s among the nine billion 64-bit integers that are stored in ascending order in a 72 Gb file.  The naive solution is to read the file into memory, making an array (or, heaven help us, an Array) of nine billion elements, then invoke the library search function.  And of course that just plain won&amp;#8217;t work &amp;#8212; the array won&amp;#8217;t fit in memory.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Agreed! We should know how our wheels work and be ready to reinvent them when necessary: but C++&amp;#8217;s &lt;code&gt;std::binary_search&lt;/code&gt; &lt;strong&gt;will&lt;/strong&gt; solve this problem efficiently. All we need is a suitable iterator over the file, in this case one which:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     increments in 8 byte steps
 &lt;/li&gt;

 &lt;li&gt;
     uses file seeks for larger steps
 &lt;/li&gt;

 &lt;li&gt;
     is dereferenced by reading 8 byte values from the file
 &lt;/li&gt;

 &lt;li&gt;
     stores file position, for use in ordering and distance operations
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I include an &lt;a href="http://wordaligned.org/articles/binary-search#tociterating-over-numbers-in-a-file"&gt;implementation&lt;/a&gt; of just such an iterator towards the end of this article. My aging laptop didn&amp;#8217;t have enough disk space for a 72GB data file but I found room for a 5GB one. &lt;code&gt;Std::binary_search()&lt;/code&gt; took milliseconds to test the presence of values in this file, and the times improved dramatically on repeat runs; using a linear search, the time extended to minutes, and repeat runs showed no such improvements.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc2" name="tocstdbinarysearch-requirements" id="tocstdbinarysearch-requirements"&gt;Std::binary_search() requirements&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s fair to suggest that creating a custom iterator just so we could use &lt;code&gt;std::binary_search&lt;/code&gt; merely moves the problem. The iterator&amp;#8217;s implementation is longer and arguably more fiddly than any custom binary search function would be. Why couldn&amp;#8217;t we use a standard &lt;a href="http://www.sgi.com/tech/stl/istream_iterator.html"&gt;input stream iterator&lt;/a&gt; with the standard binary search algorithm?
&lt;/p&gt;
&lt;p&gt;The reason is that &lt;code&gt;std::istream_iterator&lt;/code&gt;s are &lt;a href="http://www.sgi.com/tech/stl/InputIterator.html" title="SGI STL input iterator documentation"&gt;input iterators&lt;/a&gt;, suitable only for single pass algorithms. Binary search doesn&amp;#8217;t need to take any backwards steps but it does need to be able copy its iterators and advance them repeatedly. As a minimum, then, it requires &lt;a href="http://www.sgi.com/tech/stl/ForwardIterator.html" title="SGI STL forwards iterator documentation"&gt;forwards iterators&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Note the algorithm&amp;#8217;s &lt;a href="http://www.sgi.com/tech/stl/binary_search.html"&gt;complexity&lt;/a&gt;!
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The number of comparisons is logarithmic: at most &lt;code&gt;log(last - first) + 2&lt;/code&gt;. If ForwardIterator is a Random Access Iterator then the number of steps through the range is also logarithmic; otherwise, the number of steps is proportional to &lt;code&gt;last - first&lt;/code&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;In the case of our large file of numbers, comparisons are cheap; there&amp;#8217;s little point minimising them if we&amp;#8217;re going to take billions of short steps through the file. This is why we created a random access file iterator&lt;a id="fn1link" href="http://wordaligned.org/articles/binary-search#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;A more subtle point is that binary search deals with equivalence rather than equality: it only requires a less-than operator (or a comparison function), and returns true if it can find an element &lt;code&gt;x&lt;/code&gt; which satisfies &lt;code&gt;!(x &amp;lt; t) &amp;amp;&amp;amp; !(t &amp;lt; x)&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;The point I&amp;#8217;m making is that C++ does a nice job of separating algorithms and containers, which is why the same algorithm can be used on vectors, files, arrays etc. It also carefully defines minimum requirements on the types used by algorithms&lt;a id="fn2link" href="http://wordaligned.org/articles/binary-search#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc3" name="tocstdbinarysearch-limitations" id="tocstdbinarysearch-limitations"&gt;Std::binary_search() limitations&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We noted earlier that &lt;code&gt;std::binary_search&lt;/code&gt; delivers nothing more than a binary result. Is the element there or not? From the SGI STL &lt;a href="http://www.sgi.com/tech/stl/binary_search.html"&gt;documentation&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Note that this is not necessarily the information you are interested in!
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Even &lt;code&gt;bsearch&lt;/code&gt; tells us where it found the match; or rather, where it found &lt;b&gt;a&lt;/b&gt; match, since there could be several. This imprecision is one of &lt;code&gt;bsearch&lt;/code&gt;&amp;#8217;s failings &amp;#8212; but it really lets us down when it can&amp;#8217;t find the element: in this case, it subdivides the range until it finds where the element would be if it were there, realises there is no match, then throws all positional information away and returns a null pointer.
&lt;/p&gt;
&lt;p&gt;Suppose our large file represents a set of numbers and we want to know where our test number should go in this file, if it isn&amp;#8217;t already present? A C++ binary search algorithm can do this, but it isn&amp;#8217;t &lt;code&gt;std::binary_search&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc4" name="toclocating-missing-elements" id="toclocating-missing-elements"&gt;Locating missing elements&lt;/a&gt;&lt;/h3&gt;
&lt;img src="http://wordaligned.org/images/london-marathon-2008.jpg" alt="London Marathon, runners crossing Tower Bridge"/&gt;

&lt;p&gt;Here&amp;#8217;s another problem binary search can solve. Suppose we want to know how many runners finished the 2010 London marathon in a time between 3 and 4 hours. Let&amp;#8217;s suppose we&amp;#8217;ve already loaded the ordered finishing times into an array.
&lt;/p&gt;
&lt;p&gt;We might try using &lt;code&gt;bsearch&lt;/code&gt; to find the position of the runners who finished with a time of exactly 3 hours and with a time of exactly 4 hours. Then the answer would be the difference between these two positions.
&lt;/p&gt;
&lt;p&gt;There are two problems with this approach:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     what if no one finished with a time of &lt;strong&gt;exactly&lt;/strong&gt; 3 or 4 hours? 
 &lt;/li&gt;

 &lt;li&gt;
     what if more than one runner finished with a time of exactly 3 or 4 hours?
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the first case &lt;code&gt;bsearch&lt;/code&gt; returns a null pointer and we can&amp;#8217;t complete our calculation. In the second case, &lt;code&gt;bsearch&lt;/code&gt; makes no guarantees about which of the equally-placed runners it will find, and even if we can make our calculation, we cannot be sure it is correct.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Bsearch&lt;/code&gt; is not much use, then, but a binary search can give us our answer. 
&lt;/p&gt;
&lt;p&gt;Imagine we had a late result for the race, a runner who recorded a time of exactly 3 hours. What&amp;#8217;s the first position in the array at which we could place this runner, whilst maintaining the array ordering? Similarly, where&amp;#8217;s the first position at which we could insert a runner with a time of 4 hours, maintaining the array ordering. Both these positions are well defined and precise &amp;#8212; even if everyone finished the race in less than 3 hours, or even if no one ran the race &amp;#8212; and the correct answer is their difference.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc5" name="toclowerbound" id="toclowerbound"&gt;Lower_bound&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;C++ supplies just such an algorithm. It goes by the name of &lt;a href="http://www.sgi.com/tech/stl/lower_bound.html"&gt;&lt;code&gt;std::lower_bound&lt;/code&gt;&lt;/a&gt;, but really it&amp;#8217;s good old binary search. We want to find the first place our target element could go, whilst maintaining the ordering, which we do by repeatedly splitting the range.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     while the range is non-empty
 &lt;/li&gt;

 &lt;li&gt;
     look at the element in the middle of the range
 &lt;/li&gt;

 &lt;li&gt;
     is its value less than the target value?
 &lt;/li&gt;

 &lt;li&gt;
     if so, continue looking in the top half of the range
 &lt;/li&gt;

 &lt;li&gt;
     if not, continue looking in the bottom half of the range
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The while loop exits when the range has been reduced to a single point and this point is what we return. On my platform, the code itself reads a bit like:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename fwd_it, typename t&amp;gt;
fwd_it
lower_bound(fwd_it first, fwd_it last, const t &amp;amp; val)
{
    typedef typename iterator_traits&amp;lt;fwd_it&amp;gt;::difference_type distance;
    
    distance len = std::distance(first, last);
    distance half;
    fwd_it middle;
    
    while (len &amp;gt; 0)
    {
        half = len &amp;gt;&amp;gt; 1;
        middle = first;
        std::advance(middle, half);
        if (*middle &amp;lt; val)
        {
            first = middle;
            ++first;
            len = len - half - 1;
        }
        else
            len = half;
    }
    return first;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I think this version of binary search is &lt;a href="http://wordaligned.org/articles/next-permutation.html" title="Next_permutation: when C++ gets it right"&gt;yet another gem from the C++ standard library&lt;/a&gt;. As Jon Bentley and Mike Taylor eloquently point out, the implementation is subtle &amp;#8212; in particular, if &lt;code&gt;(*middle &amp;lt; val)&lt;/code&gt; we must eliminate &lt;code&gt;middle&lt;/code&gt; or risk an infinite loop &amp;#8212; but by tightening the problem specification and paring back the requirements we&amp;#8217;ve created a function which is far more useful than &lt;code&gt;bsearch&lt;/code&gt; and arguably simpler to code.
&lt;/p&gt;
&lt;p&gt;For comparison, here&amp;#8217;s the &lt;code&gt;bsearch&lt;/code&gt; implemented by glibc, version 2.11.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;/* Perform a binary search for KEY in BASE which has NMEMB elements
   of SIZE bytes each.  The comparisons are done by (*COMPAR)().  */
void *
bsearch (const void *key, const void *base, size_t nmemb, size_t size,
         int (*compar) (const void *, const void *))
{
  size_t l, u, idx;
  const void *p;
  int comparison;
  
  l = 0;
  u = nmemb;
  while (l &amp;lt; u)
    {
      idx = (l + u) / 2;
      p = (void *) (((const char *) base) + (idx * size));
      comparison = (*compar) (key, p);
      if (comparison &amp;lt; 0)
        u = idx;
      else if (comparison &amp;gt; 0)
        l = idx + 1;
      else
        return (void *) p;
    }

return NULL;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc6" name="tocbinary-search-variants" id="tocbinary-search-variants"&gt;Binary search variants&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;On my platform, &lt;code&gt;std::binary_search&lt;/code&gt; is built directly on &lt;code&gt;std::lower_bound&lt;/code&gt;. Here&amp;#8217;s the code.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename fwd_it, typename t&amp;gt;
fwd_it
lower_bound(fwd_it first, fwd_it last, const t &amp;amp; val)
{
    fwd_it i = std::lower_bound(first, last, val);
    return i != last &amp;amp;&amp;amp; !(val &amp;lt; *i);
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Std::upper_bound&lt;/code&gt; searches a sorted range to find the last position an item could be inserted without changing the ordering.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Std::equal_range&lt;/code&gt; returns a pair of iterators, logically equal to &lt;code&gt;make_pair(lower_bound(...), upper_bound(...))&lt;/code&gt;.
&lt;/p&gt;
&lt;hr /&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc7" name="tociterating-over-numbers-in-a-file" id="tociterating-over-numbers-in-a-file"&gt;Iterating over numbers in a file&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The iterator class I created to use &lt;code&gt;std::binary_search&lt;/code&gt; on an file containing fixed width binary formatted numbers appears below. To determine whether the file &lt;code&gt;numbers.bin&lt;/code&gt; contains the target value &lt;code&gt;288230376151711744&lt;/code&gt;, we would write something like:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;

....
    
    typedef binary_file_number_iter&amp;lt;long long, 8&amp;gt; iter;
    long long target = 288230376151711744LL;
    
    bool found = std::binary_search(iter("numbers.bin", iter::begin),
                                    iter("numbers.bin", iter::end),
                                    target);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To test the performance of these iterators I created a 5GB binary file packed with 8 byte numbers. These numbers were multiples of 3:
&lt;/p&gt;
&lt;pre title="File contents"&gt;
0, 3, 6, 9, ..., 2015231997
&lt;/pre&gt;

&lt;p&gt;I then timed how long it took to search this file for 10 interesting numbers (and to confirm the returned results were as expected).
&lt;/p&gt;
&lt;pre title="Seach targets"&gt;
-1, 0, 1, 2, 1007616000, 1007616001, 1007616002, 1007616003, 2015231997, 2015232000
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Binary_search()&lt;/code&gt; recorded a time of 0.308 seconds on a rather old MacBook&lt;a id="fn3link" href="http://wordaligned.org/articles/binary-search#fn3"&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;. Using a hand-coded linear search the run time was just over 38 minutes. That is, the binary search ran 7000 times faster on this sample.
&lt;/p&gt;
&lt;p&gt;Interestingly, repeated runs of the binary search test using the same input file and the same targets ran in an average time of just 0.030 seconds, a 10-fold times speed up over the first run. Similarly repeating the linear search showed no such improvement. I&amp;#8217;m attributing this to operating system file caching, but I don&amp;#8217;t pretend to know exactly what&amp;#8217;s going on here. (My thanks to Michal Mocny for his explanation in the &lt;a href="http://wordaligned.org/articles/binary-search#comment-49972118"&gt;comments&lt;/a&gt; below).
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Binary file number iterator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#ifndef BINARY_FILE_NUMBER_ITERATOR_HPP_INCLUDED
#define BINARY_FILE_NUMBER_ITERATOR_HPP_INCLUDED

#include &amp;lt;fstream&amp;gt;
#include &amp;lt;ios&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;stdexcept&amp;gt;

// File read error, thrown when low level file access fails.
class file_read_error : public std::runtime_error
{
public:
    file_read_error(std::string const &amp;amp; what)
        : std::runtime_error(what)
    {
    }
};

// This iterator class is used for numbers packed into a file
// using a fixed width binary format. Numbers must be packed
// most significant byte first.
//
// The file is not read into memory. Iterators are moved by
// file seeking and dereferenced by reading from the file.
//
// These iterators declare themselves to be random access
// iterators but a file is not usually a random access device.
// For example, advancing an iterator a large distance may well
// take longer than advancing a small distance.
template &amp;lt;typename number, int number_size&amp;gt;
class binary_file_number_iter
{
    typedef binary_file_number_iter&amp;lt;number, number_size&amp;gt; iter;
    
private: // Sanity
    // Check things are OK, closing the stream and throwing an error on failure.
    void check(bool ok, std::string const &amp;amp; what)
    {
        if (!ok)
        {
            close();
            throw file_read_error(what);          
        }
    }
    
public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef number value_type;
    typedef std::streamoff difference_type;
    typedef number * pointer;
    typedef number &amp;amp; reference;
    
public:
    static int const number_width = number_size;
    
public: // Enum used to construct begin, end iterators
    enum start_pos { begin, end };
    
public: // Lifecycle
    binary_file_number_iter(std::string const &amp;amp; filename,
                            start_pos where = begin)
        : filename(filename)
        , pos(-1)
    {
        open();
        if (where == end)
        {
            seek_end();
        }
    }
    
    binary_file_number_iter()
        : pos(-1)
    {
    }
    
    binary_file_number_iter(iter const &amp;amp; other)
        : filename(other.filename)
    {
        open();
        setpos(other.pos);
    }
    
    ~binary_file_number_iter()
    {
        close();
    }
    
    iter &amp;amp; operator=(iter const &amp;amp; other)
    {
        close();
        filename = other.filename;
        open();
        setpos(other.pos);
        return *this;
    } 
    
public: // Comparison
        // Note: it is an error to compare iterators into different files.
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }
    
    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }
    
    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }
    
public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }
    
    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }
    
    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }
    
    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }
    
public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }
    
    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }
    
    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }
    
    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }
    
public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return (pos - other.pos) / number_size;
    }
    
public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }
    
    value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }
    
    // Allow access to the underlying stream position
    std::streampos getpos()
    {
        std::streampos s = in.tellg();
        check(in, "getpos failed");
        return s;
    }
private: // Implementation details
    void open()
    {
        in.open(filename.c_str(), std::ios::binary);
        check(in, "open failed");
        pos = getpos();
    }
    
    void close()
    {
        if (in.is_open())
        {
            in.close();
        }
    }
    
    void advance(difference_type n)
    {
        check(in.seekg(n * number_size, std::ios_base::cur), "advance failed");
        pos = getpos();
    }
    
    void seek_end()
    {
        check(in.seekg(0, std::ios_base::end), "seek_end failed");
        pos = getpos();
    }
    
    void setpos(std::streampos newpos)
    {
        check(in.seekg(newpos), "setpos failed");
        pos = newpos;
    }
    
    value_type read()
    {
        number n = 0;
        unsigned char buf[number_size];
        check(in.read((char *)buf, number_size), "read failed");
        
        for (int i = 0; i != number_size; ++i)
        {
            n &amp;lt;&amp;lt;= 8;
            n |= buf[i];
        }
        return n;
    }
    
private: // State
    std::string filename;
    std::ifstream in;
    std::streampos pos;
};

#endif // BINARY_FILE_NUMBER_ITERATOR_HPP_INCLUDED

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here are some basic tests for the binary file number iterator.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Test binary file number iterator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;ext/algorithm&amp;gt; // For Gnu's non-standard is_sorted
#include &amp;lt;iostream&amp;gt;

#include "binary_file_number_iterator.hpp"

typedef binary_file_number_iter&amp;lt;long long, 8&amp;gt; iter8;
typedef binary_file_number_iter&amp;lt;int, 4&amp;gt; iter4;
typedef binary_file_number_iter&amp;lt;short, 2&amp;gt; iter2;
typedef binary_file_number_iter&amp;lt;char, 1&amp;gt; iter1;

template &amp;lt;typename fwd_it&amp;gt;
bool is_sorted(fwd_it beg, fwd_it end)
{
    return __gnu_cxx::is_sorted(beg, end);
}

char const * empty_test_file(char const * name)
{
    std::ofstream ofile;
    ofile.open(name);
    ofile.close();
    return name;
}

/*
  Create a small test file containing numbers, in ascending order,
  for number sizes 1, 2, 4 and 8 bytes.
  
  A hex view of the file looks like:
  
  0000 0000 0000 0000 0303 0303 0303 0303
  0606 0606 0606 0606 0909 0909 0909 0909
  0c0c 0c0c 0c0c 0c0c 0f0f 0f0f 0f0f 0f0f
*/
char const * basic_test_file(char const * name)
{
    std::ofstream ofile;
    ofile.open(name);
    for (unsigned char i = 0; i != 18; i += 3)
        for (unsigned j = 0; j != 8; ++j)
            ofile &amp;lt;&amp;lt; i;            
    ofile.close();
    return name;
}

void empty_file_tests()
{
    char const * empty_file = empty_test_file("empty_test_file");
    iter1 beg(empty_file, iter1::begin);
    iter1 end(empty_file, iter1::end);
    assert(beg == end);
    assert(std::lower_bound(beg, end, -1) == end);
    assert(std::upper_bound(beg, end, -1) == end);
    assert(!std::binary_search(beg, end, 0));
    assert(std::equal_range(beg, end, -1) == std::make_pair(beg, beg));
}

template &amp;lt;typename value_type&amp;gt;
value_type repeat(int v, int w)
{
    value_type result = 0;
    while (w-- != 0)
    {
        result &amp;lt;&amp;lt;= 8;
        result |= v;
    }
    return result;
}

template &amp;lt;typename iter&amp;gt;
void basic_file_tests()
{
    char const * basic_file = basic_test_file("basic_test_file");
    
    typedef typename iter::value_type value_t;
    typedef typename std::pair&amp;lt;iter, iter&amp;gt; range;
    int const w = iter::number_width;
    
    iter beg(basic_file, iter::begin);
    iter end(basic_file, iter::end);
    assert(beg &amp;lt; end);
    assert(!(beg &amp;gt; end));
    assert(!(beg == end));
    assert(beg != end);
    assert(end - beg == 48 / w);
    
    iter mid = beg;
    assert(mid[0] == 0);
    assert(mid[8/w] == repeat&amp;lt;value_t&amp;gt;(3, w));
    assert(*mid == 0);
    assert(*mid++ == 0);
    assert(*--mid == 0);
    assert(*(mid += 16/w) == repeat&amp;lt;value_t&amp;gt;(6, w));
    assert(mid &amp;lt; end);
    assert(mid &amp;gt; beg);
    
    assert(is_sorted(beg, end));
    assert(std::lower_bound(beg, mid, -1) == beg);
    assert(std::lower_bound(beg, mid, 0) == beg);
    assert(std::upper_bound(beg, mid, 0) == beg + 8/w);
    assert(std::upper_bound(beg, mid, 1) == beg + 8/w);
    assert(std::binary_search(beg, end, 0));
    assert(std::binary_search(beg, end, repeat&amp;lt;value_t&amp;gt;(0xf, w)));
    
    mid = beg + 8/w;
    assert(std::equal_range(beg, end, 0) == std::make_pair(beg, mid));
    assert(std::equal_range(beg, end, 1) == std::make_pair(mid, mid));
}

int main()
{
    empty_file_tests();
    basic_file_tests&amp;lt;iter1&amp;gt;();
    basic_file_tests&amp;lt;iter2&amp;gt;();
    basic_file_tests&amp;lt;iter4&amp;gt;();
    basic_file_tests&amp;lt;iter8&amp;gt;();
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc8" name="toctriple-fail" id="toctriple-fail"&gt;Triple fail&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In this article we&amp;#8217;ve discussed binary search:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     referring to existing implementations
 &lt;/li&gt;

 &lt;li&gt;
     calling library routines, such as &lt;code&gt;std::binary_search&lt;/code&gt;
 &lt;/li&gt;

 &lt;li&gt;
     and written some tests.
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Despite this indiscipline, we never even bothered to roll our own binary search: we&amp;#8217;ve tackled the exact opposite of the problem which Mike Taylor set. Programming tasks rarely start with a clear specification, and even if they do, the specification needs questioning.
&lt;/p&gt;
&lt;hr /&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search#toc9" name="tocthanks" id="tocthanks"&gt;Thanks&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;My thanks to &lt;a href="http://www.flickr.com/photos/pinprick/"&gt;pinprick&lt;/a&gt; for the &lt;a href="http://www.flickr.com/photos/pinprick/2547648374"&gt;cheese&lt;/a&gt; &lt;a href="http://www.flickr.com/photos/pinprick/2546825997"&gt;photos&lt;/a&gt;, and for this delicious description.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;morbier is a soft-ripened, washed rind cheese. the tradition of bathing the rinds in salty water (or strong ale) goes back to trappist monks, who perfected the art. washing the rind makes it tougher, protecting the cheese and making it last longer. washing the rind also makes it a place where a certain bacteria, b. linens, love to hang out. while they work their magic, making the cheese inside smooth and creamy and silky, they also make the outside stinky. there isn&amp;#8217;t any good way to put it. however, most stinky cheese taste amazing, and once you realize that, you find that you love the smell of stinky cheese. stink on the outside means gold on the inside! 
   &amp;#8212; &lt;a href="http://www.flickr.com/photos/pinprick/2547648374"&gt;pinprick&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;How long before flickr implements scratch and sniff?
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/binary-search#fn1link"&gt;[1]&lt;/a&gt;: Well, something which masquerades as a random access iterator. Files are not usually random access devices, and the time taken by a seek operation may well vary with the seek offset. By supplying random access scaffolding, we at least ensure that a single, efficient, seek operation is used each time we advance the file position. 
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/binary-search#fn2link"&gt;[2]&lt;/a&gt;: The C++ standard describes the requirements on types in some detail. Unfortunately C++ implementations provide little support for enforcing these requirements. Violations are likely to be punished by &lt;a href="http://wordaligned.org/articles/koenigs-first-rule-of-debugging.html#a-problem-on-line-106"&gt;grotesque compiler warnings&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn3" href="http://wordaligned.org/articles/binary-search#fn3link"&gt;[3]&lt;/a&gt;: The laptop specification:
&lt;/p&gt;
&lt;pre&gt;
Hardware Overview:
  Model Name:	            MacBook
  Model Identifier:	    MacBook1,1
  Processor Name:	    Intel Core Duo
  Processor Speed:	    2 GHz
  Number Of Processors:	    1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;</description>
<dc:date>2010-05-12</dc:date>
<guid>http://wordaligned.org/articles/binary-search</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/binary-search</link>
<category>Algorithms</category>
</item>

<item>
<title>Next permutation: When C++ gets it right</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocthe-next-number-problem" name="toc0" id="toc0"&gt;The Next Number Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocchoice-of-algorithm" name="toc1" id="toc1"&gt;Choice of Algorithm&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toclexicographical-ordering" name="toc2" id="toc2"&gt;Lexicographical Ordering&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocnext-permutation-in-action" name="toc3" id="toc3"&gt;Next permutation in action&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocsnail-sorts-revenge" name="toc4" id="toc4"&gt;Snail sort&amp;#8217;s revenge&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocthe-next-number-solved" name="toc5" id="toc5"&gt;The Next Number, Solved&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocimplementation" name="toc6" id="toc6"&gt;Implementation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocwhats-happening-here" name="toc7" id="toc7"&gt;What&amp;#8217;s happening here?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocbeautiful-c" name="toc8" id="toc8"&gt;Beautiful C++?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocpermutations-in-python" name="toc9" id="toc9"&gt;Permutations in Python&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc0" name="tocthe-next-number-problem" id="tocthe-next-number-problem"&gt;The Next Number Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose you have a fixed list of digits chosen from the range 1..9. What numbers can you make with them? You&amp;#8217;re allowed as many zeros as you want. Write the numbers in increasing order.
&lt;/p&gt;
&lt;p&gt;Exactly &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;this puzzle&lt;/a&gt; came up in the recent &lt;a href="http://code.google.com/codejam"&gt;Google Code Jam&lt;/a&gt; programming contest:
&lt;/p&gt;
&lt;blockquote&gt;You are writing out a list of numbers. Your list contains all numbers with exactly &lt;strong&gt;D&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt; digits in its decimal representation which are equal to i, for each i between 1 and 9, inclusive. You are writing them out in ascending order.&lt;/p&gt;&lt;p&gt;For example, you might be writing every number with two &amp;#8216;1&amp;#8217;s and one &amp;#8216;5&amp;#8217;. Your list would begin 115, 151, 511, 1015, 1051.&lt;/p&gt;&lt;p&gt;Given N, the last number you wrote, compute what the next number in the list will be.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The competition has closed now, but if you&amp;#8217;d like to give it a go sample input files can be found on the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;website&lt;/a&gt;, where you can also upload your results and have them checked.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a short section from a trial I ran on my computer. Input numbers are in the left-hand column: the corresponding output numbers are in the right-hand column.
&lt;/p&gt;
&lt;pre style="font-size:150%"&gt;
50110812884911623516 &amp;rarr; 50110812884911623561
82454322474161687049 &amp;rarr; 82454322474161687094
82040229261723155710 &amp;rarr; 82040229261723157015
43888989554234187388 &amp;rarr; 43888989554234187838
76080994872481480636 &amp;rarr; 76080994872481480663
31000989133449480678 &amp;rarr; 31000989133449480687
20347716554681051891 &amp;rarr; 20347716554681051918
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc1" name="tocchoice-of-algorithm" id="tocchoice-of-algorithm"&gt;Choice of Algorithm&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like many of the code jam challenges, you&amp;#8217;ll need to write a program which runs fast enough; but choosing the right algorithm is more important than choosing the right language. Typically a high-level interpreted language like Python allows me to code and test a solution far more quickly than using a low-level language like C or C++.
&lt;/p&gt;
&lt;p&gt;In this particular case, though, like most &lt;a href="http://www.go-hero.net/jam/09/problems/2/2"&gt;successful candidates&lt;/a&gt;, I used C++. &lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;Here&amp;#8217;s why&lt;/a&gt;.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;&lt;code&gt;Next_permutation&lt;/code&gt;&lt;/a&gt; transforms the range of elements &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically next greater permutation of the elements. [&amp;#8230;] If such a permutation exists, &lt;code&gt;next_permutation&lt;/code&gt; transforms &lt;code&gt;[first, last)&lt;/code&gt; into that permutation and returns true. Otherwise it transforms &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically smallest permutation and returns &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Although the next number problem appears to be about numbers and lexicographical ordering appears to be about words, &lt;code&gt;std::next_permutation&lt;/code&gt; is exactly what&amp;#8217;s needed here.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc2" name="toclexicographical-ordering" id="toclexicographical-ordering"&gt;Lexicographical Ordering&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/4099819327/" title="Lexicographical order by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2449/4099819327_4063635302.jpg" width="500" height="216" alt="Lexicographical order" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;A dictionary provides the canonical example of lexicographical ordering. Words are built from characters, which can be alphabetically ordered A, B, C, &amp;#8230; , so in the dictionary words which begin with &lt;strong&gt;A&lt;/strong&gt; appear before words which begin with &lt;strong&gt;B&lt;/strong&gt;, which themselves come in front of words beginning with &lt;strong&gt;C&lt;/strong&gt;, etc. If two words start with the same letter, pop that letter from the head of the word and compare their tails, which puts AARDVARK before ANIMAL, and &amp;#8212; applying this rule recursively &amp;#8212; after &lt;a href="http://www.aardman.com/" title="Bristol's finest"&gt;AARDMAN&lt;/a&gt;. Imagine there&amp;#8217;s an empty word marking position zero, before A, right at the front of the dictionary, and our recursive  definition is complete.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc3" name="tocnext-permutation-in-action" id="tocnext-permutation-in-action"&gt;Next permutation in action&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple program which shows &lt;code&gt;next_permutation()&lt;/code&gt; in action.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int main()
{
    char xs[] = "123";
    do
    {
        std::puts(xs);
    }
    while (std::next_permutation(xs, xs + sizeof(xs) - 1));
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This program outputs lexicographically ordered permutations of 1, 2 and 3. When the main function returns, the array &lt;code&gt;xs&lt;/code&gt; will have cycled round to hold the lexicographically smallest arrangement of its elements, which is &lt;code&gt;"123"&lt;/code&gt;. Note that we never convert the characters &lt;code&gt;'1'&lt;/code&gt;, &lt;code&gt;'2'&lt;/code&gt;, &lt;code&gt;'3'&lt;/code&gt; into the numbers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;. The values of both sets of data types appear in the same order, so all works as expected.
&lt;/p&gt;
&lt;pre&gt;
123
132
213
231
312
321
&lt;/pre&gt;

&lt;p&gt;If we tweak and rerun the same program with &lt;code&gt;xs&lt;/code&gt; initialised to &lt;code&gt;"AAADKRRV"&lt;/code&gt; we get rather more output.
&lt;/p&gt;
&lt;pre&gt;
AAADKRRV
AAADKRVR
AAADKVRR
...
AARDVARK
...
VRRKAADA
VRRKADAA
VRRKDAAA
&lt;/pre&gt;

&lt;p&gt;The sequence &lt;strong&gt;doesn&amp;#8217;t&lt;/strong&gt; start by repeating &lt;code&gt;"AAADKRRV"&lt;/code&gt; 6 times, once for every permutation of the 3 A&amp;#8217;s. Only strictly increasing permutations are included. And although the repeated calls to &lt;code&gt;next_permutation&lt;/code&gt; generate a series of permutations, the algorithm holds no state. Each function call works on its input range afresh.
&lt;/p&gt;
&lt;p&gt;This second run of the program yields 3360 lines of output, even though there are 8! = 40320 possible permutations of 8 characters. Each unique permutation corresponds to 3! &amp;times; 2! = 12 actual permutations of the 8 characters (because there are 3 A&amp;#8217;s and 2 R&amp;#8217;s), and 40320 &amp;divide; 12 is 3360.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc4" name="tocsnail-sorts-revenge" id="tocsnail-sorts-revenge"&gt;Snail sort&amp;#8217;s revenge&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/tim_norris/2789759648/"&gt;&lt;img src="http://farm4.static.flickr.com/3143/2789759648_ab4bfb5ea8.jpg" width="500px" height="333px" alt="...and in last place. By Tim Norris"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;As you can see, &lt;code&gt;next_permutation&lt;/code&gt; sorts an input range, one step at a time.  When &lt;code&gt;next_permutation&lt;/code&gt; eventually returns false, the range will be perfectly ordered. Hence we have &lt;code&gt;snail_sort()&lt;/code&gt;, hailed by the SGI STL &lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;documentation&lt;/a&gt; as the worst known deterministic sorting algorithm.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;class Iter&amp;gt; 
void snail_sort(Iter first, Iter last)
{
    while (next_permutation(first, last)) {}
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Very witty, and evidence that code can be both &lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html"&gt;elegant and inefficient&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;In two important edge cases, though, &lt;code&gt;snail_sort&lt;/code&gt; performs on a par with super-charged &lt;code&gt;quicksort&lt;/code&gt;!
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     I snail sorted an array filled with 100000000 zeros in 0.502 seconds. Running quicksort on the same array took 5.504 seconds. 
 &lt;/li&gt;

 &lt;li&gt;
     Starting with an array of the same size filled with the values 99999999, 99999998, 99999997, &amp;#8230; 1, 0 snail sort&amp;#8217;s 0.500 seconds trounced quicksort&amp;#8217;s 4.08 seconds.
 &lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc5" name="tocthe-next-number-solved" id="tocthe-next-number-solved"&gt;The Next Number, Solved&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s an outline solution to the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;next number problem&lt;/a&gt;. (I&amp;#8217;ve glossed over the exact input and output file formats for clarity.) It reads numbers from standard input and writes next numbers to standard output. &lt;code&gt;Next_permutation&lt;/code&gt; does the hard work, and there&amp;#8217;s a bit of fiddling when we have to increase the number of digits by adding a zero.&lt;a id="fn1link" href="http://wordaligned.org/articles/next-permutation#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

/*
 Given a string of digits, shift any leading '0's
 past the first non-zero digit and insert an extra zero.
 
 Examples:
  
 123 -&amp;gt; 1023
 008 -&amp;gt; 8000
 034 -&amp;gt; 3004
*/
void insert_a_zero(std::string &amp;amp; number)
{
    size_t nzeros = number.find_first_not_of('0');
    number = number.substr(nzeros);
    number.insert(1, nzeros + 1, '0');
}

/*
 Outline solution to the 2009 code jam Next Number problem.
 
 Given a string representing a decimal number, find the next
 number which can be formed from the same set of digits. Add
 another zero if necessary. Repeat for all such strings read
 from standard input.
*/
int main()
{
    std::string number;
    while (std::cin &amp;gt;&amp;gt; number)
    {
        if (!next_permutation(number.begin(), number.end()))
        {
            insert_a_zero(number);
        }
        std::cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; '\n';
    }
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc6" name="tocimplementation" id="tocimplementation"&gt;Implementation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having used the C++ standard library to solve the puzzle, let&amp;#8217;s take a look at how it works. Next permutation is a clever algorithm which shuffles a collection in place. My system implements it like this&lt;a id="fn2link" href="http://wordaligned.org/articles/next-permutation#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;
        
    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We start with a range delimited by a pair of bi-directional iterators, &lt;code&gt;[first, last)&lt;/code&gt;. If the range contains one item or fewer, there can be no next permutation, so leave the range as is and return &lt;code&gt;false&lt;/code&gt;. Otherwise, enter the &lt;code&gt;for&lt;/code&gt; loop with an iterator &lt;code&gt;i&lt;/code&gt; pointing at the final item in the range.
&lt;/p&gt;
&lt;p&gt;At each pass through the body of this for loop we decrement &lt;code&gt;i&lt;/code&gt; by one, stepping towards the first item in the range. We are looking for one of two conditions:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     the value pointed to by &lt;code&gt;i&lt;/code&gt; is smaller than the one it pointed to previously
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;i&lt;/code&gt; reaches into the first item in the range
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Put another way, we divide the range into a head and tail, where the tail is the longest possible decreasing tail of the range.
&lt;/p&gt;
&lt;p&gt;If this tail is the whole range (the second condition listed above) then the whole range is in reverse order, and we have the lexicographical maximum formed from its elements. Reversing the range returns it to its lexicographical minimum, and we can return &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;If this tail is not the whole range, then the final item in the head of the range, the item &lt;code&gt;i&lt;/code&gt; points to, this item is smaller than at least one of the items in the tail of the range, and we can certainly generate a greater permutation by moving the item towards the end of the range. To find the next permutation, we reverse iterate from the end of the range until we find an item &lt;code&gt;*j&lt;/code&gt; bigger than &lt;code&gt;*i&lt;/code&gt; &amp;#8212; that&amp;#8217;s what the while loop does. Swapping the items pointed to by &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; ensures the head of the range is bigger than it was, and the tail of the range remains in reverse order. Finally, we reverse the tail of the range, leaving us with a permutation exactly one beyond the input permutation, and we return &lt;code&gt;true&lt;/code&gt;. 
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc7" name="tocwhats-happening-here" id="tocwhats-happening-here"&gt;What&amp;#8217;s happening here?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s clear from this paper analysis that the algorithm is of linear complexity. Essentially, it walks up and down the tail of the list, comparing and swapping. But why does it work?
&lt;/p&gt;
&lt;p&gt;Let &lt;code&gt;xs&lt;/code&gt; be the range &lt;code&gt;(first, last)&lt;/code&gt;. As described above, divide this range into prefix and suffix subranges, &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, where &lt;code&gt;tail&lt;/code&gt; is the longest monotonically decreasing tail of the range.
&lt;/p&gt;
&lt;p&gt;If the &lt;code&gt;head&lt;/code&gt; of the range is empty, then the range &lt;code&gt;xs&lt;/code&gt; is clearly at its lexicographical maximum. 
&lt;/p&gt;
&lt;p&gt;Otherwise, &lt;code&gt;tail&lt;/code&gt; is a lexicographical maximum of the elements it contains, and &lt;code&gt;xs&lt;/code&gt; is therefore the largest permutation which starts with the subrange &lt;code&gt;head&lt;/code&gt;. What will the &lt;code&gt;head&lt;/code&gt; of the next permutation be? We have to swap the final item in &lt;code&gt;head&lt;/code&gt; with the smallest item of &lt;code&gt;tail&lt;/code&gt; which exceeds it: the definition of &lt;code&gt;tail&lt;/code&gt; guarantees at least one such item exists. Now we want to permute the new &lt;code&gt;tail&lt;/code&gt; to be at a its lexicographical minimum, which is a matter of sorting it from low to high.
&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;tail&lt;/code&gt; is in reverse order, finding the smallest item larger than &lt;code&gt;head[-1]&lt;/code&gt; is a matter of walking back from the end of the range to find the first such items; and once we&amp;#8217;ve swapped these items, &lt;code&gt;tail&lt;/code&gt; remains in reverse order, so a simple reversed will sort it.
&lt;/p&gt;
&lt;p&gt;As an example consider finding the next permutation of:
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8342666411
&lt;/pre&gt;

&lt;p&gt;The longest monotonically decreasing tail is &lt;code&gt;666411&lt;/code&gt;, and the corresponding head is &lt;code&gt;8342&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8342 666411
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;666411&lt;/code&gt; is, by definition, reverse-ordered, and cannot be increased by permuting its elements. To find the next permutation, we must increase the head; a matter of finding the smallest tail element larger than the head&amp;#8217;s final &lt;code&gt;2&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;2&lt;/span&gt; 666411
&lt;/pre&gt;

&lt;p&gt;Walking back from the end of tail, the first element greater than &lt;code&gt;2&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;2&lt;/span&gt;  666&lt;span style="color:#930"&gt;4&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Swap the &lt;code&gt;2&lt;/code&gt; and the &lt;code&gt;4&lt;/code&gt;
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;4&lt;/span&gt; 666&lt;span style="color:#930"&gt;2&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Since head has increased, we now have a greater permutation. To reduce to the next permutation, we reverse tail, putting it into increasing order.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8344 112666
&lt;/pre&gt;

&lt;p&gt;Join the head and tail back together. The permutation one greater than &lt;code&gt;8342666411&lt;/code&gt; is &lt;code&gt;8344112666&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc8" name="tocbeautiful-c" id="tocbeautiful-c"&gt;Beautiful C++?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/looping-forever-and-ever.html"&gt;&lt;img  src="http://wordaligned.org/images/mite.jpg" alt="for(;;) dust mite"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;C++ has its &lt;a href="http://yosefk.com/c++fqa/defective.html" title="If you are an expert in the intricacies of C++, please consider this knowledge a kind of martial art - something a real master never uses. Yossi Keinin"&gt;detractors&lt;/a&gt;, who characterise it as subtle, &lt;a href="http://twitter.com/dabeaz/status/5677453478" title="C++0x reminds me of blocks stacked by my toddler. Really wobbly and one block too many makes it topple. @dabeaz"&gt;complex&lt;/a&gt;, and &lt;a href="http://www2.research.att.com/~bs/bs_faq.html#really-say-that" title="C++ can blow your whole leg off. Bjarne Stroustrup"&gt;dangerous&lt;/a&gt;; but sometimes it excels. Look once more at the C++ implementation of this algorithm.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;
    
    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span /&gt;With its special cases, boolean literals, multiple returns (4, count them!), disembodied and infinite loops, this code fails to exhibit conventional beauty. Yet &lt;em&gt;it is&lt;/em&gt; beautiful. All the next permutation algorithm needs are iterators which can advance forwards or backwards, step by step. And that&amp;#8217;s all this implementation uses.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m as excited as anyone by the mathematical rigour of &lt;a href="http://www.informit.com/articles/article.aspx?p=1407357&amp;amp;seqNum=3" title="Great article by Andrei Alexandrescu, which questions a pure Haskell quicksort implementation"&gt;functional programming&lt;/a&gt;, but sometimes computer science is about algorithms with virtually no space overhead, algorithms which loop rather than recurse. Sometimes it&amp;#8217;s about shuffling, nudging and swapping &amp;#8212; operations which map directly to the machine&amp;#8217;s most primitive operations. In such cases, C++ gets it right.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc9" name="tocpermutations-in-python" id="tocpermutations-in-python"&gt;Permutations in Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For the code jam, though, as mentioned earlier, having a super-fast program rarely matters. More often, it&amp;#8217;s about developing a fast enough program super-quickly.
&lt;/p&gt;
&lt;p&gt;I find Python a far quicker language for developing code than C++. (Indeed, sometimes when it&amp;#8217;s obvious from the outset that a final program will need implementing in C++, I put together a working prototype using Python, which I then translate.) Could we solve the next number problem using code from the standard Python library?
&lt;/p&gt;
&lt;p&gt;At a first glance, &lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.permutations"&gt;itertools.permutations&lt;/a&gt; looks promising.
&lt;/p&gt;
&lt;blockquote&gt;&lt;h3&gt;&lt;tt&gt;itertools.permutations(&lt;em&gt;iterable&lt;/em&gt;, &lt;em&gt;r=None&lt;/em&gt;)&lt;/tt&gt;&lt;/h3&gt;&lt;p&gt;Return successive &lt;em&gt;r&lt;/em&gt; length permutations of elements in the &lt;em&gt;iterable&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;If &lt;em&gt;r&lt;/em&gt; is not specified or is &lt;tt&gt;None&lt;/tt&gt;, then &lt;em&gt;r&lt;/em&gt; defaults to the length
of the &lt;em&gt;iterable&lt;/em&gt; and all possible full-length permutations
are generated.&lt;/p&gt;&lt;p&gt;Permutations are emitted in lexicographic sort order.  So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the permutation tuples will be produced in sorted order.&lt;/p&gt;&lt;p&gt;Elements are treated as unique based on their position, not on their value.  So if the input elements are unique, there will be no repeat values in each permutation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;However, this algorithm doesn&amp;#8217;t care about the values of the items in the iterable, and the lexicographic sort order applies to the indices of these items. So although the ordering of the generated items is well-defined:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     we get repeats, and
 &lt;/li&gt;

 &lt;li&gt;
     it&amp;#8217;s not the ordering we want (in this case)
 &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; concat = ''.join
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations('AAA')))
['AAA', 'AAA', 'AAA', 'AAA', 'AAA', 'AAA']
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations('231')))
['231', '213', '321', '312', '123', '132']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It &lt;strong&gt;is&lt;/strong&gt; possible to code up &lt;code&gt;next_permutation&lt;/code&gt; using nothing more than the standard itertools, but it isn&amp;#8217;t advisable.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Snail permute&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import permutations, groupby

def next_permutation(xs):
    """Calculate the next permutation of the sequence xs.
    
    Returns a pair (yn, xs'), where yn is a boolean and xs' is the 
    next permutation. If yn is True, xs' will be the lexicographic 
    next permutation of xs, otherwise xs' is the lexicographic 
    smallest permutation of xs.
    """
    xs = tuple(xs)
    if not xs:
        return False, xs
    else:
        ps = [p for p, gp in groupby(sorted(permutations(xs)))]
        np = len(ps)
        ix = ps.index(xs) + 1
        if ix == len(ps):
            return False, ps[0]
        else:
            return True, ps[ix]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As it happens, a solution based on this exhaustive search would score points in the code jam since it copes with the small input set. For the large input set its factorial complexity rules it out, and we&amp;#8217;d need to implement the next permutation algorithm &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1"&gt;from scratch&lt;/a&gt;.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/next-permutation#fn1link"&gt;[1]&lt;/a&gt;: A more cunning &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1"&gt;solution&lt;/a&gt; avoids the special case by pushing the extra zero to head of the string before applying &lt;code&gt;next_permutation&lt;/code&gt;, then popping it if it hasn&amp;#8217;t been moved.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/next-permutation#fn2link"&gt;[2]&lt;/a&gt;: I&amp;#8217;ve tweaked the layout and parameter names for use on this site.
&lt;/p&gt;</description>
<dc:date>2009-11-19</dc:date>
<guid>http://wordaligned.org/articles/next-permutation</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/next-permutation</link>
<category>Algorithms</category>
</item>

<item>
<title>Partitioning with Python</title>
<description>&lt;h3&gt;Sums and Splits&lt;/h3&gt;
&lt;p&gt;On the subject of &lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;hunting for eodermdromes&lt;/a&gt;, here are a couple of semi-related partitioning problems.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     for a positive integer, N, find the positive integer sequences which sum to N
 &lt;/li&gt;

 &lt;li&gt;
     for a sequence, S, find the distinct partitions of that sequence
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As an example of the first, the 16 distinct integer sequences which sum to 5 are:
&lt;/p&gt;
&lt;pre&gt;
5
4 + 1
3 + 1 + 1
3 + 2
2 + 1 + 2
2 + 1 + 1 + 1
2 + 2 + 1
2 + 3
1 + 1 + 3
1 + 1 + 2 + 1
1 + 1 + 1 + 1 + 1
1 + 1 + 1 + 2
1 + 2 + 2
1 + 2 + 1 + 1
1 + 3 + 1
1 + 4
&lt;/pre&gt;

&lt;p&gt;and of the second, the 8 distinct ways of partitioning the sequence ABCD are:
&lt;/p&gt;
&lt;pre&gt;
ABCD
A BCD
AB CD
ABC D
A B CD
A BC D
AB C D
A B C D
&lt;/pre&gt;

&lt;p&gt;Note that I&amp;#8217;ve counted 2 + 1 + 2, 2 + 2 + 1, and 1 + 2 + 2 as distinct sums totalling 5. That happens to be the formulation of the problem which interested me.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Context&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;&lt;img src="http://wordaligned.org/images/eodermdrome.png" width="200px" height="200px" style="float:right" alt="eodermdrome"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Before discussing a solution to these problems, some context. Recall that an &lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;eodermdrome&lt;/a&gt; is a sequence which forms an Eulerian circuit through the fully connected graph whose vertices are the set of its elements. Put more simply: when you trace through the letters you get the figure shown, with no edge covered twice. Examples include:
&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;span style="color:#930"&gt;O&lt;/span&gt;&lt;span style="color:#036"&gt;D&lt;/span&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;R&lt;/span&gt;&lt;span style="color:#e50"&gt;M&lt;/span&gt;&lt;span style="color:#036"&gt;D&lt;/span&gt;&lt;span style="color:#555"&gt;R&lt;/span&gt;&lt;span style="color:#930"&gt;O&lt;/span&gt;&lt;span style="color:#e50"&gt;M&lt;/span&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;N&lt;/span&gt;&lt;span style="color:#036"&gt;H&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#555"&gt;N&lt;/span&gt;&lt;span style="color:#888"&gt;C&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt; &lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#888"&gt;C&lt;/span&gt;&lt;span style="color:#036"&gt;H&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#888"&gt;X&lt;/span&gt; &lt;span style="color:#e50"&gt;D&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#e50"&gt;D&lt;/span&gt; &lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#888"&gt;X&lt;/span&gt;&lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Eodermdromes turn out to be surprisingly rare. Writing a computer program to find them is a nice exercise in searching and text processing. Clearly, we should start with a collection of words. Then we can generate combinations of words from this collection and filter out the eodermdromes.
&lt;/p&gt;
&lt;pre&gt;
(filter eodermdrome? (combinations words))
&lt;/pre&gt;

&lt;p&gt;A large set of words (note: &amp;#8220;set&amp;#8221; not &amp;#8220;collection&amp;#8221;, we don&amp;#8217;t need duplicates) gives the best chance of success. I started with a file containing more than 35 thousand distinct words. This gives over a billion possible word pairs, and when we consider word triples and quartets the numbers get silly even for a modern computer.
&lt;/p&gt;
&lt;p&gt;As is so often the case in computing, we have a tension between opposing concerns. We&amp;#8217;d like code which separates the task of generating candidates and the task of testing these candidates for eodermdromicity, but in order to run this code in a timely manner we need some of the eodermdrome testing to leak into the candidate generation. For example, we could preprocess the word set removing words which contain double Ls (all, ball, call, ill, Bill, kill &amp;#8230;) since these can never appear in an eodermdrome. And we could similarly remove words which end ETE (delete, Pete, effete). As I hope you can see, it&amp;#8217;s easy to end up with finickity code and co-dependent functions.
&lt;/p&gt;
&lt;p&gt;I chose a simple but effective strategy to reduce the search space to something manageable, based on word length. First, then, I loaded my word set into a Python dict collecting lists of words keyed by their length.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import defaultdict
&amp;gt;&amp;gt;&amp;gt; words = defaultdict(list)
&amp;gt;&amp;gt;&amp;gt; for word in open('word-set.txt').read().split():
...     words[len(word)].append(word)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Given this dict, picking out single word eodermdromes is easy.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; list(filter(is_eodermdrome, words[11]))
['eodermdrome']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about eodermdromes composed of a 6 letter word followed by a 5 letter word? We can form the &lt;a href="http://docs.python.org/library/itertools.html#itertools.product"&gt;cartesian product&lt;/a&gt; of the lists of 6 and 5 letter words and filter out the ones we want.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import product
&amp;gt;&amp;gt;&amp;gt; eod_6_5 = filter(is_eodermdrome, product(words[6], words[5]))
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
('earned', 'andre')
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
('yearly', 'relay')

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about &lt;em&gt;all eodermdromes&lt;/em&gt; of length 11?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import chain.from_iterable as seq
&amp;gt;&amp;gt;&amp;gt; word_lens = sum_to_n(11)
&amp;gt;&amp;gt;&amp;gt; candidates = seq(product(*[words[i] for i in s]) for s in word_lens)
&amp;gt;&amp;gt;&amp;gt; eods = filter(is_eodermdrome, candidates)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note here that I&amp;#8217;m using Python 3.0, and that &lt;a href="http://docs.python.org/py3k/library/functions.html#filter"&gt;filter&lt;/a&gt; is therefore a lazy function. The interactive session shown above hasn&amp;#8217;t actually started taking anything from these lazily-evaluated streams.
&lt;/p&gt;
&lt;p&gt;I certainly don&amp;#8217;t claim this is the quickest way to search for eodermdromes. In fact, this little program took several hours to complete. But a back-of-an-envelope calculation showed it &lt;em&gt;would&lt;/em&gt; complete in a few hours, and that was good enough.
&lt;/p&gt;
&lt;p&gt;Note also that we haven&amp;#8217;t shown an implementation of &lt;code&gt;sum_to_n()&lt;/code&gt; yet, which takes us back to the problems posed at the start of this article.
&lt;/p&gt;

&lt;h3&gt;Sum to N&lt;/h3&gt;
&lt;p&gt;Finding the positive integer series which sum to a positive integer N is a job for &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;itertools.combinations&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import combinations, chain

def sum_to_n(n):
    'Generate the series of +ve integer lists which sum to a +ve integer, n.'
    from operator import sub
    b, mid, e = [0], list(range(1, n)), [n]
    splits = (d for i in range(n) for d in combinations(mid, i)) 
    return (list(map(sub, chain(s, e), chain(b, s))) for s in splits)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The idea here is straightforward: there&amp;#8217;s a 1-to-1 correspondence between the sums we want and ordered combinations drawn from the series 1, 2, &amp;#8230; n-1. For example, if n is 11 one such combination would be:
&lt;/p&gt;
&lt;pre&gt;
(1, 5, 7, 10)
&lt;/pre&gt;

&lt;p&gt;we can extend this by pushing 0 in front and n at the end
&lt;/p&gt;
&lt;pre&gt;
(0, 1, 5, 7, 10, 11)
&lt;/pre&gt;

&lt;p&gt;This extended tuple can now be seen as partial sums of a series which sums to 11. Taking differences gives the series
&lt;/p&gt;
&lt;pre&gt;
(1-0, 5-1, 7-5, 10-7, 11-10)
&lt;/pre&gt;

&lt;p&gt;which is
&lt;/p&gt;
&lt;pre&gt;
(1, 4, 2, 3, 1)
&lt;/pre&gt;

&lt;p&gt;which does indeed sum to 11
&lt;/p&gt;
&lt;pre&gt;
1 + 4 + 2 + 3 + 1 = 11
&lt;/pre&gt;

&lt;p&gt;The Python code shown uses a clever idea to implement this staggered differencing, an idea I &lt;a href="http://newsimg.bbc.co.uk/media/images/45909000/jpg/_45909582_badartists.jpg" title="Bristol's famous artist and thief"&gt;cleverly stole&lt;/a&gt; from one of &lt;a href="http://code.activestate.com/recipes/users/178123/"&gt;Raymond Hettinger&amp;#8217;s brilliant Python recipes&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;Partitioning a Sequence&lt;/h3&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Python Cookbook: Recipe 576795&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import chain, combinations

def partition(iterable, chain=chain, map=map):
    s = iterable if hasattr(iterable, '__getslice__') else tuple(iterable)
    n = len(s)
    first, middle, last = [0], range(1, n), [n]
    getslice = s.__getslice__
    return [map(getslice, chain(first, div), chain(div, last))
            for i in range(n) for div in combinations(middle, i)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This &lt;a href="http://code.activestate.com/recipes/576795"&gt;recipe&lt;/a&gt; shows sum-to-n and partitioning to be very similar problems. In fact, we could easily implement &lt;code&gt;sum_to_n()&lt;/code&gt; on top of  &lt;code&gt;partition()&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def sum_to_n(n):
    return ([len(t) for t in p] for p in partition(range(n)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The posted recipe needs a minor overhaul to get it working with Python 3.0, &lt;a href="http://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods"&gt;which does away&lt;/a&gt; with &lt;code&gt;__getslice__&lt;/code&gt;: getting a slice is simply what &lt;code&gt;__getitem__&lt;/code&gt; does when given a slice object. The 2to3 tool fails to convert the recipe, which must be recast as something like:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import chain, combinations

def sliceable(xs):
    '''Return a sliceable version of the iterable xs.'''
    try:
        xs[:0]
        return xs
    except TypeError:
        return tuple(xs)

def partition(iterable):
    s = sliceable(iterable)
    n = len(s)
    b, mid, e = [0], list(range(1, n)), [n]
    getslice = s.__getitem__
    splits = (d for i in range(n) for d in combinations(mid, i))
    return [[s[sl] for sl in map(slice, chain(b, d), chain(d, e))]
            for d in splits]

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Sum to N, again&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a variant implementation of &lt;code&gt;sum_to_n()&lt;/code&gt;. The idea here is to fill N slots with a pattern of 0&amp;#8217;s and 1&amp;#8217;s. We then reduce this pattern to the lengths of runs of repeated elements, giving a series which sums to N. &lt;code&gt;Itertools.product('01', repeat=n)&lt;/code&gt; generates all possible binary patterns of length N, which turns out to be twice as many as we want since (e.g.) 00001111100 and 11110000011 represent the same sum, 4 + 5 + 2; hence the n-1 &lt;code&gt;repeat&lt;/code&gt; count and the call to &lt;code&gt;chain&lt;/code&gt; in the code below&lt;a id="fn1link" href="http://wordaligned.org/articles/partitioning-with-python#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import groupby, chain, product

def ilen(it):
    return sum(1 for _ in it)

def sum_to_n(n):
    return ([ilen(gp) for _, gp in groupby(chain('1', O1))]
            for O1 in product('01', repeat=n-1))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Fun, but the version using &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;combinations&lt;/a&gt; is better!
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/partitioning-with-python#fn1link"&gt;[1]&lt;/a&gt; My first thought was to use &lt;code&gt;itertools.islice&lt;/code&gt; to limit the stream to the first 2&lt;sup&gt;n-1&lt;/sup&gt; values, but I discovered &lt;code&gt;islice&lt;/code&gt; has a surprising &lt;a href="http://bugs.python.org/issue6305" title="I've reported this as a bug"&gt;limitation&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import islice, count
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31) - 1)
&amp;lt;itertools.islice object at 0x63a0c0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31))
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
ValueError: Stop argument for islice() must be a non-negative integer or None.

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;
&lt;p style="text-align:center"&gt;so reuse ours&lt;/p&gt;</description>
<dc:date>2009-06-17</dc:date>
<guid>http://wordaligned.org/articles/partitioning-with-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/partitioning-with-python</link>
<category>Algorithms</category>
</item>

<item>
<title>Patience sort and the Longest increasing subsequence</title>
<description>&lt;a href="http://wordaligned.org/articles/patience-sort.html"&gt;&lt;img src="http://wordaligned.org/images/patience-sort.gif" alt="Patience sort and longest increasing subsequence"/&gt;&lt;/a&gt;&lt;p&gt;This article relies on Javascript and CSS for graphical content and I don&amp;#8217;t trust a feed reader to render it properly, which is why I&amp;#8217;m posting a teaser here rather than the full content. To find out how a simple card game provides an efficient algorithm for finding the longest increasing subsequence of a sequence, please &lt;a href="http://wordaligned.org/articles/patience-sort.html"&gt;visit the original&lt;/a&gt;.&lt;/p&gt;</description>
<dc:date>2009-03-26</dc:date>
<guid>http://wordaligned.org/articles/patience-sort</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/patience-sort</link>
<category>Algorithms</category>
</item>

<item>
<title>Longest common subsequence</title>
<description>&lt;a href="http://wordaligned.org/articles/longest-common-subsequence.html"&gt;&lt;img src="http://wordaligned.org/images/human-chimpanzee-lcs.gif" alt="LCS(HUMAN, CHIMPANZEE)"/&gt;&lt;/a&gt;&lt;p&gt;This article relies on Javascript and CSS for graphical content and I don&amp;#8217;t trust a feed reader to render it properly, which is why I&amp;#8217;m posting a teaser here rather than the full content. To find out why I&amp;#8217;m comparing humans with chimpanzees, please &lt;a href="http://wordaligned.org/articles/longest-common-subsequence"&gt;visit the original&lt;/a&gt;.&lt;/p&gt;</description>
<dc:date>2009-03-11</dc:date>
<guid>http://wordaligned.org/articles/longest-common-subsequence</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/longest-common-subsequence</link>
<category>Algorithms</category>
</item>

<item>
<title>Maximum of an empty sequence?</title>
<description>&lt;p&gt;So it happened: as of Python 3.0, &lt;code&gt;reduce()&lt;/code&gt; is no longer a built-in function. In the &lt;a href="http://docs.python.org/dev/3.0/whatsnew/3.0.html#builtins"&gt;&amp;#8220;What&amp;#8217;s New?&amp;#8221;&lt;/a&gt; Guido van Rossum can&amp;#8217;t resist firing a parting shot.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Removed &lt;code&gt;reduce()&lt;/code&gt;. Use &lt;code&gt;&lt;a href="http://docs.python.org/3.0/library/functools.html#functools.reduce"&gt;functools.reduce()&lt;/a&gt;&lt;/code&gt; if you really need it; however, 99 percent of the time an explicit &lt;code&gt;&lt;a href="http://docs.python.org/3.0/reference/compound_stmts.html#for"&gt;for&lt;/a&gt;&lt;/code&gt; loop is more readable.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Take that!
&lt;/p&gt;
&lt;p&gt;As I&amp;#8217;ve noted before, reduce can be side-lined in this way without causing pain because other built-ins cover the common reductions:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     &lt;code&gt;sum&lt;/code&gt;
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt;
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and the &lt;code&gt;join&lt;/code&gt; method concatenates built-in string and bytes types.
&lt;/p&gt;
&lt;p&gt;These standard functions are flexible enough to work on any iterable, be it an in-memory sequence like a list, or a stream generated one element at a time. Beware the boundary case! What if an iterable generates no elements? We can&amp;#8217;t determine its length up front, and we don&amp;#8217;t want to pull it all into memory at once just to find out if it&amp;#8217;s empty.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;Let&amp;#8217;s fire up a Python interpreter to experiment. Happily lambda survived the version 3.0 transition, and we can use it to build a mini factory function for empty streams.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; zs = lambda: iter(set())
&amp;gt;&amp;gt;&amp;gt; zs()
&amp;lt;set_iterator object at 0x6f49f8&amp;gt;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Incidentally, have you discovered Python 3.0&amp;#8217;s new set literal syntax? For example, &lt;code&gt;{True, False}&lt;/code&gt; is the set of boolean values. Sadly &lt;code&gt;{}&lt;/code&gt; creates an empty dict, just like it always did, and not an empty set, &amp;empty;.)
&lt;/p&gt;
&lt;p&gt;Can we reduce these empty iterables? No problem!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; all(zs())
True
&amp;gt;&amp;gt;&amp;gt; any(zs())
False
&amp;gt;&amp;gt;&amp;gt; '!?'.join(zs())
''
&amp;gt;&amp;gt;&amp;gt; sum(zs())
0

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Hang on though!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; max(zs())
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
ValueError: max() arg is an empty sequence

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So what exactly did we expect the maximum value of an empty sequence to be? The only plausible answer is to bounce the question back to clients and allow them to supply a default. Since the built-in max function doesn&amp;#8217;t allow this, we&amp;#8217;d need to write something like:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; def maximum(iterable, default):
...     '''Like max(), but returns a default value if xs is empty.'''
...     try:
...         return max(iterable)
...     except ValueError:
...         return default
... 
&amp;gt;&amp;gt;&amp;gt; maximum(zs(), -1)
-1

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Alternatively, the recently demoted reduce &lt;strong&gt;does&lt;/strong&gt; admit an initial value.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from functools import reduce, partial
&amp;gt;&amp;gt;&amp;gt; maximum = partial(reduce, max)
&amp;gt;&amp;gt;&amp;gt; maximum(range(42))
41
&amp;gt;&amp;gt;&amp;gt; maximum(zs(), -1)
-1

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;I guess I should point out that the final version of &lt;code&gt;maximum()&lt;/code&gt; repeatedly calls the two argument flavour of &lt;code&gt;max()&lt;/code&gt;, and may prove suboptimal for large sequences.
&lt;/p&gt;
&lt;p&gt;This may all seem trivial, but it&amp;#8217;s an issue I really did encounter recently &amp;#8212; &lt;a href="http://feeds.wordaligned.org/wordaligned"&gt;stay tuned&lt;/a&gt; for details. I&amp;#8217;m not convinced Python gets things right, so I had a quick look at the support built into other languages. Some avoid the problem, only offering a two argument version of &lt;code&gt;max()&lt;/code&gt;. Algorithms in the standard C++ library typically deal with half-open iterator ranges, and the range end forms a natural sentinel which &lt;code&gt;&lt;a href="http://www.sgi.com/tech/stl/max_element.html"&gt;std::max_element()&lt;/a&gt;&lt;/code&gt; can return given an empty range. Perl also &lt;a href="http://perldoc.perl.org/List/Util.html#max-LIST"&gt;returns a sentinel value&lt;/a&gt; if &lt;code&gt;max&lt;/code&gt; is called on an empty list.
&lt;/p&gt;</description>
<dc:date>2009-03-03</dc:date>
<guid>http://wordaligned.org/articles/maximum-of-an-empty-sequence</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/maximum-of-an-empty-sequence</link>
<category>Algorithms</category>
</item>

<item>
<title>Running Sums in Python</title>
<description>&lt;p&gt;Suppose we want to generate the running sum series &lt;code&gt;r&lt;/code&gt; formed by sums of &lt;code&gt;n&lt;/code&gt; consecutive elements taken from a series &lt;code&gt;s&lt;/code&gt;. For example, to sum consecutive pairs taken from the first 6 integers:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; n = 2
&amp;gt;&amp;gt;&amp;gt; s = 0, 1, 2, 3, 4, 5
&amp;gt;&amp;gt;&amp;gt; running_sum(s, 2)
[1, 3, 5, 7, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;One approach would be to combine the &lt;code&gt;sum&lt;/code&gt; built-in function with list slices and comprehensions.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; def running_sum(s, n):
... 	return [sum(s[lo:lo + n]) for lo in range(len(s) - n + 1)]
... 
&amp;gt;&amp;gt;&amp;gt; running_sum([0, 1, 2, 3, 4, 5], 2)
[1, 3, 5, 7, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This is fine if:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     &lt;code&gt;s&lt;/code&gt; is finite
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;s&lt;/code&gt; supports slice access (i.e. &lt;code&gt;s[lo:hi]&lt;/code&gt; doesn&amp;#8217;t raise a &lt;code&gt;TypeError&lt;/code&gt;)
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;n&lt;/code&gt; isn&amp;#8217;t too big
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With just a little extra thought we can address all these issues.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;To deal with the first two points we return to the specification. What exactly do we require of &lt;code&gt;s&lt;/code&gt; in order to generate &lt;code&gt;r&lt;/code&gt;? Well, all that&amp;#8217;s really needed is for &lt;code&gt;s&lt;/code&gt; to be iterable &amp;#8212; which is to say we can advance along it &amp;#8212; then our running sum function can arrange to buffer &lt;code&gt;n&lt;/code&gt; items from &lt;code&gt;s&lt;/code&gt; and yield their sums. For maximum flexibility the result series &lt;code&gt;r&lt;/code&gt; should also be iterable, allowing clients to choose how to consume it&lt;a id="fn1link" href="http://wordaligned.org/articles/running-sums-in-python#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;In Python an object, &lt;code&gt;o&lt;/code&gt;, becomes iterable by implementing the &lt;a href="http://docs.python.org/lib/typeiter.html"&gt;iterator protocol&lt;/a&gt;: &lt;code&gt;o.__iter__()&lt;/code&gt; should return an iterator, &lt;code&gt;i&lt;/code&gt;, over the container, which &lt;code&gt;i.next()&lt;/code&gt; advances, raising a &lt;code&gt;StopIteration&lt;/code&gt; exception when done.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; r = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; i = r.__iter__()
&amp;gt;&amp;gt;&amp;gt; i.next()
1
&amp;gt;&amp;gt;&amp;gt; i.next()
2
&amp;gt;&amp;gt;&amp;gt; i.next()
3
&amp;gt;&amp;gt;&amp;gt; i.next()
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
StopIteration

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Python programs typically don&amp;#8217;t expose this protocol directly since we can build more convenient looping constructs on top of it. By using the &lt;a href="http://docs.python.org/ref/yield.html"&gt;yield statement&lt;/a&gt; our running sum filter needn&amp;#8217;t implement the iterator protocol directly either. Here&amp;#8217;s a generator function which uses &lt;code&gt;itertools.islice&lt;/code&gt; in place of the original list slices.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Running sum for infinite series&lt;/div&gt;

&lt;pre class="prettyprint"&gt;import itertools

def running_sum(s, n):
    while True:
        r, s = itertools.tee(s)
        yield sum(itertools.islice(r, n))
        s.next()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As you can see, objects returned by this function implement the iterator protocol.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;# Running sum of pairs from 0, 1, 2, 3, ...
&amp;gt;&amp;gt;&amp;gt; rs = running_sum(itertools.count(), 2)
&amp;gt;&amp;gt;&amp;gt; i = rs.__iter__()
&amp;gt;&amp;gt;&amp;gt; i.next()
1
&amp;gt;&amp;gt;&amp;gt; i.next()
3
&amp;gt;&amp;gt;&amp;gt; for s in rs: print s
... 
5
7
9
11
13
....
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
KeyboardInterrupt

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We have to kill the for loop by interrupting it since &lt;code&gt;rs&lt;/code&gt;, being infinite (in this particular case), never raises a &lt;code&gt;StopIteration&lt;/code&gt;. In fact, this particular version of &lt;code&gt;running_sum()&lt;/code&gt; fails badly on finite inputs for reasons we&amp;#8217;ll touch on later.
&lt;/p&gt;
&lt;p&gt;I won&amp;#8217;t dwell on this flawed variant of &lt;code&gt;running_sum()&lt;/code&gt;, except to note in passing that the built-in sum function doesn&amp;#8217;t buffer &lt;code&gt;n&lt;/code&gt; items from its input stream &amp;#8212; it&amp;#8217;s a lazy function which accumulates these items one at a time. There&amp;#8217;s no magic here, though: behind the scenes, as the teed iterators &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; diverge, the in-between values must be stored somewhere!
&lt;/p&gt;
&lt;p&gt;Each slice of items from &lt;code&gt;s&lt;/code&gt; overlaps the one before: if we visualise the sliced range sliding along the series, at each stage an element gets pushed in at the top and an element gets popped out from the bottom. Rather than repeatedly summing all the elements of these slices, we can calculate a single sum at the start of the series then adjust it as we progress&lt;a id="fn2link" href="http://wordaligned.org/articles/running-sums-in-python#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def running_sum(s, n):
    lo, hi = itertools.tee(s)
    rs = sum(itertools.islice(hi, n))
    while True:
        yield rs
        rs += hi.next() - lo.next()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Before we sign this function off, there&amp;#8217;s a bug to fix. What if &lt;code&gt;n&lt;/code&gt; is larger than the length of the input series? We&amp;#8217;d expect the output series to be empty, but:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; list(running_sum([1, 2, 3], 4))
[6]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Oops! The problem here is in passing an &lt;code&gt;itertools.islice&lt;/code&gt; series to &lt;code&gt;sum()&lt;/code&gt;, which happily swallows the &lt;code&gt;StopIteration&lt;/code&gt; exception without knowing if the sliced stream reached its end or if we reached the end of the slice, or indeed both.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; i = itertools.islice([1, 2, 3], 4)
&amp;gt;&amp;gt;&amp;gt; i.next(), i.next(), i.next()
(1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; i.next()
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
StopIteration

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A fix is to pass &lt;code&gt;sum&lt;/code&gt; a list comprehension. If &lt;code&gt;n&lt;/code&gt; is too big a &lt;code&gt;StopIteration&lt;/code&gt; exception gets raised before &lt;code&gt;sum&lt;/code&gt; ever sees this list.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def running_sum(s, n):
    lo, hi = itertools.tee(s)
    rs = sum([hi.next() for _ in range(n)])
    while True:
        yield rs
        rs += hi.next() - lo.next()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As a final tweak, we can make &lt;code&gt;lo&lt;/code&gt; and &lt;code&gt;hi&lt;/code&gt; iterator.next functions rather than iterators, which saves a few attribute access calls.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def running_sum(s, n):
    '''Generate the series of running sums of n elements of s.
    
    &amp;gt;&amp;gt;&amp;gt; list(running_sum([1, 2, 3, 4], 2))
    [3, 5, 7]
    &amp;gt;&amp;gt;&amp;gt; rs = running_sum(itertools.count(), 3)
    &amp;gt;&amp;gt;&amp;gt; rs.next(), rs.next(), rs.next()
    (3, 6, 9)
    &amp;gt;&amp;gt;&amp;gt; list(running_sum([1, 2], 3))
    []
    '''
    lo, hi = [i.next for i in itertools.tee(s)]
    rs = sum([hi() for _ in range(n)])
    while True:
        yield rs
        rs += hi() - lo()

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;Thanks to &lt;a href="http://www.reddit.com/r/programming/info/6otfp/comments/"&gt;doubtingthomas&lt;/a&gt; for pointing out an off-by-one error in the original version of this article.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/running-sums-in-python#fn1link"&gt;[1]&lt;/a&gt; In a recent &lt;a href="http://geekrant.wordpress.com/2008/06/23/misconceptions/"&gt;post on his blog&lt;/a&gt;, Jake clears up some misconceptions about &lt;a href="http://haskell.org"&gt;Haskell&lt;/a&gt;. In doing so he analyses the difference between lazy and strict types with clarity and insight. Recommended reading!
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;This parallel indicates pretty clearly that recursively operating on each element of a stream is an infinite loop. &lt;code&gt;Stream&lt;/code&gt; is a &lt;em&gt;control structure&lt;/em&gt;. It doesn&amp;#8217;t exist to persist data across many parts of a program. It exists to feed data into a function one element at a time. In contrast, a &lt;code&gt;Vector&lt;/code&gt; exists to persist an intermediate or final &lt;em&gt;result&lt;/em&gt; of some 3-dimensional computation. In short, &lt;code&gt;Stream&lt;/code&gt; is for &lt;em&gt;controlling computation&lt;/em&gt;, and &lt;code&gt;Vector&lt;/code&gt; is for &lt;em&gt;storing data&lt;/em&gt;. This generalizes to lazy and strict types, respectively.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/running-sums-in-python#fn2link"&gt;[2]&lt;/a&gt; There may be situations where we really want each running sum to be generated directly from &lt;code&gt;n&lt;/code&gt; consecutive elements of the source stream: for example, if we are dealing with a series of floating point numbers, then addition is not exact and we must take care to avoid accumulated errors.
&lt;/p&gt;</description>
<dc:date>2008-06-24</dc:date>
<guid>http://wordaligned.org/articles/running-sums-in-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/running-sums-in-python</link>
<category>Algorithms</category>
</item>

<item>
<title>Takewhile drops one</title>
<description>&lt;p&gt;Here&amp;#8217;s some naughty code.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import takewhile
    
def take_some(pred, xs):
    while True:
        for x in takewhile(pred, xs):
            yield x

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code abuses the &amp;#8220;iterator building block&amp;#8221; foundations of Python&amp;#8217;s &lt;a href="http://docs.python.org/lib/module-itertools.html"&gt;itertools module&lt;/a&gt;. Once you&amp;#8217;ve chopped a stream&amp;#8217;s head off using &lt;code&gt;takewhile&lt;/code&gt; you can&amp;#8217;t resume processing its tail &amp;#8230; Or can you?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;A casual inspection of this function &lt;em&gt;suggests&lt;/em&gt; it does little more than heat up the machine: we return elements, &lt;code&gt;x&lt;/code&gt;, from a stream, &lt;code&gt;xs&lt;/code&gt;, for which &lt;code&gt;pred(x)&lt;/code&gt; holds, then we spin at the first element for which the predicate does not hold.
&lt;/p&gt;
&lt;p&gt;When we actually run the code, things turn out rather differently:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import count, islice
&amp;gt;&amp;gt;&amp;gt; def is_even(x):
... 	return x % 2 == 0
... 
&amp;gt;&amp;gt;&amp;gt; xs = take_some(is_even, count())
&amp;gt;&amp;gt;&amp;gt; xs.next()
0
&amp;gt;&amp;gt;&amp;gt; xs.next()
2
&amp;gt;&amp;gt;&amp;gt; xs.next()
4
&amp;gt;&amp;gt;&amp;gt; list(islice(xs, 10))
[6, 8, 10, 12, 14, 16, 18, 20, 22, 24]

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Dropwhile, ifilter, izip&lt;/h3&gt;
&lt;p&gt;Nothing overheats. In fact &lt;code&gt;take_some&lt;/code&gt; behaves suspiciously like &lt;code&gt;ifilter&lt;/code&gt;. Let&amp;#8217;s explore that hypothesis by zipping together an &lt;code&gt;ifilter&lt;/code&gt; stream and a &lt;code&gt;take_some&lt;/code&gt; stream and seeing if they diverge.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import dropwhile, ifilter, izip
&amp;gt;&amp;gt;&amp;gt; xs = take_some(is_even, count())
&amp;gt;&amp;gt;&amp;gt; ys = ifilter(is_even, count())
&amp;gt;&amp;gt;&amp;gt; diverge = dropwhile(lambda xy: xy[0] == xy[1], izip(xs, ys))
&amp;gt;&amp;gt;&amp;gt; diverge.next()
  C-c C-cTraceback (most recent call last):
  ...
KeyboardInterrupt
&amp;gt;&amp;gt;&amp;gt;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here &lt;code&gt;itertools.dropwhile&lt;/code&gt; iterates through the zipped stream yielding items as soon as it detects a difference in the first and second element of a pair. This time, as you can see, we &lt;em&gt;do&lt;/em&gt; start spinning, and we have to interrupt execution to regain control.
&lt;/p&gt;

&lt;h3&gt;Small print&lt;/h3&gt;
&lt;p&gt;Our casual interpretation of &lt;code&gt;take_some&lt;/code&gt; was wrong. The actual documentation for &lt;code&gt;itertools.takewhile&lt;/code&gt; reads:
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;b&gt;takewhile&lt;/b&gt;(&lt;i&gt;predicate, iterable&lt;/i&gt;)&lt;/p&gt;
&lt;p&gt;Make an iterator that returns elements from the iterable as long as the predicate is true. Equivalent to:&lt;/p&gt;
&lt;pre&gt;
     def takewhile(predicate, iterable):
         for x in iterable:
             if predicate(x):
                 yield x
             else:
                 break
&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;There you have it! Once a stream returned by &lt;code&gt;takewhile&lt;/code&gt; has run its course, the original &lt;code&gt;iterable&lt;/code&gt; is poised to yield the element immediately after the first element for which the predicate fails. That is, we drop the first element for which the predicate fails. So repeatedly applying &lt;code&gt;takewhile&lt;/code&gt; to a stream drops the elements for which the predicate doesn&amp;#8217;t hold, which is to say it generates the elements for which the predicate holds, which is of course &lt;code&gt;ifilter&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;Bug fixes&lt;/h3&gt;
&lt;p&gt;Yes, kind of. I could point out a couple of bugs in &lt;code&gt;take_some&lt;/code&gt;. First, it doesn&amp;#8217;t work for lists. Give it a list and each application of &lt;code&gt;takewhile&lt;/code&gt; resumes iteration from the beginning of the list, meaning &lt;code&gt;take_some&lt;/code&gt; either repeats the first element of the list forever, or it spins without yielding anything:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; ys = take_some(is_even, [1, 2, 3, 4])
&amp;gt;&amp;gt;&amp;gt; ys.next()
 ...
KeyboardInterrupt
&amp;gt;&amp;gt;&amp;gt; ys = take_some(is_even, [0, 1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; ys.next()
0
&amp;gt;&amp;gt;&amp;gt; ys.next()
0
&amp;gt;&amp;gt;&amp;gt; set(islice(ys, 1000000))
set([0])

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can fix that defect easily by applying &lt;code&gt;iter&lt;/code&gt; to the input iterable, but that exposes the second bug, that &lt;code&gt;take_some&lt;/code&gt; only works for infinite streams. Once we bang into the end of an iterable, we stay there, stuck in the while loop. To fix both defects we might end up with something like:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import takewhile, tee
    
def take_some(pred, xs):
    while True:
        xs, ys = tee(xs)
        try:
            ys.next()
        except StopIteration:
            return
        for x in takewhile(pred, xs):
            yield x

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;The real bug fix&lt;/h3&gt;
&lt;p&gt;Actually, the real bug, which I admitted to at the outset, is in our thinking. This code abuses the iterator-building-blocks paradigm at the heart of the &lt;a href="http://docs.python.org/lib/module-itertools.html"&gt;itertools module&lt;/a&gt;. &lt;code&gt;Takewhile&lt;/code&gt; converts one stream into another stream; the original stream has gone and if we wanted it we should have teed it first.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/tag/shell/" title="Articles about shell"&gt;&lt;img style="float:right;" src="http://wordaligned.org/images/buttons/crab.jpg" alt="Picture of a crab"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The Unix shell embeds this concept at the core of the language to great effect. &lt;span /&gt;Once again our building block is the stream but our connector, the pipeline operator, |, doesn&amp;#8217;t allow this kind of abuse; all you can do is put a stream to its left and another to its right. The syntax won&amp;#8217;t allow you to get the head and tail of the same stream in a single pipeline.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s an awkless variant of the recent &lt;a href="http://www.google.com/search?q=shell+history+meme"&gt;shell history meme&lt;/a&gt; which shows a shell pipeline in action.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ history | tr -s ' ' | cut -f 3 -d ' ' | sort | uniq -c | sort -rn
    172 cd
    147 svn
     73 bin/mheg
     57 make
     54 ls
     40 emacs
     37 pwd
     ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a slightly more interesting variant which only shows commands appearing after a pipeline operator. (It&amp;#8217;s not bombproof, but it&amp;#8217;ll do for now.)
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ history | grep -Eo '\| *\w+' | tr -d '| ' | sort | uniq -c | sort -rn
     10 head
      8 cut
      7 grep
      6 tr
      5 xargs
      4 sort
      3 wc
      3 uniq
      3 less
      ...

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Pipe Links&lt;/h3&gt;
&lt;p&gt;By way of an apology for wasting your time, here are some solid gold links.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;&lt;a href="http://www.dabeaz.com/generators/"&gt;&amp;#8220;Generator Tricks for Systems Programmers&amp;#8221;&lt;/a&gt;, a presentation made by David M. Beazley at PyCon&amp;#8217;08. I wasn&amp;#8217;t there, but for once &lt;a href="http://www.dabeaz.com/generators/Generators.pdf"&gt;the slides (PDF)&lt;/a&gt; standalone well, and despite the title it&amp;#8217;s neither tricksy nor just for systems programmers. Experienced Python programmers might choose to skip over the first few slides; by the end of the presentation, the material gets much more advanced&lt;a id="fn1link" href="http://wordaligned.org/articles/takewhile-drops-one#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;&lt;a href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/276960"&gt;&amp;#8220;Shell-like data processing&amp;#8221;&lt;/a&gt; by Maxim Krikun in the online Python Cookbook, which overloads the bitwise or operator, &lt;code&gt;|&lt;/code&gt;, to implement a Pythonic pipeline, an idea you can find  extended in &lt;a href="http://egofile.com/blog/python/pipes.html"&gt;&amp;#8220;Assembly Line Syntax&amp;#8221;&lt;/a&gt; by Patrick Roberts and &lt;a href="http://www.voidspace.org.uk/python/weblog/arch_d7_2008_03_22.shtml#e954"&gt;revised by Michael Foord&lt;/a&gt;, this time using the right shift operator as a connector.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Pipelined Python&lt;/h3&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Apache httpd log&lt;/div&gt;

&lt;pre class="prettyprint"&gt;81.107.39.38 -  ... "GET /ply/ HTTP/1.1" 200 7587 
81.107.39.38 -  ... "GET /favicon.ico HTTP/1.1" 404 133 
81.107.39.38 -  ... "GET /ply/bookplug.gif HTTP/1.1" 200 23903 
81.107.39.38 -  ... "GET /ply/ply.html HTTP/1.1" 200 97238 
81.107.39.38 -  ... "GET /ply/example.html HTTP/1.1" 200 2359 
66.249.72.134 - ... "GET /index.html HTTP/1.1" 200 4447 
...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In his presentation David Beazley shows some elegant and idiomatic Python code to sum the total number of bytes transferred in an &lt;a href="http://httpd.apache.org/docs/trunk/logs.html"&gt;Apache httpd server log&lt;/a&gt; (the final field on each line of the log file shown above). You&amp;#8217;ll notice how clean and declarative it is. Each generator expression builds upon the one on the preceding line. The source of the stream, &lt;code&gt;wwwlog&lt;/code&gt;, is a file object which, in the iterable context shown here, yields lines on demand. Nothing really happens until the final reduction, &lt;code&gt;sum&lt;/code&gt;, at which point data flows smoothly through. Stream elements &amp;#8212; lines, words, ints &amp;#8212; are processed one at a time, and nothing accumulates except the final total. 
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;wwwlog     = open("access-log") 
bytecolumn = (line.rsplit(None,1)[1] for line in wwwlog) 
bytes      = (int(x) for x in bytecolumn if x != '-') 
print "Total", sum(bytes)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s an alternative using the Python pipeline approach mentioned in the previous section. Note that in my &lt;a href="http://trac.lighttpd.net/trac/wiki/Docs%3AModAccessLog"&gt;server access logs&lt;/a&gt; it&amp;#8217;s the 9th field (whitespace separated, counting from zero) which gives the number of bytes transferred, and for variety I&amp;#8217;m pattern matching this field to a string of digits.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;wwwlog = open("access-log") 
bytes = wwwlog | cut(9) | grep(r'\d+') | xlate(int)
print "Total", sum(bytes)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Cut&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;xlate&lt;/code&gt; are simple classes which implement the numeric &lt;a href="http://docs.python.org/ref/numeric-types.html"&gt;__ror__ method&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools
import re

class xlate(object):
    "Translate the input stream by applying a function to each item". 
    def __init__(self, fn):
        self.fn = fn
    def __ror__(self, stream):
        return itertools.imap(self.fn, stream)
    
class cut(xlate):
    "Cuts a whitespace separated column from a stream of lines."
    def __init__(self, column):
        super(cut, self).__init__(lambda s: s.split()[column])

class grep(object):
    "Grep lines which match an re from a stream of lines."
    def __init__(self, pattern):
        self.match = re.compile(pattern).match
    def __ror__(self, stream):
        return itertools.ifilter(self.match, stream)

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/takewhile-drops-one#fn1link"&gt;[1]&lt;/a&gt; It could be that I&amp;#8217;m reading too much into the pipe metaphor, but I&amp;#8217;m intrigued by the caption to the photo on &lt;a href="http://www.dabeaz.com"&gt;David M. Beazley&amp;#8217;s homepage&lt;/a&gt;. What can he mean?
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href="http://www.dabeaz.com" title="Is David working on Tubes?"&gt;&lt;img src="http://www.dabeaz.com/images/Davetubes.jpg" alt="David Beazley"/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dave working on his latest project &amp;#8212; &amp;#8220;you know, it&amp;#8217;s a series of tubes.&amp;#8221;&lt;/p&gt;&lt;/blockquote&gt;</description>
<dc:date>2008-04-23</dc:date>
<guid>http://wordaligned.org/articles/takewhile-drops-one</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/takewhile-drops-one</link>
<category>Algorithms</category>
</item>

<item>
<title>Sugar Pie</title>
<description>&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; in the code snippet bleow, what does the result stream, &lt;code&gt;rs&lt;/code&gt;, approximate?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import count, ifilter, izip
from random import random as xy
from math import hypot
    
pt = lambda: (xy(), xy())
on = ifilter(lambda n: hypot(*pt()) &amp;lt; 1., count(1))
rs = (4. * j / i for i, j in izip(on, count(1)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The code isn&amp;#8217;t wilfully obscure but I&amp;#8217;ll admit it&amp;#8217;s unusual. Although written in a functional style, the source of the stream, &lt;code&gt;pt&lt;/code&gt;, is utterly impure, generating a sequence of random results: it sprinkles points in a unit square. Despite this random input the results stream always tends to the same value. Well, in theory it should!
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a picture of a round pie on a square baking tray being dusted with sugar.    &lt;br /&gt;
&lt;/p&gt;
&lt;img alt="Dusting a pie" src="http://wordaligned.org/images/sugar-pie.gif"/&gt;

&lt;p&gt;Thanks again to &lt;a href="http://gedmin.as"&gt;Marius Gedminas&lt;/a&gt; for pointing me at
   &lt;code&gt;math.hypot&lt;/code&gt;, the best way to find the length of a 2D vector. (The
   previous version of this note used &lt;code&gt;abs(complex(*pt())&lt;/code&gt;, which it
   claimed to be better than &lt;code&gt;math.sqrt(x * x + y * y)&lt;/code&gt;).
&lt;/p&gt;</description>
<dc:date>2008-03-06</dc:date>
<guid>http://wordaligned.org/articles/sugar-pie</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/sugar-pie</link>
<category>Algorithms</category>
</item>

<item>
<title>Top Ten Percent</title>
<description>&lt;p&gt;Recently I discussed two different approaches &lt;a href="http://wordaligned.org/articles/top-ten-tags.html"&gt;to finding the first N items&lt;/a&gt;, in order, from a collection of size S:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     full sort then slice
 &lt;/li&gt;

 &lt;li&gt;
     heap-based partial sort
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These two operations are respectively of complexity:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     S&amp;middot;log(S)
 &lt;/li&gt;

 &lt;li&gt;
     S&amp;middot;log(N)
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we fix N and increase S, partial sort gets the job done most efficiently, while clearly conveying the intent of the code.
&lt;/p&gt;
&lt;p&gt;What if we fix the ratio S/N? As an example, fixing S/N at 10 would correspond to finding the top 10% of the collection. In this case, a third approach will beat both full and partial sort as S increases.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Partial Sort for fixed S/N&lt;/h3&gt;
&lt;p&gt;First, let&amp;#8217;s see what happens to the heap based partial sort when we fix S/N at 10. The complexity, O(S&amp;middot;logN), becomes O(S&amp;middot;log(S/10)) which is equivalent to O(S&amp;middot;(logS-log10)), or simply O(S&amp;middot;logS).
&lt;/p&gt;
&lt;p&gt;Thus partial sort has the same complexity as full sort; but the lower constant multipliers in the full sort mean that eventually it outperforms partial sort.
&lt;/p&gt;
&lt;p&gt;How then can we reliably beat full sort?
&lt;/p&gt;

&lt;h3&gt;Partition then Sort&lt;/h3&gt;
&lt;p&gt;The idea is simple: partition the collection to place the first N elements at the front, then sort these elements in place. The partitioning algorithm is one of a family generally known as &lt;a href="http://en.wikipedia.org/wiki/Selection_algorithm"&gt;selection algorithms&lt;/a&gt;, implemented in C++ as &lt;a href="http://www.sgi.com/tech/stl/nth_element.html"&gt;std::nth_element&lt;/a&gt;. &lt;a href="http://www.sgi.com/tech/stl/sort.html"&gt;Std::sort&lt;/a&gt; handles the subsequent sort on the reduced range, as usual. 
&lt;/p&gt;
&lt;p&gt;In code:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;typename Iter&amp;gt;
void 
nth_element_then_sort(Iter first, Iter nth, Iter last)
{
    nth_element(first, nth, last);
    sort(first, nth);
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;Iter&lt;/code&gt; must be a random access iterator, and the caller must ensure the distance between &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;first&lt;/code&gt; is N. Note that this algorithm arranges the &lt;strong&gt;smallest&lt;/strong&gt; N elements in order at the front of the collection. If we want the largest, or indeed any other ordering, we&amp;#8217;ll need to supply an ordering predicate to &lt;code&gt;nth_element&lt;/code&gt; and &lt;code&gt;sort&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;The standard &lt;code&gt;nth_element&lt;/code&gt; algorithm uses a repeated partitioning scheme similar to the divide-and-conquer approach at the heart of quicksort. This time, though, after each division, the algorithm concentrates on just one side of what&amp;#8217;s left. Hence &lt;span /&gt;we have iteration on a rapidly diminishing range, not recursion, and a linear operation, O(S). The subsequent &lt;code&gt;sort&lt;/code&gt; is O(N&amp;middot;logN).
&lt;/p&gt;
&lt;p&gt;Thus the overall complexity is O(S) + O(N&amp;middot;logN). If we fix the ratio S/N, the O(N&amp;middot;logN) term eventually dominates; that is, the algorithm is dominated by the time taken by the final sort of the first N items.
&lt;/p&gt;
&lt;p&gt;Using the example ratio of S/N = 10, O(N&amp;middot;logN) is O((S&amp;middot;logS)/10), which predicts this partition-then-sort combination to run 10 times more quickly than a full sort.
&lt;/p&gt;
&lt;p&gt;Appended to this article is a short C++ program which calibrates our three variant partial sorting algorithms on a collection of random numbers. It requires two numbers, S and N, as command line input, and generates clock times for full, partial and partition sorts. It cross-checks the results for consistency, raising an error if a problem is detected.
&lt;/p&gt;

&lt;h3&gt;Performance&lt;/h3&gt;
&lt;p&gt;I compiled the program and ran it with S set to 0, 2 million, 4 million, 6 million &amp;#8230;, and the ratio S/N fixed at 10.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Test script&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#! /bin/bash
g++ -Wall -O3 partial_sort.cpp -o partial_sort
S=0
S_STEP=2000000

while true
do
    let "N = S / 10"
    ./partial_sort $S $N
    let "S += S_STEP"
done

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The loop in this script never terminates. Just kill the process once you&amp;#8217;ve seen enough.
&lt;/p&gt;
&lt;p&gt;The results confirm this Nth-element-then-sort algorithm performs better than both full and partial sort at generating the first 10% of a collection. Full sort pulls ahead of partial sort before we get to 20 million.
&lt;/p&gt;
&lt;img alt="Partial Sort Performance Chart" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=The+Great+Partial+Sort+Shootout
&amp;amp;chs=500x300
&amp;amp;chxt=x,y,x,y
&amp;amp;chxl=0:|0|10|20|30|40|50|60|1:|0|1000|2000|3000|4000|5000|6000|2:||N+%28Millions%29||3:||Time+%28ms%29|
&amp;amp;chd=t:0,2,4,6,8,11,13,15,18,20,22,24,27,29,32,34,36,39,41,44,46,48,51,54,56,58,61,63,66,68,71|0,1,2,4,6,9,12,14,17,20,23,26,29,32,36,39,43,46,50,52,56,60,64,68,72,74,78,82,85,89,92|0,0,1,1,2,2,2,3,3,4,3,4,4,5,5,5,5,6,8,7,8,8,8,10,10,10,9,10,11,13,11
&amp;amp;chco=ff0000,00ff00,0000ff
&amp;amp;chls=2,0,0|2,0,0|2,0,0
&amp;amp;chdl=Full+Sort|Partial+Sort|Nth+Elem+and+Sort" /&gt;


&lt;h3&gt;Test Platform&lt;/h3&gt;
&lt;p&gt;I ran the tests on a laptop using code compiled and optimised by GCC version 4.0.1.
&lt;/p&gt;
&lt;pre&gt;
Hardware Overview:
  Model Name:	            MacBook
  Model Identifier:	    MacBook1,1
  Processor Name:	    Intel Core Duo
  Processor Speed:	    2 GHz
  Number Of Processors:	    1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;

&lt;p&gt;Here&amp;#8217;s a table showing the actual times, in milliseconds. Note that on this platform the &lt;code&gt;clock()&lt;/code&gt; resolution is 10 milliseconds, so I&amp;#8217;ve multiplied the actual program output by 10.
&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;&lt;td&gt;S/million&lt;/td&gt;&lt;td&gt;Full Sort/ms&lt;/td&gt;&lt;td&gt;Partial/ms&lt;/td&gt;&lt;td&gt;Nth elem+sort/ms&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;110&lt;/td&gt;&lt;td&gt;70&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;240&lt;/td&gt;&lt;td&gt;140&lt;/td&gt;&lt;td&gt;40&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;380&lt;/td&gt;&lt;td&gt;250&lt;/td&gt;&lt;td&gt;70&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;500&lt;/td&gt;&lt;td&gt;390&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;640&lt;/td&gt;&lt;td&gt;540&lt;/td&gt;&lt;td&gt;110&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;790&lt;/td&gt;&lt;td&gt;700&lt;/td&gt;&lt;td&gt;110&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;14&lt;/td&gt;&lt;td&gt;910&lt;/td&gt;&lt;td&gt;860&lt;/td&gt;&lt;td&gt;160&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;1050&lt;/td&gt;&lt;td&gt;1040&lt;/td&gt;&lt;td&gt;190&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;18&lt;/td&gt;&lt;td&gt;1190&lt;/td&gt;&lt;td&gt;1200&lt;/td&gt;&lt;td&gt;220&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;1340&lt;/td&gt;&lt;td&gt;1390&lt;/td&gt;&lt;td&gt;190&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;22&lt;/td&gt;&lt;td&gt;1470&lt;/td&gt;&lt;td&gt;1580&lt;/td&gt;&lt;td&gt;260&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;1610&lt;/td&gt;&lt;td&gt;1760&lt;/td&gt;&lt;td&gt;230&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;26&lt;/td&gt;&lt;td&gt;1760&lt;/td&gt;&lt;td&gt;1950&lt;/td&gt;&lt;td&gt;310&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;28&lt;/td&gt;&lt;td&gt;1890&lt;/td&gt;&lt;td&gt;2140&lt;/td&gt;&lt;td&gt;280&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;30&lt;/td&gt;&lt;td&gt;2040&lt;/td&gt;&lt;td&gt;2360&lt;/td&gt;&lt;td&gt;310&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;2190&lt;/td&gt;&lt;td&gt;2560&lt;/td&gt;&lt;td&gt;310&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;34&lt;/td&gt;&lt;td&gt;2340&lt;/td&gt;&lt;td&gt;2750&lt;/td&gt;&lt;td&gt;330&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;36&lt;/td&gt;&lt;td&gt;2480&lt;/td&gt;&lt;td&gt;2980&lt;/td&gt;&lt;td&gt;450&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;38&lt;/td&gt;&lt;td&gt;2630&lt;/td&gt;&lt;td&gt;3150&lt;/td&gt;&lt;td&gt;430&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;40&lt;/td&gt;&lt;td&gt;2780&lt;/td&gt;&lt;td&gt;3390&lt;/td&gt;&lt;td&gt;490&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;42&lt;/td&gt;&lt;td&gt;2910&lt;/td&gt;&lt;td&gt;3620&lt;/td&gt;&lt;td&gt;470&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;44&lt;/td&gt;&lt;td&gt;3080&lt;/td&gt;&lt;td&gt;3850&lt;/td&gt;&lt;td&gt;460&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;46&lt;/td&gt;&lt;td&gt;3210&lt;/td&gt;&lt;td&gt;4080&lt;/td&gt;&lt;td&gt;570&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;48&lt;/td&gt;&lt;td&gt;3360&lt;/td&gt;&lt;td&gt;4290&lt;/td&gt;&lt;td&gt;580&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;50&lt;/td&gt;&lt;td&gt;3500&lt;/td&gt;&lt;td&gt;4470&lt;/td&gt;&lt;td&gt;590&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;52&lt;/td&gt;&lt;td&gt;3660&lt;/td&gt;&lt;td&gt;4650&lt;/td&gt;&lt;td&gt;550&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;54&lt;/td&gt;&lt;td&gt;3800&lt;/td&gt;&lt;td&gt;4890&lt;/td&gt;&lt;td&gt;620&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;56&lt;/td&gt;&lt;td&gt;3960&lt;/td&gt;&lt;td&gt;5100&lt;/td&gt;&lt;td&gt;670&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;58&lt;/td&gt;&lt;td&gt;4110&lt;/td&gt;&lt;td&gt;5340&lt;/td&gt;&lt;td&gt;760&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;60&lt;/td&gt;&lt;td&gt;4260&lt;/td&gt;&lt;td&gt;5540&lt;/td&gt;&lt;td&gt;640&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;h3&gt;Test Code&lt;/h3&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;The Great Partial Sort Shootout&lt;/div&gt;

&lt;pre class="prettyprint"&gt;/*
  This program runs three different partial sort algorithms head to head,
  writing timing information to standard out.

Usage: partial_sort S N

Here, S is the size of the collection to partially sort and N is
  the number of elements from this collection to sort. S and N must
  be positive with S &amp;gt;= N.

The program outputs three figures, the clock times taken by
  full_sort, partial_sort, nth_element_then_sort respectively.

Example:
  $ partial_sort 1000000 500000
  11 17 6
*/
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;stdexcept&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;vector&amp;gt;

#include &amp;lt;time.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

namespace {

typedef std::vector&amp;lt;long&amp;gt; numbers;
typedef numbers::size_type size_type;
typedef numbers::iterator iter;
typedef std::pair&amp;lt;size_type, size_type&amp;gt; number_pair;

// Generate a 31-bit random value.
long random_value(numbers::value_type ignored)
{
    return random();
}

// Fill the input numbers with random values.
void random_fill(numbers &amp;amp; ns)
{
    srandomdev();
    transform(ns.begin(), ns.end(), ns.begin(), random_value);
}

// full_sort(), partial_sort() and nth_element_then_sort()
// implement three variant algorithms for solving the same problem:
// of sorting the input numbers vector in place so that the N
// smallest values are in order and at the front of the vector.
typedef void (* sort_fn)(iter first, iter nth, iter last);

void full_sort(iter first, iter nth, iter last)
{
    // Ignore Nth, just sort the whole vector
    sort(first, last);
}

void part_sort(iter first, iter nth, iter last)
{
    partial_sort(first, nth, last);
}

void nth_element_then_sort(iter first, iter nth, iter last)
{
    nth_element(first, nth, last);
    sort(first, nth);
}

// Return the clock time taken by a sort function call.
clock_t clock_it(sort_fn fn, iter first, iter nth, iter last)
{
    clock_t const t_start = clock();
    fn(first, nth, last);
    return clock() - t_start;
}

// Confirms the numbers vectors share the same leading N elements.
// Throws an error if not.
void
check_equal_n(std::vector&amp;lt;numbers&amp;gt; const &amp;amp; nn, size_type N)
{
    typedef numbers::const_iterator const_iter;
    
    if (!nn.empty())
    {
        const_iter const first = nn[0].begin();
        const_iter const nth = first + N;
        std::vector&amp;lt;numbers&amp;gt;::const_iterator ni = nn.begin() + 1;
        
        while (ni != nn.end() &amp;amp;&amp;amp; equal(first, nth, ni-&amp;gt;begin()))
        {
            ++ni;
        }
        if (ni != nn.end())
        {
            throw std::runtime_error("check_equal_n fails");
        }
    }
}

// "Clocks" time taken by the supplied sort functions,
// publishing results to the output stream.
void
clock_sorters(std::ostream &amp;amp; out, number_pair SN)
{
    typedef std::vector&amp;lt;numbers&amp;gt; numbers_vec;
    
    // Unpack S and N
    size_type const S = SN.first;
    size_type const N = SN.second;
    
    sort_fn sorters[] =
        {
            full_sort,
            part_sort,
            nth_element_then_sort
        };
    
    unsigned const n_sorters = sizeof(sorters)/sizeof(*sorters);
    std::ostream_iterator&amp;lt;clock_t&amp;gt; put_times(out, " ");
    
    numbers ns(S);
    random_fill(ns);
    numbers_vec nn(n_sorters, ns);
    
    sort_fn * sorter = sorters;
    for (numbers_vec::iterator ni = nn.begin(); ni != nn.end(); ++ni)
    {
        *put_times++ =
            clock_it(*sorter++, ni-&amp;gt;begin(), ni-&amp;gt;begin() + N, ni-&amp;gt;end());
    }
    check_equal_n(nn, N);
    out &amp;lt;&amp;lt; '\n';
}

// Processes the command line reading S, the size of the
// numbers array and N, the number of elements to sort.
// Throws a runtime_error on failure.
number_pair
read_cli(int argc, char * argv[])
{
    number_pair SN;
    std::stringstream buf;
    
    if (!(argc == 3 &amp;amp;&amp;amp;
          buf &amp;lt;&amp;lt; argv[1] &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; argv[2] &amp;amp;&amp;amp;
          buf &amp;gt;&amp;gt; SN.first &amp;gt;&amp;gt; SN.second &amp;amp;&amp;amp;
          SN.first &amp;gt;= SN.second))
    {
        throw std::runtime_error("Usage: please supply S and N, "
                                 "where S and N are postive, and S &amp;gt;= N") ;
    }
    return SN;
}

} // anonymous namespace

int main(int argc, char * argv[])
{
    int error = 0;
    
    try
    {
        clock_sorters(std::cout, read_cli(argc, argv));
    }
    catch (std::exception const &amp;amp; exc)
    {
        std::cout &amp;lt;&amp;lt; "An error occurred: " &amp;lt;&amp;lt; exc.what() &amp;lt;&amp;lt; '\n';
        error = 1;
    }
    catch (...)
    {
        std::cout &amp;lt;&amp;lt; "An error occurred.\n";
        error = 1;
    }
    
    return error;
}

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2008-02-26</dc:date>
<guid>http://wordaligned.org/articles/top-ten-percent</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/top-ten-percent</link>
<category>Algorithms</category>
</item>

<item>
<title>Top Ten Tags</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocmaximum" name="toc0" id="toc0"&gt;Maximum&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocsort-and-slice" name="toc1" id="toc1"&gt;Sort and Slice&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocpartial-sort" name="toc2" id="toc2"&gt;Partial Sort&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocpartial-sorting-with-heaps" name="toc3" id="toc3"&gt;Partial Sorting with Heaps&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocpartitioning-with-heaps" name="toc4" id="toc4"&gt;Partitioning with Heaps?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocsorting-with-heaps" name="toc5" id="toc5"&gt;Sorting with Heaps&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocn-largest-in-python" name="toc6" id="toc6"&gt;N Largest in Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocn-largest-in-shell" name="toc7" id="toc7"&gt;N Largest in Shell&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocparallel-algorithm-analysis" name="toc8" id="toc8"&gt;Parallel Algorithm Analysis&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#tocchoosing-an-algorithm" name="toc9" id="toc9"&gt;Choosing an algorithm&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;Reworking this website reminded me of another classic sorting algorithm. The sidebar on the front page now has a &lt;strong&gt;Top Tags&lt;/strong&gt; node which lists, in order, the 10 most frequently used tags for articles on this site. What&amp;#8217;s the best way to find these?
&lt;/p&gt;
&lt;p&gt;More generally:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;How do you select the N largest items, in order, from a collection?
&lt;/p&gt;
&lt;/blockquote&gt;&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc0" name="tocmaximum" id="tocmaximum"&gt;Maximum&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When N is 1, the standard maximum function does the job. That would be &lt;code&gt;std::max_element&lt;/code&gt; in C++ or simply &lt;code&gt;max&lt;/code&gt; in Python. Python&amp;#8217;s &lt;code&gt;max&lt;/code&gt; has an optional &lt;code&gt;key&lt;/code&gt; parameter, allowing you to supply your own comparison function; C++ similarly has an overload of &lt;code&gt;max_element&lt;/code&gt; which accepts a comparison predicate.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc1" name="tocsort-and-slice" id="tocsort-and-slice"&gt;Sort and Slice&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If N isn&amp;#8217;t 1, you could sort the whole collection then slice the N largest elements from the end. In Python:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;nlargest = sorted(collection)[-N:]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;And in shell:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ sort FILE | tail -$N

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc2" name="tocpartial-sort" id="tocpartial-sort"&gt;Partial Sort&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A full sort isn&amp;#8217;t required if you just need the top 10, though. For large collections and small N, gains can be had from partially sorting the collection. C++ provides an algorithm, &lt;a href="http://www.sgi.com/tech/stl/partial_sort.html"&gt;std::partial_sort&lt;/a&gt;, which does just that, shuffling the collection in place until the first N elements are ordered and at the front of that collection.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a complete program based on the C++ partial sort algorithm. It reads integers from standard input into memory then writes the first 10 of them to standard output.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;// Program reads integer values from standard input and
// writes the N largest of these values, largest first,
// to standard output.
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;vector&amp;gt;

int main()
{
    typedef std::vector&amp;lt;long&amp;gt; numbers;
    typedef numbers::iterator iter;
    typedef std::istream_iterator&amp;lt;numbers::value_type&amp;gt; in;
    typedef std::ostream_iterator&amp;lt;numbers::value_type&amp;gt; out;
    
    // Read numbers from standard input
    numbers results;
    copy(in(std::cin), in(), back_inserter(results));
    
    // Make sure we cope with N &amp;gt; size of results.
    numbers::size_type const N = 10u;
    numbers::size_type const n = std::min(results.size(), N);
    
    // Find the N largest (hence the "greater" predicate)
    iter const first = results.begin();
    iter const middle = first + n;
    iter const last = results.end();
    partial_sort(first, middle, last, std::greater&amp;lt;long&amp;gt;());
    
    // Copy these to standard out
    copy(first, middle, out(std::cout, " "));
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The C++ standard guarantees the complexity of &lt;code&gt;partial_sort&lt;/code&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;It takes approximately &lt;code&gt;(last - first) * log(middle - first)&lt;/code&gt; comparisons.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;The corresponding complexity for a full &lt;a href="http://www.sgi.com/tech/stl/sort.html"&gt;sort&lt;/a&gt; is:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Approximately &lt;code&gt;(last - first) * log(last - first)&lt;/code&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;So the speed up is theoretically of the order of &lt;code&gt;log(S)/log(N)&lt;/code&gt;. Logarithms grow slowly so the gains aren&amp;#8217;t spectacular, but they may well be worth having. I ran some tests on collections of 31 bit numbers generated by the standard C &lt;code&gt;random()&lt;/code&gt; function, with the collection size, S, ranging between 2 million and 10 million.
&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;th&gt;S/million&lt;/th&gt;&lt;th&gt;Partial/ms&lt;/th&gt;&lt;th&gt;Full/ms&lt;/th&gt;&lt;th&gt;Full/Partial&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;217&lt;/td&gt;&lt;td&gt;54&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;451&lt;/td&gt;&lt;td&gt;56&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;697&lt;/td&gt;&lt;td&gt;58&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;944&lt;/td&gt;&lt;td&gt;56&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;29&lt;/td&gt;&lt;td&gt;1200&lt;/td&gt;&lt;td&gt;41&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;As you can see, for these test cases the partial sort runs around 50 times more quickly than the full sort; better than expected or predicted!
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s also worth noting that we can find the top N elements without altering or (fully) copying the original collection: see &lt;a href="http://www.sgi.com/tech/stl/partial_sort_copy.html"&gt;std::partial_sort_copy()&lt;/a&gt; for details.
&lt;/p&gt;
&lt;p&gt;C++&amp;#8217;s in-place partial sort works well with a paging model. To sketch the idea, &lt;code&gt;partial_sort(first, first + N, last)&lt;/code&gt; yields the first page of results, then, if required, &lt;code&gt;partial_sort(first + N, first + 2 * N, last)&lt;/code&gt; yields the second page, and so on. Of course, if we anticipate paging through a large portion of the entire collection, a full sort gets the job done up front.
&lt;/p&gt;
&lt;p&gt;The complexity guarantee for &lt;code&gt;partial_sort&lt;/code&gt; is the same as for &lt;code&gt;sort&lt;/code&gt; in the limiting case, when &lt;code&gt;middle&lt;/code&gt; equals &lt;code&gt;last&lt;/code&gt;. So an implementation could, I think, claim conformance by implementing &lt;code&gt;sort&lt;/code&gt; on top of &lt;code&gt;partial_sort&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc3" name="tocpartial-sorting-with-heaps" id="tocpartial-sorting-with-heaps"&gt;Partial Sorting with Heaps&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In fact the partial and full sort functions use quite different algorithms. Partial sort is based on the heap data structure and, on my present platform, is implemented largely in terms of the standard heap functions. Here&amp;#8217;s the important part of the code, which I&amp;#8217;ve reformatted for the purposes of this article. Please, compare against the same function in your own implementation.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename RanIt&amp;gt;
void partial_sort(RanIt first, RanIt middle, RanIt last)
{
    typedef typename iterator_traits&amp;lt;RanIt&amp;gt;::value_type V;
    
    std::make_heap(first, middle);
    for (RanIt i = middle; i &amp;lt; last; ++i)
        if (*i &amp;lt; *first)
            std::__pop_heap(first, middle, i, V(*i));
    std::sort_heap(first, middle);
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This function starts by making the half open range &lt;code&gt;[first, middle)&lt;/code&gt; into a heap, which has the result that &lt;code&gt;*first&lt;/code&gt; is the largest element in this range.
&lt;/p&gt;
&lt;p&gt;It then iterates through the elements &lt;code&gt;[middle, last)&lt;/code&gt;. Each time an element is smaller than &lt;code&gt;*first&lt;/code&gt; &amp;#8212; that is, smaller than the largest element of &lt;code&gt;[middle, first)&lt;/code&gt; &amp;#8212; it calls the implementation&amp;#8217;s private &lt;code&gt;std::__pop_heap()&lt;/code&gt; function. This in turn swaps the values at positions &lt;code&gt;*first&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; and adjusts the range [first, middle) to once more be a heap. Again, look in your standard library for details.
&lt;/p&gt;
&lt;p&gt;Loosely speaking, every time we see an element in the tail of the collection which is smaller than the largest element in the head of the collection, we swap these elements.
&lt;/p&gt;
&lt;p&gt;More precisely, the loop invariant is that &lt;code&gt;[first, middle)&lt;/code&gt; is a heap, and all the elements in the range &lt;code&gt;[middle, i]&lt;/code&gt; are greater than all the elements in &lt;code&gt;[first, middle)&lt;/code&gt;. &lt;span /&gt;It&amp;#8217;s subtle, efficient, and dazzlingly clever!
&lt;/p&gt;
&lt;p&gt;Once the iterator &lt;code&gt;i&lt;/code&gt; gets to the end of the range (&lt;code&gt;last&lt;/code&gt;, that is), the container has been partitioned so the smallest N elements are at its front. All that remains is to sort these elements; and since the front of the container has already been heapified, we can just heap_sort it.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc4" name="tocpartitioning-with-heaps" id="tocpartitioning-with-heaps"&gt;Partitioning with Heaps?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Note the distinction between finding the ordered top ten items in a collection and finding the ten largest items in a collection: the ten largest elements needn&amp;#8217;t be ordered.
&lt;/p&gt;
&lt;p&gt;You may have spotted that if we pull out of the &lt;code&gt;partial_sort()&lt;/code&gt; implementation shown above before applying the final &lt;code&gt;sort_heap()&lt;/code&gt;, then we&amp;#8217;ve partitioned the collection so that items in the range &lt;code&gt;[first, middle)&lt;/code&gt; are larger than items in the range &lt;code&gt;[middle, last)&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;In fact, there&amp;#8217;s a a better way of partitioning the collection to put the N largest elements at the front. It doesn&amp;#8217;t use heaps, and, amazingly, can be achieved with a linear algorithm. The C++ standard library provides just such an algorithm filed under the slightly misleading name of &lt;a href="http://www.sgi.com/tech/stl/nth_element.html"&gt;std::nth_element&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc5" name="tocsorting-with-heaps" id="tocsorting-with-heaps"&gt;Sorting with Heaps&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I claimed earlier that C++ sort implementers could reuse a special case of partial sort and still meet the C++ Standard&amp;#8217;s complexity guarantee. It would be a hard trick to pull off though, since the constant factors differ. Sort is likely to be based on quicksort, acknowledged the most efficient general purpose sorting algorithm. Partial sort, as already mentioned, is a heap sort.
&lt;/p&gt;
&lt;p&gt;On my platform, &lt;code&gt;std::sort()&lt;/code&gt; in fact delegates to an &lt;a href="http://en.wikipedia.org/wiki/Introsort"&gt;introsort&lt;/a&gt; &amp;#8212; a hybrid algorithm which starts with a quicksort and bottoms out to &lt;code&gt;std::partial_sort()&lt;/code&gt; once a heuristically determined recursion depth is exceeded.
&lt;/p&gt;
&lt;p&gt;I ran a full partial sort head to head against standard sort on my machine, feeding both algorithms large-ish (size up to 10 million) arrays of 31 bit numbers generated using the standard C &lt;code&gt;random()&lt;/code&gt; function. The results indicate sort runs around four times faster than partial sort; someone&amp;#8217;s probably got a theoretical proof of the exact multiplier.
&lt;/p&gt;
&lt;img alt="Full Sort vs Full Partial Sort chart" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Full+Sort+vs.+Full+Partial+Sort
&amp;amp;chs=400x300
&amp;amp;chxt=x,y,x,y
&amp;amp;chxl=0:|0|2|4|6|8|10|1:|0|1|2|3|4|5|6|2:||N+%28Millions%29||3:||Time+%28seconds%29|
&amp;amp;chd=t:0.0,3.7,7.7,11.8,16.0,20.2|0.0,10.0,26.3,46.7,65.7,88.7
&amp;amp;chco=ff0000,0000ff
&amp;amp;chls=2,0,0|2,0,0
&amp;amp;chdl=Full|Partial" /&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc6" name="tocn-largest-in-python" id="tocn-largest-in-python"&gt;N Largest in Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Python makes no complexity guarantees, but the location of the &lt;code&gt;nlargest&lt;/code&gt; function in the &lt;code&gt;heapq&lt;/code&gt; module gives a pretty big hint about its implementation! Note that &lt;code&gt;nlargest&lt;/code&gt; returns its results in order; it&amp;#8217;s more than just a partitioning. Note too that it&amp;#8217;s generous enough to handle the case when N is larger than the size of the collection.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a Python script which imitates our earlier C++ program:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from sys import stdin
from heapq import nlargest

numbers = map(int, stdin.read().split())
top_ten = nlargest(10, numbers)
print "\n".join(map(repr, top_ten))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;For the purpose of comparison, I timed the &lt;code&gt;nlargest()&lt;/code&gt; part of this function. I also timed a full (Python) sort of the numbers. Again, I ran on random collections of size S ranging from 2 to 10 million.
&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;th&gt;S/million&lt;/th&gt;&lt;th&gt;Partial/ms&lt;/th&gt;&lt;th&gt;Full/ms&lt;/th&gt;&lt;th&gt;Full/Partial&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;2590&lt;/td&gt;&lt;td&gt;26&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;190&lt;/td&gt;&lt;td&gt;5800&lt;/td&gt;&lt;td&gt;31&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;290&lt;/td&gt;&lt;td&gt;9300&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;410&lt;/td&gt;&lt;td&gt;12880&lt;/td&gt;&lt;td&gt;31&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;510&lt;/td&gt;&lt;td&gt;16670&lt;/td&gt;&lt;td&gt;33&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;This time, the partial sort ran about 30 times more quickly than the full sort. C++ proved about 13 times quicker than Python for the full sort, and 24 times quicker for partial sort.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc7" name="tocn-largest-in-shell" id="tocn-largest-in-shell"&gt;N Largest in Shell&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Python script shown relies on being able to read the entire file into memory (that&amp;#8217;s not a limitation of Python, just of the rather simplistic approach taken by the script). The C++ solution only needs space for the numbers, the input buffering being nicely handled by the iostreams framework. For sizable inputs &amp;#8212; of the order of a GB, say, on a modern computer &amp;#8212; we&amp;#8217;d need to use secondary storage.
&lt;/p&gt;
&lt;p&gt;The Unix shell pipeline shown earlier has no such limitation. Given enough time and secondary storage, the following command finds the 10 largest numbers in BIGFILE, even if we can&amp;#8217;t hold all these numbers in RAM.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ sort -r -n BIGFILE | head

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Executing this command on a ~9GB input file holding one billion 31 bit random numbers took over an hour and a half on my machine.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc8" name="tocparallel-algorithm-analysis" id="tocparallel-algorithm-analysis"&gt;Parallel Algorithm Analysis&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href="http://en.wikipedia.org/wiki/Big_O_notation"&gt;language&lt;/a&gt; used in this article for discussing algorithm analysis works best for a single process running a single uninterrupted thread of execution. If we want to budget time for an algorithm which makes &lt;code&gt;N * log(N)&lt;/code&gt; comparisons we plug in N, divide by the processor speed, and multiply by the number of cycles required for each comparison.
&lt;/p&gt;
&lt;p&gt;I wonder how well this language will survive in a world where processors have multiple cores. Will a new family of algorithms evolve, ones better equipped to use the new hardware?
&lt;/p&gt;
&lt;p&gt;This evolution is underway already. In a sequence of articles published in &lt;a href="http://ddj.com"&gt;Dr. Dobbs Journal&lt;/a&gt;, Herb Sutter teaches programmers &lt;a href="http://herbsutter.spaces.live.com/?_c11_BlogPart_BlogPart=blogview&amp;amp;_c=BlogPart&amp;amp;partqs=cat%3dConcurrency" title="I hope this link to Herb Sutter's blog works!"&gt;the traditional C++ way of doing things&lt;/a&gt;; a low-level, platform-dependent approach based on forking threads and locking resources. I&amp;#8217;ve come to regard these techniques as a sure route to subtle bugs. On the systems I&amp;#8217;ve worked on, a more C-style approach has worked well. At its simplest, a Unix pipeline distributes the load; this archetype generalises to a multi-process architecture, where we develop and prove each (single-threaded!) component in isolation.
&lt;/p&gt;
&lt;img src="http://erlang.org/images/erlang.gif" alt="erlang GIF"/&gt;

&lt;p&gt;There are &lt;a href="http://erlang.org"&gt;higher level languages&lt;/a&gt; though. Why limit ourselves to a single machine if we can devise a language which blurs the distinction between multiple processors on a single machine and multiple processors on a network? And why not build in some regulation of low level failures? When a task is distributed between workers, it&amp;#8217;s natural to ask what should happen if a worker fails, or simply lags behind.
&lt;/p&gt;
&lt;p&gt;Functional programming turns out to have much to offer in this new, parallel world &amp;#8212; &lt;a href="http://labs.google.com/papers/mapreduce.html"&gt;Google&amp;#8217;s Map-Reduce framework&lt;/a&gt;, for example &amp;#8212; and it&amp;#8217;s nice to know the fundamental ideas are far from being new: rather, their time has come.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/top-ten-tags#toc9" name="tocchoosing-an-algorithm" id="tocchoosing-an-algorithm"&gt;Choosing an algorithm&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When discussing algorithms it&amp;#8217;s all too easy to fret about what happens when inputs grow massive. If we&amp;#8217;ve used the standard libraries then resource use for sorting &amp;#8212; both memory and CPU cycles &amp;#8212; may not be a concern. The code in this article demonstrates highly efficient general purpose sorting routines; and in any final system it&amp;#8217;s likely we could use full- and partial- sorting interchangeably without noticeably affecting overall performance. 
&lt;/p&gt;
&lt;p&gt;What is always a concern, though, is &lt;a href="http://wordaligned.org/articles/readable-code.html"&gt;readability&lt;/a&gt;. If it&amp;#8217;s the largest few elements of a collection we want, calling &lt;code&gt;std::partial_sort()&lt;/code&gt; in C++ or &lt;code&gt;heapq.nlargest()&lt;/code&gt; in Python nicely expresses that desire.
&lt;/p&gt;</description>
<dc:date>2008-02-19</dc:date>
<guid>http://wordaligned.org/articles/top-ten-tags</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/top-ten-tags</link>
<category>Algorithms</category>
</item>

<item>
<title>Animated pair streams</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocname-that-series" name="toc0" id="toc0"&gt;Name that Series&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocbounded-pairs" name="toc1" id="toc1"&gt;Bounded Pairs&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocstreams-of-pairs" name="toc2" id="toc2"&gt;Streams of Pairs&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toca-recursive-scheme" name="toc3" id="toc3"&gt;A Recursive Scheme&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocinterleaving" name="toc4" id="toc4"&gt;Interleaving&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocdouble-trouble" name="toc5" id="toc5"&gt;Double Trouble&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocmemory-use" name="toc6" id="toc6"&gt;Memory Use&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocproblem-solved" name="toc7" id="toc7"&gt;Problem Solved?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toctying-up" name="toc8" id="toc8"&gt;Tying up&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toccredits" name="toc9" id="toc9"&gt;Credits&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc0" name="tocname-that-series" id="tocname-that-series"&gt;Name that Series&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;What&amp;#8217;s going on in the animation below?
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-stream.gif" alt="Pair stream slideshow"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc1" name="tocbounded-pairs" id="tocbounded-pairs"&gt;Bounded Pairs&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While you&amp;#8217;re waiting for the graphic to load, recall a problem we encountered while hunting for &lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#programming-pearl"&gt;maximum subsequences&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Given a number n, generate all the pairs (i, j) such that i and j are in the range 0 to n and j is greater than i.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;A Python solution reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def generate_pairs(n):
    "Generate all pairs (i, j) such that 0 &amp;lt;= i &amp;lt;= j &amp;lt; n"
    for i in range(n):
        for j in range(i, n):
            yield i, j

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can extend this to solve a more general version of the problem:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Given two sequences (S, T), generate all pairs (S&lt;sub&gt;i&lt;/sub&gt;, T&lt;sub&gt;j&lt;/sub&gt;) such that j is greater than i.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def generate_pairs(s, t):
    "Generate all pairs s[i], t[j]  such that 0 &amp;lt;= i &amp;lt;= j"
    s_count = len(s)
    t_count = len(t)
    for i in xrange(s_count):
        for j in xrange(i, t_count):
            yield s[i], t[j]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;This function requires complete and bounded collections as inputs since it asks for their lengths and accesses elements by index &amp;#8212; think &amp;#8220;lists&amp;#8221; or &amp;#8220;tuples&amp;#8221;. Yet it generates results lazily, giving clients control over just how many pairs they require. This is why I&amp;#8217;ve chosen &lt;code&gt;xrange&lt;/code&gt; in preference to &lt;code&gt;range&lt;/code&gt;, since it too generates numbers, rather than returning a complete list. (Python 3000 simplifies things: &lt;code&gt;range&lt;/code&gt; becomes &lt;code&gt;xrange&lt;/code&gt; and &lt;code&gt;xrange&lt;/code&gt; disappears.)
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;There&amp;#8217;s no need for extra logic to handle &lt;code&gt;S&lt;/code&gt; being shorter than &lt;code&gt;T&lt;/code&gt; or vice-versa: &lt;code&gt;xrange(start, stop)&lt;/code&gt; is smart enough to handle the case when &lt;code&gt;stop&lt;/code&gt; is less than &lt;code&gt;start&lt;/code&gt;. I&amp;#8217;d say adding such extra logic would count as premature optimisation.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&amp;#8217;s an example of this function in action. We run the generator to exhaustion collecting its output in a list.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; pairs = list(generate_pairs('ABC', (1, 2, 3, 4)))
&amp;gt;&amp;gt;&amp;gt; print pairs
[('A', 1), ('A', 2), ('A', 3), ('A', 4), ('B', 2), ('B', 3), ('B', 4), ('C', 3), ('C', 4)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A second example builds a &lt;a href="http://docs.python.org/ref/genexpr.html"&gt;generator expression&lt;/a&gt; from &lt;code&gt;generate_pairs()&lt;/code&gt;. We plug this expression into the built in &lt;code&gt;any&lt;/code&gt; function to determine whether the pair &lt;code&gt;('A', 2)&lt;/code&gt; is in the pair sequence. Note that &lt;code&gt;any&lt;/code&gt; only pulls two elements from the sequence to produce an answer.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; any((p == 'A', 2) for p in generate_pairs('ABC', (1, 2, 3, 4)))
True

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So far, so what? For the toy examples shown, lazy evaluation isn&amp;#8217;t an important consideration. But what if our input sequences were very large? What if they were infinite?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc2" name="tocstreams-of-pairs" id="tocstreams-of-pairs"&gt;Streams of Pairs&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Generate_pairs()&lt;/code&gt; yields results row by row. Here&amp;#8217;s a slideshow for the case when &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; have 5 and 20 elements respectively. Brightness indicates age, so the white circle represents the current head of the generated sequence, and the greying circles represent previous elements &amp;#8212; the older the greyer. Remember, it&amp;#8217;s up to clients just how many grey pairs to hold: the generator only ever yields a shiny white new pair.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-list.gif" alt="Pair list slideshow"/&gt;

&lt;p&gt;A text representation would be as follows, where, as usual, we read top to bottom, left to right.
&lt;/p&gt;
&lt;pre&gt;
S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;0&lt;/sub&gt;, S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;2&lt;/sub&gt; ...                             S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;20&lt;/sub&gt;
      S&lt;sub&gt;1&lt;/sub&gt;T&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;1&lt;/sub&gt;T&lt;sub&gt;2&lt;/sub&gt;, ...                            S&lt;sub&gt;1&lt;/sub&gt;T&lt;sub&gt;20&lt;/sub&gt;
            S&lt;sub&gt;2&lt;/sub&gt;T&lt;sub&gt;2&lt;/sub&gt;, ...                           S&lt;sub&gt;2&lt;/sub&gt;T&lt;sub&gt;20&lt;/sub&gt;
                  ...
&lt;/pre&gt;

&lt;p&gt;It&amp;#8217;s clear this mode of traversal isn&amp;#8217;t suitable for generating pairs from very large inputs: we don&amp;#8217;t advance through S quickly enough. In fact, if T were infinite, we&amp;#8217;d be stuck on the top row, forever generating pairs of the form &lt;code&gt;S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc3" name="toca-recursive-scheme" id="toca-recursive-scheme"&gt;A Recursive Scheme&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt; describes an elegant recursive scheme for &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_Temp_476"&gt;generating pairs&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Call the general stream of pairs (pairs S T), and consider it to be composed of three parts: the pair (S&lt;sub&gt;0&lt;/sub&gt;,T&lt;sub&gt;0&lt;/sub&gt;), the rest of the pairs in the first row, and the remaining pairs:&lt;br/&gt;&lt;br/&gt;
   &lt;img src="http://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-47.gif" alt="Stream of pairs structure"/&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Based on this insight, we can generate our stream of pairs:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     yielding the pair, (S&lt;sub&gt;0&lt;/sub&gt;,T&lt;sub&gt;0&lt;/sub&gt;)
 &lt;/li&gt;

 &lt;li&gt;
     yield pairs from the first row combined with the stream of remaining pairs
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note the recursion: the definition of the pairs stream refers to itself. That&amp;#8217;s not a problem so long as we&amp;#8217;re lazy about evaluating the tail of the stream. Since we always know how to pull the first pair from the stream, we can both bootstrap the process and keep going forever.
&lt;/p&gt;
&lt;p&gt;All we now need is a suitable method of combining two the first row and the remaining pairs.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc4" name="tocinterleaving" id="tocinterleaving"&gt;Interleaving&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The simplest way to combine the two streams is just to interleave them, pulling elements from each in turn. A simple (too simple!) implementation of &lt;code&gt;interleave()&lt;/code&gt; reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Simple interleave&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def interleave(s, t):
    while True:
        yield s.next()
        yield t.next()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(The problem here is that &lt;code&gt;interleave()&lt;/code&gt; stops as soon as either of the the input streams is exhausted, which isn&amp;#8217;t an issue for infinite streams, but isn&amp;#8217;t ideal in the case when either of the inputs are bounded. You get the idea. I&amp;#8217;ll provide better implementation &lt;a href="http://wordaligned.org/articles/animated-pair-streams#tying-up"&gt;later&lt;/a&gt;.)
&lt;/p&gt;
&lt;p&gt;We can now code our pairs generator:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Pairs generator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;import itertools

def pairs(s, t):
    """ Generate a stream of pairs taken from s, t.
    
    Yields a stream of pairs (si, tj) where i &amp;lt;= j.
    The input streams may be finite or bounded, but must be iterable.
    """
    first = s.next(), t.next()
    yield first
    t, t_top = itertools.tee(t)
    s0 = first[0]
    top_row = ((s0, tt) for tt in t_top)
    for st in interleave(top_row, pairs(s, t)):
        yield st

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a slideshow of this algorithm in action.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-stream.gif" alt="Pair stream slideshow"/&gt;

&lt;p&gt;Even though Python (CPython, to be specific) and recursion don&amp;#8217;t generally get along well (unlike in a proper functional programming language), this implementation doesn&amp;#8217;t &lt;em&gt;appear&lt;/em&gt; to fall foul of CPython&amp;#8217;s maximum recursion limits &lt;strong&gt;even though pairs() repeatedly calls itself&lt;/strong&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;No maximum recursion depth exceeded error here!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; integers = itertools.count
&amp;gt;&amp;gt;&amp;gt; for ij in pairs(integers, integers):
... 	print ij
... 
(0, 0)
(0, 1)
(1, 1)
(0, 2)
(1, 2)
(0, 3)
(2, 2)
....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;When I dug a little deeper, I started to understand why: the function can&amp;#8217;t run indefinitely since it eats up memory. It continually tees up iterators over &lt;code&gt;t&lt;/code&gt; and creates new generator expressions.
&lt;/p&gt;
&lt;p&gt;That said, I was surprised just how quickly it consumes memory. After all, generator expressions and iterators shouldn&amp;#8217;t take up much space. For the purposes of comparison, I compared how it fared against a Scheme program designed to do the same thing. Both had consumed a gigabyte of memory after running just a few minutes (and, for what it&amp;#8217;s worth, the Python program had generated an order of magnitude more pairs by this point).
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Scheme pair generator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;(require (lib "40.ss" "srfi")) ;; Scheme stream support

(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (stream-cons (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define (pairs s t)
  (stream-cons
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))

(define ones (stream-cons 1 ones))

(define (stream-add s t) (stream-map + s t))

(define integers
  (stream-cons 0 (stream-add ones integers)))

(stream-for-each
  (lambda (x) (newline) (display x))
  (pairs integers integers))

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc5" name="tocdouble-trouble" id="tocdouble-trouble"&gt;Double Trouble&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s look a little further into the stream. Here&amp;#8217;s the genesis of the first 120 pairs.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-stream-120.gif" alt="Pair stream slideshow"/&gt;

&lt;p&gt;Now the pattern becomes clear. Evidently the interleave strategy gives a heavy bias towards advancing rightwards; downwards motion is relatively slow.
&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s filter out the &lt;code&gt;i == j&lt;/code&gt; diagonal to try and quantify this.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; ints = itertools.count
&amp;gt;&amp;gt;&amp;gt; izip = itertools.izip
&amp;gt;&amp;gt;&amp;gt; pp = pairs(ints(), ints())
&amp;gt;&amp;gt;&amp;gt; diagonal = ((ix, (i, j))
...             for ix, (i, j) in izip(ints(1), pp) if i == j))
&amp;gt;&amp;gt;&amp;gt; for d in itertools.islice(diagonal, 10):
...     print d
...
(1, (0, 0))
(3, (1, 1))
(7, (2, 2))
(15, (3, 3))
(31, (4, 4))
(63, (5, 5))
(127, (6, 6))
(255, (7, 7))
(511, (8, 8))
(1023, (9, 9))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The output shows that pair (0, 0) is the 1&lt;sup&gt;st&lt;/sup&gt; element of the stream, (1, 1) the 3&lt;sup&gt;rd&lt;/sup&gt;, (2, 2) the 7&lt;sup&gt;th&lt;/sup&gt;, and so on.
&lt;/p&gt;
&lt;p&gt;Any computer scientist ought to quickly spot the pattern, and any mathematician ought to be able to prove why diagonal advances are exponentially infrequent.
&lt;/p&gt;
&lt;p&gt;Loosely speaking, if D&lt;sub&gt;i&lt;/sub&gt; is the stream of positions in the pairs stream of elements which lie on the diagonal (i.e. the stream 1, 3, 7, 15, &amp;#8230; shown in the interpreted Python session), then the elements of D must satisfy the recurrence relation:
&lt;/p&gt;
&lt;pre&gt;
D&lt;sub&gt;i+1&lt;/sub&gt; = 1 + 2&amp;times;D&lt;sub&gt;i&lt;/sub&gt;
&lt;/pre&gt;

&lt;p&gt;This relation derives directly from the recursive definition of &lt;code&gt;pairs()&lt;/code&gt;: yield a single element, then alternate the rest of yourself with the generated top row.
&lt;/p&gt;
&lt;p&gt;Here are some slides showing the points at which the first 5 diagonal elements appear. Watch the recursive pattern emerge.
&lt;/p&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/files/pairs-1.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-3.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-7.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-15.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-31.png" alt="diagonal pairs image"/&gt;
&lt;/p&gt;
&lt;p&gt;The solution to the recurrence relation is &lt;code&gt;D&lt;sub&gt;i&lt;/sub&gt; = 2&lt;sup&gt;i&lt;/sup&gt; &amp;minus; 1&lt;/code&gt;. These diagonal advances correspond to recursive calls to &lt;code&gt;pairs()&lt;/code&gt;. So if our Python session has a recursion limit set to 1000 (try &lt;code&gt;sys.getrecursionlimit()&lt;/code&gt;), and our pairs generator were to yield a result every nanosecond, and we had a machine with infinite memory, it would take quite a few millenia before we run into this limit.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;How many millenia until we hit the recursion limit?&lt;/div&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; (2 ** 1000 - 1)/(1.e9 * 60 * 60 * 24 * 365 * 1000) 
3.3977315042689856e+281

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc6" name="tocmemory-use" id="tocmemory-use"&gt;Memory Use&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It should also now be clear why this particular algorithm burns memory. Teeing an iterator doesn&amp;#8217;t magically mean we don&amp;#8217;t have to store any elements we&amp;#8217;ve iterated past. The greater the distance between the teed iterators, the more that need storing.
&lt;/p&gt;
&lt;p&gt;If that&amp;#8217;s not clear, run the following Python session and keep an eye on memory consumption (and be ready to interrupt the infinite loop!). You&amp;#8217;ll see memory use rapidly increase as &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; diverge, since &lt;code&gt;j&lt;/code&gt; needs to remember everything &lt;code&gt;i&lt;/code&gt; produces.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import *
&amp;gt;&amp;gt;&amp;gt; i, j = tee(repeat(0))
&amp;gt;&amp;gt;&amp;gt; for x in i: pass

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;By contrast, if we zip through &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; in parallel, memory use is stable.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; i, j = tee(repeat(0))
&amp;gt;&amp;gt;&amp;gt; for ij in izip(i, j): pass

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Our pair generator has to remember more and more elements from the &lt;code&gt;T&lt;/code&gt; stream (and also, to a lesser extent, from the &lt;code&gt;S&lt;/code&gt; stream). That&amp;#8217;s why it&amp;#8217;s so hungry. Any general purpose infinite pair generator function must suffer this problem, I think, since we &lt;strong&gt;have&lt;/strong&gt; to accumulate increasing portions of the streams into memory, but if it&amp;#8217;s just integer pairs we want we can work around the issue:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def integer_pairs(i=0):
    "Generate a stream of integer pairs (i, j) with i &amp;lt;= j"
    yield i, i
    top_row = ((i, j) for j in itertools.count(i + 1))
    for ij in interleave(top_row, integer_pairs(i + 1)):
        yield ij

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, rather than &lt;code&gt;tee()&lt;/code&gt; streams of integers, we use &lt;code&gt;itertools.count()&lt;/code&gt; to create new ones as required. This pair generator will run happily for extended periods. It will very gradually ask for more memory, as numbers get bigger and the number of rows increases. As before, it won&amp;#8217;t hit any embarrassing recursion limits in the lifetime of this galaxy.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc7" name="tocproblem-solved" id="tocproblem-solved"&gt;Problem Solved?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So, does &lt;code&gt;integer_pairs()&lt;/code&gt; solve the problem of generating an infinite stream of pairs for the special case when both input streams are integers? 
&lt;/p&gt;
&lt;p&gt;Not really, no!
&lt;/p&gt;
&lt;p&gt;The interleave strategy for combining the top row with the remaining pairs has the great merit of simplicity, but is otherwise far from ideal. I don&amp;#8217;t think a one-size-fits-all strategy for streaming pairs exists, so we should allow clients to supply one. And that will have to be the subject of another article.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc8" name="toctying-up" id="toctying-up"&gt;Tying up&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s not hard to fix the problem we noticed with &lt;code&gt;interleave()&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def interleave(s, t):
    """Generate an interleaved stream of elements from s and t.
    
    If one of the streams finishes, elements continue to be generated
    from the other until it too is finished. 
    """
    for ss, tt in itertools.izip(s, t):
        yield ss
        yield tt
    for s_or_t in itertools.chain(s, t):
        yield s_or_t

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s the script I used to generate the animated GIFs. Although it&amp;#8217;s very much geared to doing the single job which it was designed to do, it&amp;#8217;s short enough to be used as a basis for similar tasks. I hope this article helps demonstrate the merits of visualising an algorithm in action.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;pairs-animation.py&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#! /usr/bin/env python
"""Script which accepts a list of (i, j) pairs, creating slides and
   an animated GIF showing the positions of these pairs.

Example use:
$ echo '((0, 0) (0, 1) (1, 1) (0, 2) (1, 2) (0, 3) (2, 2)' | pairs-animation.py

Dependencies:
- Python Imaging Library (PIL), http://effbot.org/imagingbook/
- aggdraw, anti-aliased graphics drawing package,
  http://effbot.org/zone/pythondoc-aggdraw.htm
- ImageMagick, http://www.imagemagick.org
"""
import Image
import aggdraw
import itertools

# Script wide drawing configuration
block_w = 16
block_pad = 2

def fading_brushes():
    "Generate a sequence of fading grey brushes."
    darkgrey = itertools.repeat(16)
    greyscale = itertools.chain(range(255, 0, -16), darkgrey)
    def brush(g):
        "Return a grey brush."
        return aggdraw.Brush('rgb(%d,%d,%d)' % (g, g, g))
    return itertools.imap(brush, greyscale)

def block_start(i):
    "Return the coordinate (X or Y) at which the ith block starts."
    return (block_w + block_pad) * i + block_pad

def read_ij(data):
    """Return pairs of integers found in the input string.
    
    Note: this function is extremely unfussy about the string format!
    &amp;gt;&amp;gt;&amp;gt; read_ij('1 2 3 4')
    [(1, 2), (3, 4)]
    &amp;gt;&amp;gt;&amp;gt; read_ij('(1, 2), (3, 4)')
    [(1, 2), (3, 4)]
    """
    import re
    ij = itertools.imap(int, re.compile(r'-?\d+').findall(data))
    return zip(ij, ij)

def dimensions(ij):
    "Return dimensions of an image big enough to contain blocks at ij positions."
    import operator
    max_i = max(map(operator.itemgetter(0), ij))
    max_j = max(map(operator.itemgetter(1), ij))
    return block_start(max_j + 1), block_start(max_i + 1)

def block_xy(ij):
    "Return the left, top, right, bottom coords of a block at ij."
    ylo, xlo = map(block_start, ij)
    return xlo, ylo, xlo + block_w, ylo + block_w

def draw_blocks(image, blocks):
    "Draws the supplied blocks onto the input image."
    draw = aggdraw.Draw(image)
    brushes = fading_brushes()
    # Reverse the blocks so the newest are brightest
    for block, brush in itertools.izip(reversed(blocks), brushes):
        # The 'ellipse' will be circular since the block is square
        draw.ellipse(block_xy(block), brush)
    draw.flush()

def main(ij_data):
    "Creates slides and an animation from the ij block positions."
    import os
    ij = read_ij(ij_data)
    dims = dimensions(ij)
    # Create the slides
    slides = ['pairs-%d.gif' % n for n in range(len(ij) + 1)]
    for n, slide in enumerate(slides):
        image = Image.new('L', dims)
        draw_blocks(image, ij[:n])
        image.save(slide)
    # Use ImageMagick to create an animation
    # -loop 0 =&amp;gt; loop forever, -delay units are .01 seconds
    os.system('convert -delay 100 -loop 0 %s animation.gif'
              % ' '.join(slides))

if __name__ == '__main__':
    import sys
    main(sys.stdin.read())

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc9" name="toccredits" id="toccredits"&gt;Credits&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The inspiration for this article comes directly from &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_Temp_476"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt;, which presents some great examples of how to develop and use these pair streams.
&lt;/p&gt;</description>
<dc:date>2008-01-13</dc:date>
<guid>http://wordaligned.org/articles/animated-pair-streams</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/animated-pair-streams</link>
<category>Algorithms</category>
</item>

<item>
<title>The Maximum Sum contiguous subsequence problem</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocwelcome-to-the-pearly-gates" name="toc0" id="toc0"&gt;Welcome to the Pearly Gates&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocprogramming-pearl" name="toc1" id="toc1"&gt;Programming Pearl&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toclinear-solution" name="toc2" id="toc2"&gt;Linear Solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstreaming-solution" name="toc3" id="toc3"&gt;Streaming Solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstream-accumulate" name="toc4" id="toc4"&gt;Stream Accumulate&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstream-floor" name="toc5" id="toc5"&gt;Stream Floor&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstream-diff" name="toc6" id="toc6"&gt;Stream Diff&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstreams-and-collections" name="toc7" id="toc7"&gt;Streams and Collections&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstream-on" name="toc8" id="toc8"&gt;Stream on&amp;#8230;&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc0" name="tocwelcome-to-the-pearly-gates" id="tocwelcome-to-the-pearly-gates"&gt;Welcome to the Pearly Gates&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Pearly Gates club never closes. Its public entrance, a revolving door, just keeps on spinning. With each rotation some punters enter and others leave. The club&amp;#8217;s owners would like to track this traffic. Specifically, they&amp;#8217;d like to know the maximum increase in people entering the club over a given period.
&lt;/p&gt;
&lt;p&gt;The starting point is to track the people who enter/leave with each spin of the door. Here&amp;#8217;s a 5 minute sample of that information. Negative numbers mean more people left than entered during a particular cycle.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Entries Log&lt;/div&gt;

&lt;pre class="prettyprint"&gt;0 1 2 -3 3 -1 0 -4 0 -1 -4 2 4 1 1 3 1 0 -2 -3 -3 -2 3 1 1 4 5 -3 -2 -1 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s the same information plotted on a graph.
&lt;/p&gt;
&lt;img alt="Graph of entries to Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Entries+to+the+Pearly+Gates+club
&amp;amp;chs=500x200
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-5.0,6.0
&amp;amp;chd=t:45.5,45.5|45.5,54.5,63.6,18.2,72.7,36.4,45.5,9.1,45.5,36.4,9.1,63.6,81.8,54.5,54.5,72.7,54.5,45.5,27.3,18.2,18.2,27.3,72.7,54.5,54.5,81.8,90.9,18.2,27.3,36.4
&amp;amp;chco=BBBBBB,0000CC
&amp;amp;chls=1,1,0|4,1,0
" /&gt;

&lt;p&gt;The archetypal problem we&amp;#8217;d like to solve can be stated:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;Given a sequence of numbers, find the maximum sum of a contiguous subsequence of those numbers.&lt;/strong&gt; 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;As an example, the maximum sum contiguous subsequence of 0, -1, &lt;strong&gt;2, -1, 3&lt;/strong&gt;, -1, 0 would be 4 (= 2 + -1 + 3).
&lt;/p&gt;
&lt;p&gt;This problem is generally known as &lt;strong&gt;the maximum sum contiguous subsequence problem&lt;/strong&gt; and if you haven&amp;#8217;t encountered it before, I&amp;#8217;d recommend trying to solve it before reading on. Even if you have encountered it before, I&amp;#8217;ll invite you to read on anyway &amp;#8212; it&amp;#8217;s well worth another look.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc1" name="tocprogramming-pearl" id="tocprogramming-pearl"&gt;Programming Pearl&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The maximum sum contiguous subsequence problem appears in Jon Bentley&amp;#8217;s &lt;a href="http://www.cs.bell-labs.com/cm/cs/pearls/"&gt;&amp;#8220;Programming Pearls&amp;#8221;&lt;/a&gt;. He first presents a brute force solution which examines all possible contiguous subsequences of the initial sequence and returns the maximum sum of these subsequences.
&lt;/p&gt;
&lt;p&gt;A Python implementation might read:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def generate_pairs(n):
    "Generate all pairs (i, j) such that 0 &amp;lt;= i &amp;lt;= j &amp;lt; n"
    for i in range(n):
        for j in range(i, n):
            yield i, j

def max_sum_subsequence(seq):
    "Return the max-sum contiguous subsequence of the input sequence."
    return max(sum(seq[i:j])
               for i, j in generate_pairs(len(seq) + 1))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s a straightforward piece of code, though note the &lt;code&gt;+ 1&lt;/code&gt; which ensures that we slice to the end of &lt;code&gt;seq&lt;/code&gt;, and also that we include empty slices, which sum to &lt;code&gt;0&lt;/code&gt;, handling the case when every item in the sequence is negative. The trouble is, the algorithm is of cubic complexity: to process just 6 hours of logged activity takes over 2 minutes on a 2GHz Intel Core Duo MacBook, and the cubic nature of the algorithm means we&amp;#8217;d quickly fail to process more substantial log files in real time.
&lt;/p&gt;
&lt;img alt="Graph plotting accumulated entries to the Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Accumulated+entries+to+the+Pearly+Gates+club
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-8.0,10.0
&amp;amp;chd=t:44.4,50.0,55.6,27.8,61.1,38.9,44.4,22.2,44.4,38.9,22.2,55.6,66.7,50.0,50.0,61.1,50.0,44.4,33.3,27.8,27.8,33.3,61.1,50.0,50.0,66.7,72.2,27.8,33.3,38.9|44.4,50.0,61.1,44.4,61.1,55.6,55.6,33.3,33.3,27.8,5.6,16.7,38.9,44.4,50.0,66.7,72.2,72.2,61.1,44.4,27.8,16.7,33.3,38.9,44.4,66.7,94.4,77.8,66.7,61.1
&amp;amp;chco=CCCCCC,CC0000
&amp;amp;chls=3,1,0|3,1,0
&amp;amp;chdl=Entries|Accum.+Entries
" /&gt;

&lt;p&gt;A simple optimisation eliminates the repeated calls to &lt;code&gt;sum&lt;/code&gt; by accumulating the input sequence &amp;#8212; the red line in the graph above. Subtracting element &lt;code&gt;i-1&lt;/code&gt; from element &lt;code&gt;j&lt;/code&gt; of this cumulative sequence gives us the sum of elements in the range i, j of the original sequence. We won&amp;#8217;t study the code for this quadratic solution &amp;#8212; it doesn&amp;#8217;t add much to our analysis. Again, some care is needed to avoid &lt;a href="http://wordaligned.org/articles/joined-output-and-the-fencepost-problem.html"&gt;fencepost problems&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;We won&amp;#8217;t look at the divide-and-conquer NlogN solution either. It&amp;#8217;s hard to understand, and we can do far better.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc2" name="toclinear-solution" id="toclinear-solution"&gt;Linear Solution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There is a linear solution. The idea is to scan the sequence from start to finish keeping track of &lt;code&gt;maxsofar&lt;/code&gt;, the maximum sum of a contiguous subsequence seen so far, and &lt;code&gt;maxendinghere&lt;/code&gt;, the maximum sum of a contiguous subsequence which ends at the current position. Bentley&amp;#8217;s pseudo-code reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;maxsofar = 0
maxendinghere = 0
for i = [0, n)
    /* invariant: maxendinghere and maxsofar are accurate
       are accurate for x[0..i-1] */
    maxendinghere = max(maxendinghere + x[i], 0)
    maxsofar = max(maxsofar, maxendinghere)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This translates directly into Python.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def max_sum_subsequence(seq):
    maxsofar = 0
    maxendinghere = 0
    for s in seq:
        # invariant: maxendinghere and maxsofar are accurate
        # are accurate up to s
        maxendinghere = max(maxendinghere + s, 0)
        maxsofar = max(maxsofar, maxendinghere)
    return maxsofar

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now, this is a fabulous solution. Bentley describes it as subtle. Such a succinct code snippet hardly &lt;strong&gt;looks&lt;/strong&gt; subtle, but I agree, the loop body &lt;strong&gt;does&lt;/strong&gt; take a bit of understanding:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;maxendinghere = max(maxendinghere + s, 0)
maxsofar = max(maxsofar, maxendinghere)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Why does this work?&lt;/strong&gt; 
&lt;/p&gt;
&lt;p&gt;Well, essentially maxendinghere is what&amp;#8217;s accumulating the subsequences &amp;#8212; it keeps rolling the next element into itself. Should this accumulated sum ever become negative we know that the subsequence-which-ends-here we&amp;#8217;re currently tracking is worse than the empty subsequence-which-restarts-here; so we can reset our subsequence accumulator, and the first clause of the loop invariant still holds. Combine this with the observation that maxsofar tracks peaks in maxendinghere and we&amp;#8217;re done.
&lt;/p&gt;
&lt;p&gt;The loop-invariant comment provides a good example of how comments can help us understand an algorithm, even though the code is minimal and the variable names are well-chosen.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc3" name="tocstreaming-solution" id="tocstreaming-solution"&gt;Streaming Solution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I prefer to think of this problem in terms of streams &amp;#8212; lazily evaluated sequences. Think of our log file as generating a stream of numbers:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;... 0 1 2 -3 3 -1 0 -4 0 -1 -4 2 4 1 1 3 1 0 -2 -3 -3 -2 3 1 1 4 5 -3 -2 -1 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The first thing we do is transform this stream to generate another stream, the cumulative sum of numbers seen so far. It&amp;#8217;s an integration of sorts. You&amp;#8217;ll remember we already used this stream, or an in-memory version of it, in our quadratic solution to the problem: the difference between points on it yields subsequence-sums.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc4" name="tocstream-accumulate" id="tocstream-accumulate"&gt;Stream Accumulate&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;We generate the accumulated stream from our original stream like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def stream_accumulate(stream):
    total = 0
    for s in stream:
        total += s
        yield total

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The graph below samples the first five minutes of this stream. The red line accumulates values from the pale grey line.
&lt;/p&gt;
&lt;img alt="Graph plotting accumulated entries to the Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-8.0,10.0
&amp;amp;chd=t:44.4,50.0,55.6,27.8,61.1,38.9,44.4,22.2,44.4,38.9,22.2,55.6,66.7,50.0,50.0,61.1,50.0,44.4,33.3,27.8,27.8,33.3,61.1,50.0,50.0,66.7,72.2,27.8,33.3,38.9|44.4,50.0,61.1,44.4,61.1,55.6,55.6,33.3,33.3,27.8,5.6,16.7,38.9,44.4,50.0,66.7,72.2,72.2,61.1,44.4,27.8,16.7,33.3,38.9,44.4,66.7,94.4,77.8,66.7,61.1
&amp;amp;chm=x,FFCC33,1,10.0,20.0|x,FFCC33,1,26.0,20.0
&amp;amp;chco=CCCCCC,CC0000
&amp;amp;chls=3,1,0|3,1,0
&amp;amp;chdl=Entries|Accum.+Entries
" /&gt;

&lt;p&gt;These accumulated numbers represent the number of members who have entered the club since we started tracking them. On our graph, the maximum sum contiguous subsequence is simply the greatest Y-increase between any two points on this graph. X&amp;#8217;s mark these points on the graph above. (Note: it&amp;#8217;s &lt;strong&gt;not&lt;/strong&gt; the Y-range of the graph we want since our X-values are time-ordered, and we require X1 &amp;lt;= X2). 
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc5" name="tocstream-floor" id="tocstream-floor"&gt;Stream Floor&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;A second transformation yields the floor of the accumulated stream.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import sys

def stream_floor(stream):
    m = 0
    for s in stream:
        m = min(m, s)
        yield m

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Note that, for our purposes, the floor of the stream isn&amp;#8217;t exactly the stream of minimum values taken by the stream &amp;#8212; we enforce a baseline at zero. It would be better to allow clients of this function to supply an optional baseline value, but I wanted the simplest possible code that shows the idea.)
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a graph plotting the accumulated entries alongside the floor of these entries.
&lt;/p&gt;
&lt;img alt="Graph plotting accumulated entries and floor of accumulated entries to the Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-8.0,10.0
&amp;amp;chd=t:44.4,50.0,61.1,44.4,61.1,55.6,55.6,33.3,33.3,27.8,5.6,16.7,38.9,44.4,50.0,66.7,72.2,72.2,61.1,44.4,27.8,16.7,33.3,38.9,44.4,66.7,94.4,77.8,66.7,61.1|44.4,44.4,44.4,44.4,44.4,44.4,44.4,33.3,33.3,27.8,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6
&amp;amp;chco=CC0000,333333
&amp;amp;chls=3,1,0|3,1,0
&amp;amp;chm=b,CCCCCC,0,1,0
&amp;amp;chdl=Accum.+Entries|Floor+Accum.+Entries
" /&gt;

&lt;p&gt;We&amp;#8217;re very close to what we want now. We can track Y-increases on the graph just by generating the difference between the accumulated stream and its floor &amp;#8212; the shading on the graph.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc6" name="tocstream-diff" id="tocstream-diff"&gt;Stream Diff&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Here&amp;#8217;s an implementation of &lt;code&gt;stream_diff&lt;/code&gt;. We can&amp;#8217;t just plug a minus sign &amp;#8220;-&amp;#8221; into the mapping function, so we have to use the less wieldy &lt;code&gt;operator.sub&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools
import operator

def stream_diff(s, t):
    return itertools.imap(operator.sub, s, t)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Alternatively, we could generate the new stream with an explicit loop:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools

def stream_diff(s, t):
    for ss, tt in itertools.izip(s, t):
        yield ss - tt

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The final graph shows us the difference between the accumulated entry count and its floor. I&amp;#8217;ve also added the ceiling of this stream as a thick red line (I&amp;#8217;m sure you can figure out how to implement &lt;code&gt;stream_ceiling&lt;/code&gt;), and this ceiling represents the stream of maximum sum contiguous subsequences. 
&lt;/p&gt;
&lt;img alt="Graph plotting Max-ends-here and Max-so-far" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Maximum+Subsequences+at+the+Pearly+Gates+club
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,0.0,17.0
&amp;amp;chd=t:0.0,5.9,17.6,17.6,17.6,17.6,17.6,17.6,17.6,17.6,17.6,17.6,35.3,41.2,47.1,64.7,70.6,70.6,70.6,70.6,70.6,70.6,70.6,70.6,70.6,70.6,94.1,94.1,94.1,94.1|0.0,5.9,17.6,0.0,17.6,11.8,11.8,0.0,0.0,0.0,0.0,11.8,35.3,41.2,47.1,64.7,70.6,70.6,58.8,41.2,23.5,11.8,29.4,35.3,41.2,64.7,94.1,76.5,64.7,58.8|0.0,0.0
&amp;amp;chco=aa0000,333333
&amp;amp;chls=4,1,0|2,1,0
&amp;amp;chm=b,CCCCCC,1,2,0
&amp;amp;chdl=Max-so-far|Max-ending-here
" /&gt;

&lt;p&gt;We&amp;#8217;ve re-labelled the lines &lt;code&gt;Max-so-far&lt;/code&gt; and &lt;code&gt;Max-ending-here&lt;/code&gt; because they&amp;#8217;re the stream of values taken by the variables &lt;code&gt;maxsofar&lt;/code&gt; and &lt;code&gt;maxendinghere&lt;/code&gt; during Bentley&amp;#8217;s clever solution to the maximum sum contiguous subsequence problem. I think we&amp;#8217;re in a better position to understand how this solution works now.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc7" name="tocstreams-and-collections" id="tocstreams-and-collections"&gt;Streams and Collections&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Please don&amp;#8217;t imagine these streams are bloated. &lt;span /&gt;They may be infinite (remember the Pearly Gates club never closes!) but that doesn&amp;#8217;t mean they take up much space. The graphs shown represent snapshots of their activity, and at no point do our presented algorithms actually store a five minute buffer of entries.
&lt;/p&gt;
&lt;p&gt;A final solution to the maximum sum contiguous subsequence problem reads like this. We&amp;#8217;ve pushed the general purpose stream transformation functions into a separate module, &lt;code&gt;stream.py&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools
import stream

def max_sum_subsequence_stream(ss):
    "Return the stream of max sum contiguous subsequences of the input iterable."
    accu1, accu2 = itertools.tee(stream.accumulate(ss))
    return stream.ceil(stream.diff(accu1, 
                       stream.floor(accu2, baseline=0)))

def max_sum_subsequence(ss):
    "Return the max sum of a contiguous subsequence of the input iterable."
    return stream.last(max_sum_subsequence_stream(ss))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The iterable supplied to &lt;code&gt;max_sum_subsequence&lt;/code&gt; has its last value read, and should therefore be bounded if we want the function to return. We haven&amp;#8217;t supplied arguments to extract a portion of this iterable (to generate maximum subsequences for the club on a particular day, for example) because that&amp;#8217;s what &lt;code&gt;itertools.islice&lt;/code&gt; is for.
&lt;/p&gt;
&lt;p&gt;Note that &lt;code&gt;max_sum_subsequence_stream()&lt;/code&gt; may be more useful to clients than &lt;code&gt;max_sum_subsequence()&lt;/code&gt;. Suppose, for example, we&amp;#8217;re only interested when the maximum sum subsequence exceeds 100. We can do this directly by connecting &lt;code&gt;itertools.dropwhile()&lt;/code&gt; to our function.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def max_subseq_exceeds(seq, limit=100):
    max_sub_s = max_sum_subsequence_stream(seq)
    return itertools.dropwhile(lambda s: s &amp;lt;= limit, max_sub_s)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Perhaps we&amp;#8217;d like to know if the maximum sum subsequence reaches a plateau; that is, it stays on a level for a while.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s the stream module.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;stream.py&lt;/div&gt;

&lt;pre class="prettyprint"&gt;"General purpose stream generation functions."
import itertools

def floor(stream, baseline=None):
    """Generate the stream of minimum values from the input stream.
    
    The baseline, if supplied, is an upper limit for the floor.
    &amp;gt;&amp;gt;&amp;gt; ff = floor((1, 2, -2, 3))
    &amp;gt;&amp;gt;&amp;gt; assert list(ff) == [1, 1, -2, -2]
    &amp;gt;&amp;gt;&amp;gt; ff = floor((1, 2, -2, 3), 0)
    &amp;gt;&amp;gt;&amp;gt; assert list(ff) == [0, 0, -2, -2]    
    """
    stream = iter(stream)
    m = baseline
    if m is None:
        try:
            m = stream.next()
            yield m
        except StopIteration:
            pass
    for s in stream:
        m = min(m, s)
        yield m

def ceil(stream):
    """Generate the stream of maximum values from the input stream.
    
    &amp;gt;&amp;gt;&amp;gt; top = ceil([0, -1, 2, -2, 3])
    &amp;gt;&amp;gt;&amp;gt; assert list(top) == [0, 0, 2, 2, 3]
    """
    stream = iter(stream)
    try:
        M = stream.next()
        yield M
    except StopIteration:
        pass
    for s in stream:
        M = max(M, s)
        yield M

def accumulate(stream):
    """Generate partial sums from the stream.
    
    &amp;gt;&amp;gt;&amp;gt; accu = accumulate([1, 2, 3, 4])
    &amp;gt;&amp;gt;&amp;gt; assert list(accu) == [1, 3, 6, 10]
    """
    total = 0
    for s in stream:
        total += s
        yield total

def diff(s, t):
    """Generate the differences between two streams
    
    If the streams are of unequal length, the shorter is truncated.
    &amp;gt;&amp;gt;&amp;gt; dd = diff([2, 4, 6, 8], [1, 2, 3])
    &amp;gt;&amp;gt;&amp;gt; assert list(dd) == [1, 2, 3]
    """
    import operator
    return itertools.imap(operator.sub, s, t)

def last(stream, default=None):
    """Return the last item in the stream or the default if the stream is empty.
    
    &amp;gt;&amp;gt;&amp;gt; last('abc')
    'c'
    &amp;gt;&amp;gt;&amp;gt; last([], default=-1)
    -1
    """
    s = default
    for s in stream:
        pass
    return s

if __name__ == "__main__":
    import doctest
    doctest.testmod()

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc8" name="tocstream-on" id="tocstream-on"&gt;Stream on&amp;#8230;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;The maximum sum contiguous subsequence problem is described in &lt;a href="http://www.cs.bell-labs.com/cm/cs/pearls/"&gt;&amp;#8220;Programming Pearls&amp;#8221;&lt;/a&gt; by Jon Bentley. 
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;My favourite introduction to computer programming, &amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;, has &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5"&gt;lots to say about streams&lt;/a&gt;, and suggests they have a role in concurrent programming and modelling time. 
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;Streams are a natural fit with functional programming, and well supported by languages like &lt;a href="http://www.schemers.org"&gt;Scheme&lt;/a&gt; and &lt;a href="http://haskell.org"&gt;Haskell&lt;/a&gt;. Python also handles them nicely: look into &lt;a href="http://www.python.org/dev/peps/pep-0255/"&gt;generators&lt;/a&gt;, &lt;a href="http://www.python.org/dev/peps/pep-0289/"&gt;generator expressions&lt;/a&gt;, the &lt;a href="http://docs.python.org/lib/module-itertools.html"&gt;itertools module&lt;/a&gt;, and study &lt;code&gt;test_generators.py&lt;/code&gt; carefully.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;If you liked this article, try more Word Aligned articles &lt;a href="http://wordaligned.org/tag/streams/"&gt;tagged &amp;#8220;streams&amp;#8221;&lt;/a&gt;. And if you like puzzles, there are more articles &lt;a href="http://wordaligned.org/tag/puzzles/"&gt;tagged &amp;#8220;puzzles&amp;#8221;&lt;/a&gt; too.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;The graphs in this article are generated using the &lt;a href="http://code.google.com/apis/chart/"&gt;Google chart API&lt;/a&gt;, which is both useful and &lt;span /&gt;a fine example of how to design and document a programming interface.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;</description>
<dc:date>2007-12-17</dc:date>
<guid>http://wordaligned.org/articles/the-maximum-subsequence-problem</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/the-maximum-subsequence-problem</link>
<category>Algorithms</category>
</item>

</channel>
</rss>
