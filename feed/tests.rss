<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Unleash the test army</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocare-the-tests-adequate" name="toc0" id="toc0"&gt;Are the tests adequate?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocproperty-based-testing" name="toc1" id="toc1"&gt;Property based testing&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tochypothesis" name="toc2" id="toc2"&gt;Hypothesis&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocfirst-impressions" name="toc3" id="toc3"&gt;First impressions&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocmy-first-test" name="toc4" id="toc4"&gt;My first test&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocmy-second-test" name="toc5" id="toc5"&gt;My second test&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toccomplete-test-suite" name="toc6" id="toc6"&gt;Complete test suite&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocquality-of-failure" name="toc7" id="toc7"&gt;Quality of failure&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocconclusions" name="toc8" id="toc8"&gt;Conclusions&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc0" name="tocare-the-tests-adequate" id="tocare-the-tests-adequate"&gt;Are the tests adequate?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Recently I described a solution to &lt;a href="http://wordaligned.org/articles/slicing-a-list-evenly-with-python"&gt;the problem of dividing a list into evenly sized chunks&lt;/a&gt;. It&amp;#8217;s a simple enough problem with just two inputs: the list (or other sliceable container) &lt;code&gt;xs&lt;/code&gt; and the number of chunks &lt;code&gt;n&lt;/code&gt;. Nonetheless, there are traps to avoid and special cases to consider &amp;#8212; what if &lt;code&gt;n&lt;/code&gt; is larger than the list, for example? Must the chunks comprise contiguous elements from the original list?
&lt;/p&gt;
&lt;p&gt;The tests I came up with are straightforward and uninspiring. They were developed within the context of my own assumptions about the solution and the special cases I could imagine. They were written after the implementation &amp;#8212; which is to say, development wasn&amp;#8217;t driven by tests. They are whitebox tests, designed to cover the various paths through the code based on my insider knowledge.
&lt;/p&gt;
&lt;p&gt;Are these tests adequate? Certainly they don&amp;#8217;t accurately represent the data which will hit the algorithm in practice. Can we be sure we haven&amp;#8217;t missed anything? Would the tests still cover all paths if the implementation changed?
&lt;/p&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc1" name="tocproperty-based-testing" id="tocproperty-based-testing"&gt;Property based testing&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;David R MacIver described another, complementary, approach at &lt;a href="https://accu.org/index.php/conferences/accu_conference_2016/accu2016_sessions#The_Plural_of_Anecdote_is_not_Test_Suite"&gt;a talk I attended at ACCU 2016&lt;/a&gt;. In the talk abstract he characterises the (class of) tests I&amp;#8217;d written as &lt;strong&gt;anecdotal&lt;/strong&gt; &amp;#8212; &amp;#8220;let me tell you about this time I called a function &amp;#8230; and then it returned this .. and then it raised an exception &amp;#8230; etc. etc.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;How about if the test suite instead describes the &lt;strong&gt;properties&lt;/strong&gt; required of the system under test, and then conjures up inputs designed to see if these properties hold under stress? So, rather than our test suite being a limited set of input/output pairs, it becomes an executable specification validated by a robot army.
&lt;/p&gt;
&lt;p&gt;&lt;a data-flickr-embed="true"  href="https://www.flickr.com/photos/avatarr8/3819520612" title="China&amp;#x27;s Robot Army"&gt;&lt;img src="https://c1.staticflickr.com/3/2431/3819520612_4b32f2b423.jpg" width="500" height="334" alt="China&amp;#x27;s Robot Army"&gt;&lt;/a&gt;&lt;script async src="http://wordaligned.org//embedr.flickr.com/assets/client-code.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc2" name="tochypothesis" id="tochypothesis"&gt;Hypothesis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This approach sounds compelling but I had my doubts. I also had my doubts about the adequacy of both my code and tests. A perfect opportunity, then, to try out &lt;a href="https://hypothesis.readthedocs.io/en/latest/"&gt;Hypothesis&lt;/a&gt;, an open source property-based testing library developed by David MacIver.
&lt;/p&gt;
&lt;p&gt;I used the Python version of the library, which is the primary implementation. The rest of this article describes my experience of using &lt;a href="https://hypothesis.readthedocs.io/en/latest/"&gt;hypothesis&lt;/a&gt; for the first time: I&amp;#8217;m not claiming expertise.
&lt;/p&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc3" name="tocfirst-impressions" id="tocfirst-impressions"&gt;First impressions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Excellent!
&lt;/p&gt;
&lt;p&gt;Installation was the usual &lt;code&gt;pip&lt;/code&gt; invocation. The &lt;a href="https://hypothesis.readthedocs.io/en/latest/"&gt;documentation&lt;/a&gt; is written with care. It&amp;#8217;s evident the library is mature, supported and actively developed. It&amp;#8217;s licensed under the &lt;a href="https://www.mozilla.org/en-US/MPL/2.0/"&gt;Mozilla Public License&lt;/a&gt;.
&lt;/p&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc4" name="tocmy-first-test" id="tocmy-first-test"&gt;My first test&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Recall that the code I wanted to test reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def chunk(xs, n):
    '''Split the list, xs, into n evenly sized chunks'''
    L = len(xs)
    assert 0 &amp;lt; n &amp;lt;= L
    s, r = divmod(L, n)
    t = s + 1
    return ([xs[p:p+t] for p in range(0, r*t, t)] +
            [xs[p:p+s] for p in range(r*t, L, s)])

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I also proposed a second &lt;code&gt;itertools&lt;/code&gt; based version:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import accumulate, chain, repeat, tee

def chunk(xs, n):
    '''Split the list, xs, into n evenly sized chunks'''
    assert n &amp;gt; 0
    L = len(xs)
    s, r = divmod(L, n)
    widths = chain(repeat(s+1, r), repeat(s, n-r))
    offsets = accumulate(chain((0,), widths))
    b, e = tee(offsets)
    next(e)
    return [xs[s] for s in map(slice, b, e)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The first thing you notice when thinking about a property based test is that the specification &amp;#8212; the function&amp;#8217;s docstring &amp;#8212; doesn&amp;#8217;t describe the exact form of the output. In fact, as a comment on the article pointed out, my own interpretation of the specification is not the only one, and allowing the chunks to be formed from non-contiguous items permits a particularly elegant solution.
&lt;/p&gt;
&lt;p&gt;Also, if the list doesn&amp;#8217;t divide exactly into &lt;code&gt;n&lt;/code&gt; chunks, what should the result be? Well, although I&amp;#8217;d have been happy with any evenly-chunked solution, my conventional unit tests &lt;strong&gt;assumed&lt;/strong&gt; an implementation which placed the larger chunks first.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def test_chunk():
    assert chunk('', 1) == ['']
    assert chunk('ab', 2) == ['a', 'b']
    assert chunk('abc', 2) == ['ab', 'c']
    
    xs = list(range(8))
    assert chunk(xs, 2) == [[0, 1, 2, 3], [4, 5, 6, 7]]
    assert chunk(xs, 3) == [[0, 1, 2], [3, 4, 5], [6, 7]]
    assert chunk(xs, 5) == [[0, 1], [2, 3], [4, 5], [6], [7]]
    
    rs = range(1000000)
    assert chunk(rs, 2) == [range(500000), range(500000, 1000000)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Notice, by the way, that although the docstring only mentions lists, I can&amp;#8217;t resist demonstrating the algorithm also behaves for strings and ranges &amp;#8212; for any sliceable sequence, in fact.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s what I started with when I tried specifying the &amp;#8220;evenly sized&amp;#8221; property using hypothesis.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def test_evenly_chunked(xs, n):
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert len(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This first test case defines &amp;#8220;evenly sized&amp;#8221;, stating that the result comprises &lt;code&gt;n&lt;/code&gt; chunks, that the set of the lengths of these chunks is either 1 (all chunks the same size) or 2, and the maximum chunk length is equal to or one more than the minumum chunk length.
&lt;/p&gt;
&lt;p&gt;This doesn&amp;#8217;t fully specify the function. We also need assertions which confirm that recombining the chunks produces the original sequence.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def test_combining_chunks(xs_n):
    pass # We'll come back to this!

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We&amp;#8217;ll come back to this later!
&lt;/p&gt;
&lt;p&gt;Now, &lt;code&gt;test_evenly_chunked()&lt;/code&gt; looks quite like a conventional test function. It just needs some input values. Rather than poke the function with some hand-chosen values, we can let hypothesis have a go.
&lt;/p&gt;
&lt;p&gt;Based on a read of the &lt;a href="https://hypothesis.readthedocs.io/en/latest/quickstart.html"&gt;Quick start guide&lt;/a&gt; I tried this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import hypothesis as ht
import hypothesis.strategies as st

@ht.given(xs=st.lists(), n=st.integers())
def test_evenly_chunked(xs, n):
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert len(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As you can see, the test function pre-conditions are encapsulated in a &lt;code&gt;hypothesis.given&lt;/code&gt; decorator, which specifies the use of &lt;code&gt;hypothesis.strategies.lists()&lt;/code&gt; and &lt;code&gt;hypothesis.strategies.integers()&lt;/code&gt; to generate test values for &lt;code&gt;xs&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; respectively.
&lt;/p&gt;
&lt;p&gt;The result was a lengthy but helpful failure, which printed out the documentation of the &lt;code&gt;lists()&lt;/code&gt; strategy and the usage error:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;hypothesis.errors.InvalidArgument: Cannot create non-empty lists without an element type

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;OK then. The function doesn&amp;#8217;t really care about the element type. Integers will do.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@ht.given(xs=st.lists(st.integers()), n=st.integers())
def test_evenly_chunked(xs, n):
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This gave me an error, along with a minimal test case which produces it.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;xs = [], n = 0

def chunk(xs, n):
        '''Split the list, xs, into n evenly sized chunks'''
        L = len(xs)
&amp;gt;       assert 0 &amp;lt; n &amp;lt;= L
E       AssertionError

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Our function, &lt;code&gt;chunk()&lt;/code&gt; requires the value &lt;code&gt;n&lt;/code&gt; to be in the closed range &lt;code&gt;(0, len(xs)]&lt;/code&gt;. Looking more closely at the failure, we can see that the function under test, &lt;code&gt;chunk()&lt;/code&gt;, isn&amp;#8217;t great, since we won&amp;#8217;t be able to split an empty list into &lt;strong&gt;any&lt;/strong&gt; number of chunks since, in this case, &lt;code&gt;L&lt;/code&gt; is zero and no value of &lt;code&gt;n&lt;/code&gt; satisfies &lt;code&gt;0 &amp;lt; n &amp;lt;= L&lt;/code&gt;. 
&lt;/p&gt;
&lt;p&gt;At this point I had to makes some choices:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     should my tests confirm &lt;code&gt;chunk()&lt;/code&gt; was checking pre-conditions (by catching the &lt;code&gt;AssertionError&lt;/code&gt;)?
 &lt;/li&gt;

 &lt;li&gt;
     should my function handle the case when &lt;code&gt;n &amp;gt; L&lt;/code&gt;? It&amp;#8217;s not the intended use of the function, but it can be handled.
 &lt;/li&gt;

 &lt;li&gt;
     what about when &lt;code&gt;n == 0&lt;/code&gt;? Splitting a non-empty list into &lt;code&gt;0&lt;/code&gt; chunks is impossible, but I guess an empty list can be split into &lt;code&gt;0&lt;/code&gt; chunks.
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc5" name="tocmy-second-test" id="tocmy-second-test"&gt;My second test&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I made some decisions.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     I decided not to test the pre-condition assertions. Instead, I&amp;#8217;d modify the test strategy to pass in valid inputs.
 &lt;/li&gt;

 &lt;li&gt;
     I decided I&amp;#8217;d go with the &lt;code&gt;itertools&lt;/code&gt; chunk function which naturally handles &lt;code&gt;n &amp;gt; L&lt;/code&gt;.
 &lt;/li&gt;

 &lt;li&gt;
     I decided my function needn&amp;#8217;t handle &lt;code&gt;n == 0&lt;/code&gt;, even when &lt;code&gt;xs == []&lt;/code&gt;.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here&amp;#8217;s the modified test code
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@ht.given(xs=st.lists(st.integers()),
          n=st.integers(min_value=1))
def test_evenly_chunked(xs, n):
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert len(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;When I tried running the tests again, they appeared to hang until I interrupted them.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt; py.test
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.0.7, py-1.4.33, pluggy-0.4.0
....
plugins: hypothesis-3.8.3
collected 1 items

test_chunk.py   C-c C-c

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
to show a full traceback on KeyboardInterrupt use --fulltrace

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now, I had a suspicion that &lt;code&gt;chunk()&lt;/code&gt; couldn&amp;#8217;t really handle &lt;strong&gt;any&lt;/strong&gt; input integers &amp;#8212; it was designed for a value of &lt;code&gt;n&lt;/code&gt; equal to &lt;code&gt;multiprocessing.cpu_count()&lt;/code&gt; &amp;#8212; but I wanted to see what would happen with no upper limits. Here was my answer. Running and interrupting again with &lt;code&gt;--fulltrace&lt;/code&gt; set, I got several pages of output ending with the test inputs:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;xs = [50], n = 67108865

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Evidently my code was taking a while to create a list comprising a single list &lt;code&gt;[50]&lt;/code&gt; and over 67 million empty lists &lt;code&gt;[], [], [], ...&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Once again, I had a decision to make. Perhaps unsurprisingly, it&amp;#8217;s a decision I&amp;#8217;d already faced. I could make &lt;code&gt;chunk()&lt;/code&gt; a generator function, yielding the chunks one at a time &amp;#8212; a trivial and natural change to the &lt;code&gt;itertools&lt;/code&gt; based implementation &amp;#8212; or I could constrain the tests to more suitable values of &lt;code&gt;n&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;In this case I decided to stick with what I had: my function would accept a list and return a list (of lists). In an attempt to get some passing tests, I set a maximum value on &lt;code&gt;n&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@ht.given(xs=st.lists(st.integers()),
          n=st.integers(min_value=1, max_value=100))
def test_evenly_chunked(xs, n):
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;At last, I had a passing test.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;py.test 
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.0.7, py-1.4.33, pluggy-0.4.0
rootdir: /work/sliced-python, inifile:
plugins: hypothesis-3.8.3
collected 1 items

test_chunk.py .

========================== 1 passed in 0.23 seconds ===========================

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Building on this success, I wanted to confirm the function also handled other sliceable types &amp;#8212; strings and bytes specifically. Hypothesis provides a &lt;code&gt;one_of&lt;/code&gt; strategy for combining other strategies.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@ht.given(xs=st.one_of(st.text(),
                       st.binary(),
                       st.lists(st.integers())),
          n=st.integers(min_value=1, max_value=100))
def test_evenly_chunked(xs, n):
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert len(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Again, the test passes.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;py.test
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.0.7, py-1.4.33, pluggy-0.4.0
rootdir: /work/sliced-python, inifile:
plugins: hypothesis-3.8.3
collected 1 items

test_chunk.py .

========================== 1 passed in 0.30 seconds ===========================

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This output is rather inscrutable. Generally, passing tests shouldn&amp;#8217;t draw attention to themselves, but what inputs had my test strategies generated? Were they sufficient?
&lt;/p&gt;
&lt;p&gt;A commandline switch provides a little more detail.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;py.test --hypothesis-show-statistics

....

test_chunk.py::test_evenly_chunked:

- 200 passing examples, 0 failing examples, 0 invalid examples
  - Typical runtimes: &amp;lt; 1ms
  - Stopped because settings.max_examples=200

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s also possible to peek at examples produced by the test strategy.
&lt;/p&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; s=st.one_of(st.text(), st.binary(), st.lists(st.integers()))
&amp;gt;&amp;gt;&amp;gt; s.example()
b''
&amp;gt;&amp;gt;&amp;gt; s.example()
b'\xc2\xfd6['
&amp;gt;&amp;gt;&amp;gt; s.example()
':\n&amp;uacute;&amp;amp;\U000ea7e8'
&amp;gt;&amp;gt;&amp;gt; s.example()
b'\xe7z'
&amp;gt;&amp;gt;&amp;gt; s.example()
''
&amp;gt;&amp;gt;&amp;gt; s.example()
[184, 36, -205, 1486638017]
&lt;/pre&gt;


&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc6" name="toccomplete-test-suite" id="toccomplete-test-suite"&gt;Complete test suite&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here&amp;#8217;s my final test suite. Rather than hard code a maximum value for &lt;code&gt;n&lt;/code&gt;, I used a &lt;a href="https://hypothesis.readthedocs.io/en/latest/data.html#composite-strategies"&gt;composite strategy&lt;/a&gt; which adapts &lt;code&gt;n&lt;/code&gt; to the size of &lt;code&gt;xs&lt;/code&gt;. I&amp;#8217;ve also added a test which confirms the result does comprise chunks of the input sequence.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import functools

import hypothesis as ht
import hypothesis.strategies as st

@st.composite
def items_and_chunk_count(draw):
    xs = draw(st.one_of(st.text(),
                        st.binary(),
                        st.lists(st.integers())))
    n = draw(st.integers(min_value=1,
                         max_value=max(1, len(xs))))
    return xs, n

@ht.given(xs_n=items_and_chunk_count())
def test_evenly_chunked(xs_n):
    '''Verify there are n evenly sized chunks'''
    xs, n = xs_n
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert len(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}

@ht.given(xs_n=items_and_chunk_count())
def test_combining_chunks(xs_n):
    '''Verify recombining the chunks reproduces the original sequence.'''
    xs, n = xs_n
    chunks = chunk(xs, n)
    assert functools.reduce(lambda x, y: x+y, chunks) == xs

&lt;/pre&gt;

&lt;/div&gt;


&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc7" name="tocquality-of-failure" id="tocquality-of-failure"&gt;Quality of failure&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the comments to my original article Mike Edey put forward an elegant solution to the original problem of evenly subdividing a sequence into an exact number of chunks:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def chunk(xs, n):
    return [xs[index::n] for index in range(n)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This is a delightful piece piece of code, and an approach I simply hadn&amp;#8217;t considered. If the input list &lt;code&gt;xs&lt;/code&gt; represents a number of tasks to be distributed amongst &lt;code&gt;n&lt;/code&gt; workers, this does the job evenly. In my actual motivating example, though, however, the input sequence was a document which caused a problem, and what I wanted to do was split that document up into a number of sections and see which of these exhibited the same problem: that is, I needed the chunks to be contiguous blocks of text from the original document. This is the property which &lt;code&gt;test_combining_chunks()&lt;/code&gt; checks.
&lt;/p&gt;
&lt;p&gt;Running Mike Edey&amp;#8217;s implementation through the test suite, we get:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;py.test
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.0.7, py-1.4.33, pluggy-0.4.0
rootdir: /work/sliced-python, inifile:
plugins: hypothesis-3.8.3
collected 2 items

test_chunk.py .F

================================== FAILURES ===================================
____________________________ test_combining_chunks ____________________________

@ht.given(xs_n=items_and_chunk_count())
&amp;gt;   def test_combining_chunks(xs_n):

test_chunk.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
d:\venvs\slackbot\lib\site-packages\hypothesis\core.py:634: in wrapped_test
    state.run()
d:\venvs\slackbot\lib\site-packages\hypothesis\core.py:531: in run
    print_example=True, is_final=True
d:\venvs\slackbot\lib\site-packages\hypothesis\executors.py:58: in default_new_style_executor
    return function(data)
d:\venvs\slackbot\lib\site-packages\hypothesis\core.py:113: in run
    return test(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

xs_n = ('001', 2)

@ht.given(xs_n=items_and_chunk_count())
    def test_combining_chunks(xs_n):
        '''Verify recombining the chunks reproduces the original sequence.'''
        xs, n = xs_n
        chunks = chunk(xs, n)
&amp;gt;       assert functools.reduce(lambda x, y: x+y, chunks) == xs
E       AssertionError: assert '010' == '001'
E         - 010
E         + 001

test_chunk.py:33: AssertionError
--------------------------------- Hypothesis ----------------------------------
Falsifying example: test_combining_chunks(xs_n=('001', 2))
===================== 1 failed, 1 passed in 0.52 seconds ======================

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Hypothesis has discovered a minimal failing example: the string &lt;code&gt;001&lt;/code&gt; splits into &lt;code&gt;2&lt;/code&gt; chunks as &lt;code&gt;01&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;.
&lt;/p&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc8" name="tocconclusions" id="tocconclusions"&gt;Conclusions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Hypothesis worked well for this particular example.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     it forced me to pin down the function specification
 &lt;/li&gt;

 &lt;li&gt;
     I had to consider the special cases: would the function behave in the face of logically permissable inputs, and not just the ones I had in mind when I wrote it
 &lt;/li&gt;

 &lt;li&gt;
     it increased my confidence the function was correct
 &lt;/li&gt;

 &lt;li&gt;
     and particularly appealing, in this case &amp;#8212; the tests were not tied to a detail of the implementation, and would continue to work if, for example, the larger chunks were to appear at the end of the results.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More generally, I found the hypothesis library solid. It&amp;#8217;s well designed and documented, as well as being a fine example of how to use Python decorators.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;d say property based testing complements example based testing. Example based unit tests show you how a function is used, for instance; with hypothesis, this useful demonstration happens behind the scenes (though note that your hypothesis tests &lt;strong&gt;can&lt;/strong&gt; include explicit &lt;a href="https://hypothesis.readthedocs.io/en/latest/details.html#providing-explicit-examples"&gt;@examples&lt;/a&gt;). Example based unit tests are typically one or two orders of magnitude quicker to execute. It&amp;#8217;s not a problem if a couple of tests take half a second to run, but what if you have a couple of thousand tests?
&lt;/p&gt;
&lt;p&gt;In my case the built-in strategies were good enough to generate inputs to my function. I can imagine that&amp;#8217;s not the case for functions higher up a software stack. Test setup functions can be hard work and I suspect test setup strategies would be harder.
&lt;/p&gt;
&lt;p&gt;In closing, I&amp;#8217;d like to quote from the section of the &lt;a href="https://hypothesis.readthedocs.io/en/latest/manifesto.html"&gt;Hypothesis documentation&lt;/a&gt; which describes its purpose.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Software is, as they say, eating the world. Software is also &lt;a href="https://www.youtube.com/watch?v=csyL9EC0S0c"&gt;terrible&lt;/a&gt;. It&amp;#8217;s buggy, insecure and generally poorly thought out. This combination is clearly a recipe for disaster.
&lt;/p&gt;
&lt;p&gt;And the state of software testing is even worse. Although it&amp;#8217;s fairly uncontroversial at this point that you should be testing your code, can you really say with a straight face that most projects you&amp;#8217;ve worked on are adequately tested?
&lt;/p&gt;
&lt;p&gt;A lot of the problem here is that it&amp;#8217;s too hard to write good tests. Your tests encode exactly the same assumptions and fallacies that you had when you wrote the code, so they miss exactly the same bugs that you missed when you wrote the code.
&lt;/p&gt;
&lt;p&gt;&amp;#8212; &lt;a href="https://hypothesis.readthedocs.io/en/latest/manifesto.html"&gt;The Purpose of Hypothesis&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;</description>
<dc:date>2017-05-29</dc:date>
<guid>http://wordaligned.org/articles/unleash-the-test-army</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/unleash-the-test-army</link>
<category>Tests</category>
</item>

<item>
<title>Unit Tests Questioned: Reading List</title>
<description>&lt;p&gt;I enjoyed &lt;a href="http://swanseasdc.co.uk/events/why-service-oriented-architecture/"&gt;talking about unit testing&lt;/a&gt; last night, and would like to thank &lt;a href="https://twitter.com/SwanseaSDC"&gt;Swansea Software Development Community&lt;/a&gt; and especially Viv Richards for organising the event, &lt;a href="https://swansea.techhub.com/"&gt;TechHub&lt;/a&gt; for the venue, and everyone who turned up to listen, ask questions and offer feedback.
&lt;/p&gt;
&lt;div&gt;&lt;blockquote class="twitter-tweet" data-lang="en"&gt;&lt;p lang="en" dir="ltr"&gt;Up first &lt;a href="https://twitter.com/thomasguest"&gt;@thomasguest&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/ssdc?src=hash"&gt;#ssdc&lt;/a&gt; &lt;a href="https://t.co/4nEqh0ErZr"&gt;pic.twitter.com/4nEqh0ErZr&lt;/a&gt;&lt;/p&gt;&amp;mdash; SSDC (@SwanseaSDC) &lt;a href="https://twitter.com/SwanseaSDC/status/826137883341885441"&gt;January 30, 2017&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="http://wordaligned.org//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/div&gt;

&lt;p&gt;The slides are available &lt;a href="http://wordaligned.org/docs/unit-tests"&gt;here&lt;/a&gt;. You&amp;#8217;ll find links in the slide deck to the various papers and articles I referenced, but for convenience I&amp;#8217;m listing them here with some notes.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;&lt;big&gt;&lt;a href="http://www.gwern.net/docs/1996-hoare.pdf" title="Tony Hoare, How Did Software Get So Reliable Without Proof? (PDF)"&gt;How Did Software Get So Reliable Without Proof?&lt;/a&gt;&lt;/big&gt; by Sir Tony Hoare, published in 1996, is a considered and authoritative paper, in which the author calls into question much of his own research. It&amp;#8217;s not necessary to prove your programs correct, he writes, you can create systems which are both large and reliable using more pragmatic techniques. Since then, his conviction has strengthened. I had the privilege of attending his keynote at &lt;a href="http://wordaligned.org/articles/europython-2009"&gt;Europython 2009&lt;/a&gt;, when he spoke about the science of computing and the engineering of software (this same talk is available on &lt;a href="https://www.infoq.com/presentations/tony-hoare-computing-engineering"&gt;InfoQ&lt;/a&gt;). His closing slide stated: One day, software will be the most reliable component of every product which contains it; and software engineering will be the most dependable of all engineering professions.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;&lt;big&gt;&lt;a href="http://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf" title="Why Most Unit Testing is Waste (PDF)"&gt;Why Most Unit Testing is Waste&lt;/a&gt;&lt;/big&gt; by James O Coplien calls out the unit testing zealots and makes the point that testers should be skeptical.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;&lt;big&gt;&lt;a href="http://www.sqlite.org/testing.html" title="How SQLite Is Tested"&gt;How SQLite Is Tested&lt;/a&gt;&lt;/big&gt; details what it takes to make bomb-proof software. Most of the tests described are system level tests. It&amp;#8217;s an impressive document which proves that writing tests requires creativity, determination and maybe even a sprinkling of malice.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;&lt;big&gt;&lt;a href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html" title="Flaky Tests at Google and How We Mitigate Them, John Micco"&gt;Flaky Tests at Google and How We Mitigate Them&lt;/a&gt;&lt;/big&gt; is an honest and all too familiar tale of unreliable tests. However hard you try to eradicate test instabilities, it seems they creep back in at the same rate.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;&lt;big&gt;&lt;a href="https://martinfowler.com/articles/testing-culture.html" title="Goto Fail, Heartbleed, and Unit Testing Culture"&gt;Goto Fail, Heartbleed, and Unit Testing Culture&lt;/a&gt;&lt;/big&gt; argues unit tests would have trapped some notorious bugs in low level security software. It goes on to describe in detail the changing culture of the Google Web Server team, which successfully adopted a test-focused regime. There&amp;#8217;s some good advice on de-flaking, so I hope the author connected with his suffering colleagues.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;&lt;big&gt;&lt;a href="https://staff.fnwi.uva.nl/p.vanemdeboas/knuthnote.pdf" title="The correspondence between Donald E. Knuth and Peter van Emde Boas on priority deques during the spring of 1977"&gt;The correspondence between Donald E. Knuth and Peter van Emde Boas on priority deques during the spring of 1977&lt;/a&gt;&lt;/big&gt; provides the background and context of Donald Knuth&amp;#8217;s famous quotation, &amp;#8220;Beware of bugs in the above code; I have only proved it correct, not tried it&amp;#8221;. It&amp;#8217;s a a witty admonition but Donald Knuth isn&amp;#8217;t joking. Don&amp;#8217;t trust code until you&amp;#8217;ve run it. Better, run it repeatedly through automated tests.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;</description>
<dc:date>2017-02-01</dc:date>
<guid>http://wordaligned.org/articles/unit-tests-questioned-reading-list</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/unit-tests-questioned-reading-list</link>
<category>Tests</category>
</item>

<item>
<title>Unit Tests Questioned</title>
<description>&lt;p&gt;I&amp;#8217;m looking forward to &lt;a href="http://swanseasdc.co.uk/events/why-service-oriented-architecture/"&gt;talking at TechHub Swansea&lt;/a&gt; at the end of the month on the subject of unit testing. 
&lt;/p&gt;
&lt;p&gt;The introduction to the talk is here. 
&lt;/p&gt;
&lt;p&gt;Hope to see you there.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/docs/unit-tests/"&gt;&lt;img width=640 src="http://wordaligned.org/images/unit-tests-questioned.png" alt="Unit Tests Questioned"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;In this talk we&amp;#8217;ll consider if unit testing is a good use of our time.
&lt;/p&gt;
&lt;p&gt;I am not questioning whether &lt;strong&gt;testing&lt;/strong&gt; is important. This slide shows the abstract of &lt;a href="http://www.gwern.net/docs/1996-hoare.pdf" title="(PDF) How did software get so reliable without proof?"&gt;a paper published in 1996 by Tony Hoare&lt;/a&gt;. What he says is that you don&amp;#8217;t need to &lt;strong&gt;prove&lt;/strong&gt; your software works: you can make it so through design and review; by testing; and by good engineering.
&lt;/p&gt;
&lt;img width=640 src="http://wordaligned.org/docs/unit-tests/images/how-did-software-get-so-reliable.png" alt="How did software get so reliable without proof?"/&gt;

&lt;p&gt;This may no longer seem controversial or novel but maybe it was a surprising thing for Tony Hoare to say. After all, he invented &lt;a href="https://en.wikipedia.org/wiki/Quicksort"&gt;quicksort&lt;/a&gt; back in 1959, an algorithm which he &lt;strong&gt;proved&lt;/strong&gt; correct. He also proved how quickly it runs, and that &amp;#8212; in the general case &amp;#8212; it couldn&amp;#8217;t be beaten. Much of Hoare&amp;#8217;s subsequent research was dedicated to proving software works using techniques known as &lt;a href="https://en.wikipedia.org/wiki/Formal_methods" title="Formal Methods (Wikipedia)"&gt;formal methods&lt;/a&gt;. The idea is that you write a formal specification of what your program should do, and then you mathematically verify your code satisfies that specification. Surely nothing less is good enough for software which really is a matter of life and death: a life support system, or a device driver in a nuclear warhead, for example? Actually, no, he says in this paper, there are more pragmatic routes to reliable software.
&lt;/p&gt;
&lt;p&gt;So, the idea that you can build reliability via testing may once have seemed radical. It doesn&amp;#8217;t any more. Maybe, though, the conventional modern wisdom that &lt;strong&gt;unit tests&lt;/strong&gt; are a good thing should be questioned.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/docs/unit-tests/images/coplien.jpg" alt="Coplien" /&gt;

&lt;p&gt;James O Coplien voices a dissenting opinion in a more recent paper, &lt;a href="http://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf" title="(PDF) Why Most Unit Testing is Waste"&gt;&amp;#8220;Why most unit testing is waste&amp;#8221;&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s Cope on about!?
&lt;/p&gt;
&lt;p&gt;Such is the force of current thinking that even the title of this paper makes it seem like he&amp;#8217;s trolling. Having read the paper carefully, I don&amp;#8217;t think he is. That doesn&amp;#8217;t mean I agree with him, but I agree with his attitude:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;There&amp;#8217;s a lot of advice, but very little of it is backed either by theory, data, or even a model of why you should believe a given piece of advice. Good testing begs skepticism. Be skeptical of yourself: measure, prove, retry. Be skeptical of me for heaven&amp;#8217;s sake.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;So, this talk will do just that.
&lt;/p&gt;
&lt;p&gt;Unit tests: let&amp;#8217;s get skeptical!
&lt;/p&gt;</description>
<dc:date>2017-01-21</dc:date>
<guid>http://wordaligned.org/articles/unit-tests-questioned</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/unit-tests-questioned</link>
<category>Tests</category>
</item>

</channel>
</rss>
