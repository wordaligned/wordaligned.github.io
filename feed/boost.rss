<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Hiding iterator boilerplate behind a Boost facade</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocfilling-in-missing-methods-python" name="toc0" id="toc0"&gt;Filling in missing methods. Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocfilling-in-missing-methods-c" name="toc1" id="toc1"&gt;Filling in missing methods. C++&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocenter-boost-iterators" name="toc2" id="toc2"&gt;Enter Boost iterators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocusing-boostiteratorfacade" name="toc3" id="toc3"&gt;Using boost::iterator_facade&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toctemplates-and-traits" name="toc4" id="toc4"&gt;Templates and Traits&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocconstructors-destructors-and-operators" name="toc5" id="toc5"&gt;Constructors, destructors and operators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocwrinkles" name="toc6" id="toc6"&gt;Wrinkles&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocless-code-more-software" name="toc7" id="toc7"&gt;Less code, more software&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocperformance" name="toc8" id="toc8"&gt;Performance&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;&lt;a href="http://www.flickr.com/photos/davehamster/2336911145/" title="SS Great Britain by Dave Hamster, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2379/2336911145_5275811ec0_m.jpg" width="240" height="160" alt="SS Great Britain"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc0" name="tocfilling-in-missing-methods-python" id="tocfilling-in-missing-methods-python"&gt;Filling in missing methods. Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s another wholesome &lt;a href="http://code.activestate.com/recipes/576685" title="Total ordering class decorator, by Raymond Hettinger"&gt;recipe&lt;/a&gt; served up by Raymond Hettinger.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Total ordering class decorator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def total_ordering(cls):
    'Class decorator that fills-in missing ordering methods'    
    convert = {
        '__lt__': [('__gt__', lambda self, other: other &amp;lt; self),
                   ('__le__', lambda self, other: not other &amp;lt; self),
                   ('__ge__', lambda self, other: not self &amp;lt; other)],
        '__le__': [('__ge__', lambda self, other: other &amp;lt;= self),
                   ('__lt__', lambda self, other: not other &amp;lt;= self),
                   ('__gt__', lambda self, other: not self &amp;lt;= other)],
        '__gt__': [('__lt__', lambda self, other: other &amp;gt; self),
                   ('__ge__', lambda self, other: not other &amp;gt; self),
                   ('__le__', lambda self, other: not self &amp;gt; other)],
        '__ge__': [('__le__', lambda self, other: other &amp;gt;= self),
                   ('__gt__', lambda self, other: not other &amp;gt;= self),
                   ('__lt__', lambda self, other: not self &amp;gt;= other)]
    }
    roots = set(dir(cls)) &amp;amp; set(convert)
    assert roots, 'must define at least one ordering operation: &amp;lt; &amp;gt; &amp;lt;= &amp;gt;='
    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__
    for opname, opfunc in convert[root]:
        if opname not in roots:
            opfunc.__name__ = opname
            opfunc.__doc__ = getattr(int, opname).__doc__
            setattr(cls, opname, opfunc)
    return cls

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If you have a class, &lt;code&gt;X&lt;/code&gt;, which implements one or more of the ordering operators, &lt;code&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; then &lt;code&gt;total_ordering(X)&lt;/code&gt; adapts and returns the class with the missing operators filled-in. Alternatively, use standard decorator syntax to adapt a class. If we apply &lt;code&gt;@total_ordering&lt;/code&gt; to a &lt;code&gt;Point&lt;/code&gt; class
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@total_ordering
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __lt__(self, other):
        return (self.x, self.y) &amp;lt; (other.x, other.y)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;then we can compare points however we like
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; p = Point(1,2)
&amp;gt;&amp;gt;&amp;gt; q = Point(1,3)
&amp;gt;&amp;gt;&amp;gt; p &amp;lt; q, p &amp;gt; q, p &amp;gt;= q, p &amp;lt;= q
(True, False, False, True)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a nice touch: the freshly-baked methods even have documentation!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; help(Point)
Help on class Point in module __main__:

class Point
 |  Methods defined here:
 |  
 |  __ge__(self, other)
 |      x.__ge__(y) &amp;lt;==&amp;gt; x&amp;gt;=y
 |  
 |  __gt__(self, other)
 |      x.__gt__(y) &amp;lt;==&amp;gt; x&amp;gt;y
 |  
 |  __init__(self, x, y)
 |  
 |  __le__(self, other)
 |      x.__le__(y) &amp;lt;==&amp;gt; x&amp;lt;=y
 |  
 |  __lt__(self, other)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Writing class decorators may not be the first thing a new Python programmer attempts, but once you&amp;#8217;ve discovered the relationship between Python&amp;#8217;s special method names and the more familiar operator symbols, I think this recipe is remarkably straightforward.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;convert = {
    '__lt__': [('__gt__', lambda self, other: other &amp;lt; self),
               ('__le__', lambda self, other: not other &amp;lt; self),
               ('__ge__', lambda self, other: not self &amp;lt; other)],
    '__le__': [('__ge__', lambda self, other: other &amp;lt;= self),
               ('__lt__', lambda self, other: not other &amp;lt;= self),
               ('__gt__', lambda self, other: not self &amp;lt;= other)],
    '__gt__': [('__lt__', lambda self, other: other &amp;gt; self),
               ('__ge__', lambda self, other: not other &amp;gt; self),
               ('__le__', lambda self, other: not self &amp;gt; other)],
    '__ge__': [('__le__', lambda self, other: other &amp;gt;= self),
               ('__gt__', lambda self, other: not other &amp;gt;= self),
               ('__lt__', lambda self, other: not self &amp;gt;= other)]
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Before moving on to something more challenging, look again at one of the recipe&amp;#8217;s key ingredients, the &lt;code&gt;convert&lt;/code&gt; dict, which helps create the missing ordering functions from existing ones. As you can see, there&amp;#8217;s much repetition here, and plenty of opportunities for cut-and-paste errors.
&lt;/p&gt;
&lt;p&gt;This block of code is an example of what programmers term &lt;a href="http://en.wikipedia.org/wiki/Boilerplate_(text)#Boilerplate_code"&gt;boilerplate&lt;/a&gt;. By using the total ordering decorator, we can avoid boilerplating our own code.&lt;a id="fn1link" href="http://wordaligned.org/articles/boost-iterator-facade#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc1" name="tocfilling-in-missing-methods-c" id="tocfilling-in-missing-methods-c"&gt;Filling in missing methods. C++&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Python is dynamic and self-aware, happy to expose its internals for this kind of tinkering.  It takes real wizardry to achieve similar results with a &lt;a href="http://sites.google.com/site/steveyegge2/tour-de-babel" title="C++ is the dumbest language on earth ... doesn't know about itself. It is not introspective"&gt;less flexible language, such as C++&lt;/a&gt; &amp;#8212; but it can be done.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;In a &lt;a href="http://wordaligned.org/articles/binary-search-revisited.html"&gt;previous article&lt;/a&gt; we developed a random access file iterator in C++. At its heart, this iterator simply repositioned itself using file-seeks and dereferenced itself using file-reads. There wasn&amp;#8217;t much to it.
&lt;/p&gt;
&lt;p&gt;Unfortunately we had to fill-out the iterator with the various members required to make it comply with the standard random access iterator requirements (which was the whole point, since we wanted something we could use with standard binary search algorithms).
&lt;/p&gt;
&lt;p&gt;We had to expose standard typedefs:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef std::random_access_iterator_tag iterator_category;
typedef item value_type;
typedef std::streamoff difference_type;
typedef item * pointer;
typedef item &amp;amp; reference;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Worse, we had to implement a full set of comparison, iteration, step and access functions. Please, page down past the following code block! I only include it here so you can see how long it goes on for.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Iterator boilerplate&lt;/div&gt;

&lt;pre class="prettyprint"&gt;public: // Comparison
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }
    
    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }
    
    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }
    
public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }
    
    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }
    
    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }
    
    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }
    
public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }
    
    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }
    
    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }
    
    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }
    
public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return pos - other.pos;
    }
    
public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }

value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How tiresome! Most of these member functions are directly and unsurprisingly implemented in a standard way. It would be nice if we could write (and test!) what we actually needed to and have a decorator fill in the rest.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/chr1sp/3997724676/" title="Library - Ephesus by Chris. P, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2554/3997724676_bf73106637.jpg" width="500" height="334" alt="Library - Ephesus"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc2" name="tocenter-boost-iterators" id="tocenter-boost-iterators"&gt;Enter Boost iterators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Actually, we can! I&amp;#8217;m grateful to proggitor dzorz for &lt;a href="http://www.reddit.com/r/programming/comments/c8fsk/binary_search_revisited/c0quxr0"&gt;telling me how&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;A nicer solution would use boost::iterator_facade and just implement dereference, equal, increment, decrement, advance and distance_to.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Like many programmers I have mixed feelings about C++ &amp;#8212; when it&amp;#8217;s good it&amp;#8217;s very very good, but when it&amp;#8217;s bad it&amp;#8217;s horrid &amp;#8212; and these feelings are only amplified by the &lt;a href="http://www.boost.org" title="Boost library home page"&gt;Boost&lt;/a&gt; library. Boost is superb, so long as you stick to the good parts.
&lt;/p&gt;
&lt;p&gt;So which parts are good? It depends. On you, who you work with, and the platforms you&amp;#8217;re working on.
&lt;/p&gt;
&lt;p&gt;In my previous article I used an ingenious iterator adaptor from the &lt;a href="http://www.boost.org/doc/libs/release/libs/spirit/index.html"&gt;Boost.Spirit&lt;/a&gt; parser library to disastrous effect. If only I&amp;#8217;d looked a little more carefully I&amp;#8217;d have discovered something more useful in a more obvious place. &lt;a href="http://www.boost.org/doc/libs/release/libs/iterator/"&gt;Boost.Iterator&lt;/a&gt; could have helped.
&lt;/p&gt;
&lt;p&gt;As dzorz points out, &lt;code&gt;boost::iterator_facade&lt;/code&gt; can work with any C++ iterable. Implement whatever subset of 
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     dereference
 &lt;/li&gt;

 &lt;li&gt;
     equal
 &lt;/li&gt;

 &lt;li&gt;
     increment 
 &lt;/li&gt;

 &lt;li&gt;
     decrement
 &lt;/li&gt;

 &lt;li&gt;
     advance
 &lt;/li&gt;

 &lt;li&gt;
     distance_to
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;is appropriate and &lt;code&gt;iterator_facade&lt;/code&gt; will fill in the boilerplate required to standardise your iterator.
&lt;/p&gt;
&lt;p&gt;In our case, we&amp;#8217;ll need the full set. That&amp;#8217;s because we&amp;#8217;re after a random access iterator. Other iterators need rather less. Here&amp;#8217;s a &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#iterator-facade-requirements"&gt;table&lt;/a&gt; showing the relationship between core operations and iterator concepts.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#iterator-facade-requirements"&gt;&lt;img src="http://wordaligned.org/images/iterator-facade.png" alt="iterator_facade Core Operations"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc3" name="tocusing-boostiteratorfacade" id="tocusing-boostiteratorfacade"&gt;Using boost::iterator_facade&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href="http://www.boost.org/doc/libs/release/libs/iterator/"&gt;Boost.Iterator&lt;/a&gt; documentation is well-written but daunting. Read it from top-to bottom and you&amp;#8217;ll get:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     rationale and theory
 &lt;/li&gt;

 &lt;li&gt;
     plans for standardisation (which don&amp;#8217;t seem correct &lt;a id="fn2link" href="http://wordaligned.org/articles/boost-iterator-facade#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;)
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;usage notes&lt;/strong&gt;
 &lt;/li&gt;

 &lt;li&gt;
     some subtle points on the implementation and its predecessor
 &lt;/li&gt;

 &lt;li&gt;
     a namecheck for the curiously recurring template pattern
 &lt;/li&gt;

 &lt;li&gt;
     a fat reference section detailing the boilerplate which this library allows you to forget
 &lt;/li&gt;

 &lt;li&gt;
     a &lt;strong&gt;tutorial&lt;/strong&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&amp;#8217;re tempted to skip to the end of the page, you&amp;#8217;ll see this code block.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;boost/type_traits/is_convertible.hpp&amp;gt;
#include &amp;lt;boost/utility/enable_if.hpp&amp;gt;
  
  ....
  
private:
  struct enabler {};
  
public:
  template &amp;lt;class OtherValue&amp;gt;
  node_iter(
      node_iter&amp;lt;OtherValue&amp;gt; const&amp;amp; other
    , typename boost::enable_if&amp;lt;
          boost::is_convertible&amp;lt;OtherValue*,Value*&amp;gt;
        , enabler
      &amp;gt;::type = enabler()
  )
    : m_node(other.m_node) {}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;According to the surrounding documentation this is &amp;#8220;magic&amp;#8221;. I find it scary.
&lt;/p&gt;
&lt;p&gt;Luckily it turns out the library is straightforward to use. What you really want, as a newcomer, are the &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#usage"&gt;usage notes&lt;/a&gt; and the &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#tutorial-example"&gt;tutorial example&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;The tutorial walks through the process of skinning a singly-linked list with a forwards iterator facade. This is a different use case to ours: the tutorial shows a basic class which implements what it should, and the facade allows it to be treated as a forwards iterator. In our case we&amp;#8217;ve already created a full-blown random access iterator. We can retrospectively apply &lt;code&gt;iterator_facade&lt;/code&gt; to strip our class back to basics.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc4" name="toctemplates-and-traits" id="toctemplates-and-traits"&gt;Templates and Traits&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Where we had:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;typename item&amp;gt;
class text_file_iter
{
public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef item value_type;
    typedef std::streamoff difference_type;
    typedef item * pointer;
    typedef item &amp;amp; reference;
....
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We now need (my thanks here to Giuseppe for correcting the code I originally posted here):
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;typename value&amp;gt;
class text_file_iter
    : public boost::iterator_facade&amp;lt;
      text_file_iter&amp;lt;value&amp;gt;
    , value
    , std::random_access_iterator_tag
    , value
    , std::streamoff
    &amp;gt;
....
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Yes, the class accepts itself as a template parameter. That&amp;#8217;s the curious recursion.)
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc5" name="tocconstructors-destructors-and-operators" id="tocconstructors-destructors-and-operators"&gt;Constructors, destructors and operators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We still need iterator constructors and destructors &amp;#8212; these are unchanged &amp;#8212; but &lt;strong&gt;we can eliminate every single operator&lt;/strong&gt; shown in the &amp;#8220;Iterator boilerplate&amp;#8221; code block above.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s what we need instead, to ensure &lt;code&gt;iterator_facade&lt;/code&gt; can do its job. The &lt;code&gt;read()&lt;/code&gt; member function we had before doesn&amp;#8217;t need changing.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;    ....
private: // Everything Boost's iterator facade needs
    friend class boost::iterator_core_access;
    
    value dereference() const
    {
        return read();
    }
    
    bool equal(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    void increment()
    {
        advance(1);
    }
    
    void decrement()
    {
        advance(-1);
    }
    
    void advance(std::streamoff n)
    {
        in.seekg(n, std::ios_base::cur);
        pos = in.tellg();
    }
    
    std::streamoff distance_to(iter const &amp;amp; other) const
    {
        return other.pos - pos;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;And that really is all there is to it. I&amp;#8217;m impressed.
&lt;/p&gt;
&lt;p&gt;Notice, by the way, that &lt;code&gt;friend&lt;/code&gt; is used to expose the primitive, private member functions for use by the &lt;code&gt;boost::iterator_core_access&lt;/code&gt; class. This follows the example set by the tutorial. I&amp;#8217;ve written enough C and Python to question C++&amp;#8217;s sophisticated access rules &amp;#8212; you have &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt;, but that&amp;#8217;s &lt;strong&gt;still&lt;/strong&gt; not enough, so you need &lt;code&gt;friend&lt;/code&gt; declaration to cut through it all &amp;#8212; which tempts me to simply make &lt;code&gt;dereference()&lt;/code&gt;, &lt;code&gt;equal()&lt;/code&gt; etc. public, but then the facade wouldn&amp;#8217;t be a proper facade. Users should treat the final class exactly as they would any other random access iterator, and designating these members as &lt;code&gt;private&lt;/code&gt; means they&amp;#8217;ll have to.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc6" name="tocwrinkles" id="tocwrinkles"&gt;Wrinkles&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You&amp;#8217;ll notice the &lt;code&gt;dereference()&lt;/code&gt; member function has a &lt;code&gt;const&lt;/code&gt; signature. However, the &lt;code&gt;read()&lt;/code&gt; member function is non-const.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;    // Return the item at the current position
    value_type read()
    {
        value_type n = 0;
        
        // Reverse till we hit whitespace or the start of the file
        while (in &amp;amp;&amp;amp; !isspace(in.peek()))
        {
            in.unget();
        }
        in.clear();
        
        in &amp;gt;&amp;gt; n;
        return n;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;in&lt;/code&gt; is a data member of type &lt;code&gt;std::ifstream&lt;/code&gt;, and clearly the read call modifies it. That&amp;#8217;s what this alarming compiler error is trying to tell us.
&lt;/p&gt;
&lt;pre&gt;
boost_binary_search_text_file.cpp: In member function 'value text_file_iter&amp;lt;value&amp;gt;::read() const [with value = long long int]':
boost_binary_search_text_file.cpp:90:   instantiated from 'value text_file_iter&amp;lt;value&amp;gt;::dereference() const [with value = long long int]'
/opt/local/include/boost/iterator/iterator_facade.hpp:516:   instantiated from 'static typename Facade::reference boost::iterator_core_access::dereference(const Facade&amp;amp;) [with Facade = text_file_iter&amp;lt;long long int&amp;gt;]'
/opt/local/include/boost/iterator/iterator_facade.hpp:634:   instantiated from 'Reference boost::iterator_facade&amp;lt;I, V, TC, R, D&amp;gt;::operator*() const [with Derived = text_file_iter&amp;lt;long long int&amp;gt;, Value = long long int, CategoryOrTraversal = boost::random_access_traversal_tag, Reference = long long int, Difference = long long int]'
/usr/include/c++/4.2.1/bits/stl_algo.h:4240:   instantiated from 'bool std::binary_search(_ForwardIterator, _ForwardIterator, const _Tp&amp;amp;) [with _ForwardIterator = text_file_iter&amp;lt;long long int&amp;gt;, _Tp = main::number]'
boost_binary_search_text_file.cpp:203:   instantiated from here
boost_binary_search_text_file.cpp:174: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'typename std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::int_type std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::peek() [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
boost_binary_search_text_file.cpp:176: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;&amp;amp; std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::unget() [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
boost_binary_search_text_file.cpp:178: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'void std::basic_ios&amp;lt;_CharT, _Traits&amp;gt;::clear(std::_Ios_Iostate) [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
boost_binary_search_text_file.cpp:180: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;&amp;amp; std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::operator&amp;gt;&amp;gt;(long long int&amp;amp;) [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
&lt;/pre&gt;

&lt;p&gt;Related to this, the &lt;code&gt;Reference&lt;/code&gt; template parameter (shown in bold in the listing below) is actually a &lt;code&gt;value&lt;/code&gt;, rather than the (default) &lt;code&gt;value &amp;amp;&lt;/code&gt;. As we originally implemented it, our file iterator reads values lazily, only when clients request them. We have no reference to return.
&lt;/p&gt;
&lt;pre&gt;
template &amp;lt;typename value&amp;gt;
class text_file_iter
    : public boost::iterator_facade&amp;lt;
      text_file_iter&amp;lt;value&amp;gt;
    , value
    , std::random_access_iterator_tag
    , &lt;strong&gt;value&lt;/strong&gt;
    , std::streamoff
    &amp;gt;
};
&lt;/pre&gt;

&lt;p&gt;I faced a dilemma here. Either I could modify my original file iterator, including a current value data member, which I would take care to update every time we repositioned the file read position. Then our references could be real references and &lt;code&gt;read()&lt;/code&gt; would naturally be &lt;code&gt;const&lt;/code&gt;, simply returning a reference to this member. Or, I could make the &lt;code&gt;in&lt;/code&gt; input stream data member &lt;code&gt;mutable&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Mutable&lt;/code&gt; makes me uneasy for the same reason that &lt;code&gt;friend&lt;/code&gt; does &amp;#8212; if you can shake off the rigours of const-correctness so easily, then why bother with it? &amp;#8212; and for this reason the first option appealed. However, a read-only file is an unusual container: we do not change it, but we cannot supply const references to its elements without reading them in, and that will mean changes to the file input stream. The easier option, involving the smallest code change, was to make &lt;code&gt;in&lt;/code&gt; mutable. So that&amp;#8217;s what I did.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc7" name="tocless-code-more-software" id="tocless-code-more-software"&gt;Less code, more software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;By employing two of my least favourite C++ keywords I now had a class which provided the functions it should, and, thanks to the magic worked by Boost&amp;#8217;s iterator facade, I also had a class which I could use as a standard random access iterator. Most of the code changes were the deletion of boilerplate &amp;#8212; very satisfying. I added code too, since I decided to invest a little more effort in tests. I didn&amp;#8217;t have any doubts about the Boost library&amp;#8217;s correctness but I thought I might not have been using it correctly. Happily these tests all passed.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc8" name="tocperformance" id="tocperformance"&gt;Performance&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s not forget why we originally wanted a random access file iterator: we had a large sorted file, too large to read into memory, and we wanted to test for the presence of the number in this file.
&lt;/p&gt;
&lt;p&gt;For test purposes I created a file just over 4GB in size. A simple linear search through this file took around 180 seconds on my (aging laptop) computer, and was light on memory use. By creating a random access file iterator, boilerplate and all, we took advantage of the standard binary search algorithm and reduced the time to around 4 milliseconds.
&lt;/p&gt;
&lt;p&gt;How would our version using Boost iterator facade do? I wasn&amp;#8217;t expecting it to be faster than the original, but I wouldn&amp;#8217;t have been surprised if it gave it a close run: using Boost doesn&amp;#8217;t usually involve compromise. In fact, over repeated runs of my performance tests there was no significant difference between the two iterator versions &amp;#8212; or at least there wasn&amp;#8217;t once a helpful reader had discovered and fixed a bug in my program, which was causing it to run correctly but slowly.
&lt;/p&gt;
&lt;p&gt;To trust a facade I guess you need some knowledge of what lies behind it.
&lt;/p&gt;
&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: During my original performance tests, reported in the first version of this article, the Boost iterator performed woefully, far slower even than a linear search. By this time I&amp;#8217;d lost patience, and it was left up to a reader, Giuseppe, to &lt;a href="http://wordaligned.org/articles/boost-iterator-facade#comment-60988668"&gt;point out my mistake&lt;/a&gt;. I&amp;#8217;d been using a &lt;code&gt;boost::random_access_traversal_tag&lt;/code&gt; template parameter, with the result that &lt;code&gt;std::distance()&lt;/code&gt; was using repeated increments rather than calling &lt;code&gt;distance_to()&lt;/code&gt; to get an immediate result, and consequently ran very slowly. I should have used &lt;code&gt;std::random_access_iterator_tag&lt;/code&gt;. I modified my code accordingly and confirmed that the Boost version does indeed perform on a par with the original version.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;My thanks to &lt;a href="http://www.flickr.com/photos/chr1sp/" title="Chris. P on Flickr"&gt;Chris P&lt;/a&gt; for permission to use his &lt;a href="http://www.flickr.com/photos/chr1sp/3997724676"&gt;photograph&lt;/a&gt; of the &lt;a href="http://en.wikipedia.org/wiki/Library_of_Celsus" title="Library of Celsus, Wikipedia"&gt;Library of Celsus&lt;/a&gt; at Ephesus, or at rather its beautiful facade. Ephesus is famous for the Temple of Artemis, one of the seven wonders of the ancient world, of which only fragments remain. Thanks too to &lt;a href="http://www.flickr.com/photos/davehamster/"&gt;Dave Hamster&lt;/a&gt; for the boilerplate &lt;a href="http://www.flickr.com/photos/davehamster/2336911145/"&gt;photo&lt;/a&gt; &amp;#8212; actually a detail from the hull of the &lt;a href="http://www.ssgreatbritain.org"&gt;SS Great Britain&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;d like to continue this experiment the code and the tests I used are available via anonymous SVN access from &lt;a href="http://svn.wordaligned.org/svn/etc/search_text_file"&gt;http://svn.wordaligned.org/svn/etc/search_text_file&lt;/a&gt;.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/boost-iterator-facade#fn1link"&gt;[1]&lt;/a&gt;: As of Python 2.7 and 3.2, the standard library will include a version of this recipe. It&amp;#8217;s in the &lt;a href="http://docs.python.org/dev/py3k/library/functools.html#functools.total_ordering" title="functools.total_ordering decorator documentation"&gt;functools module&lt;/a&gt;. For some reason, your class &amp;#8220;should supply an __eq__()&amp;#8221; method.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/boost-iterator-facade#fn2link"&gt;[2]&lt;/a&gt;: According to the Boost.Iterator documentation:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Both &lt;code&gt;iterator_facade&lt;/code&gt; and &lt;code&gt;iterator_adaptor&lt;/code&gt; as well as many of the specialized adaptors mentioned below have been proposed for standardization, and accepted into the first C++ technical report; see our [Standard Proposal For Iterator Facade and Adaptor (PDF)][tr1proposal] for more details.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I assumed this meant there&amp;#8217;d be &lt;code&gt;tr1::iterator_(facade|adaptor)&lt;/code&gt; classes, but I don&amp;#8217;t think that&amp;#8217;s the case. Unlike other (good) bits of Boost, the Iterator library doesn&amp;#8217;t seem likely to be part of the next C++ release.
&lt;/p&gt;</description>
<dc:date>2010-07-07</dc:date>
<guid>http://wordaligned.org/articles/boost-iterator-facade</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/boost-iterator-facade</link>
<category>Boost</category>
</item>

<item>
<title>Elegance and Efficiency</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocwhat-is-elegant-code" name="toc0" id="toc0"&gt;What is Elegant Code?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocappearance" name="toc1" id="toc1"&gt;Appearance&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocuse-of-standard-libraries" name="toc2" id="toc2"&gt;Use of standard libraries&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocplanar-vectors-in-scheme" name="toc3" id="toc3"&gt;Planar vectors in Scheme&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocminimalism-and-simplicity" name="toc4" id="toc4"&gt;Minimalism and Simplicity&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocefficiency-and-elegance" name="toc5" id="toc5"&gt;Efficiency and Elegance?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocelegance-and-inefficiency" name="toc6" id="toc6"&gt;Elegance and Inefficiency?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocislipogram1" name="toc7" id="toc7"&gt;is_lipogram1&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocislipogram2--3" name="toc8" id="toc8"&gt;is_lipogram2 &amp;amp; 3&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocislipogram4" name="toc9" id="toc9"&gt;is_lipogram4&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocislipogram5" name="toc10" id="toc10"&gt;is_lipogram5&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocislipogram6" name="toc11" id="toc11"&gt;is_lipogram6&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocwinding-up" name="toc12" id="toc12"&gt;Winding Up&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#tocc-source-code" name="toc13" id="toc13"&gt;C++ Source Code&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;Elegant code is often efficient. Think of the heap data structure, for example, which always remains exactly as sorted as it needs to be, making it perfect for modelling priority queues. It&amp;#8217;s both elegant and efficient &amp;mdash; and dazzlingly so.
&lt;/p&gt;
&lt;img src="http://upload.wikimedia.org/wikipedia/commons/b/bf/Max-heap.png" width="50%" alt="Heap graphic"/&gt;

&lt;p&gt;This article discusses the relationship between elegance and efficiency in more depth, and asks the question: &lt;strong&gt;Can inefficient code ever be elegant?&lt;/strong&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc0" name="tocwhat-is-elegant-code" id="tocwhat-is-elegant-code"&gt;What is Elegant Code?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;First, we should consider what&amp;#8217;s meant by &amp;#8220;elegant code&amp;#8221;.
&lt;/p&gt;
&lt;p&gt;Anthony Williams discusses this very subject in a recent blog &lt;a href="http://www.justsoftwaresolutions.co.uk/design/elegance-in-software.html"&gt;post&lt;/a&gt; (which is what got me thinking about it in the first place). Up front he admits the search for elegance is subjective and that the factors he lists are all &lt;em&gt;&amp;#8220;my opinion&amp;#8221;&lt;/em&gt;. He also points out his list is not exhaustive. Nonetheless, it&amp;#8217;s a good starting point, and I&amp;#8217;d like to build on it. Let&amp;#8217;s start by summarising his list here.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Factors affecting the elegance of software
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Does it work?
 &lt;/li&gt;

 &lt;li&gt;
     Is it easy to understand?
 &lt;/li&gt;

 &lt;li&gt;
     Is it efficient?
 &lt;/li&gt;

 &lt;li&gt;
     Short functions
 &lt;/li&gt;

 &lt;li&gt;
     Good naming
 &lt;/li&gt;

 &lt;li&gt;
     Clear division of responsibility
 &lt;/li&gt;

 &lt;li&gt;
     High cohesion
 &lt;/li&gt;

 &lt;li&gt;
     Low coupling
 &lt;/li&gt;

 &lt;li&gt;
     Appropriate use of OO and other techniques
 &lt;/li&gt;

 &lt;li&gt;
     Minimal code
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc1" name="tocappearance" id="tocappearance"&gt;Appearance&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I&amp;#8217;m not sure this list completely nails elegance. For a start, there&amp;#8217;s no mention of appearance &amp;mdash; the way the code actually looks, on screen, or in print &amp;#8212; which in my opinion is fundamental. Elegant code looks clean, balanced, self-consistent.
&lt;/p&gt;
&lt;p&gt;&lt;span /&gt;That&amp;#8217;s one of the reasons I like Python: it&amp;#8217;s hard to get away with poorly laid out code. Scheme, with its minimal syntax, also wins here. Java stands a good chance of doing well on this front too, thanks to a clearly stated set of coding conventions and excellent IDE support for applying these conventions.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc2" name="tocuse-of-standard-libraries" id="tocuse-of-standard-libraries"&gt;Use of standard libraries&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I&amp;#8217;d also say that appropriate and even cunning use of the language&amp;#8217;s standard libraries can add to code&amp;#8217;s elegance. Williams hints at this with his mention of &lt;em&gt;Minimal Code&lt;/em&gt;, though minimalism covers many other things.
&lt;/p&gt;
&lt;p&gt;As an example, if you&amp;#8217;re using C++, you should take the time to become familiar with the standard library, and use it whenever possible. &lt;a href="http://www.artima.com/cppsource/lazy_builder.html"&gt;It works. It&amp;#8217;s efficient&lt;/a&gt;. In fact it embodies pretty much everything Williams lists, with a few notable exceptions (no one could describe &lt;code&gt;std::string&lt;/code&gt; as minimal, and &lt;code&gt;std::auto_ptr&lt;/code&gt; is notoriously slippery). Use the standard library and you&amp;#8217;ll save yourself code and time, and your own code will be the more elegant for it.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc3" name="tocplanar-vectors-in-scheme" id="tocplanar-vectors-in-scheme"&gt;Planar vectors in Scheme&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Let&amp;#8217;s return to Scheme to illustrate my point about cunning use of standard libraries and consider &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.46"&gt;exercise 2.46&lt;/a&gt; from the &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;Wizard Book&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;Exercise 2.46.&lt;/strong&gt;  A two-dimensional vector v running from the origin to a point can be represented as a pair consisting of an x-coordinate and a y-coordinate. Implement a data abstraction for vectors by giving a constructor make-vect and corresponding selectors xcor-vect and ycor-vect. In terms of your selectors and constructor, implement procedures add-vect, sub-vect, and scale-vect that perform the operations vector addition, vector subtraction, and multiplying a vector by a scalar.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;An obvious solution would be to model the 2-D vector as a pair.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;(define make-vect cons)
(define xcor-vect car)
(define ycor-vect cdr)

(define (add-vect v w)
  (make-vect (+ (xcor-vect v) (xcor-vect w))
             (+ (ycor-vect v) (ycor-vect w))))

(define (sub-vect v w)
  (make-vect (- (xcor-vect v) (xcor-vect w))
             (- (ycor-vect v) (ycor-vect w))))

(define (scale-vect s v)
  (make-vect (* s (xcor-vect v))
             (* s (ycor-vect v))))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;An elegant alternative builds on Scheme&amp;#8217;s support for complex numbers.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;;; represent 2-D vect using a complex number
(define make-vect make-rectangular)
(define xcor-vect real-part)
(define ycor-vect imag-part)

(define add-vect +)
(define sub-vect -)
(define scale-vect *)

;; some other vector operations come for free
(define magnitude-vect magnitude)
(define make-vect-from-polar-coords make-polar)
(define angle-vect angle)

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc4" name="tocminimalism-and-simplicity" id="tocminimalism-and-simplicity"&gt;Minimalism and Simplicity&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Elegance and beauty are not the same, though perhaps elegant forms a subset of beautiful. Elegance carries the additional connotation of simplicity, which itself correlates with minimalism. If I were forced to select the single item from Williams&amp;#8217; list most closely aligned to elegance, I&amp;#8217;d go for minimalism: allowed my own choice, it would be simplicity.
&lt;/p&gt;
&lt;p&gt;Williams notes a couple of ways you can remove to improve:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     avoid unnecessary layering 
 &lt;/li&gt;

 &lt;li&gt;
     eliminate duplication
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&amp;#8217;ve already added:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     use standard libraries
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kevlin Henney gives minimalism more careful attention in a series of &lt;a href="http://www.two-sdg.demon.co.uk/curbralan/papers.html"&gt;articles&lt;/a&gt;. &lt;a href="http://www.two-sdg.demon.co.uk/curbralan/papers/minimalism/OmitNeedlessCode.html"&gt;Omit Needless Code&lt;/a&gt; promotes:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Code that is simple and clear, brief and direct.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Henney illustrates his points with some elegant examples which reinforce my own claims about the C++ standard library
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;As an example, the common task of counting words in a text file or stream can be reduced to a single statement of executable C++ code &lt;a href="http://www.two-sdg.demon.co.uk/curbralan/papers/IfIHadAHammer.pdf"&gt;[Henney2001c]&lt;/a&gt; when built on the appropriate abstractions:&lt;/p&gt;
&lt;pre&gt;
typedef std::istream_iterator&amp;lt;std::string&amp;gt; in;
std::cout &amp;lt;&amp;lt; std::distance(in(std::cin), in());
&lt;/pre&gt;
&lt;p&gt;Want to count characters instead?&lt;/p&gt;
&lt;pre&gt;
typedef std::istreambuf_iterator&amp;lt;char&amp;gt; in;
std::cout &amp;lt;&amp;lt; std::distance(in(std::cin), in());
&lt;/pre&gt;
&lt;p&gt;Or lines?&lt;/p&gt;
&lt;pre&gt;
typedef std::istreambuf_iterator&amp;lt;char&amp;gt; in;
std::cout &amp;lt;&amp;lt; std::count(in(std::cin), in(), '\n');
&lt;/pre&gt;
&lt;p&gt;These fragments are all compact and fluffless, crisp and essential.&lt;/p&gt;&lt;/blockquote&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc5" name="tocefficiency-and-elegance" id="tocefficiency-and-elegance"&gt;Efficiency and Elegance?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Efficiency comes high on Williams&amp;#8217; list, right after correctness, which shouldn&amp;#8217;t be a surprise to anyone who writes code for a living. Surely code which doesn&amp;#8217;t run fast enough is about as useful as code which doesn&amp;#8217;t work? You could even note that efficiency is yet another aspect of minimalism: in this case, it&amp;#8217;s the machine&amp;#8217;s resource consumption you&amp;#8217;d like to reduce.
&lt;/p&gt;
&lt;img src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="Quicksort animation"/&gt;

&lt;p&gt;I&amp;#8217;m not convinced, though. It&amp;#8217;s true, many of the most elegant algorithms happen to be efficient too &amp;mdash; and may even have arisen from the quest for efficiency. Thus the standard quicksort algorithm has virtually no space overhead, and as a general purpose sorting algorithm, really can&amp;#8217;t be beaten. Similarly the &lt;a href="http://en.wikipedia.org/wiki/Heap_(data_structure)"&gt;heap&lt;/a&gt;, as already mentioned, is a lean clean implementation of a priority queue. But &lt;em&gt;&lt;/em&gt;I don&amp;#8217;t think elegance implies efficiency&lt;em&gt;&lt;/em&gt;. I&amp;#8217;d even suggest that something could be elegant but of no practical use, at least not on today&amp;#8217;s hardware.
&lt;/p&gt;
&lt;p&gt;The downside of efficiency is that it can be at odds with simplicity and minimalism. Consider the sad fate of &lt;code&gt;boost::lexical_cast&lt;/code&gt;, a general purpose conversion function. If I go back to early &lt;a href="http://www.boost.org"&gt;Boost&lt;/a&gt; releases I find code which reads like this.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Excerpt from lexical_cast.hpp, Boost 1.22&lt;/div&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Target, typename Source&amp;gt;
Target lexical_cast(Source arg)
{
# ifndef BOOST_NO_STRINGSTREAM
    std::stringstream interpreter;
# else
    std::strstream interpreter; // for out-of-the-box g++ 2.95.2
# endif
    Target result;
    
    if(!(interpreter &amp;lt;&amp;lt; arg) || !(interpreter &amp;gt;&amp;gt; result) ||
       !(interpreter &amp;gt;&amp;gt; std::ws).eof())
        throw bad_lexical_cast();
     return result;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;For brevity I&amp;#8217;ve omitted file headers, include guards and the unexceptional definition of &lt;code&gt;boost::bad_lexical_cast&lt;/code&gt;. Even with these present, the file runs to just 68 lines long, and provides an elegant example of what generic C++ code can do. The body of &lt;code&gt;lexical_cast&lt;/code&gt; itself is a readable one-liner, tainted only by a preprocessor workaround for non-compliant compilers. 
&lt;/p&gt;
&lt;p&gt;Wind forwards to 2007, and this small stain has spread across the entire &lt;a href="http://boost.cvs.sourceforge.net/boost/boost/boost/lexical_cast.hpp?revision=1.36&amp;amp;view=markup"&gt;library&lt;/a&gt;, which, after tuning for correctness, portability and &lt;strong&gt;efficiency&lt;/strong&gt; now weighs in at well over 1K lines of code. Here&amp;#8217;s a flavour of the latest greatest &lt;code&gt;lexical_cast&lt;/code&gt;, which is far too long to include in its entirety.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Excerpt from lexical_cast.hpp@1.36&lt;/div&gt;

&lt;pre class="prettyprint"&gt;namespace detail // lcast_put_unsigned
{
    // I'd personally put lcast_put_unsigned in .cpp file if not
    // boost practice for header-only libraries (Alexander Nasonov).
    template&amp;lt;typename T, typename CharT&amp;gt;
    CharT* lcast_put_unsigned(T n, CharT* finish)
    {
        CharT thousands_sep = 0;
#ifdef BOOST_LEXICAL_CAST_ASSUME_C_LOCALE
        char const* grouping = "";
        std::size_t const grouping_size = 0;
#else
        std::locale loc;
        typedef std::numpunct&amp;lt;CharT&amp;gt; numpunct;
        numpunct const&amp;amp; np = BOOST_USE_FACET(numpunct, loc);
        std::string const&amp;amp; grouping = np.grouping();
        std::string::size_type const grouping_size = grouping.size();    
        if(grouping_size)
            thousands_sep = np.thousands_sep();
#endif
        std::string::size_type group = 0; // current group number
        char last_grp_size = grouping[0] &amp;lt;= 0 ? CHAR_MAX : grouping[0];
        // a) Since grouping is const, grouping[grouping.size()] returns 0.
        // b) It's safe to assume here and below that CHAR_MAX
        //    is equivalent to unlimited grouping:
#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
        BOOST_STATIC_ASSERT(std::numeric_limits&amp;lt;T&amp;gt;::digits10 &amp;lt; CHAR_MAX);
#endif
        char left = last_grp_size;
        do
        {
            if(left == 0)
            {
                ++group;
                if(group &amp;lt; grouping_size)
                {
                    char const grp_size = grouping[group];
                    last_grp_size = grp_size &amp;lt;= 0 ? CHAR_MAX : grp_size;
                }
                left = last_grp_size;
                --finish;
                *finish = thousands_sep;
            }
            --left;
            --finish;
            int const digit = static_cast&amp;lt;int&amp;gt;(n % 10);
            int const cdigit = digit + lcast_char_constants&amp;lt;CharT&amp;gt;::zero;
            *finish = static_cast&amp;lt;char&amp;gt;(cdigit);
            n /= 10;
        } while(n);
    
        return finish;
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I&amp;#8217;m not saying that the changes to &lt;code&gt;boost::lexical_cast&lt;/code&gt; are &lt;em&gt;bad&lt;/em&gt;: after all, users of the library get software which does the right thing more often and more quickly &amp;mdash; all without any client-side changes. That&amp;#8217;s one of the benefits of using a layered software stack. Rather, I present this as an example of the tension between efficiency and elegance. Somewhere along the line, an elegant piece of code got buried.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s also interesting that, in this case, even &amp;#8220;does-it-work&amp;#8221; counteracts elegance. We noted that &lt;code&gt;boost::lexical_cast@v1.22&lt;/code&gt; became tainted in its eagerness to work with legacy compilers. The current version makes far greater concessions. It&amp;#8217;s a reminder &amp;mdash; as if any were needed &amp;mdash; that we programmers have to keep our feet on the ground and aim for pragmatic solutions. Perfection is rarely possible, elegance occasional.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc6" name="tocelegance-and-inefficiency" id="tocelegance-and-inefficiency"&gt;Elegance and Inefficiency?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We&amp;#8217;ve demonstrated the tension between elegance and efficiency, but could blatantly inefficient code ever claim to be elegant? The original elegant implementation of &lt;code&gt;lexical_cast&lt;/code&gt; may not have been optimally tuned for all possible inputs (it&amp;#8217;s meant to be generic code, after all), but it could hardly be described as inefficient.
&lt;/p&gt;
&lt;p&gt;We&amp;#8217;re going to develop some code which I&amp;#8217;ll claim is elegant despite being inefficient. To get us started, let&amp;#8217;s consider another problem we can skin in more than one way: &lt;strong&gt;how do we determine if a book forms a lipogram?&lt;/strong&gt; (A &lt;a href="http://phrontistery.info/lipogram.html"&gt;lipogram&lt;/a&gt; is a piece of text written avoiding the use of a particular character, the letter E for example, and &lt;a href="http://en.wikipedia.org/wiki/A_Void"&gt;full length books&lt;/a&gt; really have been written &amp;mdash; and even translated &amp;mdash; which adhere to this constraint.)
&lt;/p&gt;
&lt;p&gt;We&amp;#8217;ll pose the problem in C++. Here&amp;#8217;s the function prototype.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
    
typedef std::string word;
typedef std::vector&amp;lt;word&amp;gt; book;
    
// Return true if the input text avoids using any characters
// in 'avoid', false otherwise.
// Example call:
// bool const lipo = is_lipogram(text, "Ee");
bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;What we have here might be seen as a loop within a loop within a loop: for each word in the book, for each character in that word, check against each character in the string of characters to be avoided. A match against an avoided character means we know our book isn&amp;#8217;t a lipogram, and we can return false; but if we reach the end of our book without such a match, we can return true.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc7" name="tocislipogram1" id="tocislipogram1"&gt;is_lipogram1&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;We can code this up:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef word::const_iterator word_iter;
typedef book::const_iterator book_iter;
    
bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    // Handle edge case -- empty book
    if (text.empty())
    {
        return true;
    }
    // Handle edge case -- nothing to avoid
    if (avoid.empty())
    {
        return true;
    }
    for (book_iter w = text.begin(); w != text.end(); ++w)
    {
        for (word_iter c = w-&amp;gt;begin(); c != w-&amp;gt;end(); ++c)
        {
            for (word_iter a = avoid.begin(); a != avoid.end(); ++a)
            {
                if (*c == *a)
                {
                    return false;
                }
            }
        }
    }
    return true;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This painstaking chunk of code reads like a direct transcription of the way an unfortunate human proof-reader might approach the task, one finger tracking through the text, word by word, character by character, another finger repeatedly working through the characters to be avoided. It fails the elegance test on a number of counts:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     &lt;strong&gt;Not minimal&lt;/strong&gt;. The edge cases do not merit special treatment. Normal processing of the (nested) main loop handles empty inputs just fine.
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;Failure to use the standard library.&lt;/strong&gt; The &lt;code&gt;std::string&lt;/code&gt; class is big enough to support searches for characters in a string directly, allowing us to remove a couple of layers of nesting.
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;Clumsy&lt;/strong&gt;. The function has &lt;em&gt;four&lt;/em&gt; separate exit points.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Perhaps none of these charges seem too bad in such a small function, but small functions have a tendency to grow into larger ones, and &lt;span /&gt;flaws, in particular, scale rapidly.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc8" name="tocislipogram2--3" id="tocislipogram2--3"&gt;is_lipogram2 &amp;amp; 3&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Here&amp;#8217;s a standard-library-aware improvement.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    for (book_iter w = text.begin(); w != text.end(); ++w)
    {
        if (w-&amp;gt;find_first_of(avoid) != std::string::npos)
        {
            return false;
        }
    }
    return true;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Many programmers would leave it at that, but I still prefer to re-cast this particular variant as follows:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    book_iter w = text.begin();
    while (w != text.end() &amp;amp;&amp;amp;
           w-&amp;gt;find_first_of(avoid) == std::string::npos)
    {
        ++w;
    }
    return w == text.end();
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Rather than exit as soon as we detect a character in the &lt;code&gt;avoid&lt;/code&gt; string, we keep reading as long as there&amp;#8217;s text to read and we&amp;#8217;ve avoided such characters. There&amp;#8217;s not much in it, especially in such a small function, but my preference is to simplify the control flow.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc9" name="tocislipogram4" id="tocislipogram4"&gt;is_lipogram4&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;We can remove the explicit iteration from our code by using the &lt;code&gt;std::find_if&lt;/code&gt; algorithm, which accepts a predicate. In this case we want to find the first word which isn&amp;#8217;t itself a lipogram. Combining the &lt;code&gt;std::not1&lt;/code&gt; function adaptor with a hand-written class deriving from &lt;code&gt;std::unary_function&amp;lt;std::string const, bool&amp;gt;&lt;/code&gt; does the job.
&lt;/p&gt;
&lt;p&gt;This code demonstrates proper use of the STL predicates and adaptors, but it also reaches the limits of my personal comfort zone for using C++ in a functional programming style. The price paid for avoiding explicit iteration is just too high; clever though this code may be, I don&amp;#8217;t find it elegant. 
&lt;/p&gt;
&lt;p&gt;When I first coded up &lt;code&gt;lipogram_word_tester&lt;/code&gt;, it derived from &lt;code&gt;std::unary_function&amp;lt;word const &amp;amp;, bool&amp;gt;&lt;/code&gt;. This turns out to be wrong, or at least, it failed to compile with a typically cryptic diagnostic, and I&amp;#8217;m still not sure why!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;// Simple functor for use in lipogram algorithms
class lipogram_word_tester:
    public std::unary_function&amp;lt;word const, bool&amp;gt;
{
public:
    // Constructor. Caches a copy of the 'avoid' parameter.
    lipogram_word_tester(word const &amp;amp; avoid)
        : avoid(avoid)
    {
    }
    // Function operator returns true if the word being tested
    // omits characters from the 'avoid' string, false otherwise.
    bool operator()(word const &amp;amp; to_test) const
    {
        return to_test.find_first_of(avoid)
            == std::string::npos;
    }
private:
    // Private cache of characters to avoid.
    word const avoid;
};
    
bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    lipogram_word_tester const word_test(avoid);
    return find_if(text.begin(), text.end(),
                   not1(word_test)) == text.end();
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc10" name="tocislipogram5" id="tocislipogram5"&gt;is_lipogram5&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;I would expect all four functions presented so far to be similarly efficient in terms of memory, stack, CPU cycles. 
&lt;/p&gt;
&lt;p&gt;A recursive solution may require more stack: it depends on the compiler. We&amp;#8217;ve now got two functions, and although each comprises just a single expression, the expression forming the body of the recursive helper function, &lt;code&gt;is_lipo()&lt;/code&gt;, is tricky. I wouldn&amp;#8217;t recommend this implementation.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;bool is_lipo(book_iter wb, book_iter we, word const &amp;amp; avoid)
{
    return wb == we ||
        wb-&amp;gt;find_first_of(avoid) == std::string::npos &amp;amp;&amp;amp;
        is_lipo(++wb, we, avoid);
}
    
bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    return is_lipo(text.begin(), text.end(), avoid);
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc11" name="tocislipogram6" id="tocislipogram6"&gt;is_lipogram6&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Our final alternative is a clear winner on the three fronts which led us to reject our original implementation: it&amp;#8217;s brief, it leans heavily on the standard library, it has just a single exit point &amp;mdash; in fact, is just a single expression.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    return accumulate(text.begin(), text.end(), std::string()
                     ).find_first_of(avoid) == std::string::npos;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Does it qualify as elegant? I&amp;#8217;d say so, yes. Sadly, though, its inefficiency rules it out as a heavy-duty lipogram checker. The &lt;code&gt;std::string&lt;/code&gt; class is not designed for repeated addition &amp;mdash; which is what &lt;code&gt;std::accumulate&lt;/code&gt; does.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc12" name="tocwinding-up" id="tocwinding-up"&gt;Winding Up&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Actually none of the C++ lipogram checkers are much use, except in the case when we&amp;#8217;re certain our book is written in 7-bit ASCII. A lipogram which avoids the letter E should also avoid its various accented forms: &amp;eacute;, &amp;egrave;, &amp;ecirc;, &amp;euml;, &amp;Eacute;, &amp;Egrave;, &amp;Ecirc;, &amp;Euml;, &amp;#8230;
&lt;/p&gt;
&lt;p&gt;A heavy-duty lipogram checker needs to work in Unicode and, for C++ at least, will have to establish some ground rules for input encoding schemes. The current C++ standard (C++98) has little to say about Unicode. We&amp;#8217;d be better off using a more Unicode aware language, such as Java.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python.org"&gt;Python&lt;/a&gt; allows us to create a character stream which accumulates all the characters in all the words, but yields them lazily. The function below uses &lt;code&gt;itertools.chain&lt;/code&gt; to flatten the input words (which themselves may be a stream or an in-memory collection) into a character stream. The built-in &lt;code&gt;all&lt;/code&gt; function reads exactly as far into this stream as it needs to. In other words, we&amp;#8217;ve got a Python counterpart to our final C++ algorithm which is both efficient (efficient for Python that is!) and equally happy with Unicode and ASCII.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import iterools
    
def is_lipogram(words, avoid):
    return all(ch not in avoid
               for ch in itertools.chain(*words))

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency#toc13" name="tocc-source-code" id="tocc-source-code"&gt;C++ Source Code&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
    
namespace
{
typedef std::string word;
typedef word::const_iterator word_iter;
typedef std::vector&amp;lt;word&amp;gt; book;
typedef book::const_iterator book_iter;
typedef bool (* lipo_fn)(book const &amp;amp;, word const &amp;amp;);
    
// Return true if the input text avoids using any characters
// in 'avoid', false otherwise.
bool is_lipogram1(book const &amp;amp; text, word const &amp;amp; avoid)
{
    // Handle edge case -- empty book
    if (text.empty())
    {
        return true;
    }
    // Handle edge case -- nothing to avoid
    if (avoid.empty())
    {
        return true;
    }
    for (book_iter w = text.begin(); w != text.end(); ++w)
    {
        for (word_iter c = w-&amp;gt;begin(); c != w-&amp;gt;end(); ++c)
        {
            for (word_iter a = avoid.begin(); a != avoid.end(); ++a)
            {
                if (*c == *a)
                {
                    return false;
                }
            }
        }
    }
    return true;
}       
    
bool is_lipogram2(book const &amp;amp; text, word const &amp;amp; avoid)
{
    for (book_iter w = text.begin(); w != text.end(); ++w)
    {
        if (w-&amp;gt;find_first_of(avoid) != std::string::npos)
        {
            return false;
        }
    }
    return true;
}
    
bool is_lipogram3(book const &amp;amp; text, word const &amp;amp; avoid)
{
    book_iter w = text.begin();
    while (w != text.end() &amp;amp;&amp;amp;
           w-&amp;gt;find_first_of(avoid) == std::string::npos)
    {
        ++w;
    }
    return w == text.end();
}
    
// Simple functor for use in lipogram algorithms
class lipogram_word_tester:
    public std::unary_function&amp;lt;std::string const, bool&amp;gt;
{
public:
    // Constructor. Caches a copy of the avoid parameter.
    lipogram_word_tester(word const &amp;amp; avoid)
        : avoid(avoid)
    {
    }
    // Function operator returns true if the word being tested
    // omits characters from the 'avoid' string, false otherwise.
    bool operator()(word const &amp;amp; to_test) const
    {
        return to_test.find_first_of(avoid)
            == std::string::npos;
    }
private:
    // Private cache of characters to avoid.
    word const avoid;
};
    
bool is_lipogram4(book const &amp;amp; text, word const &amp;amp; avoid)
{
    lipogram_word_tester const word_test(avoid);
    return find_if(text.begin(), text.end(),
                   not1(word_test)) == text.end();
}
    
bool is_lipo5(book_iter wb, book_iter we, word const &amp;amp; avoid)
{
    return wb == we ||
        wb-&amp;gt;find_first_of(avoid) == std::string::npos &amp;amp;&amp;amp;
        is_lipo5(++wb, we, avoid);
}
    
bool is_lipogram5(book const &amp;amp; text, word const &amp;amp; avoid)
{
    return is_lipo5(text.begin(), text.end(), avoid);
}
    
bool is_lipogram6(book const &amp;amp; text, word const &amp;amp; avoid)
{
    return accumulate(text.begin(), text.end(), std::string()
                      ).find_first_of(avoid) == std::string::npos;
}
    
void read_book(book &amp;amp; text, std::istream &amp;amp; input) 
{
    typedef std::istream_iterator&amp;lt;word&amp;gt; in;
    std::copy(in(input), in(), back_inserter(text));
}
    
// Function-like class used for lipo_fn evaluation.
class lipo_functor
{
public:
    // Construct an instance of this class, caching lipo_fn parameters.
    lipo_functor(book const &amp;amp; text, word const &amp;amp; avoid)
        : text(text)
        , avoid(avoid)
    {
    }
    // Return the result of applying is_lipo to the cached parameters.
    bool operator()(lipo_fn is_lipo)
    {
        return is_lipo(text, avoid);
    }
private:
    book const &amp;amp; text;
    word const &amp;amp; avoid;
};
    
void check_if_lipogram(std::ostream &amp;amp; report,
                       book const &amp;amp; text, word const &amp;amp; avoid)
{
    typedef std::set&amp;lt;bool&amp;gt; answers;
    lipo_fn const lipo_fns[] =
        {
            is_lipogram1,
            is_lipogram2,
            is_lipogram3,
            is_lipogram4,
            is_lipogram5,
            is_lipogram6,
        };
    
    lipo_functor lipo_func(text, avoid);
    answers results;
    lipo_fn const * const end = lipo_fns + sizeof lipo_fns / sizeof *lipo_fns;
    transform(lipo_fns, end, inserter(results, results.end()), lipo_func);
    assert(results.size() == 1);
    report &amp;lt;&amp;lt; "Is " &amp;lt;&amp;lt; (*results.begin() ? "" : "not ")
           &amp;lt;&amp;lt; "a lipogram" &amp;lt;&amp;lt; '\n';
}
} // end anonymous namespace
    
int main()
{
    book text;
    word const avoid = "Ee";
    read_book(text, std::cin);
    check_if_lipogram(std::cout, text, avoid);
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2007-12-03</dc:date>
<guid>http://wordaligned.org/articles/elegance-and-efficiency</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/elegance-and-efficiency</link>
<category>Boost</category>
</item>

<item>
<title>Retro-fitting coding standards</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#tocwhat-no-coding-standards" name="toc0" id="toc0"&gt;What, No Coding Standards!?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#tocloss-of-freedom" name="toc1" id="toc1"&gt;Loss of Freedom&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#tocask-the-experts" name="toc2" id="toc2"&gt;Ask the Experts&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#tocsmall-stuff" name="toc3" id="toc3"&gt;Small Stuff&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#tocreuse" name="toc4" id="toc4"&gt;Re-Use&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#toclanguage-conventions" name="toc5" id="toc5"&gt;Language Conventions&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#tocthe-legacy-issue" name="toc6" id="toc6"&gt;The Legacy Issue&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;I&amp;#8217;ve worked at more than one organisation where a retrospective
   attempt has been made to set up a coding standard. This article
   discusses why these attempts were made and how they went.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#toc0" name="tocwhat-no-coding-standards" id="tocwhat-no-coding-standards"&gt;What, No Coding Standards!?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I say &amp;#8220;a retrospective attempt&amp;#8221;, I mean that plenty of code had
   already been written &amp;#8212; over a number of years, in fact &amp;#8212; with no
   existing coding standard in place. Is this a bad thing? Not
   necessarily. Joel Spolsky&amp;#8217;s 12 point &lt;a href="http://www.joelonsoftware.com/articles/fog0000000043.html"&gt;checklist&lt;/a&gt; on how to
   write better code is generally sound, and in particular I think he
   does well to &lt;strong&gt;not&lt;/strong&gt; say:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8220;Do you have a Coding Standard, and does everyone follow it?&amp;#8221;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;In the cases I&amp;#8217;m describing the code was in no way sub-standard. It
   worked well. Its success had caused the team to grow, with all the
   consequent problems, and in fact it wasn&amp;#8217;t management who imposed
   a coding standard, but the developers themselves who decided they 
   wanted one.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#toc1" name="tocloss-of-freedom" id="tocloss-of-freedom"&gt;Loss of Freedom&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span /&gt;A good coding standard shouldn&amp;#8217;t be there to constrain developers or force
   them to comply to a particular coding style. In fact, most seasoned
   programmers are careful not to waste energy arguing about coding
   styles (which isn&amp;#8217;t to say we don&amp;#8217;t care, or don&amp;#8217;t have opinions
   on such matters &amp;#8212; it&amp;#8217;s just that we prefer not to waste energy).
&lt;/p&gt;
&lt;p&gt;For this very reason, a coding standard can help. By drawing a line
   under arguments about where to place braces, how far to indent, what
   to call things, and then moving on, we allow ourselves to concentrate
   on solving more interesting problems. Even better, if everyone adopts
   a consistent style, it becomes easier to work with code written
   by colleagues.
&lt;/p&gt;
&lt;p&gt;The term &amp;#8220;Coding Standards&amp;#8221; suggests rules and red tape. It&amp;#8217;s perhaps
   the most common term, which is why I&amp;#8217;ve been using it, but I think
   guidelines are what are really required. In fact, as I&amp;#8217;ll explain, we
   don&amp;#8217;t really need guidelines since the experts have already written
   them for us. A &amp;#8220;Style Guide&amp;#8221; describing local conventions should be
   quite enough.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#toc2" name="tocask-the-experts" id="tocask-the-experts"&gt;Ask the Experts&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;All too often a corporate coding standard reads as an attempt by a
   local expert to lay down rules on how to write good code: when to use
   exceptions, why to pass arguments by constant reference, when to use
   protected data members, etc.  At best, this is a waste of effort, and,
   more likely (unless &lt;a href="http://www.gotw.ca/"&gt;Herb Sutter&lt;/a&gt; or &lt;a href="http://www.aristeia.com/"&gt;Scott Meyers&lt;/a&gt;
   happens to be your local expert), there&amp;#8217;s a high probability these
   home-brewed rules will be wrong.
&lt;/p&gt;
&lt;p&gt;&lt;span /&gt;It&amp;#8217;s far better to provide a well-stocked library than to attempt
   to write your own diluted imitations of Sutter and Meyers.
&lt;/p&gt;
&lt;p&gt;What &lt;a href="http://www.gotw.ca/"&gt;Sutter&lt;/a&gt; and &lt;a href="http://www.aristeia.com/"&gt;Meyers&lt;/a&gt; can&amp;#8217;t do, though, is document your
   local coding style &amp;#8212; by which I mean those finickity things such as
   what &amp;copy; copyright notice goes in a header file, where braces get
   placed, how far to indent, how to name things. That&amp;#8217;s what goes in
   your Style Guide.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#toc3" name="tocsmall-stuff" id="tocsmall-stuff"&gt;Small Stuff&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Style Guide, then, will comprise entirely of what 
   &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;Sutter and Alexandrescu&lt;/a&gt;
   refer to as &amp;#8220;small stuff&amp;#8221;, about which their specific advice is:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Item 0. Don&amp;#8217;t sweat the small stuff.
&lt;/p&gt;
&lt;p&gt;&amp;#8212; &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;C++ Coding Standards&lt;/a&gt;, Herb Sutter and Andrei Alexandrescu
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;By this they mean:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Issues that are really just personal taste and don&amp;#8217;t affect correctness
   don&amp;#8217;t belong in a coding standard. Any professional programmer can easily
   read and write code that is formatted a little differently than they&amp;#8217;re
   used to.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Does this imply that even a Style Guide isn&amp;#8217;t worth writing? And if so,
   why ever did the team I was working on want one?
&lt;/p&gt;
&lt;p&gt;I agree with Sutter and Alexandrescu&amp;#8217;s headline advice, but my take on
   it is slightly different: yes, small stuff isn&amp;#8217;t worth fussing over;
   and yes, I&amp;#8217;m capable of resetting my tabwidth to edit a file, and even
   of adopting the brace placement rules and naming conventions in force
   in that file &amp;#8212; but it requires concentration and becomes
   tiresome. What if there are several conflicting styles in a single
   file? I prefer to work on a consistent code base, and so do most
   programmers I&amp;#8217;ve worked with. So some sweating turns out to be
   necessary!
&lt;/p&gt;
&lt;p&gt;In this same section, 
   &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;Sutter and Alexandrescu&lt;/a&gt; manage to
   define a sensible naming convention in a single paragraph: this
   demonstrates the level of detail we&amp;#8217;re looking for. An entire Style
   Guide should fit comfortably on a single page, otherwise 
   it&amp;#8217;s too fussy and won&amp;#8217;t be adopted.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#toc4" name="tocreuse" id="tocreuse"&gt;Re-Use&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I hope we&amp;#8217;ve agreed to resist the temptation to write our own feeble
   imitations of 
   &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;&amp;#8220;C++ Coding Standards&amp;#8221;&lt;/a&gt;, 
   &lt;a href="http://www.aristeia.com/books_frames.html"&gt;&amp;#8220;Effective C++&amp;#8221;&lt;/a&gt;, 
   and similar. Out-sourcing this kind of thing is appealing. Surely we 
   could also reuse a coding style we&amp;#8217;ve seen elsewhere?
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#toc5" name="toclanguage-conventions" id="toclanguage-conventions"&gt;Language Conventions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Up to now I&amp;#8217;ve avoided explicitly mentioned what programming language
   I&amp;#8217;m talking about. If the language were &lt;a href="http://www.java.com/"&gt;Java&lt;/a&gt;,
   then defining our Style Guide really shouldn&amp;#8217;t be an issue: we&amp;#8217;d just
   cross-reference the 
   &lt;a href="http://java.sun.com/docs/codeconv/"&gt;Sun Java Programming Conventions&lt;/a&gt;, 
   configure an &lt;a href="http://eclipse-cs.sourceforge.net/"&gt;Eclipse plugin&lt;/a&gt; 
   to enforce these conventions, share the configuration
   and be done with it.
&lt;/p&gt;
&lt;p&gt;Similarly, &lt;a href="http://python.org"&gt;Python&lt;/a&gt; has a reasonably well-defined
   preferred style &amp;#8212; and its famous space-sensitivity unasks most
   questions about code layout.
&lt;/p&gt;
&lt;p&gt;If it&amp;#8217;s C++ we&amp;#8217;re talking about, the ground rules are less clear, and
   there&amp;#8217;s a whole lot more syntax to fret about. Nonetheless, we could
   draw inspiration from the C++ Standard Library, which follows a
   consistent &amp;#8212; if not formally documented &amp;#8212; naming style. This is exactly
   what &lt;a href="http//boost.org"&gt;Boost&lt;/a&gt; has chosen to do, and indeed parts of &lt;a href="http//boost.org"&gt;Boost&lt;/a&gt; are already
   making their way into the C++ Library. Many of the Boost
   &lt;a href="http://boost.org/more/lib_guide.htm#Guidelines"&gt;guidelines&lt;/a&gt; are specific to the Boost project, but we could
   sensibly extract the short sections on naming and layout to form the
   basis of our own Style Guide.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Use the naming conventions of the C++ Standard Library (See Naming
   conventions rationale): 
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Names (except as noted below) should be all lowercase, with words separated by underscores.  &lt;br /&gt;
 &lt;/li&gt;

 &lt;li&gt;
     Acronyms should be treated as ordinary names (e.g. xml_parser instead of XML_parser).  &lt;br /&gt;
 &lt;/li&gt;

 &lt;li&gt;
     Template parameter names begin with an uppercase letter.  &lt;br /&gt;
 &lt;/li&gt;

 &lt;li&gt;
     Macro (gasp!) names all uppercase and begin with BOOST_.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Choose meaningful names &amp;#8212; explicit is better than implicit, and
   readability counts. There is a strong preference for clear and
   descriptive names, even if lengthy.  &lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;&amp;#8230;  &lt;br /&gt;
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Use fixed-width fonts.
 &lt;/li&gt;

 &lt;li&gt;
     Use spaces rather than tabs.
 &lt;/li&gt;

 &lt;li&gt;
     Limit line lengths to 80 characters.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;p&gt;Of course, if we&amp;#8217;re retro-fitting a style guide, it&amp;#8217;s unlikely that we
   can just cut and paste the relevant sections of the Boost one. Another
   great site is Sven Rosvall&amp;#8217;s 
   &lt;a href="http://www.rosvall.ie/CSG/"&gt;Coding Standard Generator&lt;/a&gt;, 
   which allows you to generate your own coding standard by filling out a few forms.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/retro-fitting-coding-standards#toc6" name="tocthe-legacy-issue" id="tocthe-legacy-issue"&gt;The Legacy Issue&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;What if, having got together our one page Style Guide, we find that,
   say, only 50% the codebase fits that style? This is a serious concern,
   and one which threatens the usefulness of the whole exercise.
&lt;/p&gt;
&lt;p&gt;A Style Guide is supposed to make things easier for new team members
   to pick things up &amp;#8212; but if they discover little of the codebase
   follows the guide, then they&amp;#8217;ll ignore it like everyone else seems
   to. Similarly, experienced team members will resent effort spent on
   writing a guide which only looks good on paper, and will ignore
   it too.
&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s no easy way to tackle this issue, but there are a few viable
   approaches:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     Relax the style guide. By loosening it to accomodate everything,
        everything conforms.
 &lt;/li&gt;

 &lt;li&gt;
     Refactor the entire codebase to meet the accepted style.
 &lt;/li&gt;

 &lt;li&gt;
     When working on a file, first refactor it to meet the accepted style.
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;General C++ refactorings &amp;#8212; to change the name of a class, for example
   &amp;#8212; can be surprisingly difficult to automate and guarantee. The
   complexity of the language and its compilation model makes sure of
   that. Nonetheless, it can be done if the benefits are judged
   worthwhile. If you&amp;#8217;re worried that changing code will break it, then
   you probably don&amp;#8217;t have a good suite of regression tests: setting up
   and automating such a suite is &lt;em&gt;far&lt;/em&gt; more important than code style
   issues.
&lt;/p&gt;
&lt;p&gt;Simple refactorings &amp;#8212; to expand tabs to spaces, or to eliminate
   unwanted 
   &lt;a href="http://wordaligned.org/articles/keyword-substitution-just-say-no.html"&gt;Subversion keywords&lt;/a&gt;
    &amp;#8212; are easier to apply. Once done,
   they can be enforced using 
   &lt;a href="http://wordaligned.org/articles/a-subversion-pre-commit-hook.html"&gt;hook scripts&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;In practice, a balance between the listed approaches combined with a
   good dose of common sense provides our only way forward. The Style
   Guide should be a living document which always reflects the current
   code base. As is so often the case, we can iterate to get where we want,
   starting from: step zero, no style guide, anything goes.
&lt;/p&gt;</description>
<dc:date>2007-01-11</dc:date>
<guid>http://wordaligned.org/articles/retro-fitting-coding-standards</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/retro-fitting-coding-standards</link>
<category>Boost</category>
</item>

<item>
<title>Review of Pete Becker&#8217;s TR1 Book</title>
<description>&lt;p&gt;If you&amp;#8217;re a C++ programmer, you should know that &lt;a href="http://www.petebecker.com"&gt;Pete Becker&lt;/a&gt;
   has written a tutorial and reference &lt;a href="http://www.petebecker.com/tr1book"&gt;book&lt;/a&gt; on the first C++ Library
   Technical Report (more commonly known as &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1745.pdf"&gt;TR1&lt;/a&gt;).  I recently
   reviewed this book for &lt;a href="http://accu.org"&gt;ACCU&lt;/a&gt;.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h4&gt;Book Details&lt;/h4&gt;
&lt;ul&gt;
 &lt;li&gt;
     &lt;strong&gt;Title:&lt;/strong&gt; The C++ Standard Library Extensions: A Tutorial and Reference
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;Author:&lt;/strong&gt; Pete Becker
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;Publisher:&lt;/strong&gt; Addison Wesley Professional
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;ISBN:&lt;/strong&gt; ISBN-13: 978-0-321-15962-5
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Review&lt;/h4&gt;
&lt;p&gt;The standard C++ library is a fine thing but there are some notable
   omissions and weaknesses: there are no hashed containers, few smart
   pointers, no standard regular expression library; support for gluing
   functions and algorithms could be improved on; and so on. The first
   C++ Library Technical Report (&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1745.pdf"&gt;TR1&lt;/a&gt;) addresses these issues and many
   more. In 2006 the TR1 library was approved by ISO, and you can already
   find TR1 implementations. &lt;a href="http://www.petebecker.com"&gt;Pete Becker&lt;/a&gt;&amp;#8217;s book provides a comprehensive
   and accurate reference guide for the TR1 library.
&lt;/p&gt;
&lt;p&gt;The book styles itself as the perfect companion to Josuttis&amp;#8217; &lt;a href="http://www.josuttis.com/libbook/"&gt;&amp;#8220;The C++
Standard Library&amp;#8221;&lt;/a&gt;, and that&amp;#8217;s what
   I hoped for &amp;#8212; a book which would cut through the standardese and
   provide clear instructions on how I could benefit from TR1. In the
   main, it succeeds. There&amp;#8217;s plenty of example code, and there needs to
   be &amp;#8212; TR1 gives the standard C++ library a sizeable
   &lt;a href="http://boost.org"&gt;boost&lt;/a&gt;. The code is clearly written and described,
   and available for download from the author&amp;#8217;s website. The examples I
   tried (using GCC 4.01) worked, though I had to fiddle a little with
   include paths.  Pete Becker has first-hand knowledge of implementing
   TR1, giving this book an authorative tone. I can imagine this book
   becoming &lt;em&gt;The&lt;/em&gt; TR1 Book and I would certainly recommend it.
&lt;/p&gt;
&lt;p&gt;I do have some niggles, though. More attention could have been given
   to the layout. The code examples often break awkwardly across pages
   and some form of syntax highlighting would have made them more
   readable.  I can&amp;#8217;t understand why the output from these programs was
   either omitted or buried in a paragraph of explanatory text. Code
   comments were abused throughout the book to provide a running
   commentary. E.g.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;tuple&amp;lt;&amp;gt; t0;        // default constructor
tuple&amp;lt;int&amp;gt; t2(3);  // element initialised to 3

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I realise this is common practice in programming books, but I&amp;#8217;d like
   to see authors and publishers find a better way to annotate code.
&lt;/p&gt;
&lt;p&gt;These are niggles, though. My only real complaint was that many of the
   examples failed to show the benefits of using TR1. Much of TR1 is
   designed to make C++ easier to use; it&amp;#8217;s easier to manage dynamically
   allocated objects, it&amp;#8217;s easier to bind function arguments, it&amp;#8217;s easier
   to wrap functions for use in standard algorithms. The examples showed
   how to get TR1 code up and running, but sometimes failed to explain
   why.
&lt;/p&gt;</description>
<dc:date>2006-12-14</dc:date>
<guid>http://wordaligned.org/articles/review-of-pete-beckers-tr1-book</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/review-of-pete-beckers-tr1-book</link>
<category>Boost</category>
</item>

<item>
<title>Wiki Markup</title>
<description>&lt;p&gt;I&amp;#8217;m a big fan of wikis but one irritation is that they all have their
   own markup syntax. I guess that&amp;#8217;s because the wiki is one of those sweet
   web applications that every programmer wants to reinvent.
&lt;/p&gt;
&lt;p&gt;On a fairly regular basis, and in order of personal preference, I use:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     &lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;
     &lt;a href="http://boost.org/tools/quickbook"&gt;QuickBook&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;
     &lt;a href="http://trac.edgewall.org/wiki/TracWiki"&gt;TracWiki&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;
     &lt;a href="http://www.textism.com/tools/textile/"&gt;Textile&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;
     &lt;a href="http://www.mediawiki.org/"&gt;MediaWiki&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There&amp;#8217;s some convergence between these mini-languages, but not a whole
   lot. Ampersands and angle brackets are of course converted into
   HTML-safe equivalents. Paragraphs and bulleted lists usually work as
   you&amp;#8217;d expect. The other primary ingredients &amp;#8212; headings, links, images
   &amp;#8212; vary between implementations.
&lt;/p&gt;
&lt;p&gt;This post describes what I think makes a good wiki markup syntax and why
   I rate &lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt; so highly.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Bigger != Better&lt;/h3&gt;
&lt;p&gt;Given the number of wiki variants out there, most users are unlikely
   to remember even the basics of any single wiki markup
   syntax.  Ideally, then, the wiki markup rules should be simple &amp;#8212;
   simple enough to fit on a post-it note (or a post-it note sized
   block of pixels on a screen) which the user can refer to.
&lt;/p&gt;
&lt;p&gt;I wouldn&amp;#8217;t use this criterion to rule out a more complex markup
   syntax. &lt;a href="http://www.mediawiki.org/"&gt;MediaWiki&lt;/a&gt; is probably about as complex a markup as there
   is but it still manages to keep the simple things simple.
&lt;/p&gt;
&lt;p&gt;All things being equal, though, I prefer a compact set of markup rules.
&lt;/p&gt;

&lt;h3&gt;Well Documented&lt;/h3&gt;
&lt;p&gt;It goes without saying that the wiki markup rules should be well
   documented. How else is an end user to work out what to do?
&lt;/p&gt;
&lt;p&gt;I think it&amp;#8217;s also plain that a wiki markup should be self-documented,
   by which I mean the
   &lt;a href="http://daringfireball.net/projects/markdown/syntax"&gt;documentation&lt;/a&gt;
   should be written using
   &lt;a href="http://daringfireball.net/projects/markdown/syntax.text"&gt;itself&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;Escape to (X)HTML&lt;/h3&gt;
&lt;p&gt;Noone expects a wiki syntax to do everything HTML can, so there&amp;#8217;d
   better be a way of escaping the normal wiki markup rules to include
   raw HTML in a document.  For example, there have been a number of
   attempts to provide a wiki syntax for tables, but none works quite as well
   as an HTML table &amp;#8212; so a wiki should simply provide a way for HTML
   tables to be introduced into a document.
&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s another side to this. Sometimes we simply want to stop normal
   wiki processing from happening. If the underscore is normally used to
   emphasize words &lt;em&gt;like this&lt;/em&gt;, then we&amp;#8217;d better be able to escape this
   behaviour when we want to see the underscores _like this_.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;escaping underscores with Markdown&lt;/div&gt;

&lt;pre class="prettyprint"&gt;If the underscore is normally used to emphasize
words _like this_, then we'd better be able to
escape this behaviour when we want to see
the underscores \_like this\_.

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Conformance Tests&lt;/h3&gt;
&lt;p&gt;A good wiki markup syntax may well have a life outside its native wiki
   implementation. It could be used in other wikis or blogs. It could become a
   general purpose HTML templating application.
&lt;/p&gt;
&lt;p&gt;If it&amp;#8217;s to have any hope of standing on its own like this, it had
   better come with a decent set of conformance tests: that is, a set of
   test inputs and expected outputs.
&lt;/p&gt;
&lt;p&gt;The existence of such a suite helps explain why you can find
   trustworthy &lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt; implementations in a variety of popular
   high-level languages (Perl, PHP, Python, Ruby &amp;#8230;).
&lt;/p&gt;

&lt;h3&gt;Suck it and See&lt;/h3&gt;
&lt;p&gt;Most wikis provide a page to be used for experimentation &amp;#8212; it&amp;#8217;s often
   called something like &amp;#8220;SandBox&amp;#8221;. A superior better wiki markup syntax
   will also host such a facility online. You can try out Markdown
   &lt;a href="http://daringfireball.net/projects/markdown/dingus"&gt;here&lt;/a&gt; and
   Textile &lt;a href="http://www.textism.com/tools/textile/"&gt;here&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;And the Winner is &amp;#8230;&lt;/h3&gt;
&lt;p&gt;No suprises here: I said at the outset that &lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt; is my favourite. It
   more than meets all the criteria mentioned above which already puts
   it one step ahead of most alternatives. It also wins points for:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;Explaining its design goals so clearly:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Readability, however, is emphasized above all else. A
   Markdown-formatted document should be publishable as-is, as plain
   text, without looking like it&amp;#8217;s been marked up with tags or formatting
   instructions.
&lt;/p&gt;
&lt;/blockquote&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;Working so well with an &amp;#8220;aware&amp;#8221; text editor. I write the content for
      my &lt;a href="http://www.wordaligned.org"&gt;web site&lt;/a&gt; in Markdown using
      &lt;a href="http://www.gnu.org/software/emacs/"&gt;emacs&lt;/a&gt;, and the emacs text mode
      does the right thing when I&amp;#8217;m writing lists, blockquotes etc.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;Providing superior support for
      &lt;a href="http://daringfireball.net/projects/markdown/syntax#link"&gt;links&lt;/a&gt;.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="http://boost.org/tools/quickbook"&gt;Quickbook&lt;/a&gt; deserves a special mention too, since it generates not HTML
   but &lt;a href="http://docbook.org"&gt;DocBook XML&lt;/a&gt;, and hence can be used as a starting point for both
   &lt;a href="http://wordaligned.org/docs/softdoc_overload/index.html"&gt;online and printed&lt;/a&gt;
   versions of a document.
&lt;/p&gt;</description>
<dc:date>2006-12-03</dc:date>
<guid>http://wordaligned.org/articles/wiki-markup</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/wiki-markup</link>
<category>Boost</category>
</item>

<item>
<title>Computer Language Complexity</title>
<description>&lt;p&gt;A debate has been raging on the &lt;a href="http://accu.org/index.php/mailinglists"&gt;ACCU general&lt;/a&gt; email reflector. It
   started with some ugly &lt;a href="http://www.boost.org/boost/mpl/vector.hpp"&gt;C++
code&lt;/a&gt; and ended up
   attempting to answer some more general questions about computer
   languages:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     Can a language be both small and powerful?
 &lt;/li&gt;

 &lt;li&gt;
     What makes a language powerful anyway?
 &lt;/li&gt;

 &lt;li&gt;
     Is it better for (any necessary) complexity to be in the language or in its associated libraries?
 &lt;/li&gt;

 &lt;li&gt;
     Shouldn&amp;#8217;t we just admit that programming is hard?
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C++ came in for criticism from some, though, as its &lt;a href="http://www.research.att.com/~bs/"&gt;designer and
original implementer&lt;/a&gt; has been compelled to
   &lt;a href="http://www.research.att.com/~bs/blast.html"&gt;remind&lt;/a&gt; us:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The major cause of complaints is C++&amp;#8217;s undoubted success. As someone
   remarked: There are only two kinds of programming languages: those
   people always bitch about and those nobody uses.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Who is that someone? I&amp;#8217;d like to disagree with him &amp;#8212; or her. For now, though,
   I want to record some of the answers to these questions
   which I &lt;em&gt;did&lt;/em&gt; agree with.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h4&gt;Can a language be both small and powerful?&lt;/h4&gt;
&lt;p&gt;Yes. &lt;a href="http://www.russel.org.uk"&gt;Russel&lt;/a&gt; explains:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; If the language comprises a small, orthogonal set of
   higher order functions and primitive operations, all other things
   can be built from them.  &lt;span /&gt;Small, powerful language, large, structured library of usable software.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Clearly, though, there&amp;#8217;s some tension between &amp;#8220;small&amp;#8221; and
   &amp;#8220;powerful&amp;#8221;. For example, when
   &lt;a href="http://www.python.org/dev/peps/pep-0255/"&gt;generators&lt;/a&gt; were added to
   &lt;a href="http://python.org"&gt;Python&lt;/a&gt;, the language gained in power at the expense
   of size: in this case, though, the gains more than
   outweighed the costs.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s also noteworthy that the next major revision of Python actually
   aims to make the core language &lt;em&gt;smaller&lt;/em&gt;. Yes, Python isn&amp;#8217;t as
   widely-used as C++ (yet), but it is a major language and it does take
   backwards compatibility very seriously.  I guess it&amp;#8217;s the kind of
   progression which can only happen when you have a &lt;a href="http://www.python.org/~guido/"&gt;benevolent dictator
for life&lt;/a&gt; rather than a standards
   committee. Of course, it remains to be seen how well the transition to
   Python 3.0 actually goes.
&lt;/p&gt;

&lt;h4&gt;What makes a language powerful anyway?&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://www.spongelava.com"&gt;Paul&lt;/a&gt; came up with a practical and
   appealing definition.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The language facilitates more with less required of the programmer.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;On examination, though, this doesn&amp;#8217;t distinguish between the power of
   the language itself and the power attained through associated libraries.
   It&amp;#8217;s possible for the language itself to be simple
   and powerful, but for the range of available libraries to be poor,
   meaning that the programmer has to (for example) write their own
   database access code.  It looks as though &lt;a href="http://schemers.org"&gt;Scheme&lt;/a&gt;
   &lt;em&gt;currently&lt;/em&gt; falls into this category. And it&amp;#8217;s possible
   for a language to be less powerful but the range of libraries to be
   excellent, meaning that the programmer (for example) can&amp;#8217;t overload
   operators, but can (for example) access a database. I&amp;#8217;d say
   &lt;a href="http://java.sun.com"&gt;Java&lt;/a&gt; falls into this category.
&lt;/p&gt;

&lt;h4&gt;Should complexity be in the language or its libraries?&lt;/h4&gt;
&lt;p&gt;It&amp;#8217;s better to keep the core of the language as small and powerful as
   possible. It&amp;#8217;s far easier to extend what you can do with a language by
   adding libraries (and it&amp;#8217;s easier to deprecate libraries than
   deprecate language features).
&lt;/p&gt;

&lt;h3&gt;Shouldn&amp;#8217;t we just admit that programming is hard?&lt;/h3&gt;
&lt;p&gt;We should. It is. But we should still strive for
   &lt;a href="http://wiki.hsr.ch/SimpleCode/wiki.cgi"&gt;simplicity&lt;/a&gt;.
&lt;/p&gt;</description>
<dc:date>2006-10-26</dc:date>
<guid>http://wordaligned.org/articles/computer-language-complexity</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/computer-language-complexity</link>
<category>Boost</category>
</item>

<item>
<title>String literals and regular expressions</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#tocstring-literals" name="toc0" id="toc0"&gt;String Literals&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#tocescape-sequences" name="toc1" id="toc1"&gt;Escape Sequences&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#tocliteral-backslashes" name="toc2" id="toc2"&gt;Literal Backslashes&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#tocregular-expressions" name="toc3" id="toc3"&gt;Regular Expressions&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#tocattempting-to-match-a-c-string-literal" name="toc4" id="toc4"&gt;Attempting to Match a C++ String Literal&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toccorrectly-matching-a-c-string-literal" name="toc5" id="toc5"&gt;Correctly Matching a C++ String Literal&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#tocnow-lets-do-it-in-c" name="toc6" id="toc6"&gt;Now let&amp;#8217;s do it in C++&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toca-complete-c-string-literal-matcher" name="toc7" id="toc7"&gt;A complete C++ string literal matcher&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#tocraw-strings-in-python" name="toc8" id="toc8"&gt;Raw Strings in Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#tocraw-strings-in-c" name="toc9" id="toc9"&gt;Raw Strings in C++?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#tocverbatim-strings-in-c" name="toc10" id="toc10"&gt;Verbatim Strings in C++?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toctheres-no-escape" name="toc11" id="toc11"&gt;There&amp;#8217;s no escape&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;According to the &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf"&gt;&amp;#8220;Draft Technical Report on C++ Library Extensions&amp;#8221;&lt;/a&gt;
   (more commonly known as &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf"&gt;TR1&lt;/a&gt;) regular expressions are making their way
   into the C++ standard library. Actually, &lt;a href="http://boost.org"&gt;Boost&lt;/a&gt; users have had
   a &lt;a href="http://www.boost.org/libs/regex/doc/index.html"&gt;regular expression library&lt;/a&gt; for a while now. The library
   is well designed and easy to use but is let down by the limitations
   of string literals.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc0" name="tocstring-literals" id="tocstring-literals"&gt;String Literals&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Let&amp;#8217;s go back to basics and examine a C++ string literal:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;char const * s = "string literal";

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the string literal comprises the sequence of characters &lt;code&gt;s&lt;/code&gt;,
   &lt;code&gt;t&lt;/code&gt;, &amp;#8230; &lt;code&gt;l&lt;/code&gt;. The double-quotes &lt;code&gt;"&lt;/code&gt; serve to delimit the contents of
   the string.
&lt;/p&gt;
&lt;p&gt;All&amp;#8217;s fine until we need a double-quote inside the string:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Broken string literal&lt;/div&gt;

&lt;pre class="prettyprint"&gt;char const * s = "The "x" in C++0x will probably be 9";

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This line of code gives a compilation error:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;error: expected `,' or `;' before "x"

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;since the first internal double-quote closed the string. But how can we
   include a double-quote without closing the string?
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc1" name="tocescape-sequences" id="tocescape-sequences"&gt;Escape Sequences&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Here&amp;#8217;s how: the backslash, &lt;code&gt;\&lt;/code&gt;, is treated as an &lt;em&gt;escape&lt;/em&gt;
   &lt;em&gt;character&lt;/em&gt;. That is to say, normal interpretation of the string is suspended
   for a while &amp;#8212; in this case for a single character &amp;#8212; allowing us to write:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Fixed string literal&lt;/div&gt;

&lt;pre class="prettyprint"&gt;char const * s = "The \"x\" in C++0x will probably be 9";

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the internal double-quotes have been &lt;em&gt;escaped&lt;/em&gt;, so they don&amp;#8217;t close the
   string literal but are in fact interpreted as double-quote characters
   within the string itself. Yes, it&amp;#8217;s confusing.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc2" name="tocliteral-backslashes" id="tocliteral-backslashes"&gt;Literal Backslashes&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Now, if the backslash takes on a special meaning, how are
   we to insert a literal backslash into the string? Simple &amp;#8212; we must escape that too:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;String literal containing a single backslash&lt;/div&gt;

&lt;pre class="prettyprint"&gt;char const * s = "A backslash \\ starts an escape sequence";

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, despite first appearances, the string contains just a &lt;em&gt;single&lt;/em&gt;
   backslash character.  We did say it was confusing! Which leads us on to &amp;#8230;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc3" name="tocregular-expressions" id="tocregular-expressions"&gt;Regular Expressions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Put string literals aside for now. We&amp;#8217;re going to talk about regular
   expressions (let&amp;#8217;s call them regexes from now on).  Regexes are used
   to find and match patterns in blocks of text.  Like string literals,
   regexes are composed of sequences of characters, and, also like
   string literals, we need to escape the usual meaning of characters in regexes.
&lt;/p&gt;
&lt;p&gt;Once again, the backslash, &lt;code&gt;\&lt;/code&gt;, is used as the escape sequence prefix.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruby-lang.org" title="Ruby Website"&gt;Ruby&lt;/a&gt; embeds a powerful regex engine, so let&amp;#8217;s use Ruby for our regex
   examples:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Some Ruby regex patterns&lt;/div&gt;

&lt;pre class="prettyprint"&gt;/w/
/w+/
/\w+/
/"\w*"/
/\\/

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Notice here that the &lt;em&gt;forward&lt;/em&gt; slash, &lt;code&gt;/&lt;/code&gt;, is used as a delimiter and
   is not part of the body of the regex pattern &amp;#8212; just like the
   double-quote, &lt;code&gt;"&lt;/code&gt;, was not part of the body our string literals.
&lt;/p&gt;
&lt;p&gt;What do these regex patterns mean?
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     &lt;code&gt;/w/&lt;/code&gt; matches the character &lt;code&gt;w&lt;/code&gt;.
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;/w+/&lt;/code&gt; matches a sequence of one or more adjacent &lt;code&gt;w&lt;/code&gt;&amp;#8217;s.
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;/\w+/&lt;/code&gt; matches one or more adjacent &amp;#8220;word&amp;#8221; characters.
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;/"\w*"/&lt;/code&gt; matches a double-quote delimited sequence of zero or more &amp;#8220;word&amp;#8221; characters.
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;/\\/&lt;/code&gt; matches a &lt;em&gt;single&lt;/em&gt; backslash.
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Did you notice that the backslash, &lt;code&gt;\&lt;/code&gt;, gives the succeding &lt;code&gt;w&lt;/code&gt; a special
   meaning? Did you notice that the &lt;code&gt;+&lt;/code&gt; has a special meaning within a regex
   (it means one or more)?  To match a literal &lt;code&gt;+&lt;/code&gt;, we&amp;#8217;d need to escape
   it like this: &lt;code&gt;/\+/&lt;/code&gt;. And did you notice that to match a literal backslash
   we must escape it? Good &amp;#8212; but that was the easy bit!
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc4" name="tocattempting-to-match-a-c-string-literal" id="tocattempting-to-match-a-c-string-literal"&gt;Attempting to Match a C++ String Literal&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Let&amp;#8217;s suppose we want to use our regex pattern matching on some C++ code.
   Now, matching a C++ string literal is going to be tricky. A first attempt,
   &lt;code&gt;/".*"/&lt;/code&gt;, just won&amp;#8217;t do because the &lt;code&gt;.*&lt;/code&gt; is &lt;em&gt;greedy&lt;/em&gt; and will eat up
   everything until the final &lt;code&gt;"&lt;/code&gt; in the text to be matched. So
   we might match too much:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;char * s1 = "string", * s2 = "literal";
            ^---------match----------^

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A non-greedy second attempt, &lt;code&gt;/".*?"/&lt;/code&gt;, won&amp;#8217;t do either since it gets
   confused by an escaped double-quote in a string literal. So
   we might match too little:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;char const * s = "The \"x\" in C++0x will probably be 9";
                 ^match^

&lt;/pre&gt;

&lt;/div&gt;


&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc5" name="toccorrectly-matching-a-c-string-literal" id="toccorrectly-matching-a-c-string-literal"&gt;Correctly Matching a C++ String Literal&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;To properly match a C++ string literal we need to apply the following
   pattern: start with a double-quote; continue with a sequence of
   &lt;em&gt;either&lt;/em&gt; characters which aren&amp;#8217;t the double-quote or the backslash
   &lt;em&gt;or&lt;/em&gt; escape sequences; then finish with a double-quote.
&lt;/p&gt;
&lt;p&gt;Precisely what makes up a valid escape sequence is a little fiddly;
   there are octal and hexadecimal escapes, there are various whitespace
   characters, and there are unicode values. We can however compose a
   pattern using a suitable short-cut as follows:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;A regex to match a C++ string literal&lt;/div&gt;

&lt;pre class="prettyprint"&gt;/"([^"\\]|\\.)*"/

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can read this as: a string literal starts with a double quote,
   followed by any number of items which are:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     &lt;em&gt;either&lt;/em&gt; not a double-quote or a backslash
 &lt;/li&gt;

 &lt;li&gt;
     &lt;em&gt;or&lt;/em&gt; are a backslash followed by any single character
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and then finishes with a closing double-quote.
&lt;/p&gt;
&lt;p&gt;As you&amp;#8217;ve probably spotted, we have to double up the backslashes in
   the regex pattern because the backslash is used as an escape sequence;
   i.e. a literal backslash is matched by the pattern &lt;code&gt;\\\\&lt;/code&gt;.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc6" name="tocnow-lets-do-it-in-c" id="tocnow-lets-do-it-in-c"&gt;Now let&amp;#8217;s do it in C++&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;I&amp;#8217;ll use the &lt;a href="http://www.boost.org/libs/regex/doc/index.html"&gt;Boost&lt;/a&gt; implementation since the compilers I
   have available don&amp;#8217;t support &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf"&gt;TR1&lt;/a&gt; yet. We&amp;#8217;re going to need to
   construct a &lt;code&gt;boost::regex&lt;/code&gt; using a pattern represented by a string
   literal. Which is where the problems start.  Of course we can&amp;#8217;t write:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;This regex won&amp;#8217;t compile!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;boost::regex const
    string_matcher(/"([^"\\]|\\.)*"/);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;because we haven&amp;#8217;t passed a string literal to the &lt;code&gt;boost::regex&lt;/code&gt;
   constructor.  In order to pass a string literal we&amp;#8217;ll need to use
   double-quotes instead of forward-slashes and we&amp;#8217;ll have to escape
   the internal double-quotes. Let&amp;#8217;s try again:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;This regex throws an exception!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;boost::regex const
    string_matcher("\"([^\"\\]|\\.)*\"");

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Oh dear &amp;#8212; the error moves to run-time. We get an exception:
   &lt;code&gt;Unmatched [ or [^&lt;/code&gt;. This is because the closing square bracket &lt;code&gt;]&lt;/code&gt;
   has been escaped by the time it gets to the regex engine. Unfortunately
   the &lt;code&gt;\\&lt;/code&gt;&amp;#8217;s in the string literal contract to just single backslashes. We need
   to redouble them.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;This regex is just right!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;boost::regex const
    string_matcher("\"([^\"\\\\]|\\\\.)*\"");

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, each pair of backslashes has contracted to a single backslash by the
   time the regex engine sees it, which &amp;#8212; believe it or not &amp;#8212; is what&amp;#8217;s
   required.
&lt;/p&gt;
&lt;p&gt;This &lt;code&gt;string_matcher&lt;/code&gt; works, but as code it is rather more cryptic
   than communicative.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc7" name="toca-complete-c-string-literal-matcher" id="toca-complete-c-string-literal-matcher"&gt;A complete C++ string literal matcher&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Here&amp;#8217;s a complete program for you to try.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;A C++ string matcher&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;boost/regex.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdexcept&amp;gt;
#include &amp;lt;string&amp;gt;

int main(int argc, char * argv[])
{
  try
  {
    boost::regex const
      string_matcher("\"([^\"\\\\]|\\\\.)*\"");
    std::string line;
    while (std::getline(std::cin, line))
    {
      if (boost::regex_match(line, string_matcher))
      {
        std::cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; " is a C++ string literal\n";
      }
    }
  }
  catch (std::exception &amp;amp; exc)
  {
    std::cerr &amp;lt;&amp;lt; "An error occurred: " &amp;lt;&amp;lt; exc.what();
  }
  catch (...)
  {
    std::cerr &amp;lt;&amp;lt; "An error occurred\n";
  }
  return 0;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc8" name="tocraw-strings-in-python" id="tocraw-strings-in-python"&gt;Raw Strings in Python&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Unlike &lt;a href="http://www.ruby-lang.org" title="Ruby Website"&gt;Ruby&lt;/a&gt;, &lt;a href="http://python.org"&gt;Python&lt;/a&gt; doesn&amp;#8217;t include support for regexes in the
   language itself. Instead, regex support is provided by the standard
   &lt;a href="http://docs.python.org/lib/module-re.html"&gt;regular expression library&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python.org"&gt;Python&lt;/a&gt;&amp;#8217;s flexible string literals allow us to simplify the pattern,
   though. Here, we use a &lt;a href="http://docs.python.org/ref/strings.html"&gt;raw string&lt;/a&gt;, and we chose to delimit it with
   single-quotes so we don&amp;#8217;t need to escape the internal double-quotes.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;string_literal_pattern = r'"([^"\\]|\\.)*"'

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This is nice. Basically, &lt;a href="http://docs.python.org/ref/strings.html"&gt;raw strings&lt;/a&gt; leave the backslashes
   unprocessed.  &lt;a href="http://docs.python.org/ref/strings.html"&gt;Raw strings&lt;/a&gt; aren&amp;#8217;t just restricted to regex patterns,
   though perhaps that&amp;#8217;s their most common use.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc9" name="tocraw-strings-in-c" id="tocraw-strings-in-c"&gt;Raw Strings in C++?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;C++ doesn&amp;#8217;t support raw strings (at least, it doesn&amp;#8217;t support them
   yet, and I haven&amp;#8217;t found them mentioned in &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf"&gt;TR1&lt;/a&gt;) &amp;#8212; but it does
   support wide-strings, indicated by the &lt;code&gt;L&lt;/code&gt; prefix.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;cpp_wide_string = L"this is a wide string";

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Maybe if we switched the &lt;code&gt;L&lt;/code&gt; for an &lt;code&gt;R&lt;/code&gt; we could allow raw strings into
   C++? It would make regex patterns far more readable.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc10" name="tocverbatim-strings-in-c" id="tocverbatim-strings-in-c"&gt;Verbatim Strings in C++?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Alternatively &amp;#8230;
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ve never used C# but &lt;a href="http://www.google.co.uk/search?q=c%23%20string%20literals&amp;amp;hl=en&amp;amp;meta="&gt;googling&lt;/a&gt;
   suggests raw strings are supported and rather nicely named
   &amp;#8220;verbatim string literals&amp;#8221;. C# uses the &lt;code&gt;@&lt;/code&gt; prefix to indicate that a
   string literal is a verbatim string. Now, &lt;code&gt;@&lt;/code&gt; isn&amp;#8217;t even part of the C++
   source character set, so maybe this too would be possible.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/string-literals-and-regular-expressions#toc11" name="toctheres-no-escape" id="toctheres-no-escape"&gt;There&amp;#8217;s no escape&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The proliferation of backslashes when we combine regexes and string
   literals is unfortunate. &lt;span /&gt;It could be worse. What if the backslash key
   had fallen off our keyboard? Remarkably &amp;ndash; and, as far as I know,
   uniquely &amp;ndash; C++ caters for this situation. A number source characters
   can be written as &amp;#8220;trigraphs&amp;#8221; &amp;#8212; sequences of three characters
   starting &lt;code&gt;??&lt;/code&gt;. The backslash is one such character: it can be
   written as &lt;code&gt;??/&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;regex using trigraphs&lt;/div&gt;

&lt;pre class="prettyprint"&gt;boost::regex const
    string_matcher("??/"([^??/"??/??/??/??/]|??/??/??/??/.)*??/"");

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;For completeness, we could also lose the &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; keys.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;regex using even more trigraphs&lt;/div&gt;

&lt;pre class="prettyprint"&gt;boost::regex const
    string_matcher("??/"(??(^??/"??/??/??/??/??)??!??/??/??/??/.)*??/"");

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The string literal used to initialise &lt;code&gt;string_matcher&lt;/code&gt; &lt;em&gt;is&lt;/em&gt; valid, but
   the regex wouldn&amp;#8217;t match it properly. I&amp;#8217;ll leave the fix as an exercise
   for the reader.
&lt;/p&gt;</description>
<dc:date>2006-09-02</dc:date>
<guid>http://wordaligned.org/articles/string-literals-and-regular-expressions</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/string-literals-and-regular-expressions</link>
<category>Boost</category>
</item>

<item>
<title>A Mini-Project to Decode a Mini-Language</title>
<description>&lt;p&gt;This &lt;a href="http://wordaligned.org/docs/dvbcodec/index.html"&gt;article&lt;/a&gt; documents a project inspired by &lt;a href="http://www.catb.org/~esr/"&gt;Eric S. Raymond&lt;/a&gt;&amp;#8217;s book The Art of Unix Programming. It visits the worlds of the &lt;a href="http://spirit.sourceforge.net/"&gt;Spirit&lt;/a&gt; C++ parser framework and MPEG-2 transport streams.
&lt;/p&gt;
&lt;p&gt;The article originally appeared in two parts in &lt;a href="http://accu.org/index.php/journals/c149/"&gt;Overload 63&lt;/a&gt; and &lt;a href="http://accu.org/index.php/journals/c148/"&gt;Overload 64&lt;/a&gt;, winning an award as best Overload article 2004. The &lt;a href="http://wordaligned.org/docs/dvbcodec/index.html"&gt;online edition&lt;/a&gt; adds a third part.
&lt;/p&gt;
&lt;div class="extended"&gt;&lt;p&gt;&lt;a href="http://wordaligned.org/docs/dvbcodec/index.html"&gt;Continue reading&amp;#8230;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description>
<dc:date>2004-06-07</dc:date>
<guid>http://wordaligned.org/articles/dvbcodec</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/dvbcodec</link>
<category>Boost</category>
</item>

</channel>
</rss>
