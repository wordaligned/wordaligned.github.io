<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Animated pair streams</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#tocname-that-series" name="toc0" id="toc0"&gt;Name that Series&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#tocbounded-pairs" name="toc1" id="toc1"&gt;Bounded Pairs&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#tocstreams-of-pairs" name="toc2" id="toc2"&gt;Streams of Pairs&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toca-recursive-scheme" name="toc3" id="toc3"&gt;A Recursive Scheme&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#tocinterleaving" name="toc4" id="toc4"&gt;Interleaving&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#tocdouble-trouble" name="toc5" id="toc5"&gt;Double Trouble&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#tocmemory-use" name="toc6" id="toc6"&gt;Memory Use&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#tocproblem-solved" name="toc7" id="toc7"&gt;Problem Solved?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toctying-up" name="toc8" id="toc8"&gt;Tying up&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toccredits" name="toc9" id="toc9"&gt;Credits&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc0" name="tocname-that-series" id="tocname-that-series"&gt;Name that Series&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;What&amp;#8217;s going on in the animation below?
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-stream.gif" alt="Pair stream slideshow"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc1" name="tocbounded-pairs" id="tocbounded-pairs"&gt;Bounded Pairs&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While you&amp;#8217;re waiting for the graphic to load, recall a problem we encountered while hunting for &lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#programming-pearl"&gt;maximum subsequences&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Given a number n, generate all the pairs (i, j) such that i and j are in the range 0 to n and j is greater than i.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;A Python solution reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def generate_pairs(n):
    "Generate all pairs (i, j) such that 0 &amp;lt;= i &amp;lt;= j &amp;lt; n"
    for i in range(n):
        for j in range(i, n):
            yield i, j

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can extend this to solve a more general version of the problem:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Given two sequences (S, T), generate all pairs (S&lt;sub&gt;i&lt;/sub&gt;, T&lt;sub&gt;j&lt;/sub&gt;) such that j is greater than i.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def generate_pairs(s, t):
    "Generate all pairs s[i], t[j]  such that 0 &amp;lt;= i &amp;lt;= j"
    s_count = len(s)
    t_count = len(t)
    for i in xrange(s_count):
        for j in xrange(i, t_count):
            yield s[i], t[j]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;This function requires complete and bounded collections as inputs since it asks for their lengths and accesses elements by index &amp;#8212; think &amp;#8220;lists&amp;#8221; or &amp;#8220;tuples&amp;#8221;. Yet it generates results lazily, giving clients control over just how many pairs they require. This is why I&amp;#8217;ve chosen &lt;code&gt;xrange&lt;/code&gt; in preference to &lt;code&gt;range&lt;/code&gt;, since it too generates numbers, rather than returning a complete list. (Python 3000 simplifies things: &lt;code&gt;range&lt;/code&gt; becomes &lt;code&gt;xrange&lt;/code&gt; and &lt;code&gt;xrange&lt;/code&gt; disappears.)
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;There&amp;#8217;s no need for extra logic to handle &lt;code&gt;S&lt;/code&gt; being shorter than &lt;code&gt;T&lt;/code&gt; or vice-versa: &lt;code&gt;xrange(start, stop)&lt;/code&gt; is smart enough to handle the case when &lt;code&gt;stop&lt;/code&gt; is less than &lt;code&gt;start&lt;/code&gt;. I&amp;#8217;d say adding such extra logic would count as premature optimisation.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&amp;#8217;s an example of this function in action. We run the generator to exhaustion collecting its output in a list.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; pairs = list(generate_pairs('ABC', (1, 2, 3, 4)))
&amp;gt;&amp;gt;&amp;gt; print pairs
[('A', 1), ('A', 2), ('A', 3), ('A', 4), ('B', 2), ('B', 3), ('B', 4), ('C', 3), ('C', 4)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A second example builds a &lt;a href="http://docs.python.org/ref/genexpr.html"&gt;generator expression&lt;/a&gt; from &lt;code&gt;generate_pairs()&lt;/code&gt;. We plug this expression into the built in &lt;code&gt;any&lt;/code&gt; function to determine whether the pair &lt;code&gt;('A', 2)&lt;/code&gt; is in the pair sequence. Note that &lt;code&gt;any&lt;/code&gt; only pulls two elements from the sequence to produce an answer.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; any((p == 'A', 2) for p in generate_pairs('ABC', (1, 2, 3, 4)))
True

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So far, so what? For the toy examples shown, lazy evaluation isn&amp;#8217;t an important consideration. But what if our input sequences were very large? What if they were infinite?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc2" name="tocstreams-of-pairs" id="tocstreams-of-pairs"&gt;Streams of Pairs&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Generate_pairs()&lt;/code&gt; yields results row by row. Here&amp;#8217;s a slideshow for the case when &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; have 5 and 20 elements respectively. Brightness indicates age, so the white circle represents the current head of the generated sequence, and the greying circles represent previous elements &amp;#8212; the older the greyer. Remember, it&amp;#8217;s up to clients just how many grey pairs to hold: the generator only ever yields a shiny white new pair.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-list.gif" alt="Pair list slideshow"/&gt;

&lt;p&gt;A text representation would be as follows, where, as usual, we read top to bottom, left to right.
&lt;/p&gt;
&lt;pre&gt;
S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;0&lt;/sub&gt;, S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;2&lt;/sub&gt; ...                             S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;20&lt;/sub&gt;
      S&lt;sub&gt;1&lt;/sub&gt;T&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;1&lt;/sub&gt;T&lt;sub&gt;2&lt;/sub&gt;, ...                            S&lt;sub&gt;1&lt;/sub&gt;T&lt;sub&gt;20&lt;/sub&gt;
            S&lt;sub&gt;2&lt;/sub&gt;T&lt;sub&gt;2&lt;/sub&gt;, ...                           S&lt;sub&gt;2&lt;/sub&gt;T&lt;sub&gt;20&lt;/sub&gt;
                  ...
&lt;/pre&gt;

&lt;p&gt;It&amp;#8217;s clear this mode of traversal isn&amp;#8217;t suitable for generating pairs from very large inputs: we don&amp;#8217;t advance through S quickly enough. In fact, if T were infinite, we&amp;#8217;d be stuck on the top row, forever generating pairs of the form &lt;code&gt;S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc3" name="toca-recursive-scheme" id="toca-recursive-scheme"&gt;A Recursive Scheme&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt; describes an elegant recursive scheme for &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_Temp_476"&gt;generating pairs&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Call the general stream of pairs (pairs S T), and consider it to be composed of three parts: the pair (S&lt;sub&gt;0&lt;/sub&gt;,T&lt;sub&gt;0&lt;/sub&gt;), the rest of the pairs in the first row, and the remaining pairs:&lt;br/&gt;&lt;br/&gt;
   &lt;img src="http://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-47.gif" alt="Stream of pairs structure"/&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Based on this insight, we can generate our stream of pairs:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     yielding the pair, (S&lt;sub&gt;0&lt;/sub&gt;,T&lt;sub&gt;0&lt;/sub&gt;)
 &lt;/li&gt;

 &lt;li&gt;
     yield pairs from the first row combined with the stream of remaining pairs
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note the recursion: the definition of the pairs stream refers to itself. That&amp;#8217;s not a problem so long as we&amp;#8217;re lazy about evaluating the tail of the stream. Since we always know how to pull the first pair from the stream, we can both bootstrap the process and keep going forever.
&lt;/p&gt;
&lt;p&gt;All we now need is a suitable method of combining two the first row and the remaining pairs.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc4" name="tocinterleaving" id="tocinterleaving"&gt;Interleaving&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The simplest way to combine the two streams is just to interleave them, pulling elements from each in turn. A simple (too simple!) implementation of &lt;code&gt;interleave()&lt;/code&gt; reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Simple interleave&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def interleave(s, t):
    while True:
        yield s.next()
        yield t.next()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(The problem here is that &lt;code&gt;interleave()&lt;/code&gt; stops as soon as either of the the input streams is exhausted, which isn&amp;#8217;t an issue for infinite streams, but isn&amp;#8217;t ideal in the case when either of the inputs are bounded. You get the idea. I&amp;#8217;ll provide better implementation &lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#tying-up"&gt;later&lt;/a&gt;.)
&lt;/p&gt;
&lt;p&gt;We can now code our pairs generator:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Pairs generator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;import itertools

def pairs(s, t):
    """ Generate a stream of pairs taken from s, t.
    
    Yields a stream of pairs (si, tj) where i &amp;lt;= j.
    The input streams may be finite or bounded, but must be iterable.
    """
    first = s.next(), t.next()
    yield first
    t, t_top = itertools.tee(t)
    s0 = first[0]
    top_row = ((s0, tt) for tt in t_top)
    for st in interleave(top_row, pairs(s, t)):
        yield st

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a slideshow of this algorithm in action.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-stream.gif" alt="Pair stream slideshow"/&gt;

&lt;p&gt;Even though Python (CPython, to be specific) and recursion don&amp;#8217;t generally get along well (unlike in a proper functional programming language), this implementation doesn&amp;#8217;t &lt;em&gt;appear&lt;/em&gt; to fall foul of CPython&amp;#8217;s maximum recursion limits &lt;strong&gt;even though pairs() repeatedly calls itself&lt;/strong&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;No maximum recursion depth exceeded error here!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; integers = itertools.count
&amp;gt;&amp;gt;&amp;gt; for ij in pairs(integers, integers):
... 	print ij
... 
(0, 0)
(0, 1)
(1, 1)
(0, 2)
(1, 2)
(0, 3)
(2, 2)
....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;When I dug a little deeper, I started to understand why: the function can&amp;#8217;t run indefinitely since it eats up memory. It continually tees up iterators over &lt;code&gt;t&lt;/code&gt; and creates new generator expressions.
&lt;/p&gt;
&lt;p&gt;That said, I was surprised just how quickly it consumes memory. After all, generator expressions and iterators shouldn&amp;#8217;t take up much space. For the purposes of comparison, I compared how it fared against a Scheme program designed to do the same thing. Both had consumed a gigabyte of memory after running just a few minutes (and, for what it&amp;#8217;s worth, the Python program had generated an order of magnitude more pairs by this point).
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Scheme pair generator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;(require (lib "40.ss" "srfi")) ;; Scheme stream support

(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (stream-cons (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define (pairs s t)
  (stream-cons
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))

(define ones (stream-cons 1 ones))

(define (stream-add s t) (stream-map + s t))

(define integers
  (stream-cons 0 (stream-add ones integers)))

(stream-for-each
  (lambda (x) (newline) (display x))
  (pairs integers integers))

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc5" name="tocdouble-trouble" id="tocdouble-trouble"&gt;Double Trouble&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s look a little further into the stream. Here&amp;#8217;s the genesis of the first 120 pairs.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-stream-120.gif" alt="Pair stream slideshow"/&gt;

&lt;p&gt;Now the pattern becomes clear. Evidently the interleave strategy gives a heavy bias towards advancing rightwards; downwards motion is relatively slow.
&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s filter out the &lt;code&gt;i == j&lt;/code&gt; diagonal to try and quantify this.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; ints = itertools.count
&amp;gt;&amp;gt;&amp;gt; izip = itertools.izip
&amp;gt;&amp;gt;&amp;gt; pp = pairs(ints(), ints())
&amp;gt;&amp;gt;&amp;gt; diagonal = ((ix, (i, j))
...             for ix, (i, j) in izip(ints(1), pp) if i == j))
&amp;gt;&amp;gt;&amp;gt; for d in itertools.islice(diagonal, 10):
...     print d
...
(1, (0, 0))
(3, (1, 1))
(7, (2, 2))
(15, (3, 3))
(31, (4, 4))
(63, (5, 5))
(127, (6, 6))
(255, (7, 7))
(511, (8, 8))
(1023, (9, 9))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The output shows that pair (0, 0) is the 1&lt;sup&gt;st&lt;/sup&gt; element of the stream, (1, 1) the 3&lt;sup&gt;rd&lt;/sup&gt;, (2, 2) the 7&lt;sup&gt;th&lt;/sup&gt;, and so on.
&lt;/p&gt;
&lt;p&gt;Any computer scientist ought to quickly spot the pattern, and any mathematician ought to be able to prove why diagonal advances are exponentially infrequent.
&lt;/p&gt;
&lt;p&gt;Loosely speaking, if D&lt;sub&gt;i&lt;/sub&gt; is the stream of positions in the pairs stream of elements which lie on the diagonal (i.e. the stream 1, 3, 7, 15, &amp;#8230; shown in the interpreted Python session), then the elements of D must satisfy the recurrence relation:
&lt;/p&gt;
&lt;pre&gt;
D&lt;sub&gt;i+1&lt;/sub&gt; = 1 + 2&amp;times;D&lt;sub&gt;i&lt;/sub&gt;
&lt;/pre&gt;

&lt;p&gt;This relation derives directly from the recursive definition of &lt;code&gt;pairs()&lt;/code&gt;: yield a single element, then alternate the rest of yourself with the generated top row.
&lt;/p&gt;
&lt;p&gt;Here are some slides showing the points at which the first 5 diagonal elements appear. Watch the recursive pattern emerge.
&lt;/p&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/files/pairs-1.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-3.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-7.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-15.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-31.png" alt="diagonal pairs image"/&gt;
&lt;/p&gt;
&lt;p&gt;The solution to the recurrence relation is &lt;code&gt;D&lt;sub&gt;i&lt;/sub&gt; = 2&lt;sup&gt;i&lt;/sup&gt; &amp;minus; 1&lt;/code&gt;. These diagonal advances correspond to recursive calls to &lt;code&gt;pairs()&lt;/code&gt;. So if our Python session has a recursion limit set to 1000 (try &lt;code&gt;sys.getrecursionlimit()&lt;/code&gt;), and our pairs generator were to yield a result every nanosecond, and we had a machine with infinite memory, it would take quite a few millenia before we run into this limit.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;How many millenia until we hit the recursion limit?&lt;/div&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; (2 ** 1000 - 1)/(1.e9 * 60 * 60 * 24 * 365 * 1000) 
3.3977315042689856e+281

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc6" name="tocmemory-use" id="tocmemory-use"&gt;Memory Use&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It should also now be clear why this particular algorithm burns memory. Teeing an iterator doesn&amp;#8217;t magically mean we don&amp;#8217;t have to store any elements we&amp;#8217;ve iterated past. The greater the distance between the teed iterators, the more that need storing.
&lt;/p&gt;
&lt;p&gt;If that&amp;#8217;s not clear, run the following Python session and keep an eye on memory consumption (and be ready to interrupt the infinite loop!). You&amp;#8217;ll see memory use rapidly increase as &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; diverge, since &lt;code&gt;j&lt;/code&gt; needs to remember everything &lt;code&gt;i&lt;/code&gt; produces.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import *
&amp;gt;&amp;gt;&amp;gt; i, j = tee(repeat(0))
&amp;gt;&amp;gt;&amp;gt; for x in i: pass

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;By contrast, if we zip through &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; in parallel, memory use is stable.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; i, j = tee(repeat(0))
&amp;gt;&amp;gt;&amp;gt; for ij in izip(i, j): pass

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Our pair generator has to remember more and more elements from the &lt;code&gt;T&lt;/code&gt; stream (and also, to a lesser extent, from the &lt;code&gt;S&lt;/code&gt; stream). That&amp;#8217;s why it&amp;#8217;s so hungry. Any general purpose infinite pair generator function must suffer this problem, I think, since we &lt;strong&gt;have&lt;/strong&gt; to accumulate increasing portions of the streams into memory, but if it&amp;#8217;s just integer pairs we want we can work around the issue:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def integer_pairs(i=0):
    "Generate a stream of integer pairs (i, j) with i &amp;lt;= j"
    yield i, i
    top_row = ((i, j) for j in itertools.count(i + 1))
    for ij in interleave(top_row, integer_pairs(i + 1)):
        yield ij

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, rather than &lt;code&gt;tee()&lt;/code&gt; streams of integers, we use &lt;code&gt;itertools.count()&lt;/code&gt; to create new ones as required. This pair generator will run happily for extended periods. It will very gradually ask for more memory, as numbers get bigger and the number of rows increases. As before, it won&amp;#8217;t hit any embarrassing recursion limits in the lifetime of this galaxy.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc7" name="tocproblem-solved" id="tocproblem-solved"&gt;Problem Solved?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So, does &lt;code&gt;integer_pairs()&lt;/code&gt; solve the problem of generating an infinite stream of pairs for the special case when both input streams are integers? 
&lt;/p&gt;
&lt;p&gt;Not really, no!
&lt;/p&gt;
&lt;p&gt;The interleave strategy for combining the top row with the remaining pairs has the great merit of simplicity, but is otherwise far from ideal. I don&amp;#8217;t think a one-size-fits-all strategy for streaming pairs exists, so we should allow clients to supply one. And that will have to be the subject of another article.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc8" name="toctying-up" id="toctying-up"&gt;Tying up&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s not hard to fix the problem we noticed with &lt;code&gt;interleave()&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def interleave(s, t):
    """Generate an interleaved stream of elements from s and t.
    
    If one of the streams finishes, elements continue to be generated
    from the other until it too is finished. 
    """
    for ss, tt in itertools.izip(s, t):
        yield ss
        yield tt
    for s_or_t in itertools.chain(s, t):
        yield s_or_t

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s the script I used to generate the animated GIFs. Although it&amp;#8217;s very much geared to doing the single job which it was designed to do, it&amp;#8217;s short enough to be used as a basis for similar tasks. I hope this article helps demonstrate the merits of visualising an algorithm in action.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;pairs-animation.py&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#! /usr/bin/env python
"""Script which accepts a list of (i, j) pairs, creating slides and
   an animated GIF showing the positions of these pairs.

Example use:
$ echo '((0, 0) (0, 1) (1, 1) (0, 2) (1, 2) (0, 3) (2, 2)' | pairs-animation.py

Dependencies:
- Python Imaging Library (PIL), http://effbot.org/imagingbook/
- aggdraw, anti-aliased graphics drawing package,
  http://effbot.org/zone/pythondoc-aggdraw.htm
- ImageMagick, http://www.imagemagick.org
"""
import Image
import aggdraw
import itertools

# Script wide drawing configuration
block_w = 16
block_pad = 2

def fading_brushes():
    "Generate a sequence of fading grey brushes."
    darkgrey = itertools.repeat(16)
    greyscale = itertools.chain(range(255, 0, -16), darkgrey)
    def brush(g):
        "Return a grey brush."
        return aggdraw.Brush('rgb(%d,%d,%d)' % (g, g, g))
    return itertools.imap(brush, greyscale)

def block_start(i):
    "Return the coordinate (X or Y) at which the ith block starts."
    return (block_w + block_pad) * i + block_pad

def read_ij(data):
    """Return pairs of integers found in the input string.
    
    Note: this function is extremely unfussy about the string format!
    &amp;gt;&amp;gt;&amp;gt; read_ij('1 2 3 4')
    [(1, 2), (3, 4)]
    &amp;gt;&amp;gt;&amp;gt; read_ij('(1, 2), (3, 4)')
    [(1, 2), (3, 4)]
    """
    import re
    ij = itertools.imap(int, re.compile(r'-?\d+').findall(data))
    return zip(ij, ij)

def dimensions(ij):
    "Return dimensions of an image big enough to contain blocks at ij positions."
    import operator
    max_i = max(map(operator.itemgetter(0), ij))
    max_j = max(map(operator.itemgetter(1), ij))
    return block_start(max_j + 1), block_start(max_i + 1)

def block_xy(ij):
    "Return the left, top, right, bottom coords of a block at ij."
    ylo, xlo = map(block_start, ij)
    return xlo, ylo, xlo + block_w, ylo + block_w

def draw_blocks(image, blocks):
    "Draws the supplied blocks onto the input image."
    draw = aggdraw.Draw(image)
    brushes = fading_brushes()
    # Reverse the blocks so the newest are brightest
    for block, brush in itertools.izip(reversed(blocks), brushes):
        # The 'ellipse' will be circular since the block is square
        draw.ellipse(block_xy(block), brush)
    draw.flush()

def main(ij_data):
    "Creates slides and an animation from the ij block positions."
    import os
    ij = read_ij(ij_data)
    dims = dimensions(ij)
    # Create the slides
    slides = ['pairs-%d.gif' % n for n in range(len(ij) + 1)]
    for n, slide in enumerate(slides):
        image = Image.new('L', dims)
        draw_blocks(image, ij[:n])
        image.save(slide)
    # Use ImageMagick to create an animation
    # -loop 0 =&amp;gt; loop forever, -delay units are .01 seconds
    os.system('convert -delay 100 -loop 0 %s animation.gif'
              % ' '.join(slides))

if __name__ == '__main__':
    import sys
    main(sys.stdin.read())

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams.html#toc9" name="toccredits" id="toccredits"&gt;Credits&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The inspiration for this article comes directly from &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_Temp_476"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt;, which presents some great examples of how to develop and use these pair streams.
&lt;/p&gt;</description>
<dc:date>2008-01-13</dc:date>
<guid>http://wordaligned.org/articles/animated-pair-streams.html</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/animated-pair-streams.html</link>
<category>Scheme</category>
</item>

<item>
<title>The Maximum Sum contiguous subsequence problem</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#tocwelcome-to-the-pearly-gates" name="toc0" id="toc0"&gt;Welcome to the Pearly Gates&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#tocprogramming-pearl" name="toc1" id="toc1"&gt;Programming Pearl&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toclinear-solution" name="toc2" id="toc2"&gt;Linear Solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#tocstreaming-solution" name="toc3" id="toc3"&gt;Streaming Solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#tocstream-accumulate" name="toc4" id="toc4"&gt;Stream Accumulate&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#tocstream-floor" name="toc5" id="toc5"&gt;Stream Floor&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#tocstream-diff" name="toc6" id="toc6"&gt;Stream Diff&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#tocstreams-and-collections" name="toc7" id="toc7"&gt;Streams and Collections&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#tocstream-on" name="toc8" id="toc8"&gt;Stream on&amp;#8230;&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toc0" name="tocwelcome-to-the-pearly-gates" id="tocwelcome-to-the-pearly-gates"&gt;Welcome to the Pearly Gates&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Pearly Gates club never closes. Its public entrance, a revolving door, just keeps on spinning. With each rotation some punters enter and others leave. The club&amp;#8217;s owners would like to track this traffic. Specifically, they&amp;#8217;d like to know the maximum increase in people entering the club over a given period.
&lt;/p&gt;
&lt;p&gt;The starting point is to track the people who enter/leave with each spin of the door. Here&amp;#8217;s a 5 minute sample of that information. Negative numbers mean more people left than entered during a particular cycle.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Entries Log&lt;/div&gt;

&lt;pre class="prettyprint"&gt;0 1 2 -3 3 -1 0 -4 0 -1 -4 2 4 1 1 3 1 0 -2 -3 -3 -2 3 1 1 4 5 -3 -2 -1 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s the same information plotted on a graph.
&lt;/p&gt;
&lt;img alt="Graph of entries to Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Entries+to+the+Pearly+Gates+club
&amp;amp;chs=500x200
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-5.0,6.0
&amp;amp;chd=t:45.5,45.5|45.5,54.5,63.6,18.2,72.7,36.4,45.5,9.1,45.5,36.4,9.1,63.6,81.8,54.5,54.5,72.7,54.5,45.5,27.3,18.2,18.2,27.3,72.7,54.5,54.5,81.8,90.9,18.2,27.3,36.4
&amp;amp;chco=BBBBBB,0000CC
&amp;amp;chls=1,1,0|4,1,0
" /&gt;

&lt;p&gt;The archetypal problem we&amp;#8217;d like to solve can be stated:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;Given a sequence of numbers, find the maximum sum of a contiguous subsequence of those numbers.&lt;/strong&gt; 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;As an example, the maximum sum contiguous subsequence of 0, -1, &lt;strong&gt;2, -1, 3&lt;/strong&gt;, -1, 0 would be 4 (= 2 + -1 + 3).
&lt;/p&gt;
&lt;p&gt;This problem is generally known as &lt;strong&gt;the maximum sum contiguous subsequence problem&lt;/strong&gt; and if you haven&amp;#8217;t encountered it before, I&amp;#8217;d recommend trying to solve it before reading on. Even if you have encountered it before, I&amp;#8217;ll invite you to read on anyway &amp;#8212; it&amp;#8217;s well worth another look.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toc1" name="tocprogramming-pearl" id="tocprogramming-pearl"&gt;Programming Pearl&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The maximum sum contiguous subsequence problem appears in Jon Bentley&amp;#8217;s &lt;a href="http://www.cs.bell-labs.com/cm/cs/pearls/"&gt;&amp;#8220;Programming Pearls&amp;#8221;&lt;/a&gt;. He first presents a brute force solution which examines all possible contiguous subsequences of the initial sequence and returns the maximum sum of these subsequences.
&lt;/p&gt;
&lt;p&gt;A Python implementation might read:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def generate_pairs(n):
    "Generate all pairs (i, j) such that 0 &amp;lt;= i &amp;lt;= j &amp;lt; n"
    for i in range(n):
        for j in range(i, n):
            yield i, j

def max_sum_subsequence(seq):
    "Return the max-sum contiguous subsequence of the input sequence."
    return max(sum(seq[i:j])
               for i, j in generate_pairs(len(seq) + 1))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s a straightforward piece of code, though note the &lt;code&gt;+ 1&lt;/code&gt; which ensures that we slice to the end of &lt;code&gt;seq&lt;/code&gt;, and also that we include empty slices, which sum to &lt;code&gt;0&lt;/code&gt;, handling the case when every item in the sequence is negative. The trouble is, the algorithm is of cubic complexity: to process just 6 hours of logged activity takes over 2 minutes on a 2GHz Intel Core Duo MacBook, and the cubic nature of the algorithm means we&amp;#8217;d quickly fail to process more substantial log files in real time.
&lt;/p&gt;
&lt;img alt="Graph plotting accumulated entries to the Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Accumulated+entries+to+the+Pearly+Gates+club
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-8.0,10.0
&amp;amp;chd=t:44.4,50.0,55.6,27.8,61.1,38.9,44.4,22.2,44.4,38.9,22.2,55.6,66.7,50.0,50.0,61.1,50.0,44.4,33.3,27.8,27.8,33.3,61.1,50.0,50.0,66.7,72.2,27.8,33.3,38.9|44.4,50.0,61.1,44.4,61.1,55.6,55.6,33.3,33.3,27.8,5.6,16.7,38.9,44.4,50.0,66.7,72.2,72.2,61.1,44.4,27.8,16.7,33.3,38.9,44.4,66.7,94.4,77.8,66.7,61.1
&amp;amp;chco=CCCCCC,CC0000
&amp;amp;chls=3,1,0|3,1,0
&amp;amp;chdl=Entries|Accum.+Entries
" /&gt;

&lt;p&gt;A simple optimisation eliminates the repeated calls to &lt;code&gt;sum&lt;/code&gt; by accumulating the input sequence &amp;#8212; the red line in the graph above. Subtracting element &lt;code&gt;i-1&lt;/code&gt; from element &lt;code&gt;j&lt;/code&gt; of this cumulative sequence gives us the sum of elements in the range i, j of the original sequence. We won&amp;#8217;t study the code for this quadratic solution &amp;#8212; it doesn&amp;#8217;t add much to our analysis. Again, some care is needed to avoid &lt;a href="http://wordaligned.org/articles/joined-output-and-the-fencepost-problem.html"&gt;fencepost problems&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;We won&amp;#8217;t look at the divide-and-conquer NlogN solution either. It&amp;#8217;s hard to understand, and we can do far better.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toc2" name="toclinear-solution" id="toclinear-solution"&gt;Linear Solution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There is a linear solution. The idea is to scan the sequence from start to finish keeping track of &lt;code&gt;maxsofar&lt;/code&gt;, the maximum sum of a contiguous subsequence seen so far, and &lt;code&gt;maxendinghere&lt;/code&gt;, the maximum sum of a contiguous subsequence which ends at the current position. Bentley&amp;#8217;s pseudo-code reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;maxsofar = 0
maxendinghere = 0
for i = [0, n)
    /* invariant: maxendinghere and maxsofar are accurate
       are accurate for x[0..i-1] */
    maxendinghere = max(maxendinghere + x[i], 0)
    maxsofar = max(maxsofar, maxendinghere)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This translates directly into Python.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def max_sum_subsequence(seq):
    maxsofar = 0
    maxendinghere = 0
    for s in seq:
        # invariant: maxendinghere and maxsofar are accurate
        # are accurate up to s
        maxendinghere = max(maxendinghere + s, 0)
        maxsofar = max(maxsofar, maxendinghere)
    return maxsofar

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now, this is a fabulous solution. Bentley describes it as subtle. Such a succinct code snippet hardly &lt;strong&gt;looks&lt;/strong&gt; subtle, but I agree, the loop body &lt;strong&gt;does&lt;/strong&gt; take a bit of understanding:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;maxendinghere = max(maxendinghere + s, 0)
maxsofar = max(maxsofar, maxendinghere)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Why does this work?&lt;/strong&gt; 
&lt;/p&gt;
&lt;p&gt;Well, essentially maxendinghere is what&amp;#8217;s accumulating the subsequences &amp;#8212; it keeps rolling the next element into itself. Should this accumulated sum ever become negative we know that the subsequence-which-ends-here we&amp;#8217;re currently tracking is worse than the empty subsequence-which-restarts-here; so we can reset our subsequence accumulator, and the first clause of the loop invariant still holds. Combine this with the observation that maxsofar tracks peaks in maxendinghere and we&amp;#8217;re done.
&lt;/p&gt;
&lt;p&gt;The loop-invariant comment provides a good example of how comments can help us understand an algorithm, even though the code is minimal and the variable names are well-chosen.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toc3" name="tocstreaming-solution" id="tocstreaming-solution"&gt;Streaming Solution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I prefer to think of this problem in terms of streams &amp;#8212; lazily evaluated sequences. Think of our log file as generating a stream of numbers:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;... 0 1 2 -3 3 -1 0 -4 0 -1 -4 2 4 1 1 3 1 0 -2 -3 -3 -2 3 1 1 4 5 -3 -2 -1 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The first thing we do is transform this stream to generate another stream, the cumulative sum of numbers seen so far. It&amp;#8217;s an integration of sorts. You&amp;#8217;ll remember we already used this stream, or an in-memory version of it, in our quadratic solution to the problem: the difference between points on it yields subsequence-sums.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toc4" name="tocstream-accumulate" id="tocstream-accumulate"&gt;Stream Accumulate&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;We generate the accumulated stream from our original stream like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def stream_accumulate(stream):
    total = 0
    for s in stream:
        total += s
        yield total

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The graph below samples the first five minutes of this stream. The red line accumulates values from the pale grey line.
&lt;/p&gt;
&lt;img alt="Graph plotting accumulated entries to the Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-8.0,10.0
&amp;amp;chd=t:44.4,50.0,55.6,27.8,61.1,38.9,44.4,22.2,44.4,38.9,22.2,55.6,66.7,50.0,50.0,61.1,50.0,44.4,33.3,27.8,27.8,33.3,61.1,50.0,50.0,66.7,72.2,27.8,33.3,38.9|44.4,50.0,61.1,44.4,61.1,55.6,55.6,33.3,33.3,27.8,5.6,16.7,38.9,44.4,50.0,66.7,72.2,72.2,61.1,44.4,27.8,16.7,33.3,38.9,44.4,66.7,94.4,77.8,66.7,61.1
&amp;amp;chm=x,FFCC33,1,10.0,20.0|x,FFCC33,1,26.0,20.0
&amp;amp;chco=CCCCCC,CC0000
&amp;amp;chls=3,1,0|3,1,0
&amp;amp;chdl=Entries|Accum.+Entries
" /&gt;

&lt;p&gt;These accumulated numbers represent the number of members who have entered the club since we started tracking them. On our graph, the maximum sum contiguous subsequence is simply the greatest Y-increase between any two points on this graph. X&amp;#8217;s mark these points on the graph above. (Note: it&amp;#8217;s &lt;strong&gt;not&lt;/strong&gt; the Y-range of the graph we want since our X-values are time-ordered, and we require X1 &amp;lt;= X2). 
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toc5" name="tocstream-floor" id="tocstream-floor"&gt;Stream Floor&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;A second transformation yields the floor of the accumulated stream.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import sys

def stream_floor(stream):
    m = 0
    for s in stream:
        m = min(m, s)
        yield m

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Note that, for our purposes, the floor of the stream isn&amp;#8217;t exactly the stream of minimum values taken by the stream &amp;#8212; we enforce a baseline at zero. It would be better to allow clients of this function to supply an optional baseline value, but I wanted the simplest possible code that shows the idea.)
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a graph plotting the accumulated entries alongside the floor of these entries.
&lt;/p&gt;
&lt;img alt="Graph plotting accumulated entries and floor of accumulated entries to the Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-8.0,10.0
&amp;amp;chd=t:44.4,50.0,61.1,44.4,61.1,55.6,55.6,33.3,33.3,27.8,5.6,16.7,38.9,44.4,50.0,66.7,72.2,72.2,61.1,44.4,27.8,16.7,33.3,38.9,44.4,66.7,94.4,77.8,66.7,61.1|44.4,44.4,44.4,44.4,44.4,44.4,44.4,33.3,33.3,27.8,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6
&amp;amp;chco=CC0000,333333
&amp;amp;chls=3,1,0|3,1,0
&amp;amp;chm=b,CCCCCC,0,1,0
&amp;amp;chdl=Accum.+Entries|Floor+Accum.+Entries
" /&gt;

&lt;p&gt;We&amp;#8217;re very close to what we want now. We can track Y-increases on the graph just by generating the difference between the accumulated stream and its floor &amp;#8212; the shading on the graph.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toc6" name="tocstream-diff" id="tocstream-diff"&gt;Stream Diff&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Here&amp;#8217;s an implementation of &lt;code&gt;stream_diff&lt;/code&gt;. We can&amp;#8217;t just plug a minus sign &amp;#8220;-&amp;#8221; into the mapping function, so we have to use the less wieldy &lt;code&gt;operator.sub&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools
import operator

def stream_diff(s, t):
    return itertools.imap(operator.sub, s, t)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Alternatively, we could generate the new stream with an explicit loop:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools

def stream_diff(s, t):
    for ss, tt in itertools.izip(s, t):
        yield ss - tt

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The final graph shows us the difference between the accumulated entry count and its floor. I&amp;#8217;ve also added the ceiling of this stream as a thick red line (I&amp;#8217;m sure you can figure out how to implement &lt;code&gt;stream_ceiling&lt;/code&gt;), and this ceiling represents the stream of maximum sum contiguous subsequences. 
&lt;/p&gt;
&lt;img alt="Graph plotting Max-ends-here and Max-so-far" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Maximum+Subsequences+at+the+Pearly+Gates+club
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,0.0,17.0
&amp;amp;chd=t:0.0,5.9,17.6,17.6,17.6,17.6,17.6,17.6,17.6,17.6,17.6,17.6,35.3,41.2,47.1,64.7,70.6,70.6,70.6,70.6,70.6,70.6,70.6,70.6,70.6,70.6,94.1,94.1,94.1,94.1|0.0,5.9,17.6,0.0,17.6,11.8,11.8,0.0,0.0,0.0,0.0,11.8,35.3,41.2,47.1,64.7,70.6,70.6,58.8,41.2,23.5,11.8,29.4,35.3,41.2,64.7,94.1,76.5,64.7,58.8|0.0,0.0
&amp;amp;chco=aa0000,333333
&amp;amp;chls=4,1,0|2,1,0
&amp;amp;chm=b,CCCCCC,1,2,0
&amp;amp;chdl=Max-so-far|Max-ending-here
" /&gt;

&lt;p&gt;We&amp;#8217;ve re-labelled the lines &lt;code&gt;Max-so-far&lt;/code&gt; and &lt;code&gt;Max-ending-here&lt;/code&gt; because they&amp;#8217;re the stream of values taken by the variables &lt;code&gt;maxsofar&lt;/code&gt; and &lt;code&gt;maxendinghere&lt;/code&gt; during Bentley&amp;#8217;s clever solution to the maximum sum contiguous subsequence problem. I think we&amp;#8217;re in a better position to understand how this solution works now.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toc7" name="tocstreams-and-collections" id="tocstreams-and-collections"&gt;Streams and Collections&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Please don&amp;#8217;t imagine these streams are bloated. &lt;span /&gt;They may be infinite (remember the Pearly Gates club never closes!) but that doesn&amp;#8217;t mean they take up much space. The graphs shown represent snapshots of their activity, and at no point do our presented algorithms actually store a five minute buffer of entries.
&lt;/p&gt;
&lt;p&gt;A final solution to the maximum sum contiguous subsequence problem reads like this. We&amp;#8217;ve pushed the general purpose stream transformation functions into a separate module, &lt;code&gt;stream.py&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools
import stream

def max_sum_subsequence_stream(ss):
    "Return the stream of max sum contiguous subsequences of the input iterable."
    accu1, accu2 = itertools.tee(stream.accumulate(ss))
    return stream.ceil(stream.diff(accu1, 
                       stream.floor(accu2, baseline=0)))

def max_sum_subsequence(ss):
    "Return the max sum of a contiguous subsequence of the input iterable."
    return stream.last(max_sum_subsequence_stream(ss))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The iterable supplied to &lt;code&gt;max_sum_subsequence&lt;/code&gt; has its last value read, and should therefore be bounded if we want the function to return. We haven&amp;#8217;t supplied arguments to extract a portion of this iterable (to generate maximum subsequences for the club on a particular day, for example) because that&amp;#8217;s what &lt;code&gt;itertools.islice&lt;/code&gt; is for.
&lt;/p&gt;
&lt;p&gt;Note that &lt;code&gt;max_sum_subsequence_stream()&lt;/code&gt; may be more useful to clients than &lt;code&gt;max_sum_subsequence()&lt;/code&gt;. Suppose, for example, we&amp;#8217;re only interested when the maximum sum subsequence exceeds 100. We can do this directly by connecting &lt;code&gt;itertools.dropwhile()&lt;/code&gt; to our function.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def max_subseq_exceeds(seq, limit=100):
    max_sub_s = max_sum_subsequence_stream(seq)
    return itertools.dropwhile(lambda s: s &amp;lt;= limit, max_sub_s)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Perhaps we&amp;#8217;d like to know if the maximum sum subsequence reaches a plateau; that is, it stays on a level for a while.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s the stream module.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;stream.py&lt;/div&gt;

&lt;pre class="prettyprint"&gt;"General purpose stream generation functions."
import itertools

def floor(stream, baseline=None):
    """Generate the stream of minimum values from the input stream.
    
    The baseline, if supplied, is an upper limit for the floor.
    &amp;gt;&amp;gt;&amp;gt; ff = floor((1, 2, -2, 3))
    &amp;gt;&amp;gt;&amp;gt; assert list(ff) == [1, 1, -2, -2]
    &amp;gt;&amp;gt;&amp;gt; ff = floor((1, 2, -2, 3), 0)
    &amp;gt;&amp;gt;&amp;gt; assert list(ff) == [0, 0, -2, -2]    
    """
    stream = iter(stream)
    m = baseline
    if m is None:
        try:
            m = stream.next()
            yield m
        except StopIteration:
            pass
    for s in stream:
        m = min(m, s)
        yield m

def ceil(stream):
    """Generate the stream of maximum values from the input stream.
    
    &amp;gt;&amp;gt;&amp;gt; top = ceil([0, -1, 2, -2, 3])
    &amp;gt;&amp;gt;&amp;gt; assert list(top) == [0, 0, 2, 2, 3]
    """
    stream = iter(stream)
    try:
        M = stream.next()
        yield M
    except StopIteration:
        pass
    for s in stream:
        M = max(M, s)
        yield M

def accumulate(stream):
    """Generate partial sums from the stream.
    
    &amp;gt;&amp;gt;&amp;gt; accu = accumulate([1, 2, 3, 4])
    &amp;gt;&amp;gt;&amp;gt; assert list(accu) == [1, 3, 6, 10]
    """
    total = 0
    for s in stream:
        total += s
        yield total

def diff(s, t):
    """Generate the differences between two streams
    
    If the streams are of unequal length, the shorter is truncated.
    &amp;gt;&amp;gt;&amp;gt; dd = diff([2, 4, 6, 8], [1, 2, 3])
    &amp;gt;&amp;gt;&amp;gt; assert list(dd) == [1, 2, 3]
    """
    import operator
    return itertools.imap(operator.sub, s, t)

def last(stream, default=None):
    """Return the last item in the stream or the default if the stream is empty.
    
    &amp;gt;&amp;gt;&amp;gt; last('abc')
    'c'
    &amp;gt;&amp;gt;&amp;gt; last([], default=-1)
    -1
    """
    s = default
    for s in stream:
        pass
    return s

if __name__ == "__main__":
    import doctest
    doctest.testmod()

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#toc8" name="tocstream-on" id="tocstream-on"&gt;Stream on&amp;#8230;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;The maximum sum contiguous subsequence problem is described in &lt;a href="http://www.cs.bell-labs.com/cm/cs/pearls/"&gt;&amp;#8220;Programming Pearls&amp;#8221;&lt;/a&gt; by Jon Bentley. 
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;My favourite introduction to computer programming, &amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;, has &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5"&gt;lots to say about streams&lt;/a&gt;, and suggests they have a role in concurrent programming and modelling time. 
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;Streams are a natural fit with functional programming, and well supported by languages like &lt;a href="http://www.schemers.org"&gt;Scheme&lt;/a&gt; and &lt;a href="http://haskell.org"&gt;Haskell&lt;/a&gt;. Python also handles them nicely: look into &lt;a href="http://www.python.org/dev/peps/pep-0255/"&gt;generators&lt;/a&gt;, &lt;a href="http://www.python.org/dev/peps/pep-0289/"&gt;generator expressions&lt;/a&gt;, the &lt;a href="http://docs.python.org/lib/module-itertools.html"&gt;itertools module&lt;/a&gt;, and study &lt;code&gt;test_generators.py&lt;/code&gt; carefully.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;If you liked this article, try more Word Aligned articles &lt;a href="http://wordaligned.org/tag/streams/"&gt;tagged &amp;#8220;streams&amp;#8221;&lt;/a&gt;. And if you like puzzles, there are more articles &lt;a href="http://wordaligned.org/tag/puzzles/"&gt;tagged &amp;#8220;puzzles&amp;#8221;&lt;/a&gt; too.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;The graphs in this article are generated using the &lt;a href="http://code.google.com/apis/chart/"&gt;Google chart API&lt;/a&gt;, which is both useful and &lt;span /&gt;a fine example of how to design and document a programming interface.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;</description>
<dc:date>2007-12-17</dc:date>
<guid>http://wordaligned.org/articles/the-maximum-subsequence-problem.html</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/the-maximum-subsequence-problem.html</link>
<category>Scheme</category>
</item>

<item>
<title>Elegance and Efficiency</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocwhat-is-elegant-code" name="toc0" id="toc0"&gt;What is Elegant Code?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocappearance" name="toc1" id="toc1"&gt;Appearance&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocuse-of-standard-libraries" name="toc2" id="toc2"&gt;Use of standard libraries&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocplanar-vectors-in-scheme" name="toc3" id="toc3"&gt;Planar vectors in Scheme&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocminimalism-and-simplicity" name="toc4" id="toc4"&gt;Minimalism and Simplicity&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocefficiency-and-elegance" name="toc5" id="toc5"&gt;Efficiency and Elegance?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocelegance-and-inefficiency" name="toc6" id="toc6"&gt;Elegance and Inefficiency?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocislipogram1" name="toc7" id="toc7"&gt;is_lipogram1&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocislipogram2--3" name="toc8" id="toc8"&gt;is_lipogram2 &amp;amp; 3&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocislipogram4" name="toc9" id="toc9"&gt;is_lipogram4&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocislipogram5" name="toc10" id="toc10"&gt;is_lipogram5&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocislipogram6" name="toc11" id="toc11"&gt;is_lipogram6&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocwinding-up" name="toc12" id="toc12"&gt;Winding Up&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#tocc-source-code" name="toc13" id="toc13"&gt;C++ Source Code&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;Elegant code is often efficient. Think of the heap data structure, for example, which always remains exactly as sorted as it needs to be, making it perfect for modelling priority queues. It&amp;#8217;s both elegant and efficient &amp;mdash; and dazzlingly so.
&lt;/p&gt;
&lt;img src="http://upload.wikimedia.org/wikipedia/commons/b/bf/Max-heap.png" width="50%" alt="Heap graphic"/&gt;

&lt;p&gt;This article discusses the relationship between elegance and efficiency in more depth, and asks the question: &lt;strong&gt;Can inefficient code ever be elegant?&lt;/strong&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc0" name="tocwhat-is-elegant-code" id="tocwhat-is-elegant-code"&gt;What is Elegant Code?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;First, we should consider what&amp;#8217;s meant by &amp;#8220;elegant code&amp;#8221;.
&lt;/p&gt;
&lt;p&gt;Anthony Williams discusses this very subject in a recent blog &lt;a href="http://www.justsoftwaresolutions.co.uk/design/elegance-in-software.html"&gt;post&lt;/a&gt; (which is what got me thinking about it in the first place). Up front he admits the search for elegance is subjective and that the factors he lists are all &lt;em&gt;&amp;#8220;my opinion&amp;#8221;&lt;/em&gt;. He also points out his list is not exhaustive. Nonetheless, it&amp;#8217;s a good starting point, and I&amp;#8217;d like to build on it. Let&amp;#8217;s start by summarising his list here.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Factors affecting the elegance of software
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Does it work?
 &lt;/li&gt;

 &lt;li&gt;
     Is it easy to understand?
 &lt;/li&gt;

 &lt;li&gt;
     Is it efficient?
 &lt;/li&gt;

 &lt;li&gt;
     Short functions
 &lt;/li&gt;

 &lt;li&gt;
     Good naming
 &lt;/li&gt;

 &lt;li&gt;
     Clear division of responsibility
 &lt;/li&gt;

 &lt;li&gt;
     High cohesion
 &lt;/li&gt;

 &lt;li&gt;
     Low coupling
 &lt;/li&gt;

 &lt;li&gt;
     Appropriate use of OO and other techniques
 &lt;/li&gt;

 &lt;li&gt;
     Minimal code
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc1" name="tocappearance" id="tocappearance"&gt;Appearance&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I&amp;#8217;m not sure this list completely nails elegance. For a start, there&amp;#8217;s no mention of appearance &amp;mdash; the way the code actually looks, on screen, or in print &amp;#8212; which in my opinion is fundamental. Elegant code looks clean, balanced, self-consistent.
&lt;/p&gt;
&lt;p&gt;&lt;span /&gt;That&amp;#8217;s one of the reasons I like Python: it&amp;#8217;s hard to get away with poorly laid out code. Scheme, with its minimal syntax, also wins here. Java stands a good chance of doing well on this front too, thanks to a clearly stated set of coding conventions and excellent IDE support for applying these conventions.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc2" name="tocuse-of-standard-libraries" id="tocuse-of-standard-libraries"&gt;Use of standard libraries&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I&amp;#8217;d also say that appropriate and even cunning use of the language&amp;#8217;s standard libraries can add to code&amp;#8217;s elegance. Williams hints at this with his mention of &lt;em&gt;Minimal Code&lt;/em&gt;, though minimalism covers many other things.
&lt;/p&gt;
&lt;p&gt;As an example, if you&amp;#8217;re using C++, you should take the time to become familiar with the standard library, and use it whenever possible. &lt;a href="http://www.artima.com/cppsource/lazy_builder.html"&gt;It works. It&amp;#8217;s efficient&lt;/a&gt;. In fact it embodies pretty much everything Williams lists, with a few notable exceptions (no one could describe &lt;code&gt;std::string&lt;/code&gt; as minimal, and &lt;code&gt;std::auto_ptr&lt;/code&gt; is notoriously slippery). Use the standard library and you&amp;#8217;ll save yourself code and time, and your own code will be the more elegant for it.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc3" name="tocplanar-vectors-in-scheme" id="tocplanar-vectors-in-scheme"&gt;Planar vectors in Scheme&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Let&amp;#8217;s return to Scheme to illustrate my point about cunning use of standard libraries and consider &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.46"&gt;exercise 2.46&lt;/a&gt; from the &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;Wizard Book&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;Exercise 2.46.&lt;/strong&gt;  A two-dimensional vector v running from the origin to a point can be represented as a pair consisting of an x-coordinate and a y-coordinate. Implement a data abstraction for vectors by giving a constructor make-vect and corresponding selectors xcor-vect and ycor-vect. In terms of your selectors and constructor, implement procedures add-vect, sub-vect, and scale-vect that perform the operations vector addition, vector subtraction, and multiplying a vector by a scalar.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;An obvious solution would be to model the 2-D vector as a pair.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;(define make-vect cons)
(define xcor-vect car)
(define ycor-vect cdr)

(define (add-vect v w)
  (make-vect (+ (xcor-vect v) (xcor-vect w))
             (+ (ycor-vect v) (ycor-vect w))))

(define (sub-vect v w)
  (make-vect (- (xcor-vect v) (xcor-vect w))
             (- (ycor-vect v) (ycor-vect w))))

(define (scale-vect s v)
  (make-vect (* s (xcor-vect v))
             (* s (ycor-vect v))))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;An elegant alternative builds on Scheme&amp;#8217;s support for complex numbers.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;;; represent 2-D vect using a complex number
(define make-vect make-rectangular)
(define xcor-vect real-part)
(define ycor-vect imag-part)

(define add-vect +)
(define sub-vect -)
(define scale-vect *)

;; some other vector operations come for free
(define magnitude-vect magnitude)
(define make-vect-from-polar-coords make-polar)
(define angle-vect angle)

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc4" name="tocminimalism-and-simplicity" id="tocminimalism-and-simplicity"&gt;Minimalism and Simplicity&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Elegance and beauty are not the same, though perhaps elegant forms a subset of beautiful. Elegance carries the additional connotation of simplicity, which itself correlates with minimalism. If I were forced to select the single item from Williams&amp;#8217; list most closely aligned to elegance, I&amp;#8217;d go for minimalism: allowed my own choice, it would be simplicity.
&lt;/p&gt;
&lt;p&gt;Williams notes a couple of ways you can remove to improve:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     avoid unnecessary layering 
 &lt;/li&gt;

 &lt;li&gt;
     eliminate duplication
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&amp;#8217;ve already added:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     use standard libraries
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kevlin Henney gives minimalism more careful attention in a series of &lt;a href="http://www.two-sdg.demon.co.uk/curbralan/papers.html"&gt;articles&lt;/a&gt;. &lt;a href="http://www.two-sdg.demon.co.uk/curbralan/papers/minimalism/OmitNeedlessCode.html"&gt;Omit Needless Code&lt;/a&gt; promotes:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Code that is simple and clear, brief and direct.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Henney illustrates his points with some elegant examples which reinforce my own claims about the C++ standard library
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;As an example, the common task of counting words in a text file or stream can be reduced to a single statement of executable C++ code &lt;a href="http://www.two-sdg.demon.co.uk/curbralan/papers/IfIHadAHammer.pdf"&gt;[Henney2001c]&lt;/a&gt; when built on the appropriate abstractions:&lt;/p&gt;
&lt;pre&gt;
typedef std::istream_iterator&amp;lt;std::string&amp;gt; in;
std::cout &amp;lt;&amp;lt; std::distance(in(std::cin), in());
&lt;/pre&gt;
&lt;p&gt;Want to count characters instead?&lt;/p&gt;
&lt;pre&gt;
typedef std::istreambuf_iterator&amp;lt;char&amp;gt; in;
std::cout &amp;lt;&amp;lt; std::distance(in(std::cin), in());
&lt;/pre&gt;
&lt;p&gt;Or lines?&lt;/p&gt;
&lt;pre&gt;
typedef std::istreambuf_iterator&amp;lt;char&amp;gt; in;
std::cout &amp;lt;&amp;lt; std::count(in(std::cin), in(), '\n');
&lt;/pre&gt;
&lt;p&gt;These fragments are all compact and fluffless, crisp and essential.&lt;/p&gt;&lt;/blockquote&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc5" name="tocefficiency-and-elegance" id="tocefficiency-and-elegance"&gt;Efficiency and Elegance?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Efficiency comes high on Williams&amp;#8217; list, right after correctness, which shouldn&amp;#8217;t be a surprise to anyone who writes code for a living. Surely code which doesn&amp;#8217;t run fast enough is about as useful as code which doesn&amp;#8217;t work? You could even note that efficiency is yet another aspect of minimalism: in this case, it&amp;#8217;s the machine&amp;#8217;s resource consumption you&amp;#8217;d like to reduce.
&lt;/p&gt;
&lt;img src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="Quicksort animation"/&gt;

&lt;p&gt;I&amp;#8217;m not convinced, though. It&amp;#8217;s true, many of the most elegant algorithms happen to be efficient too &amp;mdash; and may even have arisen from the quest for efficiency. Thus the standard quicksort algorithm has virtually no space overhead, and as a general purpose sorting algorithm, really can&amp;#8217;t be beaten. Similarly the &lt;a href="http://en.wikipedia.org/wiki/Heap_(data_structure)"&gt;heap&lt;/a&gt;, as already mentioned, is a lean clean implementation of a priority queue. But &lt;em&gt;&lt;/em&gt;I don&amp;#8217;t think elegance implies efficiency&lt;em&gt;&lt;/em&gt;. I&amp;#8217;d even suggest that something could be elegant but of no practical use, at least not on today&amp;#8217;s hardware.
&lt;/p&gt;
&lt;p&gt;The downside of efficiency is that it can be at odds with simplicity and minimalism. Consider the sad fate of &lt;code&gt;boost::lexical_cast&lt;/code&gt;, a general purpose conversion function. If I go back to early &lt;a href="http://www.boost.org"&gt;Boost&lt;/a&gt; releases I find code which reads like this.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Excerpt from lexical_cast.hpp, Boost 1.22&lt;/div&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Target, typename Source&amp;gt;
Target lexical_cast(Source arg)
{
# ifndef BOOST_NO_STRINGSTREAM
    std::stringstream interpreter;
# else
    std::strstream interpreter; // for out-of-the-box g++ 2.95.2
# endif
    Target result;
    
    if(!(interpreter &amp;lt;&amp;lt; arg) || !(interpreter &amp;gt;&amp;gt; result) ||
       !(interpreter &amp;gt;&amp;gt; std::ws).eof())
        throw bad_lexical_cast();
     return result;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;For brevity I&amp;#8217;ve omitted file headers, include guards and the unexceptional definition of &lt;code&gt;boost::bad_lexical_cast&lt;/code&gt;. Even with these present, the file runs to just 68 lines long, and provides an elegant example of what generic C++ code can do. The body of &lt;code&gt;lexical_cast&lt;/code&gt; itself is a readable one-liner, tainted only by a preprocessor workaround for non-compliant compilers. 
&lt;/p&gt;
&lt;p&gt;Wind forwards to 2007, and this small stain has spread across the entire &lt;a href="http://boost.cvs.sourceforge.net/boost/boost/boost/lexical_cast.hpp?revision=1.36&amp;amp;view=markup"&gt;library&lt;/a&gt;, which, after tuning for correctness, portability and &lt;strong&gt;efficiency&lt;/strong&gt; now weighs in at well over 1K lines of code. Here&amp;#8217;s a flavour of the latest greatest &lt;code&gt;lexical_cast&lt;/code&gt;, which is far too long to include in its entirety.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Excerpt from lexical_cast.hpp@1.36&lt;/div&gt;

&lt;pre class="prettyprint"&gt;namespace detail // lcast_put_unsigned
{
    // I'd personally put lcast_put_unsigned in .cpp file if not
    // boost practice for header-only libraries (Alexander Nasonov).
    template&amp;lt;typename T, typename CharT&amp;gt;
    CharT* lcast_put_unsigned(T n, CharT* finish)
    {
        CharT thousands_sep = 0;
#ifdef BOOST_LEXICAL_CAST_ASSUME_C_LOCALE
        char const* grouping = "";
        std::size_t const grouping_size = 0;
#else
        std::locale loc;
        typedef std::numpunct&amp;lt;CharT&amp;gt; numpunct;
        numpunct const&amp;amp; np = BOOST_USE_FACET(numpunct, loc);
        std::string const&amp;amp; grouping = np.grouping();
        std::string::size_type const grouping_size = grouping.size();    
        if(grouping_size)
            thousands_sep = np.thousands_sep();
#endif
        std::string::size_type group = 0; // current group number
        char last_grp_size = grouping[0] &amp;lt;= 0 ? CHAR_MAX : grouping[0];
        // a) Since grouping is const, grouping[grouping.size()] returns 0.
        // b) It's safe to assume here and below that CHAR_MAX
        //    is equivalent to unlimited grouping:
#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
        BOOST_STATIC_ASSERT(std::numeric_limits&amp;lt;T&amp;gt;::digits10 &amp;lt; CHAR_MAX);
#endif
        char left = last_grp_size;
        do
        {
            if(left == 0)
            {
                ++group;
                if(group &amp;lt; grouping_size)
                {
                    char const grp_size = grouping[group];
                    last_grp_size = grp_size &amp;lt;= 0 ? CHAR_MAX : grp_size;
                }
                left = last_grp_size;
                --finish;
                *finish = thousands_sep;
            }
            --left;
            --finish;
            int const digit = static_cast&amp;lt;int&amp;gt;(n % 10);
            int const cdigit = digit + lcast_char_constants&amp;lt;CharT&amp;gt;::zero;
            *finish = static_cast&amp;lt;char&amp;gt;(cdigit);
            n /= 10;
        } while(n);
    
        return finish;
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I&amp;#8217;m not saying that the changes to &lt;code&gt;boost::lexical_cast&lt;/code&gt; are &lt;em&gt;bad&lt;/em&gt;: after all, users of the library get software which does the right thing more often and more quickly &amp;mdash; all without any client-side changes. That&amp;#8217;s one of the benefits of using a layered software stack. Rather, I present this as an example of the tension between efficiency and elegance. Somewhere along the line, an elegant piece of code got buried.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s also interesting that, in this case, even &amp;#8220;does-it-work&amp;#8221; counteracts elegance. We noted that &lt;code&gt;boost::lexical_cast@v1.22&lt;/code&gt; became tainted in its eagerness to work with legacy compilers. The current version makes far greater concessions. It&amp;#8217;s a reminder &amp;mdash; as if any were needed &amp;mdash; that we programmers have to keep our feet on the ground and aim for pragmatic solutions. Perfection is rarely possible, elegance occasional.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc6" name="tocelegance-and-inefficiency" id="tocelegance-and-inefficiency"&gt;Elegance and Inefficiency?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We&amp;#8217;ve demonstrated the tension between elegance and efficiency, but could blatantly inefficient code ever claim to be elegant? The original elegant implementation of &lt;code&gt;lexical_cast&lt;/code&gt; may not have been optimally tuned for all possible inputs (it&amp;#8217;s meant to be generic code, after all), but it could hardly be described as inefficient.
&lt;/p&gt;
&lt;p&gt;We&amp;#8217;re going to develop some code which I&amp;#8217;ll claim is elegant despite being inefficient. To get us started, let&amp;#8217;s consider another problem we can skin in more than one way: &lt;strong&gt;how do we determine if a book forms a lipogram?&lt;/strong&gt; (A &lt;a href="http://phrontistery.info/lipogram.html"&gt;lipogram&lt;/a&gt; is a piece of text written avoiding the use of a particular character, the letter E for example, and &lt;a href="http://en.wikipedia.org/wiki/A_Void"&gt;full length books&lt;/a&gt; really have been written &amp;mdash; and even translated &amp;mdash; which adhere to this constraint.)
&lt;/p&gt;
&lt;p&gt;We&amp;#8217;ll pose the problem in C++. Here&amp;#8217;s the function prototype.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
    
typedef std::string word;
typedef std::vector&amp;lt;word&amp;gt; book;
    
// Return true if the input text avoids using any characters
// in 'avoid', false otherwise.
// Example call:
// bool const lipo = is_lipogram(text, "Ee");
bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;What we have here might be seen as a loop within a loop within a loop: for each word in the book, for each character in that word, check against each character in the string of characters to be avoided. A match against an avoided character means we know our book isn&amp;#8217;t a lipogram, and we can return false; but if we reach the end of our book without such a match, we can return true.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc7" name="tocislipogram1" id="tocislipogram1"&gt;is_lipogram1&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;We can code this up:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef word::const_iterator word_iter;
typedef book::const_iterator book_iter;
    
bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    // Handle edge case -- empty book
    if (text.empty())
    {
        return true;
    }
    // Handle edge case -- nothing to avoid
    if (avoid.empty())
    {
        return true;
    }
    for (book_iter w = text.begin(); w != text.end(); ++w)
    {
        for (word_iter c = w-&amp;gt;begin(); c != w-&amp;gt;end(); ++c)
        {
            for (word_iter a = avoid.begin(); a != avoid.end(); ++a)
            {
                if (*c == *a)
                {
                    return false;
                }
            }
        }
    }
    return true;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This painstaking chunk of code reads like a direct transcription of the way an unfortunate human proof-reader might approach the task, one finger tracking through the text, word by word, character by character, another finger repeatedly working through the characters to be avoided. It fails the elegance test on a number of counts:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     &lt;strong&gt;Not minimal&lt;/strong&gt;. The edge cases do not merit special treatment. Normal processing of the (nested) main loop handles empty inputs just fine.
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;Failure to use the standard library.&lt;/strong&gt; The &lt;code&gt;std::string&lt;/code&gt; class is big enough to support searches for characters in a string directly, allowing us to remove a couple of layers of nesting.
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;Clumsy&lt;/strong&gt;. The function has &lt;em&gt;four&lt;/em&gt; separate exit points.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Perhaps none of these charges seem too bad in such a small function, but small functions have a tendency to grow into larger ones, and &lt;span /&gt;flaws, in particular, scale rapidly.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc8" name="tocislipogram2--3" id="tocislipogram2--3"&gt;is_lipogram2 &amp;amp; 3&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Here&amp;#8217;s a standard-library-aware improvement.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    for (book_iter w = text.begin(); w != text.end(); ++w)
    {
        if (w-&amp;gt;find_first_of(avoid) != std::string::npos)
        {
            return false;
        }
    }
    return true;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Many programmers would leave it at that, but I still prefer to re-cast this particular variant as follows:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    book_iter w = text.begin();
    while (w != text.end() &amp;amp;&amp;amp;
           w-&amp;gt;find_first_of(avoid) == std::string::npos)
    {
        ++w;
    }
    return w == text.end();
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Rather than exit as soon as we detect a character in the &lt;code&gt;avoid&lt;/code&gt; string, we keep reading as long as there&amp;#8217;s text to read and we&amp;#8217;ve avoided such characters. There&amp;#8217;s not much in it, especially in such a small function, but my preference is to simplify the control flow.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc9" name="tocislipogram4" id="tocislipogram4"&gt;is_lipogram4&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;We can remove the explicit iteration from our code by using the &lt;code&gt;std::find_if&lt;/code&gt; algorithm, which accepts a predicate. In this case we want to find the first word which isn&amp;#8217;t itself a lipogram. Combining the &lt;code&gt;std::not1&lt;/code&gt; function adaptor with a hand-written class deriving from &lt;code&gt;std::unary_function&amp;lt;std::string const, bool&amp;gt;&lt;/code&gt; does the job.
&lt;/p&gt;
&lt;p&gt;This code demonstrates proper use of the STL predicates and adaptors, but it also reaches the limits of my personal comfort zone for using C++ in a functional programming style. The price paid for avoiding explicit iteration is just too high; clever though this code may be, I don&amp;#8217;t find it elegant. 
&lt;/p&gt;
&lt;p&gt;When I first coded up &lt;code&gt;lipogram_word_tester&lt;/code&gt;, it derived from &lt;code&gt;std::unary_function&amp;lt;word const &amp;amp;, bool&amp;gt;&lt;/code&gt;. This turns out to be wrong, or at least, it failed to compile with a typically cryptic diagnostic, and I&amp;#8217;m still not sure why!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;// Simple functor for use in lipogram algorithms
class lipogram_word_tester:
    public std::unary_function&amp;lt;word const, bool&amp;gt;
{
public:
    // Constructor. Caches a copy of the 'avoid' parameter.
    lipogram_word_tester(word const &amp;amp; avoid)
        : avoid(avoid)
    {
    }
    // Function operator returns true if the word being tested
    // omits characters from the 'avoid' string, false otherwise.
    bool operator()(word const &amp;amp; to_test) const
    {
        return to_test.find_first_of(avoid)
            == std::string::npos;
    }
private:
    // Private cache of characters to avoid.
    word const avoid;
};
    
bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    lipogram_word_tester const word_test(avoid);
    return find_if(text.begin(), text.end(),
                   not1(word_test)) == text.end();
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc10" name="tocislipogram5" id="tocislipogram5"&gt;is_lipogram5&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;I would expect all four functions presented so far to be similarly efficient in terms of memory, stack, CPU cycles. 
&lt;/p&gt;
&lt;p&gt;A recursive solution may require more stack: it depends on the compiler. We&amp;#8217;ve now got two functions, and although each comprises just a single expression, the expression forming the body of the recursive helper function, &lt;code&gt;is_lipo()&lt;/code&gt;, is tricky. I wouldn&amp;#8217;t recommend this implementation.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;bool is_lipo(book_iter wb, book_iter we, word const &amp;amp; avoid)
{
    return wb == we ||
        wb-&amp;gt;find_first_of(avoid) == std::string::npos &amp;amp;&amp;amp;
        is_lipo(++wb, we, avoid);
}
    
bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    return is_lipo(text.begin(), text.end(), avoid);
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc11" name="tocislipogram6" id="tocislipogram6"&gt;is_lipogram6&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Our final alternative is a clear winner on the three fronts which led us to reject our original implementation: it&amp;#8217;s brief, it leans heavily on the standard library, it has just a single exit point &amp;mdash; in fact, is just a single expression.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;bool is_lipogram(book const &amp;amp; text, word const &amp;amp; avoid)
{
    return accumulate(text.begin(), text.end(), std::string()
                     ).find_first_of(avoid) == std::string::npos;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Does it qualify as elegant? I&amp;#8217;d say so, yes. Sadly, though, its inefficiency rules it out as a heavy-duty lipogram checker. The &lt;code&gt;std::string&lt;/code&gt; class is not designed for repeated addition &amp;mdash; which is what &lt;code&gt;std::accumulate&lt;/code&gt; does.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc12" name="tocwinding-up" id="tocwinding-up"&gt;Winding Up&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Actually none of the C++ lipogram checkers are much use, except in the case when we&amp;#8217;re certain our book is written in 7-bit ASCII. A lipogram which avoids the letter E should also avoid its various accented forms: &amp;eacute;, &amp;egrave;, &amp;ecirc;, &amp;euml;, &amp;Eacute;, &amp;Egrave;, &amp;Ecirc;, &amp;Euml;, &amp;#8230;
&lt;/p&gt;
&lt;p&gt;A heavy-duty lipogram checker needs to work in Unicode and, for C++ at least, will have to establish some ground rules for input encoding schemes. The current C++ standard (C++98) has little to say about Unicode. We&amp;#8217;d be better off using a more Unicode aware language, such as Java.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python.org"&gt;Python&lt;/a&gt; allows us to create a character stream which accumulates all the characters in all the words, but yields them lazily. The function below uses &lt;code&gt;itertools.chain&lt;/code&gt; to flatten the input words (which themselves may be a stream or an in-memory collection) into a character stream. The built-in &lt;code&gt;all&lt;/code&gt; function reads exactly as far into this stream as it needs to. In other words, we&amp;#8217;ve got a Python counterpart to our final C++ algorithm which is both efficient (efficient for Python that is!) and equally happy with Unicode and ASCII.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import iterools
    
def is_lipogram(words, avoid):
    return all(ch not in avoid
               for ch in itertools.chain(*words))

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html#toc13" name="tocc-source-code" id="tocc-source-code"&gt;C++ Source Code&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
    
namespace
{
typedef std::string word;
typedef word::const_iterator word_iter;
typedef std::vector&amp;lt;word&amp;gt; book;
typedef book::const_iterator book_iter;
typedef bool (* lipo_fn)(book const &amp;amp;, word const &amp;amp;);
    
// Return true if the input text avoids using any characters
// in 'avoid', false otherwise.
bool is_lipogram1(book const &amp;amp; text, word const &amp;amp; avoid)
{
    // Handle edge case -- empty book
    if (text.empty())
    {
        return true;
    }
    // Handle edge case -- nothing to avoid
    if (avoid.empty())
    {
        return true;
    }
    for (book_iter w = text.begin(); w != text.end(); ++w)
    {
        for (word_iter c = w-&amp;gt;begin(); c != w-&amp;gt;end(); ++c)
        {
            for (word_iter a = avoid.begin(); a != avoid.end(); ++a)
            {
                if (*c == *a)
                {
                    return false;
                }
            }
        }
    }
    return true;
}       
    
bool is_lipogram2(book const &amp;amp; text, word const &amp;amp; avoid)
{
    for (book_iter w = text.begin(); w != text.end(); ++w)
    {
        if (w-&amp;gt;find_first_of(avoid) != std::string::npos)
        {
            return false;
        }
    }
    return true;
}
    
bool is_lipogram3(book const &amp;amp; text, word const &amp;amp; avoid)
{
    book_iter w = text.begin();
    while (w != text.end() &amp;amp;&amp;amp;
           w-&amp;gt;find_first_of(avoid) == std::string::npos)
    {
        ++w;
    }
    return w == text.end();
}
    
// Simple functor for use in lipogram algorithms
class lipogram_word_tester:
    public std::unary_function&amp;lt;std::string const, bool&amp;gt;
{
public:
    // Constructor. Caches a copy of the avoid parameter.
    lipogram_word_tester(word const &amp;amp; avoid)
        : avoid(avoid)
    {
    }
    // Function operator returns true if the word being tested
    // omits characters from the 'avoid' string, false otherwise.
    bool operator()(word const &amp;amp; to_test) const
    {
        return to_test.find_first_of(avoid)
            == std::string::npos;
    }
private:
    // Private cache of characters to avoid.
    word const avoid;
};
    
bool is_lipogram4(book const &amp;amp; text, word const &amp;amp; avoid)
{
    lipogram_word_tester const word_test(avoid);
    return find_if(text.begin(), text.end(),
                   not1(word_test)) == text.end();
}
    
bool is_lipo5(book_iter wb, book_iter we, word const &amp;amp; avoid)
{
    return wb == we ||
        wb-&amp;gt;find_first_of(avoid) == std::string::npos &amp;amp;&amp;amp;
        is_lipo5(++wb, we, avoid);
}
    
bool is_lipogram5(book const &amp;amp; text, word const &amp;amp; avoid)
{
    return is_lipo5(text.begin(), text.end(), avoid);
}
    
bool is_lipogram6(book const &amp;amp; text, word const &amp;amp; avoid)
{
    return accumulate(text.begin(), text.end(), std::string()
                      ).find_first_of(avoid) == std::string::npos;
}
    
void read_book(book &amp;amp; text, std::istream &amp;amp; input) 
{
    typedef std::istream_iterator&amp;lt;word&amp;gt; in;
    std::copy(in(input), in(), back_inserter(text));
}
    
// Function-like class used for lipo_fn evaluation.
class lipo_functor
{
public:
    // Construct an instance of this class, caching lipo_fn parameters.
    lipo_functor(book const &amp;amp; text, word const &amp;amp; avoid)
        : text(text)
        , avoid(avoid)
    {
    }
    // Return the result of applying is_lipo to the cached parameters.
    bool operator()(lipo_fn is_lipo)
    {
        return is_lipo(text, avoid);
    }
private:
    book const &amp;amp; text;
    word const &amp;amp; avoid;
};
    
void check_if_lipogram(std::ostream &amp;amp; report,
                       book const &amp;amp; text, word const &amp;amp; avoid)
{
    typedef std::set&amp;lt;bool&amp;gt; answers;
    lipo_fn const lipo_fns[] =
        {
            is_lipogram1,
            is_lipogram2,
            is_lipogram3,
            is_lipogram4,
            is_lipogram5,
            is_lipogram6,
        };
    
    lipo_functor lipo_func(text, avoid);
    answers results;
    lipo_fn const * const end = lipo_fns + sizeof lipo_fns / sizeof *lipo_fns;
    transform(lipo_fns, end, inserter(results, results.end()), lipo_func);
    assert(results.size() == 1);
    report &amp;lt;&amp;lt; "Is " &amp;lt;&amp;lt; (*results.begin() ? "" : "not ")
           &amp;lt;&amp;lt; "a lipogram" &amp;lt;&amp;lt; '\n';
}
} // end anonymous namespace
    
int main()
{
    book text;
    word const avoid = "Ee";
    read_book(text, std::cin);
    check_if_lipogram(std::cout, text, avoid);
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2007-12-03</dc:date>
<guid>http://wordaligned.org/articles/elegance-and-efficiency.html</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/elegance-and-efficiency.html</link>
<category>Scheme</category>
</item>

<item>
<title>Shameful Names</title>
<description>&lt;p&gt;There&amp;#8217;s a lots of good positive &lt;a href="http://www.objectmentor.com/resources/articles/naming.htm"&gt;advice&lt;/a&gt; out there on how programmers should name classes, functions, variables and so on. To help balance things out are three half-baked tips on how &lt;em&gt;not&lt;/em&gt; to name things.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Don&amp;#8217;t use &lt;code&gt;m_something&lt;/code&gt; for member variables. Prefer &lt;code&gt;something&lt;/code&gt;. If there&amp;#8217;s any doubt about a variable&amp;#8217;s scope your code blocks are too long. Besides, you can always qualify a member variable&amp;#8217;s scope like &lt;code&gt;this-&amp;gt;something&lt;/code&gt;&lt;sup&gt;&lt;a href="http://wordaligned.org/articles/shameful-names.html#footnote1"&gt;[1]&lt;/a&gt;&lt;/sup&gt;.
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;Utility&lt;/code&gt; is a poor name for a module. And yes, the same goes for &lt;code&gt;utilities&lt;/code&gt; and &lt;code&gt;util&lt;/code&gt;.
 &lt;/li&gt;

 &lt;li&gt;
     Don&amp;#8217;t create a class called &lt;code&gt;SomethingManager&lt;/code&gt; when plain old &lt;code&gt;Something&lt;/code&gt; would do. Why? Because &amp;#8220;manager&amp;#8221; is a long word and I&amp;#8217;ll bet class instance names get abbreviated to &lt;code&gt;something_mgr&lt;/code&gt;. Because you&amp;#8217;ll end up with source code with too many managers and not enough workers &lt;sup&gt;&lt;a href="http://wordaligned.org/articles/shameful-names.html#footnote2"&gt;[2]&lt;/a&gt;&lt;/sup&gt;. And because eventually you&amp;#8217;ll find yourself needing a &lt;code&gt;SomethingManagerManager&lt;/code&gt;.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One thing I like about &lt;a href="http://schemers.org"&gt;Scheme&lt;/a&gt; is that you can use punctuation characters in identifiers. Question marks work well in predicates (rather than &lt;code&gt;is_empty&lt;/code&gt;, write &lt;code&gt;empty?&lt;/code&gt;), and an exclamation mark alerts readers to functions with side-effects (&lt;code&gt;set!&lt;/code&gt;, for example).
&lt;/p&gt;
&lt;p&gt;&lt;a id="footnote1"&gt;[1]&lt;/a&gt; &lt;span /&gt;I can understand C++ programmers objecting to the explicit &lt;code&gt;self&lt;/code&gt; Python requires for member access. The objection becomes less easy to understand if they adopt the &lt;code&gt;m_something&lt;/code&gt; naming convention.
&lt;/p&gt;
&lt;p&gt;&lt;a id="footnote2"&gt;[2]&lt;/a&gt; Now that I think about it, my real objection is to object oriented code-bloat. Too many managers = too deep a heirarchy = not enough action. Think of JBoss and shudder.
&lt;/p&gt;</description>
<dc:date>2007-08-20</dc:date>
<guid>http://wordaligned.org/articles/shameful-names.html</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/shameful-names.html</link>
<category>Scheme</category>
</item>

<item>
<title>Computer Language Complexity</title>
<description>&lt;p&gt;A debate has been raging on the &lt;a href="http://accu.org/index.php/mailinglists"&gt;ACCU general&lt;/a&gt; email reflector. It
   started with some ugly &lt;a href="http://www.boost.org/boost/mpl/vector.hpp"&gt;C++
code&lt;/a&gt; and ended up
   attempting to answer some more general questions about computer
   languages:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     Can a language be both small and powerful?
 &lt;/li&gt;

 &lt;li&gt;
     What makes a language powerful anyway?
 &lt;/li&gt;

 &lt;li&gt;
     Is it better for (any necessary) complexity to be in the language or in its associated libraries?
 &lt;/li&gt;

 &lt;li&gt;
     Shouldn&amp;#8217;t we just admit that programming is hard?
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C++ came in for criticism from some, though, as its &lt;a href="http://www.research.att.com/~bs/"&gt;designer and
original implementer&lt;/a&gt; has been compelled to
   &lt;a href="http://www.research.att.com/~bs/blast.html"&gt;remind&lt;/a&gt; us:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The major cause of complaints is C++&amp;#8217;s undoubted success. As someone
   remarked: There are only two kinds of programming languages: those
   people always bitch about and those nobody uses.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Who is that someone? I&amp;#8217;d like to disagree with him &amp;#8212; or her. For now, though,
   I want to record some of the answers to these questions
   which I &lt;em&gt;did&lt;/em&gt; agree with.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h4&gt;Can a language be both small and powerful?&lt;/h4&gt;
&lt;p&gt;Yes. &lt;a href="http://www.russel.org.uk"&gt;Russel&lt;/a&gt; explains:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; If the language comprises a small, orthogonal set of
   higher order functions and primitive operations, all other things
   can be built from them.  &lt;span /&gt;Small, powerful language, large, structured library of usable software.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Clearly, though, there&amp;#8217;s some tension between &amp;#8220;small&amp;#8221; and
   &amp;#8220;powerful&amp;#8221;. For example, when
   &lt;a href="http://www.python.org/dev/peps/pep-0255/"&gt;generators&lt;/a&gt; were added to
   &lt;a href="http://python.org"&gt;Python&lt;/a&gt;, the language gained in power at the expense
   of size: in this case, though, the gains more than
   outweighed the costs.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s also noteworthy that the next major revision of Python actually
   aims to make the core language &lt;em&gt;smaller&lt;/em&gt;. Yes, Python isn&amp;#8217;t as
   widely-used as C++ (yet), but it is a major language and it does take
   backwards compatibility very seriously.  I guess it&amp;#8217;s the kind of
   progression which can only happen when you have a &lt;a href="http://www.python.org/~guido/"&gt;benevolent dictator
for life&lt;/a&gt; rather than a standards
   committee. Of course, it remains to be seen how well the transition to
   Python 3.0 actually goes.
&lt;/p&gt;

&lt;h4&gt;What makes a language powerful anyway?&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://www.spongelava.com"&gt;Paul&lt;/a&gt; came up with a practical and
   appealing definition.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The language facilitates more with less required of the programmer.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;On examination, though, this doesn&amp;#8217;t distinguish between the power of
   the language itself and the power attained through associated libraries.
   It&amp;#8217;s possible for the language itself to be simple
   and powerful, but for the range of available libraries to be poor,
   meaning that the programmer has to (for example) write their own
   database access code.  It looks as though &lt;a href="http://schemers.org"&gt;Scheme&lt;/a&gt;
   &lt;em&gt;currently&lt;/em&gt; falls into this category. And it&amp;#8217;s possible
   for a language to be less powerful but the range of libraries to be
   excellent, meaning that the programmer (for example) can&amp;#8217;t overload
   operators, but can (for example) access a database. I&amp;#8217;d say
   &lt;a href="http://java.sun.com"&gt;Java&lt;/a&gt; falls into this category.
&lt;/p&gt;

&lt;h4&gt;Should complexity be in the language or its libraries?&lt;/h4&gt;
&lt;p&gt;It&amp;#8217;s better to keep the core of the language as small and powerful as
   possible. It&amp;#8217;s far easier to extend what you can do with a language by
   adding libraries (and it&amp;#8217;s easier to deprecate libraries than
   deprecate language features).
&lt;/p&gt;

&lt;h3&gt;Shouldn&amp;#8217;t we just admit that programming is hard?&lt;/h3&gt;
&lt;p&gt;We should. It is. But we should still strive for
   &lt;a href="http://wiki.hsr.ch/SimpleCode/wiki.cgi"&gt;simplicity&lt;/a&gt;.
&lt;/p&gt;</description>
<dc:date>2006-10-26</dc:date>
<guid>http://wordaligned.org/articles/computer-language-complexity.html</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/computer-language-complexity.html</link>
<category>Scheme</category>
</item>

</channel>
</rss>
