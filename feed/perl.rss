<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Define pedantic</title>
<description>&lt;p&gt;My dictionary &lt;span id="definition"&gt;defines a pedant&lt;/span&gt; as:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;pedant&lt;/strong&gt; &lt;em&gt;n.&lt;/em&gt; &lt;strong&gt;1.&lt;/strong&gt; A person who relies too much on academic learning or who is concerned chiefly with academic detail.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Apparently the word derives from the Italian, &lt;em&gt;pedante&lt;/em&gt;, meaning teacher. During my career as a computer programmer a number of my colleagues have been surprisingly pedantic about the proper use of English.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8220;I refuse to join a supermarket queue marked &lt;strong&gt;10 items or less&lt;/strong&gt;.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;&amp;#8220;I do wish people would stop using &lt;strong&gt;target&lt;/strong&gt; as a verb. You &lt;strong&gt;aim&lt;/strong&gt; at a target, you don&amp;#8217;t &lt;strong&gt;target&lt;/strong&gt; it.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;&amp;#8220;I am an exceptionally &lt;strong&gt;skilled grammarian&lt;/strong&gt; in English &amp;#8230; Take that rule and shove it!&amp;#8221;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Some of this fussiness may well be a reaction against &lt;a href="http://news.bbc.co.uk/1/hi/7457287.stm"&gt;corporate double-speak&lt;/a&gt;. Still, I wouldn&amp;#8217;t have expected programmers to be 1) so particular and 2) so certain they&amp;#8217;re right. Maybe this attitude comes from all those years of writing code. Programming languages are strict about what they&amp;#8217;ll accept: after all, they have standards!
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/5142421926/" title="The C++ Standard vs Perl in a Nutshell by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm2.static.flickr.com/1072/5142421926_6b76c52749_m.jpg" width="240" height="183" alt="The C++ Standard vs Perl in a Nutshell" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;Some programming languages are more pedantic than others. Paul Graham memorably characterises C++ as a pernickety aunt&lt;a id="fn1link" href="http://wordaligned.org/articles/define-pedantic#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;. By contrast, Perl won&amp;#8217;t pick nits. Designed by Larry Wall to be his software &lt;a href="http://www.wall.org/~larry/pm.html" title="Perl, the first postmodern computer language. Larry Wall"&gt;butler&lt;/a&gt;, Perl interprets your ill-expressed wishes with discretion and assurance. Hence you can end up with a Perl program which gets on with its job but which no-one fully understands.
&lt;/p&gt;
&lt;p&gt;Pedants, by definition, take things too far, but pedantry in programming isn&amp;#8217;t all bad. GCC has a useful &lt;a href="http://gcc.gnu.org/onlinedocs/gcc/Standards.html"&gt;&lt;code&gt;-pedantic&lt;/code&gt;&lt;/a&gt; flag. It helps you write portable programs. Perl has a &lt;a href="http://perldoc.perl.org/strict.html"&gt;&lt;code&gt;use strict&lt;/code&gt;&lt;/a&gt; pragma which recasts the butler as a personal trainer. 
&lt;/p&gt;
&lt;p&gt;When it comes to correctness, attention to detail matters. What if this input parameter goes negative? Will that file be closed when an exception is thrown? Can your algorithm handle an empty container?
&lt;/p&gt;
&lt;p&gt;I recently fixed a defect in some (of my own) code which assumed conformant input. When faced with garbage-in this code failed even to generate garbage-out, instead getting caught in an infinite loop. Should a pedantic program insist on correct inputs or should it consider how to handle all possible inputs? &lt;a href="http://wordaligned.org/articles/define-pedantic#definition"&gt;Define pedantic&lt;/a&gt;.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/define-pedantic#fn1link"&gt;[1]&lt;/a&gt;: It turns out my memory is at fault here. When I checked the reference I discovered Paul Graham makes no explicit mention of C++. 
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We need a language that lets us scribble and smudge and smear, not a language where you have to sit with a teacup of types balanced on your knee and make polite conversation with a strict old aunt of a compiler. &amp;#8212; Paul Graham, &lt;a href="http://www.paulgraham.com/hp.html" title="Hackers and Painters"&gt;Hackers and Painters&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;You might have guessed which language he&amp;#8217;s promoting for scribbling but there&amp;#8217;s no mention of Lisp either in this particular essay. In fact only one programming language earns a name-check. I&amp;#8217;ll let you find out which one for yourselves.
&lt;/p&gt;</description>
<dc:date>2010-11-02</dc:date>
<guid>http://wordaligned.org/articles/define-pedantic</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/define-pedantic</link>
<category>Perl</category>
</item>

<item>
<title>Power programming</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocpowerful-or-dangerous" name="toc0" id="toc0"&gt;Powerful or dangerous?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocdecision-trees" name="toc1" id="toc1"&gt;Decision trees&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toccuteness-calculator" name="toc2" id="toc2"&gt;Cuteness calculator&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toceval" name="toc3" id="toc3"&gt;Eval&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocdynamic-or-hacky" name="toc4" id="toc4"&gt;Dynamic or hacky?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocjam-to-golf" name="toc5" id="toc5"&gt;Jam to golf&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toccode-vs-data" name="toc6" id="toc6"&gt;Code vs data&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocpowerful-language-vs-power-user" name="toc7" id="toc7"&gt;Powerful language vs power user?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocappendix-a-first-impressions-of-arc" name="toc8" id="toc8"&gt;Appendix A: First impressions of Arc&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocappendix-b-c-solution" name="toc9" id="toc9"&gt;Appendix B: C++ solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocappendix-c-a-python-solution" name="toc10" id="toc10"&gt;Appendix C: A Python Solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocnotes" name="toc11" id="toc11"&gt;Notes&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc0" name="tocpowerful-or-dangerous" id="tocpowerful-or-dangerous"&gt;Powerful or dangerous?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recently I &lt;a href="http://wordaligned.org/articles/next-permutation.html" title="Next permutation: when C++ gets it right"&gt;wrote about&lt;/a&gt; one of the &lt;a href="http://code.google.com/codejam/"&gt;Google Code Jam&lt;/a&gt; challenges, where, perhaps surprisingly, the best answer &amp;#8212; the most elegant and obviously correct answer, requiring the fewest lines of code, with virtually zero space overhead, and running the quickest &amp;#8212; the very best answer was coded in C++.
&lt;/p&gt;
&lt;p&gt;Why should this be surprising? C++ is a powerful language.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In my experience there is almost no limit to the damage that a sufficiently ingenious fool can do with C++. But there is also almost no limit to the degree of complexity that a skillful library designer can hide behind a simple, safe, and elegant C++ interface. 
&lt;/p&gt;
&lt;p&gt;&amp;#8212; Greg Colvin, &lt;a href="http://www.artima.com/cppsource/spiritofc2.html" title="Greg Colvin, In the Spirit of C"&gt;&amp;#8220;In the Spirit of C&amp;#8221;&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Yes. And yes! But in this article I wanted to discuss something C++ &lt;strong&gt;can&amp;#8217;t&lt;/strong&gt; do. Let&amp;#8217;s start with another &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#" title="Decision Tree, Google Code Jam 2009"&gt;challenge&lt;/a&gt; from the same round of the 2009 Google Code Jam.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc1" name="tocdecision-trees" id="tocdecision-trees"&gt;Decision trees&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;Decision trees &amp;#8212; in particular, a type called classification trees &amp;#8212; are data structures that are used to classify &lt;i&gt;items&lt;/i&gt; into &lt;i&gt;categories&lt;/i&gt; using &lt;i&gt;features&lt;/i&gt; of those items. For example, each animal is either &amp;#8220;cute&amp;#8221; or not. For any given animal, we can decide whether it is cute by looking at the animal&amp;#8217;s features and using the following decision tree.&lt;/p&gt;
&lt;pre&gt;(0.2 furry
  (0.81 fast
    (0.3)
    (0.2)
  )
  (0.1 fishy
    (0.3 freshwater
      (0.01)
      (0.01)
    )
    (0.1)
  )
)
&lt;/pre&gt;&lt;p&gt;&amp;mdash; &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#"&gt;Decision Trees, Google Code Jam 2009&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="http://www.zazzle.com/cute_beaver_magnet-147411069592023743"&gt;&lt;img src="http://wordaligned.org/images/cute-beaver.png" alt="Cute beaver!" width="227px" height="193px" style="float:right;margin:25px 25px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The challenge goes on to describe the structure more formally, then steps through an example calculation. What is the probability, &lt;code&gt;p&lt;/code&gt;, that a beaver is cute?
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;For example, a beaver is an animal that has two features: &lt;code&gt;furry&lt;/code&gt; and &lt;code&gt;freshwater&lt;/code&gt;. We start at the root with &lt;code&gt;p&lt;/code&gt; equal to &lt;code&gt;1&lt;/code&gt;. We multiply &lt;code&gt;p&lt;/code&gt; by &lt;code&gt;0.2&lt;/code&gt;, the weight of the root and move into the first sub-tree because the beaver has the &lt;code&gt;furry&lt;/code&gt; feature. There, we multiply &lt;code&gt;p&lt;/code&gt; by &lt;code&gt;0.81&lt;/code&gt;, which makes &lt;code&gt;p&lt;/code&gt; equal to &lt;code&gt;0.162&lt;/code&gt;. From there we move further down into the second sub-tree because the beaver does not have the fast feature. Finally, we multiply &lt;code&gt;p&lt;/code&gt; by &lt;code&gt;0.2&lt;/code&gt; and end up with &lt;code&gt;0.0324&lt;/code&gt; &amp;#8212; the probability that the beaver is cute. 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;img src="http://wordaligned.org/images/decision-tree.png" alt="Decision tree calculation"/&gt;

&lt;p&gt;The challenge itself involves processing input comprising a number of test cases. Each test case consists of a decision tree followed by a number of animals. A solution should parse the input and output the calculated cuteness probabilities.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc2" name="toccuteness-calculator" id="toccuteness-calculator"&gt;Cuteness calculator&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def cuteness(decision_tree, features):
    """Return the probability an animal is cute.
    
    - decision_tree, the decision tree
    - features, the animal's features,
    """
    p = 1.0
    dt = decision_tree
    has_feature = features.__contains__
    while dt:
        weight, *dt = dt
        p *= weight
        if dt:
            feat, lt, rt = dt
            dt = lt if has_feature(feat) else rt
    return p

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Calculating an animal&amp;#8217;s cuteness given a decision tree and the animal&amp;#8217;s features isn&amp;#8217;t hard. In Python we don&amp;#8217;t need to code up a specialised decision tree class &amp;#8212; a nested tuple does just fine. The &lt;code&gt;cuteness()&lt;/code&gt; function shown above descends the decision tree, switching left or right according to each feature&amp;#8217;s presence or absence. The efficiency of this algorithm is proportional to the depth of the tree multiplied by the length of the feature list; as far as the code jam challenge goes, it&amp;#8217;s not a concern.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; decision_tree = (
...     0.2, 'furry',
...         (0.81, 'fast',
...             (0.3,),
...             (0.2,),
...         ),
...         (0.1, 'fishy',
...             (0.3, 'freshwater',
...                  (0.01,),
...                  (0.01,),
...             ),
...             (0.1,),
...         ),
...     )
&amp;gt;&amp;gt;&amp;gt; beaver = ('furry', 'freshwater')
&amp;gt;&amp;gt;&amp;gt; cuteness(decision_tree, beaver)
0.032400000000000005

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;No, the real problem here is how to parse the input data to create the decision trees and feature sets. As you can see, though, the textual specification of a decision tree closely resembles a Python representation of that decision tree. Just add punctuation.
&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;Specification&lt;/td&gt;&lt;td&gt;Python&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre&gt;(0.2 furry
  (0.81 fast
    (0.3)
    (0.2)
  )
  (0.1 fishy
    (0.3 freshwater
      (0.01)
      (0.01)
    )
    (0.1)
  )
)&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;(0.2, 'furry',
  (0.81, 'fast',
    (0.3,),
    (0.2,),
  ),
  (0.1, 'fishy',
    (0.3, 'freshwater',
      (0.01,),
      (0.01,),
      ),
      (0.1,),
  ),
)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Rather than parse the decision tree definition by hand, why not tweak it so that it &lt;strong&gt;is&lt;/strong&gt; a valid Python nested tuple? Then we can just let the Python interpreter &lt;a href="http://docs.python.org/library/functions.html#eval"&gt;&lt;tt&gt;eval&lt;/tt&gt;&lt;/a&gt; the tuple and use it directly.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc3" name="toceval" id="toceval"&gt;Eval&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A program&amp;#8217;s ability to read and execute source code at run-time is one of the things which makes &lt;a href="http://en.wikipedia.org/wiki/Dynamic_programming_language#Eval"&gt;dynamic languages&lt;/a&gt; dynamic. You can&amp;#8217;t do it in C and C++ &amp;#8212; no, sneaking instructions &lt;a href="http://en.wikipedia.org/wiki/Buffer_overrun"&gt;past the end of a buffer&lt;/a&gt; doesn&amp;#8217;t count. Should you do it in Python? Well, it won&amp;#8217;t hurt to give it a try.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;spec = '''\
(0.2 furry
  (0.81 fast
    (0.3)
    (0.2)
  )
  (0.1 fishy
    (0.3 freshwater
      (0.01)
      (0.01)
    )
    (0.1)
  )
)
'''

tuple_rep = re.sub(r'([\.\d]+|\))', r'\1,', spec)
tuple_rep = re.sub(r'([a-z]+)', r'"\1",', tuple_rep)
decision_tree = eval(tuple_rep)[0]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, we start with the input specification of the decision tree (imagine this has been read directly from standard input). The first regex substitution inserts commas after numbers, and right parentheses. The second substitution quotes and inserts a comma after feature strings. This turns the decision tree&amp;#8217;s specification into a textual representation of a nested Python tuple. We then &lt;code&gt;eval&lt;/code&gt; that tuple and assign the result to &lt;code&gt;decision_tree&lt;/code&gt; &amp;#8212; a Python decision tree we can go on and use in the rest of our program. And that&amp;#8217;s the code jam challenge cracked, pretty much.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from pprint import pprint
&amp;gt;&amp;gt;&amp;gt; pprint(decision_tree)
(0.2,
 'furry',
 (0.81, 'fast', (0.3,), (0.2,)),
 (0.1, 'fishy', (0.3, 'freshwater', (0.01,), (0.01,)), (0.1,)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Minor wrinkle: you&amp;#8217;ll have spotted the final decision tree is the first element of the evaluated tuple. That&amp;#8217;s because the regex substitution puts a trailing comma after the right parenthesis which closes the decision tree specification, which turns &lt;code&gt;tuple_rep&lt;/code&gt; into a one-tuple. The single element contained in this one-tuple is what we need.)
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc4" name="tocdynamic-or-hacky" id="tocdynamic-or-hacky"&gt;Dynamic or hacky?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As you can see, it doesn&amp;#8217;t take much code to pull the decision tree in ready for use. Python allows us to convert between text and code and to execute code within the current environment: you just need to keep a clear head and remember where you are. Regular expressions may not have the first class language support they enjoy in Perl and Ruby, but they are well supported, and the raw string syntax makes them more readable.
&lt;/p&gt;
&lt;p&gt;Certainly, this code snippet is easier to put together than a full blown &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=0" title="Google's analysis of the decision tree challenge, including a parser"&gt;parser&lt;/a&gt;, but I think it will take more than this to convince a C++ programmer that Python is a powerful language, rather than a dangerous tool for ingenious fools. It fails to convince me. I can&amp;#8217;t remember ever using &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; in production code, where keeping a separation between layers is more important than speed of coding.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc5" name="tocjam-to-golf" id="tocjam-to-golf"&gt;Jam to golf&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://codegolf.com"&gt;&lt;img src="http://codegolf.com/images/logo.png" alt="Code Golf logo" width="332px" height="75px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;That said, Python is a fine language for scripting, and speed of coding &lt;strong&gt;is&lt;/strong&gt; what matters in this particular challenge. Just for fun, what if there were &lt;a href="http://stackoverflow.com/questions/1433263/decision-tree-code-golf" title="Decision tree code golf on Stack Overflow"&gt;a prize for brevity&lt;/a&gt;? Then of course Perl would &lt;a href="http://stackoverflow.com/questions/1433263/decision-tree-code-golf/1442392#1442392" title="gnibbler's winning Perl entry"&gt;win&lt;/a&gt;!
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Code Jam golf, by gnibbler, Stack Overflow&lt;/div&gt;

&lt;pre class="prettyprint"&gt;say("Case #$_:"),
$_=eval"''".'.&amp;lt;&amp;gt;'x&amp;lt;&amp;gt;,
s:[a-z]+:*(/ $&amp;amp;\\s/?:g,s/\)\s*\(/):/g,
eval"\$_=&amp;lt;&amp;gt;;say$_;"x&amp;lt;&amp;gt;for 1..&amp;lt;&amp;gt;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that this does more than simply parse a decision tree &amp;#8212; it&amp;#8217;s a complete solution to the code jam &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#" title="Decision Tree, Google Code Jam 2009"&gt;challenge&lt;/a&gt;, reading trees, features, calculating cutenesses, and producing output in the required format. Sadly that&amp;#8217;s all I can say about it because the details of its operation are beyond me.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc6" name="toccode-vs-data" id="toccode-vs-data"&gt;Code vs data&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Using Python to dynamically execute code may not generally be needed or welcomed in Python production code, and over-reliance on the same trick risks reinforcing Perl&amp;#8217;s  &amp;#8220;write only&amp;#8221; reputation, but Python and Perl aren&amp;#8217;t the only contenders. &lt;span /&gt;The equivalence of code and data marks Lisp&amp;#8217;s apotheosis. Take a look at a &lt;a href="http://stackoverflow.com/questions/1433263/decision-tree-code-golf/1540845#1540845" title="Arc solution to decision tree"&gt;Lisp solution&lt;/a&gt; to the challenge. This one is coded up in &lt;a href="http://arclanguage.org" title="Arc, a new dialect of Lisp"&gt;Arc&lt;/a&gt;.
&lt;/p&gt;
&lt;pre class="prettyprint lang-lisp"&gt;
(def r () (read))
(for i 1 (r)
  (prn "Case #" i ":")
  (r)
  (= z (r))
  (repeat (r)
    (r)
    (loop (= g (n-of (r) (r))
             c z
             p 1)
       c
       (= p (* (pop c) p)
          c (if (pos (pop c) g)
                (c 0)
                (cadr c))))
    (prn p)))
&lt;/pre&gt;

&lt;p&gt;Which challenge does this solve? 
&lt;/p&gt;
&lt;p&gt;I meant the code golf challenge, of solving the decision tree problem using the fewest keystrokes. At 154 characters this Arc program is nearly half as long again as the winning Perl entry, but it&amp;#8217;s hardly flabby. What really impresses me, though, is that the code is (almost) as readable as it is succinct. It&amp;#8217;s elegant code. The only real scars left by the battle for brevity are the one character variable names. Here&amp;#8217;s the same code with improved variable names and some comments added. It&amp;#8217;s the &lt;code&gt;(read)&lt;/code&gt; calls which evaluate expressions on standard input. The &lt;code&gt;(for ...)&lt;/code&gt; and &lt;code&gt;(repeat ...)&lt;/code&gt; expressions operate as you might expect. The third looping construct, &lt;code&gt;(loop ...)&lt;/code&gt; initialises, tests and proceeds, much like a C for loop.
&lt;/p&gt;
&lt;pre class="prettyprint lang-lisp"&gt;
(for i 1 (read)               ; Read N, # test cases, and loop
  (prn "Case #" i ":")
  
  (read)                      ; Skip L, # lines taken by decision tree
  (= dtree (read))            ; and read the tree in directly
  
  (repeat (read)              ; Repeat over A, # animals
    (read)                    ; Skip animal name
    ; Read in the animal's features and walk down the 
    ; decision tree calculating p, the cuteness probability
    (loop (= features (n-of (read) (read)) 
             dt dtree
             p 1)
       dt
       (= p (* (pop dt) p)
          dt (if (pos (pop dt) features)
                (car dt)
                (cadr dt))))
    (prn p)))
&lt;/pre&gt;

&lt;p&gt;You could argue the elegance of this solution is due to the fact the input comprises a sequence of tokens and &lt;a href="http://en.wikipedia.org/wiki/S-expression" title="S-expressions, Wikipedia"&gt;S-expressions&lt;/a&gt;. If commas had been used to separate input elements and the text fields had been enclosed in quotes, then maybe a Python solution would have been equally clean. Or if the input had been in XML, then we&amp;#8217;d be looking to a library rather than &lt;code&gt;eval&lt;/code&gt; for parsing the input.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s a fair point, but the equivalence of code and data counts as Lisp&amp;#8217;s biggest idea. Where Python&amp;#8217;s &lt;code&gt;eval&lt;/code&gt; is workable but rarely needed, Lisp&amp;#8217;s &lt;code&gt;(read)&lt;/code&gt; is fundamental.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc7" name="tocpowerful-language-vs-power-user" id="tocpowerful-language-vs-power-user"&gt;Powerful language vs power user?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So, the most elegant answer to the code jam decision tree challenge would also be the quickest to write, and it would be written in Lisp. Did code jam champion, &lt;a href="http://www.go-hero.net/jam/09/name/ACRush" title="ACRush's code jam solutions"&gt;ACRush&lt;/a&gt;, submit a Lisp solution?
&lt;/p&gt;
&lt;p&gt;Absolutely not!
&lt;/p&gt;
&lt;p&gt;Another fundamental thing about Lisp is that it&amp;#8217;s straightforward to parse. A C++ expert can knock up an input parser for decision trees and features to order. ACRush brushed this round aside with a perfect score, taking just 45 minutes to code up working C++ solutions to this question &lt;strong&gt;and two others&lt;/strong&gt;. I&amp;#8217;ve reproduced his solution to the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#" title="Decision Tree, Google Code Jam 2009"&gt;decision tree challenge&lt;/a&gt; at the end of this article. It&amp;#8217;s plain and direct. Given the time constraints, I think it exhibits astonishing fluency &amp;#8212; the work of someone who can think in C++.
&lt;/p&gt;
&lt;p&gt;In this article we&amp;#8217;ve encountered four programming languages:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Python
 &lt;/li&gt;

 &lt;li&gt;
     Perl
 &lt;/li&gt;

 &lt;li&gt;
     Lisp
 &lt;/li&gt;

 &lt;li&gt;
     C++
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are very different but they share features too. They are all mature, popular and well-supported&lt;a id="fn1link" href="http://wordaligned.org/articles/power-programming#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;. Each is a powerful general purpose programming language. &lt;span /&gt;But ultimately, the power of the programmer is what matters.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc8" name="tocappendix-a-first-impressions-of-arc" id="tocappendix-a-first-impressions-of-arc"&gt;Appendix A: First impressions of Arc&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s another revision of the Arc solution, this time decomposed into subfunctions. I found no complete formal documentation of &lt;a href="http://arclanguage.org" title="Arc, a new dialect of Lisp"&gt;Arc&lt;/a&gt;. You&amp;#8217;ll have to read the source and follow the forum, and to actually run any code you&amp;#8217;ll have to download a an old version of MzScheme. The official line is: by all means have a play, but expect things to change. That said, the language looks delightful, practical, and quite &lt;a href="http://www.paulgraham.com/arcll1.html" title="No onions in the varnish, says Paul Graham"&gt;onion free&lt;/a&gt;. The &lt;a href="http://ycombinator.com/arc/tut.txt"&gt;tutorial&lt;/a&gt; made me smile. Recommended reading.
&lt;/p&gt;
&lt;pre class="prettyprint lang-lisp"&gt;
; The input is a sequence of valid Arc expressions.
; Create some read aliases to execute these.
(= skip read
   decision-tree read
   n-features read 
   n-tests read
   n-animals read)

(def animal-features ()
     ; Get an animal's features
     (skip) ; animal name
     (n-of (n-features) (read)))

(def cuteness (dtree features)
     ; Calculate cuteness from a decision tree and feature set
     (= dt dtree
        p 1.0)
     (while dt
          (= p (* (pop dt) p)
             dt (if (pos (pop dt) features)
                (car dt)
                (cadr dt))))
     p)

; Loop through the tests, printing results
(for i 1 (n-tests)
     (prn "Case #" i ":")
     (skip) ; # lines the tree specification takes
     (= dtree (decision-tree))
     (repeat 
         (n-animals)
         (prn (cuteness dtree (animal-features)))))
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc9" name="tocappendix-b-c-solution" id="tocappendix-b-c-solution"&gt;Appendix B: C++ solution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s champion ACRush&amp;#8217;s C++ solution. I&amp;#8217;ve removed some general purpose macros from the top of the file. You can download the &lt;a href="http://code.google.com/codejam/contest/scoreboard/do?cmd=GetSourceCode&amp;amp;contest=186264&amp;amp;problem=171116&amp;amp;io_set_id=1&amp;amp;username=ACRush"&gt;original here&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;set&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;

using namespace std;

vector&amp;lt;string&amp;gt; A;
vector&amp;lt;int&amp;gt; P;
set&amp;lt;string&amp;gt; M;

#define SIZE(X) ((int)(X.size()))

double solve(int H,int T)
{
    H++;T--;
    double p=atof(A[H].c_str());
    if (H==T) return p;
    if (M.find(A[H+1])!=M.end())
        return p*solve(H+2,P[H+2]);
    else
        return p*solve(P[T],T);
}
int main()
{
    freopen("A-large.in","r",stdin);freopen("A-large.out","w",stdout);
    int testcase;
    scanf("%d",&amp;amp;testcase);
    for (int caseId=1;caseId&amp;lt;=testcase;caseId++)
    {
        int nline;
        scanf("%d",&amp;amp;nline);
        A.clear();
        char str[1024];
        gets(str);
        for (int i=0;i&amp;lt;nline;i++)
        {
            gets(str);
            string s="";
            for (int k=0;str[k];k++)
                if (str[k]=='(' || str[k]==')')
                    s+=" "+string(1,str[k])+" ";
                else
                    s+=str[k];
            istringstream sin(s);
            for (;sin&amp;gt;&amp;gt;s;A.push_back(s));
        }
        P.resize(SIZE(A),-1);
        vector&amp;lt;int&amp;gt; stack;
        for (int i=0;i&amp;lt;SIZE(A);i++)
            if (A[i]=="(")
                stack.push_back(i);
            else if (A[i]==")")
            {
                int p=stack[SIZE(stack)-1];
                P[i]=p;
                P[p]=i;
                stack.pop_back();
            }
        int cnt;
        printf("Case #%d:\n",caseId);
        for (scanf("%d",&amp;amp;cnt);cnt&amp;gt;0;cnt--)
        {
            scanf("%s",str);
            M.clear();
            int length;
            for (scanf("%d",&amp;amp;length);length&amp;gt;0;length--)
            {
                scanf("%s",str);
                M.insert(str);
            }
            double r=solve(0,SIZE(A)-1);
            printf("%.12lf\n",r);
        }
    }
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc10" name="tocappendix-c-a-python-solution" id="tocappendix-c-a-python-solution"&gt;Appendix C: A Python Solution&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import re
from itertools import islice

def cuteness(decision_tree, features):
    p = decision_tree[0]
    if len(decision_tree) &amp;gt; 1:
        _, feat, lt, rt = decision_tree
        p *= cuteness(lt if feat in features else rt, features)
    return p

def read_decision_tree(spec):
    tuple_rep = re.sub(r'([\.\d]+|\))', r'\1,', spec)
    tuple_rep = re.sub(r'([a-z]+)', r'"\1",', tuple_rep)
    return eval(tuple_rep)[0]

def take_lines(lines, n):
    return ''.join(islice(lines, n))

def main(fp):
    lines = iter(fp)
    n_tests = int(next(lines))
    for tc in range(1, n_tests + 1):
        print("Case #%d:" % tc)
        tree_spec = take_lines(lines, int(next(lines)))
        dtree = read_decision_tree(tree_spec)
        n_animals = int(next(lines))
        for line in islice(lines, n_animals):
            features = set(line.split()[2:])
            print(cuteness(dtree, features))

import sys
main(sys.stdin)

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc11" name="tocnotes" id="tocnotes"&gt;Notes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/power-programming#fn1link"&gt;[1]&lt;/a&gt; (Arc may not be mature, popular or well-supported; but Lisp certainly is.)
&lt;/p&gt;</description>
<dc:date>2010-01-26</dc:date>
<guid>http://wordaligned.org/articles/power-programming</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/power-programming</link>
<category>Perl</category>
</item>

<item>
<title>comp.lang.name?</title>
<description>&lt;h3&gt;How the Python became&lt;/h3&gt;
&lt;p&gt;Guido van Rossum had a problem: &lt;a href="http://python-history.blogspot.com/2009/01/personal-history-part-1-cwi.html"&gt;what to call his new language&lt;/a&gt;? Computer language names often tip a hat to their predecessors, as &lt;strong&gt;Ruby&lt;/strong&gt; does to &lt;strong&gt;Perl&lt;/strong&gt;, for example. In this case the immediate predecessor, &lt;strong&gt;ABC&lt;/strong&gt;, had itself changed from &lt;i&gt;&lt;b&gt;B&lt;/b&gt;&lt;/i&gt; because it got mistaken for &lt;strong&gt;B&lt;/strong&gt;, and the suggestion ABC &amp;#8220;made programming easy as ABC&amp;#8221; failed to convince Guido. So he dropped the alphabetic sequencing. Rather than tip a hat he picked a name from one.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I picked the first thing that came to mind, which happened to be &lt;a href="http://en.wikipedia.org/wiki/Monty_Python%27s_Flying_Circus"&gt;Monty Python&amp;#8217;s Flying Circus&lt;/a&gt;, one of my favorite comedy troupes. The reference felt suitably irreverent for what was essentially a &lt;a href="http://en.wikipedia.org/wiki/Skunkworks_project"&gt;&amp;#8220;skunkworks project&amp;#8221;&lt;/a&gt;. The word &amp;#8220;Python&amp;#8221; was also catchy, a bit edgy, and at the same time, it fit in the tradition of naming languages after famous people, like Pascal, Ada, and Eiffel.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Animals&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3215793436/" title="ya(k|cc) came?l a[uw]k "&gt;&lt;img style="float:right" src="http://farm4.static.flickr.com/3431/3215793436_6840bb27b3_m.jpg" width="174" height="240" alt="yacc caml awk" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Although Guido van Rossum held out for some time against Python being associated with snakes, he eventually &lt;a href="http://personal.ee.surrey.ac.uk/Personal/L.Wood/softwear/" title="At last GvR embraces the snake"&gt;capitulated&lt;/a&gt;. Blame the animal cover lovers at O&amp;#8217;Reilly! As it happens, I rate the reptile as highly as the comedians. I also like languages with animal names. Perhaps &lt;strong&gt;Yacc&lt;/strong&gt;, &lt;strong&gt;Awk&lt;/strong&gt; and &lt;strong&gt;Caml&lt;/strong&gt; also started life as skunkworks?
&lt;/p&gt;

&lt;h3&gt;Naming words&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Python_(mythology)"&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Virgil_Solis_-_Apollo_Python.jpg/350px-Virgil_Solis_-_Apollo_Python.jpg" alt="Apollo slaying Python"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Python is a noun &amp;#8212; what we called a &amp;#8220;naming word&amp;#8221; at junior school. Python is also a proper noun: in &lt;a href="http://en.wikipedia.org/wiki/Python_(mythology)" title="Python (mythology)"&gt;Greek Mythology&lt;/a&gt;, &lt;strong&gt;she&lt;/strong&gt; was the earth-dragon of Delphi. It&amp;#8217;s hardly surprising when language creators opt for nouns, often proper, frequently female: &lt;strong&gt;Ada&lt;/strong&gt;, &lt;strong&gt;Miranda&lt;/strong&gt;, &lt;strong&gt;Ruby&lt;/strong&gt;, for example. Also, &lt;strong&gt;Java&lt;/strong&gt;, &lt;strong&gt;Pascal&lt;/strong&gt;, &lt;strong&gt;Haskell&lt;/strong&gt; &amp;#8212; oh, yes, and &lt;strong&gt;Delphi&lt;/strong&gt;.
&lt;/p&gt;

&lt;h3&gt;Single characters&lt;/h3&gt;
&lt;p&gt;We&amp;#8217;ve already mentioned &lt;strong&gt;B&lt;/strong&gt;, which I guess is a (homophone of a) girl&amp;#8217;s name. It&amp;#8217;s also a well rounded character found near the front of the alphabet. Alphabetically, B comes before C, and the language B features amongst &lt;strong&gt;C&lt;/strong&gt;&amp;#8217;s predecessors. When Bjarne Stroustrup built object-oriented features on top of C, his new language became known as &amp;#8220;new C&amp;#8221; and &amp;#8220;C with classes&amp;#8221;. The former was disrespectful to C, which risked becoming &amp;#8220;old C&amp;#8221;, and the latter failed to excite. The final name, &lt;strong&gt;C++&lt;/strong&gt;, was an inspired choice, even if some have pointed out &lt;strong&gt;++C&lt;/strong&gt; would be more correct.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C#&lt;/strong&gt; squeezes more juice from the pun. Pronounced &amp;#8220;See Sharp!&amp;#8221;, the name has a commanding ring to it, and if you look within the hash symbol, #, you can make out redoubled ++ signs. Shouldn&amp;#8217;t it &lt;a href="http://en.wikipedia.org/wiki/C_Sharp_(programming_language)#Language_name"&gt;be written C&amp;#x266f;&lt;/a&gt; though, or should we really pronounce it &amp;#8220;See Hash&amp;#8221;? 
&lt;/p&gt;
&lt;p&gt;Both the + and the # characters have special semantics within URLs. How many C++ and C# blog posts end up being tagged &amp;#8220;C&amp;#8221;, I wonder? For similar reasons I guess it&amp;#8217;s still impractical to name a language &lt;b&gt;&amp;lambda;&lt;/b&gt; or &lt;b&gt;&amp;mu;&lt;/b&gt;, unless you&amp;#8217;re prepared to accept that name being spelled &lt;strong&gt;lambda&lt;/strong&gt; or &lt;strong&gt;mu&lt;/strong&gt;, that is.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;D&lt;/strong&gt; really does look like a great language in the C and C++ tradition, but its name lacks imagination. Enough alphabet already!
&lt;/p&gt;

&lt;h3&gt;Doing words&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;B&lt;/strong&gt; and &lt;strong&gt;C&lt;/strong&gt; are both strong, active verbs. Nothing beats being and seeing. Writers like verbs. Verbs make things happen, just like programming languages. Maybe &lt;strong&gt;Lisp&lt;/strong&gt; and &lt;strong&gt;Scheme&lt;/strong&gt; sound a bit geeky, sleazy even, but I like them. They&amp;#8217;re great names. Ever wonder how &lt;strong&gt;Bash&lt;/strong&gt; bludgeoned its way to shell domination? &lt;strong&gt;Squeak&lt;/strong&gt; is a great play on &lt;strong&gt;Smalltalk&lt;/strong&gt;. Knitters &lt;a href="http://dictionary.reference.com/browse/purl"&gt;&lt;strong&gt;perl&lt;/strong&gt;&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;Etc&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.lancearmstrong.com/"&gt;&lt;img style="float:right;" src="http://wordaligned.org/images/lance-armstrong.jpg" alt="Lance Armstrong, champion cyclist"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Adjectives and adverbs are poorly represented. &lt;strong&gt;Groovy&lt;/strong&gt; comes to mind, but not a lot else. Plenty of language names are (or once were) acronyms and abbreviations: as names, I prefer the ones you can read over the mouthfuls of consonants. On this basis, &lt;strong&gt;Fortran&lt;/strong&gt; pips &lt;strong&gt;PL/I&lt;/strong&gt;, and &lt;strong&gt;Sequel&lt;/strong&gt; beats &lt;strong&gt;Ess Queue El&lt;/strong&gt;.
&lt;/p&gt;
&lt;p&gt;We&amp;#8217;ve listed some great computer languages with great names. Can a good name shape a language&amp;#8217;s success? Well, certainly it can&amp;#8217;t hurt. Names matter. Lance Armstrong is surely the name of a champion, the kind of guy who can beat testicular cancer and win the world&amp;#8217;s toughest endurance event 7 times in a row. Check out his &lt;a href="http://www.lancearmstrong.com/"&gt;flash heavy website&lt;/a&gt;. Whereas the more gently named Tim Henman never quite fulfilled his tennis potential, and I can&amp;#8217;t even connect to &lt;a href="http://www.timhenman.org"&gt;www.timhenman.org&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Conversely, can a poor name stand in the way of success? &lt;strong&gt;ABC&lt;/strong&gt; has become (part of Python&amp;#8217;s) history. I think it&amp;#8217;s fair to say that, at this point, the weakly-named &lt;strong&gt;D&lt;/strong&gt; has gained respect rather than presence. On the other hand, &lt;strong&gt;JavaScript&lt;/strong&gt; is a poor name too, and &lt;strong&gt;ECMAScript&lt;/strong&gt; is worse, but it&amp;#8217;s a fine language which can claim to be more widely deployed than any other.
&lt;/p&gt;
&lt;h5&gt;&lt;a name="feedback"&gt;Feedback&lt;/a&gt;&lt;/h5&gt;&lt;div id="feedback_div"&gt;&lt;ol id="feedback" class="feedback"&gt;&lt;li class="feedbackitem"&gt;&lt;div class="author"&gt;&lt;cite&gt;Jez&lt;/cite&gt; 2009-01-23&lt;/div&gt;&lt;div class="content"&gt;&lt;p&gt;Names are important.  Choosing a good name for something is very difficult, and I know from past experience that you don&amp;#8217;t usually get a second go.  The humorous code name you chose almost certainly won&amp;#8217;t get changed later, and you&amp;#8217;ll be talking about &amp;#8220;using the Linguini server to add the zubins&amp;#8221; for ever.  Yes, that&amp;#8217;s a real example.&lt;/p&gt;&lt;p&gt;One of my favourite cartoons, The Secret Show, is a comedy spy thriller.  The agency head takes security &lt;i&gt;very&lt;/i&gt; seriously, and so his name is changed daily.  He&amp;#8217;s constantly undermined by being assigned ridiculous names - Mimzy Woowoo, Pimlico Buttonfluff, Princess Fairycakes, and so on.  In one episode his new name is Rock Justice, and his chest swells with pride.  Sadly though, it was just a dream.&lt;/p&gt;&lt;/div&gt;&lt;/li&gt;&lt;li class="feedbackitem" id="feedback-1000"&gt;&lt;div class="author"&gt;&lt;cite&gt;matt burns&lt;/cite&gt; 2009-01-28&lt;/div&gt;&lt;div class="content"&gt;&lt;p&gt;I&amp;#8217;m sure I&amp;#8217;m not alone in pronouncing things incorrectly due to many of the things I learn being done so by reading.&lt;/p&gt;&lt;p&gt;C# was one example because for quite a while I pronounced it &amp;#8220;see hash&amp;#8221; in my head until I descovered it should be &amp;#8220;see sharp&amp;#8221;. I still occasionally slip out with kay-sh instead of cah-sh for cache.&lt;/p&gt;&lt;p&gt;I didn&amp;#8217;t know that # and &amp;#x266f; were different symbols but now I do I feel less stupid.&lt;/p&gt;&lt;p&gt;(Wikipedia does mention that the language is actually C&amp;#x266f; but the # character is merely used to represent the &amp;#x266f; for simplicity.)&lt;/p&gt;&lt;/div&gt;&lt;/li&gt;&lt;li class="feedbackitem"&gt; 
&lt;div class="author"&gt;&lt;cite&gt;Thomas Guest&lt;/cite&gt; 2009-02-02&lt;/div&gt;&lt;div class="content"&gt;&lt;p&gt;You&amp;#8217;re definitely not alone, Matt. One thing which bugs me is when a name is spelled in a way which makes guessing its pronunciation hard.&lt;/p&gt;&lt;p&gt;The Cuil search engine, for example, which we&amp;#8217;re meant to pronounce &amp;#8220;cool&amp;#8221;.&lt;/p&gt;&lt;p&gt;Much as I like lighttpd, how are you supposed to say it? Lighty, apparently.&lt;/p&gt;&lt;p&gt;And it&amp;#8217;s &amp;#8220;Val-grinned&amp;#8221;, not &amp;#8220;Val-grind&amp;#8221;. Don&amp;#8217;t feed bad, &lt;a href="http://valgrind.org/docs/manual/faq.html#faq.pronounce"&gt;everyone gets it wrong at first&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description>
<dc:date>2009-01-21</dc:date>
<guid>http://wordaligned.org/articles/complangname</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/complangname</link>
<category>Perl</category>
</item>

<item>
<title>Perl 6, Python 3</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#tocchristmas-present" name="toc0" id="toc0"&gt;Christmas Present&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#tocpython-30" name="toc1" id="toc1"&gt;Python 3.0&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#tocprint-is-a-function" name="toc2" id="toc2"&gt;Print is a function&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#toc30-is-lazier" name="toc3" id="toc3"&gt;3.0 is lazier&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#tocunicode-support-is-better" name="toc4" id="toc4"&gt;Unicode support is better&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#tocunicode-and-word-aligned" name="toc5" id="toc5"&gt;Unicode and Word Aligned&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#tocword-aligned-and-python-30" name="toc6" id="toc6"&gt;Word Aligned and Python 3.0&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#toc0" name="tocchristmas-present" id="tocchristmas-present"&gt;Christmas Present&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I wish I could find a dedicated feed for Computerworld&amp;#8217;s &amp;#8220;A to Z of Programming Languages&amp;#8221; series &amp;#8212; I&amp;#8217;d subscribe, they&amp;#8217;re great reading. (My second wish is for online magazines to find a better way of generating revenue than all those noisy adverts.) Subscribed or not, I found and read the &lt;a href="http://www.computerworld.com.au/article/270267/-z_programming_languages_perl?pp=1"&gt;recent interview with Larry Wall about Perl&lt;/a&gt;. Perl 6 gets its first mention in the Q and A on the second page.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Would you have done anything differently in the development of Perl if you had the chance?
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Either nothing or everything. See Perl 6.&lt;/strong&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Except you can&amp;#8217;t really see Perl 6 yet. This ambitious new version of the language is, Larry Wall says, scheduled for release on Christmas Day. When pressed further on progress, he adds
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We&amp;#8217;re certainly well into the second 80 percent.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;A metric all software developers can relate to!
&lt;/p&gt;
&lt;p&gt;&lt;a title="95% done, just the other 95% to go" href="http://www.programmer-tshirts.com/"&gt;&lt;img alt="95% done, just the other 95% to go" src="http://successfulsoftware.files.wordpress.com/2008/12/programmer-tshirt.png?w=400"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;As a consequence of its protracted emergence, some of Perl 6&amp;#8217;s best features have been backported to Perl 5.10. Larry Wall, again:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;One of the most popular things is the use of &amp;#8220;say&amp;#8221; instead of &amp;#8220;print&amp;#8221;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I don&amp;#8217;t follow Perl closely enough to know if &lt;code&gt;say&lt;/code&gt; and &lt;code&gt;print&lt;/code&gt; are synonymous; and even if they are I can see why this change would be popular. Programmers use &lt;code&gt;print&lt;/code&gt; frequently, especially when trying to figure out what a program is doing (all of the time, that is!), and &lt;code&gt;say&lt;/code&gt; is two characters fewer to type, it&amp;#8217;s chatty, and I&amp;#8217;m all for variety.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#toc1" name="tocpython-30" id="tocpython-30"&gt;Python 3.0&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Perl 6 may have slipped another Christmas, but notably, soberly, sensibly, Python recently hit a milestone in its own ambitious trajectory. &lt;a href="http://python.org/news/"&gt;Python 3.0 (final) was released on December 3rd 2008&lt;/a&gt;. Python 3.0 is, I think, the first version of the language which breaks backwards compatibility: so, for example, a Python 2.2 program should work unchanged in Python 2.6, but a Python 2.6 program is unlikely to work in Python 3.0.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s a bold move, and one which has taken a lot of smart people a lot of hard work. For many others the hard work has just begun: forking the language marks the start, not the end, of a period of transition.
&lt;/p&gt;
&lt;p&gt;As Perl 5.10 anticipates Perl 6, so Python 2.6 anticipates Python 3.0. Some features, such as &lt;a href="http://docs.python.org/reference/lexical_analysis.html#grammar-token-bininteger" title="0b1011001, for example"&gt;binary literals&lt;/a&gt;, have been backported from 3.0; the &lt;code&gt;-3&lt;/code&gt; flag warns about Python 3.0 incompatibilities in 2.6 code; and a new tool, &lt;code&gt;2to3&lt;/code&gt;, converts 2.6 code into 3.0 code.
&lt;/p&gt;
&lt;p&gt;Despite looking forwards in this way, Python 2.6 is unlikely to mark the end of the Python 2.N line, and even for new users on greenfield projects Python 3.0 may not be a wise choice. For one thing it&amp;#8217;s new, whereas (e.g.) 2.5 is battle-hardened; for another, many popular third-party libraries and frameworks have yet to be released against 3.0. Although the standard documentation for Python 3.0 is complete, the &amp;#8220;current documentation&amp;#8221; linked to from the Python homepage resolves to &lt;a href="http://docs.python.org"&gt;Python 2.6.1&lt;/a&gt;, and that&amp;#8217;s where you&amp;#8217;re likely to find yourself if you e.g. google for help on &lt;a href="http://www.google.com/search?q=python+complex+numbers"&gt;a particular Python topic&lt;/a&gt;, or click a link from an online article. If you&amp;#8217;re after a book on Python, the choice for Python 3.0 is limited.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#toc2" name="tocprint-is-a-function" id="tocprint-is-a-function"&gt;Print is a function&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As with Perl 6, &lt;code&gt;print&lt;/code&gt; has changed: in Python 3.0 &lt;a href="http://docs.python.org/3.0/whatsnew/3.0.html#print-is-a-function"&gt;print is a function, not a statement&lt;/a&gt;. So while Perl loses a couple of characters, Python gains two (the parentheses required for function application). On the other hand, it would no longer be a syntax error to assign the function &lt;code&gt;print&lt;/code&gt; to a variable &lt;code&gt;say&lt;/code&gt;.
&lt;/p&gt;
&lt;pre&gt;
$ python3.0 -c "say = print"
$ python2.6 -c "say = print"
  File "&amp;lt;string&amp;gt;", line 1
    say = print
              ^
SyntaxError: invalid syntax
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#toc3" name="toc30-is-lazier" id="toc30-is-lazier"&gt;3.0 is lazier&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a blot on Python 2.6 and its predecessors: the &lt;code&gt;range()&lt;/code&gt; builtin function returns a complete list, even if you only want to consume its elements one at a time. &lt;code&gt;Xrange()&lt;/code&gt;, which generates numbers on demand, is more efficient and generally what&amp;#8217;s needed. Similarly in 2.6 &lt;code&gt;map()&lt;/code&gt; and &lt;code&gt;filter()&lt;/code&gt; return complete lists; for elements on demand, use &lt;code&gt;itertools.imap()&lt;/code&gt; and &lt;code&gt;itertools.ifilter()&lt;/code&gt;. And Python 2.6 provides both lazy and complete ways to access keys, values and items in a dict.
&lt;/p&gt;
&lt;p&gt;Note the redundancy here: &lt;code&gt;range()&lt;/code&gt; is equivalent to &lt;code&gt;list(xrange())&lt;/code&gt;, etc.
&lt;/p&gt;
&lt;p&gt;Python 3.0 simplifies things, letting &lt;code&gt;range()&lt;/code&gt; do what &lt;code&gt;xrange()&lt;/code&gt; used to, and eliminating the awkwardly named &lt;code&gt;xrange()&lt;/code&gt;. Similarly &lt;code&gt;map/filter()&lt;/code&gt; replace &lt;code&gt;itertools.imap/ifilter()&lt;/code&gt;. &lt;code&gt;Dict.iteritems()&lt;/code&gt; etc. have gone; thus &lt;code&gt;dict.items()&lt;/code&gt; is lazy, and if you need the complete list of all &lt;code&gt;(key, value)&lt;/code&gt; pairs in a dict, &lt;code&gt;list(dict.items())&lt;/code&gt; does the job.
&lt;/p&gt;
&lt;p&gt;These changes add little to the power of the language, and may even seem to wilfully break backwards compatibility. For me, they&amp;#8217;re about consistency, and reducing interfaces to a minimal complete set. I applaud them.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#toc4" name="tocunicode-support-is-better" id="tocunicode-support-is-better"&gt;Unicode support is better&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span style="font-size:600%;"&gt;&amp;#x2600; &amp;#x2601; &amp;#x2602; &amp;#x2603;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;More significantly, Python 3.0 builds in proper support for Unicode, or at least the basis for proper Unicode support. The problem here being, &lt;a href="http://www.cmlenz.net/archives/2008/07/the-truth-about-unicode-in-python"&gt;Unicode is &lt;strong&gt;necessarily&lt;/strong&gt; complex&lt;/a&gt; &amp;#8212; as any system which encompasses so many subtle cultural differences must be &amp;#8212; and however cleverly Python has adapted to the challenge, some of this complexity must rise to the surface of Python 3.0 programs.
&lt;/p&gt;
&lt;p&gt;Is this complexity really essential? Could a modern language reasonably ignore Unicode, or delegate its support to a standard library? Has Python become less attractive to learners and novices? When Paul Graham &lt;a href="http://www.paulgraham.com/arc0.html" title="Arc's Out, 2008-01-29"&gt;launched a new lisp dialect, Arc&lt;/a&gt;, at the start of 2008, he noted:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I went to a talk last summer by Guido van Rossum about Python, and he seemed to have spent most of the preceding year switching from one representation of characters to another. I never want to blow a year dealing with characters. Why did Guido have to? Because he had to think about compatibility. But though it seems benevolent to worry about breaking existing code, ultimately there&amp;#8217;s a cost: it means you spend a year dealing with character sets instead of making the language more powerful.
&lt;/p&gt;
&lt;p&gt;Which is why, incidentally, Arc &lt;a href="http://arclanguage.org/item?id=391"&gt;only supports Ascii&lt;/a&gt;. MzScheme, which the current version of Arc compiles to, has some more advanced plan for dealing with characters. But it would probably have taken me a couple days to figure out how to interact with it, and I don&amp;#8217;t want to spend even one day dealing with character sets.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Sad to say, it would take me more than a couple of days to figure out MzScheme&amp;#8217;s advanced character plan, so I&amp;#8217;m not qualified to comment on Paul Graham&amp;#8217;s decision. Many others did, at the time, and if you follow the link in the blockquote above, you&amp;#8217;ll find a few words of explanation which I&amp;#8217;ll paraphrase here: Arc is not about the details of character sets, it&amp;#8217;s a high-level language, for writing short programs.
&lt;/p&gt;
&lt;p&gt;I class Python as &lt;a href="http://wordaligned.org/articles/pitching-python-in-three-syllables.html"&gt;a high-level language&lt;/a&gt; too, and regard its power and accessibility as the source of its popularity. Python is also a mainstream language and one increasingly used at the heart of internationalised applications. I agree with James Bennett: &lt;a href="http://www.b-list.org/weblog/2008/dec/05/python-3000/"&gt;Unicode support is fundamental and necessary&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#toc5" name="tocunicode-and-word-aligned" id="tocunicode-and-word-aligned"&gt;Unicode and Word Aligned&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Anyone who&amp;#8217;s visited &lt;a href="http://wordaligned.org/"&gt;Word Aligned&lt;/a&gt; before will know that most of the example code here is in Python. I&amp;#8217;m aware that on several occasions I&amp;#8217;ve waved away Unicode issues (an anagram solver which fails to identify &amp;#8220;face&amp;#8221; as an anagram of &amp;#8220;caf&amp;eacute;&amp;#8221;, for example).
&lt;/p&gt;
&lt;p&gt;Like Paul Graham, I can justify my decision. I want the code presented on this site to work, but not just so you can cut and paste it. I&amp;#8217;m not a library provider. I use Python here primarily because it&amp;#8217;s succinct and accessible. &lt;strong&gt;I want you to read it!&lt;/strong&gt; Sometimes blurring the distinction between characters and bytes makes for short and sweet examples.
&lt;/p&gt;
&lt;p&gt;If I switch to Python 3.0, will I still be able to cut these corners? Or will my code become more fiddly because it must deal more explicitly with character encoding issues? The truth is, I don&amp;#8217;t know yet, I&amp;#8217;ve only written one Python 3.0 program.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;My first Python 3.0 program&lt;/div&gt;

&lt;pre class="prettyprint"&gt;import antigravity

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/perl-6-python-3#toc6" name="tocword-aligned-and-python-30" id="tocword-aligned-and-python-30"&gt;Word Aligned and Python 3.0&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At work, our choice is obvious. We shall continue to use Python 2.5 for the immediate future. There&amp;#8217;s no advantage to switching even a point revision at this stage in the project I&amp;#8217;m working on, and the third party code we depend on has yet to be released against Python 3.0.
&lt;/p&gt;
&lt;p&gt;On this website, I can take a complementary and more forward looking approach. Anything published in 2008 and before should work with Python 2.6. Anything published in 2009 and beyond should work with Python 3.0.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;My second Python 3.0 program&lt;/div&gt;

&lt;pre class="prettyprint"&gt;print('Happy new year!')

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2009-01-01</dc:date>
<guid>http://wordaligned.org/articles/perl-6-python-3</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/perl-6-python-3</link>
<category>Perl</category>
</item>

<item>
<title>Entertaining Documentation</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#toca-programmers-first-language" name="toc0" id="toc0"&gt;A Programmer&amp;#8217;s first language&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#tocshould-documentation-entertain" name="toc1" id="toc1"&gt;Should documentation entertain?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#tocunix-sets-the-standard" name="toc2" id="toc2"&gt;Unix sets the standard&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#tocentertaining-python-documentation" name="toc3" id="toc3"&gt;Entertaining Python documentation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#tocmultimedia-documentation" name="toc4" id="toc4"&gt;Multimedia documentation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#tocducking-the-challenge" name="toc5" id="toc5"&gt;Ducking the challenge&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#toclooking-further" name="toc6" id="toc6"&gt;Looking further&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#toc0" name="toca-programmers-first-language" id="toca-programmers-first-language"&gt;A Programmer&amp;#8217;s first language&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://personal.ee.surrey.ac.uk/Personal/L.Wood/double-plus-ungood/" title="BDFL wearing ++ungood T-shirt and snake"&gt;&lt;img src="http://info.ee.surrey.ac.uk/Personal/L.Wood/softwear/ungood-guido-van-rossum-small.jpeg" alt="BDFL wearing ++ungood T-shirt"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;A recent enquiry on the &lt;a href="http://accu.org/index.php/mailinglists"&gt;ACCU mailing list&lt;/a&gt; asked which programming language would be most suitable for a beginner. The general response favoured Python. This should come as no surprise: &lt;a href="http://www.techworld.com.au/article/255835/-z_programming_languages_python"&gt;elsewhere&lt;/a&gt;, Python&amp;#8217;s benevolent dictator for life explains: 
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     how his funky title came about, and 
 &lt;/li&gt;

 &lt;li&gt;
     how (somewhat to his surprise) Python has become increasingly popular for teaching and as a first language.
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hang on though! Back on the mailing list Mike Small voiced his dissent and spoke up for Perl.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; I also think the online &lt;a href="http://perldoc.perl.org/"&gt;Perl documentation&lt;/a&gt; blows away the online &lt;a href="http://docs.python.org"&gt;Python docs&lt;/a&gt;.  One I can read for entertainment. The other has just the bare facts and is dull, although not as bad as the run of the mill doxygen-type tool generated, fill in the required fields docs you get for mainstream stuff like Java or .NET.
&lt;/p&gt;
&lt;p&gt;Compare&amp;#8230;
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://perldoc.perl.org/perlbot.html"&gt;http://perldoc.perl.org/perlbot.html&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&amp;#8230; with &amp;#8230;
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.python.org/ref/types.html"&gt;http://docs.python.org/ref/types.html&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;(if that&amp;#8217;s an unfair comparison someone feel free to find me an excerpt from the standard python docs that isn&amp;#8217;t a complete snore-fest).
&lt;/p&gt;
&lt;/blockquote&gt;&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#toc1" name="tocshould-documentation-entertain" id="tocshould-documentation-entertain"&gt;Should documentation entertain?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Well, this &lt;em&gt;did&lt;/em&gt; surprise me, primarily because it seemed such an unusual charge. It&amp;#8217;s hard &amp;#8212; harder than generally acknowledged, I think &amp;#8212; to write good documentation. In the case of a language reference manual or a standard library user guide, &amp;#8220;good&amp;#8221; would mean accurate, accessible and written as simply as possible. Surely entertainment value doesn&amp;#8217;t get a look in?
&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s more, for a language up there with Perl and Python, many readers face text written by an author from a different culture and in a language which may not be their first. Irony and wit easily get mistranslated.
&lt;/p&gt;
&lt;p&gt;Most &lt;a href="http://c2.com/cgi/wiki?FunnyThingsSeenInSourceCodeAndDocumentation"&gt;jokes in software and its documentation fall flat&lt;/a&gt;. If it&amp;#8217;s hard to write clearly, it&amp;#8217;s almost impossible to write clearly and entertainingly. Guido van Rossum may be a fan of Monty Python, but I imagine he&amp;#8217;s happy leave the humour up to experts like &lt;a href="http://www.cleeseblog.com/"&gt;Cleese&lt;/a&gt; et al.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cleeseblog.com/"&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/en/a/ae/Tv_muppet_show_john_cleese.jpg" alt="Humour Experts"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Maybe.
&lt;/p&gt;
&lt;p&gt;On the other hand, even the &lt;a href="http://www.google.co.uk/search?q=14882%3A2003" title="Search for the current C++ standard"&gt;driest reference in computer programming&lt;/a&gt; makes space for an amusing &amp;#8212; and &lt;em&gt;informative&lt;/em&gt; &amp;#8212; limerick.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www-cs-faculty.stanford.edu/~knuth"&gt;&lt;img style="float:right;" src="http://www-cs-faculty.stanford.edu/~uno/don.gif" alt="Don Knuth"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;I happen to think the standard Python documentation is generally very good. I wouldn&amp;#8217;t recommend Python as a language for learners if this wasn&amp;#8217;t the case. But perhaps Mike Small has a point. The very best software writers can entertain and amuse as well as inform &amp;#8212; Donald Knuth being the outstanding example. &lt;a href="http://www-cs-faculty.stanford.edu/~knuth/taocp.html"&gt;&amp;#8220;The Art of Computer Programming&amp;#8221;&lt;/a&gt; manages to be academic without being dry, a readable reference. Classics like Jon Bentley&amp;#8217;s &amp;#8220;Programming Pearls&amp;#8221; and Abelson and Sussman&amp;#8217;s &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt; also show what can be achieved. From what I&amp;#8217;ve read of his, &lt;a href="http://www.wall.org/~larry"&gt;Larry Wall&lt;/a&gt; is up there too, and his wit and linguistic energy shine through Perl, even if he didn&amp;#8217;t personally document all of it.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.wall.org/~larry/"&gt;&lt;img src="http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/033/3394/3394f1.png" alt="Larry Wall"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#toc2" name="tocunix-sets-the-standard" id="tocunix-sets-the-standard"&gt;Unix sets the standard&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We mustn&amp;#8217;t equate &amp;#8220;entertaining&amp;#8221; with &amp;#8220;funny&amp;#8221;. The Unix documentation (available at terminal near you via &lt;code&gt;man&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt;) is hardly a chuckle-fest, but its vigour and clarity make it a fine read. Although it never aims to amuse, sometimes its deadpan delivery makes me laugh. Here&amp;#8217;s the BSD documentation for a handy but non-standard C string function:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Note that because strlcpy(3) is not defined in any standards, it should only be used when portability is not a concern.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Typing &lt;code&gt;man gamma&lt;/code&gt; on a nearby Linux box generates the painfully funny story of the confusion surrounding the naming and usage of the &lt;a href="http://www.johndcook.com/blog/2008/04/24/how-to-calculate-binomial-probabilities/"&gt;Gamma function&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;HISTORY&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;4.2BSD had a &lt;strong&gt;gamma()&lt;/strong&gt; that computed ln(|Gamma(|x|)|), leaving the sign of  Gamma(|x|) in the external integer signgam.  In 4.3BSD the name was changed to &lt;strong&gt;lgamma()&lt;/strong&gt;, and the man page promises
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8220;At some time in the future the name gamma will be rehabilitated and used for the Gamma function&amp;#8221;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;This  did indeed happen in 4.4BSD, where &lt;strong&gt;gamma()&lt;/strong&gt; computes the Gamma function (with no effect on signgam).  However, this came too late, and we now have &lt;strong&gt;tgamma()&lt;/strong&gt;, the &amp;#8220;true gamma&amp;#8221; function.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CONFORMING TO&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;4.2BSD. Compatible with previous mistakes.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;In the main, though, the Unix documentation is plain, understated and accurate. It sets the standard for written software reference documentation. 
&lt;/p&gt;
&lt;p&gt;Maybe this is why Mike enjoys the Perl documentation? I&amp;#8217;ve heard Perl described as &amp;#8220;shell on steroids&amp;#8221;; and while the Perl documentation &lt;em&gt;does&lt;/em&gt; have the look and feel of a man page, there&amp;#8217;s also something a bit more pumped up and manic about it.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#toc3" name="tocentertaining-python-documentation" id="tocentertaining-python-documentation"&gt;Entertaining Python documentation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;What about the standard Python documentation? Certainly, it aims for a friendly, informal tone. Here&amp;#8217;s an &lt;a href="http://docs.python.org/tut/node3.html"&gt;excerpt&lt;/a&gt; from the tutorial introduction:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;By the way, the language is named after the BBC show &amp;#8220;Monty Python&amp;#8217;s Flying Circus&amp;#8221; and has nothing to do with nasty reptiles. Making references to Monty Python skits in documentation is not only allowed, it is encouraged! 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Later, this same tutorial makes good on that promise, taking us through the subtleties of &lt;a href="http://docs.python.org/tut/node6.html"&gt;keyword arguments&lt;/a&gt; with reference to the famous &lt;a href="http://en.wikipedia.org/wiki/Dead_Parrot"&gt;dead parrot sketch&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Functions can also be called using keyword arguments of the form &amp;#8220;&lt;tt&gt;keyword = value&lt;/tt&gt;&amp;#8221;.  For instance, the following function:&lt;/p&gt;
&lt;pre&gt;
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print "-- This parrot wouldn't", action,
    print "if you put", voltage, "volts through it."
    print "-- Lovely plumage, the", type
    print "-- It's", state, "!"
&lt;/pre&gt;
&lt;p&gt;could be called in any of the following ways:&lt;/p&gt;
&lt;pre&gt;
parrot(1000)
parrot(action = 'VOOOOOM', voltage = 1000000)
parrot('a thousand', state = 'pushing up the daisies')
parrot('a million', 'bereft of life', 'jump')
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, I guess it beats the weary employee database examples found in so many programming texts. Sadly, though, the parrot sketch has been repeated too often, and in this case the &amp;#8220;snore-fest&amp;#8221; epithet sticks.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#toc4" name="tocmultimedia-documentation" id="tocmultimedia-documentation"&gt;Multimedia documentation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Mike talks explicitly about &amp;#8220;online documentation&amp;#8221;, and these days online (for programmers, at least) implies:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     a decent browser
 &lt;/li&gt;

 &lt;li&gt;
     plenty of pixels
 &lt;/li&gt;

 &lt;li&gt;
     a high bandwidth connection
 &lt;/li&gt;

 &lt;li&gt;
     javascript
 &lt;/li&gt;

 &lt;li&gt;
     excellent graphics
 &lt;/li&gt;

 &lt;li&gt;
     a means to collaborate and contribute
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These factors, in combination, enable some novel possibilities for documentation. Hyperlinks provide basic navigation; mix in folding documentation and search facilities, and readers quickly find what they&amp;#8217;re looking for. There&amp;#8217;s ample space for examples and comments, for contributions, for diagrams, for &lt;a href="http://showmedo.com/videos/python"&gt;audio and video&lt;/a&gt; content. Why bother reading how to create a &lt;a href="http://showmedo.com/videos/series?name=PythonWxPythonBeginnersSeries"&gt;graphical user interface using wxPython&lt;/a&gt;, for example, when you can effectively look over someone&amp;#8217;s shoulder while they walk through its features?
&lt;/p&gt;
&lt;p&gt;I said earlier that the Unix documentation set the standard for written documentation. If you&amp;#8217;re reading at a terminal 40 rows deep and 72 columns wide, with limited font rendering and graphical capabilities, you couldn&amp;#8217;t do better. If you have a larger screen and more than one monitor, maybe you can.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#toc5" name="tocducking-the-challenge" id="tocducking-the-challenge"&gt;Ducking the challenge&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Returning to Mike Small&amp;#8217;s challenge:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; someone feel free to find me an excerpt from the standard python docs that isn&amp;#8217;t a complete snore-fest.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I can see where he&amp;#8217;s coming from, but I disagree. In my opinion the Python documentation is well-organised, accessible and accurate. The documentation for some modules may be rather thin, but that&amp;#8217;s the strongest criticism I would make. I do struggle to single out an entertaining excerpt, though: the documentation aims to inform, and at that it does well.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/entertaining-documentation#toc6" name="toclooking-further" id="toclooking-further"&gt;Looking further&lt;/a&gt;&lt;/h3&gt;
&lt;div class="amazon"&gt;&lt;a href="http://www.amazon.com/gp/product/0596007973?ie=UTF8&amp;amp;tag=wordalig-20"&gt;&lt;img src="http://wordaligned.org/images/books/python-cookbook.jpg" alt="Python Cookbook cover"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;If you&amp;#8217;re prepared to venture away from &lt;a href="http://docs.python.org"&gt;docs.python.org&lt;/a&gt;, you&amp;#8217;ll find the Python community is served by some &lt;a href="http://diveintomark.org" title="Mark Pilgrim"&gt;talented&lt;/a&gt; &lt;a href="http://www.dabeaz.com" title="David Beazley"&gt;and&lt;/a&gt; &lt;a href="http://www.aleax.it/python_mat_en.html" title="Alex Martelli"&gt;entertaining&lt;/a&gt; writers. I&amp;#8217;ve &lt;a href="http://wordaligned.org/articles/essential-python-reading-list.html" title="My essential Python reading list"&gt;mentioned&lt;/a&gt; the &lt;a href="http://www.amazon.com/gp/product/0596007973?ie=UTF8&amp;amp;amp;tag=wordalig-20"&gt;Python Cookbook&lt;/a&gt; before: the entire text can now be found &lt;a href="http://www.ubookcase.com/book/Oreilly/Python.Cookbook.2nd.edition"&gt;online&lt;/a&gt;, but I recommend getting hold of hard-copy so you can sit down and read it from cover to cover &amp;#8212; definite armchair material. Many programmers contributed recipes to the book but it&amp;#8217;s pulled together by some skillful editing and by the fine essays which introduce each chapter.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/codebear/7409127/"&gt;&lt;img style="float:left;" src="http://static.flickr.com/4/7409127_53df0dd56c_s.jpg" alt="Tim Peters by codebear"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Tim Peters introduces the chapter on &lt;a href="http://www.ubookcase.com/book/Oreilly/Python.Cookbook.2nd.edition/0596007973/ch05-77003.html"&gt;Searching and Sorting&lt;/a&gt; and if you scratch at Python a little harder you&amp;#8217;ll find plenty more written by him. &lt;a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt"&gt;Here are his notes&lt;/a&gt; on Python&amp;#8217;s hybrid sort algorithm. &lt;a href="http://svn.python.org/projects/python/trunk/Objects/listobject.c"&gt;Here&amp;#8217;s&lt;/a&gt; the implementation. Enjoy!
&lt;/p&gt;</description>
<dc:date>2008-08-27</dc:date>
<guid>http://wordaligned.org/articles/entertaining-documentation</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/entertaining-documentation</link>
<category>Perl</category>
</item>

<item>
<title>Too big or too clever?</title>
<description>&lt;p&gt;When it comes to programming languages, not everyone equates &lt;em&gt;dynamic&lt;/em&gt; with &lt;em&gt;better&lt;/em&gt;, but I was surprised to read Alex Martelli cautioning against it. Here he is though, in a recent &lt;a href="http://groups.google.com/group/comp.lang.python/msg/28422d707512283"&gt;post&lt;/a&gt; on &lt;code&gt;comp.lang.python&lt;/code&gt;, responding eloquently to the topic &amp;#8220;What&amp;#8217;s better about Ruby than Python?&amp;#8221;. 
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Too clever&lt;/h3&gt;
&lt;p&gt;Martelli identifies a fundamental difference between the two languages:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; Ruby&amp;#8217;s TOTAL, unbridled &amp;#8220;dynamicity&amp;#8221;, including the ability to &amp;#8220;reopen&amp;#8221; any existing class, including all built-in ones, and change its behavior at run-time &amp;#8212; vs Python&amp;#8217;s vast but &lt;em&gt;bounded&lt;/em&gt; dynamicity, which never changes the behavior of existing built-in classes and their instances.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;He considers this:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; a crucial issue &amp;#8212; one that makes Ruby much more suitable for &amp;#8220;tinkering&amp;#8221;, BUT Python equally more suitable for use in large production applications.  It&amp;#8217;s funny, in a way, because both languages are so MUCH more dynamic than most others, that in the end the key difference between them from my POV should hinge on that &amp;#8212; that Ruby &amp;#8220;goes to eleven&amp;#8221; in this regard (the reference here is to &amp;#8220;Spinal Tap&amp;#8221;, of course).  In Ruby, there are no limits to my creativity &amp;#8212; if I decide that all string comparisons must become case-insensitive, I CAN DO THAT!  I.e., I can dynamically alter the built-in string class so that&lt;/p&gt;
&lt;pre&gt;
    a = "Hello World"
    b = "hello world"
    if a == b
        print "equal!\n"
    else
        print "different!\n"
    end
&lt;/pre&gt;
&lt;p&gt;WILL print &amp;#8220;equal&amp;#8221;.&lt;/p&gt;
&lt;p&gt;In python, there is NO way I can do
that.  For the purposes of metaprogramming, implementing
experimental frameworks, and the like, this amazing dynamic
ability of Ruby is _extremely_ appealing.  BUT &amp;#8212; if we&amp;#8217;re
talking about large applications, developed by many people
and maintained by even more, including all kinds of libraries
from diverse sources, and needing to go into production in
client sites&amp;#8230; well, I don&amp;#8217;t WANT a language that is QUITE
so dynamic, thank you very much.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I&amp;#8217;ve heard this opinion before, nudged even further along the static-dynamic scale. Some argue Python is &lt;a href="http://wordaligned.org/articles/pitching-python-in-three-syllables.html"&gt;too dynamic&lt;/a&gt; for large applications; that you&amp;#8217;re better off with something more disciplined, statically typed, enterprise ready, something with decent IDEs to keep your code in shape &amp;#8212; something like Java.
&lt;/p&gt;

&lt;h3&gt;Too Big&lt;/h3&gt;
&lt;p&gt;In &lt;a href="http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html"&gt;&amp;#8220;Code&amp;#8217;s Worst Enemy&amp;#8221;&lt;/a&gt; Steve Yegge rants about his own large application:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; a beautiful game [written] in an ugly language &amp;#8230; lovely on the outside and quite horrific internally
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;The ugly language turns out to be Java, 500,000 lines of it. Eclipse won&amp;#8217;t load it. The code base has collapsed under its own weight.
&lt;/p&gt;
&lt;p&gt;Yegge identifies size as the enemy. More controversially, he argues some of our conventional allies in countering this enemy are, in fact, traitors. Refactoring, for one: applied to Java, it can result in code bloat. And all that design-pattern boiler-plate. Look, even our precious IDEs deceive us!
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Java-style IDEs intrinsically create a circular problem. The circularity stems from the nature of programming languages: the &amp;#8220;game piece&amp;#8221; shapes are determined by the language&amp;#8217;s static type system. Java&amp;#8217;s game pieces don&amp;#8217;t permit code elimination because Java&amp;#8217;s static type system doesn&amp;#8217;t have any compression facilities &amp;#8212; no macros, no lambdas, no declarative data structures, no templates, nothing that would permit the removal of the copy-and-paste duplication patterns that Java programmers think of as &amp;#8220;inevitable boilerplate&amp;#8221;, but which are in fact easily factored out in dynamic languages.
&lt;/p&gt;
&lt;p&gt;Completing the circle, dynamic features make it more difficult for IDEs to work their static code-base-management magic. IDEs don&amp;#8217;t work as well with dynamic code features, so IDEs are responsible for encouraging the use of languages that require&amp;#8230; IDEs. Ouch.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I think Yegge gets a lot wrong in this rant, but it&amp;#8217;s clear he speaks from experience, and for all his swagger it&amp;#8217;s also clear he&amp;#8217;s thought hard about what he says. I agree with his main point: &lt;strong&gt;size is the enemy&lt;/strong&gt;. And I agree with his conclusion too. You need a language which allows you to dispense with boiler-plate, a language in which you &lt;a href="http://c2.com/cgi/wiki?DontRepeatYourself"&gt;don&amp;#8217;t have to repeat yourself&lt;/a&gt;. A powerful language. A dynamic language.
&lt;/p&gt;

&lt;h3&gt;Who&amp;#8217;s Right?&lt;/h3&gt;
&lt;p&gt;So, who&amp;#8217;s right? 
&lt;/p&gt;
&lt;p&gt;For a large application developed by a large team and maintained by a larger one could a language like Ruby be &lt;strong&gt;too dynamic&lt;/strong&gt;? 
&lt;/p&gt;
&lt;p&gt;Or is &lt;strong&gt;size the enemy&lt;/strong&gt;? Do we need a language so powerful it &lt;a href="http://blog.plover.com/prog/design-patterns.html"&gt;absorbs design patterns&lt;/a&gt;, so dynamic we never need repeat ourselves, so succinct we can &lt;a href="http://www.paulgraham.com/head.html"&gt;fit the code in our heads&lt;/a&gt;?
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;d say the latter. A dynamic language might be too slow (for a few parts of a system) but it can&amp;#8217;t be too dynamic. Meta-programming requires taste and restraint, of course, not to mention boundaries; and we mustn&amp;#8217;t expect any one programming language to fix our design. For any large system, I&amp;#8217;d expect multiple components, layers of abstraction &amp;#8212; and layers of languages.
&lt;/p&gt;</description>
<dc:date>2007-12-20</dc:date>
<guid>http://wordaligned.org/articles/too-big-or-too-clever</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/too-big-or-too-clever</link>
<category>Perl</category>
</item>

<item>
<title>Maybe we live in a scripting universe</title>
<description>&lt;p&gt;Although Perl was &lt;a href="http://wordaligned.org/articles/perlish-wisdom.html#excerpt0"&gt;the first high-level language I fell for&lt;/a&gt; I rarely use it these days. It&amp;#8217;s true, some well-worn Perl scripts still lurk in my &lt;code&gt;~/bin&lt;/code&gt; but, despite their manipulexity and whipuptitude, I make little effort to maintain them.
&lt;/p&gt;
&lt;img src="http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/Perl/PerlPresentFuture?action=download&amp;amp;value=10.png" alt="Graph plotting manipulexity against whipuptitude"/&gt;

&lt;p&gt;As a consequence I haven&amp;#8217;t really tracked the development of Perl 6. Standing on the sidelines it sometimes seems &lt;a href="http://wordaligned.org/articles/a-yen-for-more-symbols.html"&gt;like a joke&lt;/a&gt;: but &lt;span /&gt;Perl has always had a great sense of humour; and, like all great humour, it deserves taking seriously.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Wall on Perl&lt;/h3&gt;
&lt;p&gt;The language&amp;#8217;s creator, &lt;a href="http://www.wall.org/~larry/"&gt;Larry Wall&lt;/a&gt;, very definitely merits attention. Given Perl&amp;#8217;s heritage, it&amp;#8217;s hardly surprising his 11th State of the Onion address about &lt;a href="http://www.perl.com/pub/a/2007/12/06/soto-11.html" title="Programming is Hard, Let's go Scripting"&gt;scripting, programming and the future of Perl&lt;/a&gt; is crammed with &lt;a href="http://sial.org/howto/perl/one-liner"&gt;one-liners&lt;/a&gt;. I can&amp;#8217;t resist quoting a few:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;So basically, multiple dispatch is like democracy. It&amp;#8217;s the worst way to do late binding, except for all the others.
&lt;/p&gt;
&lt;p&gt;And we&amp;#8217;re making all the remaining punctuation work harder. Each symbol has to justify its existence according to Huffman coding.
&lt;/p&gt;
&lt;p&gt;Keep common things short, but not too short. In this case, 0 is too short.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ve looked a bit at Microsoft&amp;#8217;s Monad, and I&amp;#8217;m pleased to note that it has object pipes like Perl 6. I just hope they don&amp;#8217;t patent it.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Wall&amp;#8217;s linguistic facility shines through every level of his &lt;a href="http://www.perl.com/pub/a/2007/12/06/soto-11.html" title="Programming is Hard, Let's go Scripting"&gt;address&lt;/a&gt;. I hadn&amp;#8217;t realised he studied linguistics at grad school. It seems obvious now. Programming, scripting, reading, writing &amp;#8212; &lt;a href="http://wordaligned.org/articles/why-software-development-isnt-like-construction.html#a-better-metaphor"&gt;all language&lt;/a&gt;. Wall again:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I view a string as a Text, with a capital T.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Text&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;I read that word from a postmodern perspective. Of course, the term Postmodern is itself context-sensitive. Some folks think Postmodernism means little more than the Empowerment of the Vulgar. Some folks think the same about Perl.
&lt;/p&gt;
&lt;p&gt;But I take Postmodernism to mean that a Text, whether spoken or written, is an act of communication requiring intelligence on both ends, and sometimes in the middle too.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I won&amp;#8217;t pretend I followed all Wall&amp;#8217;s flourishes or grasped every linguistic dimension he describes. He admits in advance he&amp;#8217;s probably got it wrong.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Really designing a language for the future involves a great deal of humility. As with science, you have to assume that, over the long term, a great deal of what you think is true will turn out not to be quite the case. On the other hand, if you don&amp;#8217;t make your best guess now, you&amp;#8217;re not really doing science either. In retrospect, we know APL had too many strange symbols. But we wouldn&amp;#8217;t be as sure about that if APL hadn&amp;#8217;t tried it first.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Wherever and whenever Perl 6 may be, there&amp;#8217;s more than one way to do there&amp;#8217;s more than one way to do it.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; for each of these dimensions, it&amp;#8217;s not just a binary decision, but a knob that can be positioned at design time, compile time, or even run time. For a given dimension X, different scripting languages make different choices, set the knob at different locations.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     You can&amp;#8217;t even think about X!
 &lt;/li&gt;

 &lt;li&gt;
     There&amp;#8217;s only one way to do X!
 &lt;/li&gt;

 &lt;li&gt;
     There&amp;#8217;s more than one way to do X!
 &lt;/li&gt;

 &lt;li&gt;
     There are too many ways to do X!
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;hr /&gt;


&lt;h4&gt;Footnote&lt;/h4&gt;
&lt;p&gt;In the &lt;a href="http://www.perl.com/pub/a/2007/12/06/soto-11.html" title="Programming is Hard, Let's go Scripting"&gt;11th State of the Onion&lt;/a&gt; Wall asserts:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Perl and Ruby take their functional programming support rather more seriously than Python does.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I don&amp;#8217;t know enough about Perl and Ruby to disagree with any authority. I do know Python&amp;#8217;s support for functional programming has been steadily improving from one minor revision of the language to the next, with (e.g.) core language features like decorators and generator expressions, and library support for &lt;a href="http://docs.python.org/lib/module-itertools.html"&gt;lazily evaluated sequences&lt;/a&gt; and &lt;a href="http://docs.python.org/lib/module-functools.html"&gt;partial function application&lt;/a&gt;. The next major revision, Python 3000, continues this evolution, even if anonymous functions remain under-emphasised and &lt;a href="http://wordaligned.org/articles/paralipsis.html"&gt;reduce&lt;/a&gt; is to be axed from the language core.
&lt;/p&gt;</description>
<dc:date>2007-12-18</dc:date>
<guid>http://wordaligned.org/articles/maybe-we-live-in-a-scripting-universe</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/maybe-we-live-in-a-scripting-universe</link>
<category>Perl</category>
</item>

<item>
<title>A yen for more symbols</title>
<description>&lt;p&gt;Apparently &lt;a href="http://tartley.com/?p=197"&gt;true&lt;/a&gt;: at one point &lt;a href="http://dev.perl.org/perl6/"&gt;Perl 6&lt;/a&gt; used &amp;#x00a5; U+00A5 YEN SIGN as a zip operator, for the excellent reason that this particular symbol looks like a zip.
&lt;/p&gt;
&lt;pre&gt;
my @tile_values = &amp;lt; A B C D E F &amp;gt; &amp;#x00a5; (1, 3, 4, 2, 1, 4)
&lt;/pre&gt;

&lt;p&gt;Sadly this witty visual pun seems to have been deprecated. &lt;span /&gt;All programming languages I know of are firmly stuck in the 7-bit ASCII range, where the only currency character is the good old American $ 0x24 DOLLAR SIGN.
&lt;/p&gt;
&lt;p&gt;There are plenty of useful symbols for programmers once you&amp;#8217;re willing to advance into Unicode space:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Multiplication &amp;#x00d7; U+00D7 MULTIPLICATION SIGN, obviously
 &lt;/li&gt;

 &lt;li&gt;
     &lt;a href="http://haskell.org"&gt;Haskell&lt;/a&gt; would surely prefer a real &amp;#x03BB; U+03BB GREEK SMALL LETTER LAMDA to the backslash currently used for anonymous functions
 &lt;/li&gt;

 &lt;li&gt;
     Pointers would be less threatening if we could dereference them with a &amp;rarr; U+2192 RIGHTWARDS ARROW
 &lt;/li&gt;

 &lt;li&gt;
     And there are lots of nice symbols we could use for assignment, &amp;#x21a4; U+21A4 LEFTWARDS ARROW FROM BAR for example, and then we could use the EQUALS SIGN for equality and fix several bugs
 &lt;/li&gt;

 &lt;li&gt;
     Proper &lt;a href="http://en.wikipedia.org/wiki/Table_of_logic_symbols"&gt;logic symbols&lt;/a&gt; for and, or, not, which wipe the floor with &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;
 &lt;/li&gt;

 &lt;li&gt;
     I won&amp;#8217;t even try to list the exciting mathematical symbols and the possibilities they open up. Let&amp;#8217;s just say we&amp;#8217;d all use container operations if &amp;#x2200; U+2200 FOR ALL were available
 &lt;/li&gt;
&lt;/ul&gt;</description>
<dc:date>2007-09-13</dc:date>
<guid>http://wordaligned.org/articles/a-yen-for-more-symbols</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/a-yen-for-more-symbols</link>
<category>Perl</category>
</item>

<item>
<title>Pitching Python in three syllables</title>
<description>&lt;p&gt;Someone recently posted a question on the &lt;a href="http://accu.org/index.php/mailinglists"&gt;accu-general mailing list&lt;/a&gt;. It went something like this:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8220;A new project is starting at work using C++, and I was suggesting use the &lt;a href="http://boost.org"&gt;Boost&lt;/a&gt; C++ libraries, only a colleague said there were problems with Boost 64 bit build on some platforms, and wanted to know what people here thought about Boost?&amp;#8221;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;My reply unanswered the question:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8220;Why choose C++ for a new project?&amp;#8221;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;When pressed further, I wrote:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8220;Use Python!&amp;#8221;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Thinking things over, I realised this wasn&amp;#8217;t a particularly helpful suggestion. Maybe the company in question had a team of experienced C++ programmers; maybe they&amp;#8217;d delivered previous projects using C++; maybe the development manager had been promoted following the successful completion of one of these projects.
&lt;/p&gt;
&lt;p&gt;So I asked myself a question: If I were a junior developer at this company, how could I convince management that Python was a better language for a greenfield project than C++. Management time being at a premium and attention-spans being short, I made the question more specific: &lt;strong&gt;how could I best describe Python in a single sentence&lt;/strong&gt;?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h4&gt;No prize for originality&lt;/h4&gt;
&lt;p&gt;There&amp;#8217;s no need for an original answer. Python has an official &lt;a href="http://python.org"&gt;home page&lt;/a&gt; and the very first sentence on this page supplies Python&amp;#8217;s own answer. Also, although I&amp;#8217;ve used Python as a specific C++ alternative, I might equally well have favoured other languages in a similar niche: &lt;a href="http://ruby-lang.org"&gt;Ruby&lt;/a&gt;, &lt;a href="http://groovy.codehaus.org/"&gt;Groovy&lt;/a&gt;, &lt;a href="http://perl.org"&gt;Perl&lt;/a&gt;, for example. It depends which you&amp;#8217;re happiest to promote. 
&lt;/p&gt;
&lt;p&gt;All these languages offer one sentence introductions on their homepages. Thus, in no particular order (can you guess which is which?), Python/Ruby/Groovy/Perl is:
&lt;/p&gt;
&lt;blockquote&gt;&lt;ol&gt;
 &lt;li&gt;
     A stable, cross platform programming language.
 &lt;/li&gt;

 &lt;li&gt;
     A dynamic object-oriented programming language that can be used for many kinds of software development.
 &lt;/li&gt;

 &lt;li&gt;
     A dynamic, open source programming language with a focus on simplicity and productivity.
 &lt;/li&gt;

 &lt;li&gt;
     An agile dynamic language for the Java Virtual Machine.
 &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;p&gt;Plenty of other languages occupy a similar domain. All describe themselves using similar words. I wasn&amp;#8217;t entirely happy though, since none of these sentences do a great job of pitching Python etc.
&lt;/p&gt;
&lt;p&gt;So I applied a common programming tactic. I reduced the scope of the problem: &lt;span /&gt;how could I pitch Python in just 3 syllables?
&lt;/p&gt;

&lt;h4&gt;Dynamic?&lt;/h4&gt;
&lt;p&gt;Three of the four sentences above use the term &lt;strong&gt;dynamic&lt;/strong&gt; and there&amp;#8217;s little doubt that Perl (which, with an uncharacteristically serious face on, describes itself as &lt;strong&gt;stable&lt;/strong&gt;) is every bit as dynamic as its peers.
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Dynamic&lt;/em&gt; appeals, especially to a programmer (as do adjectives like &lt;em&gt;Agile&lt;/em&gt; and  &lt;em&gt;eXtreme&lt;/em&gt;). The word implies change, energy, force. My dictionary has nothing to say about its specific connotations when applied to a computer language, so I &lt;a href="http://www.google.co.uk/search?q=dynamic+programing+language"&gt;googled&lt;/a&gt; and found myself at &lt;a href="http://en.wikipedia.org/wiki/Dynamic_language"&gt;Wikipedia&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Dynamic_language"&gt;Dynamic programming language&lt;/a&gt; is a term used broadly in computer science to describe a class of high level programming languages that execute at runtime many common behaviors that other languages might perform during compilation, if at all. These behaviors could include extension of the program, by adding new code, by extending objects and definitions, or by modifying the type system, all during program execution.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I&amp;#8217;m not sure that&amp;#8217;s especially helpful as a sales pitch, and certainly it&amp;#8217;s not a commonly understood definition. If I wanted to promote (for example) Python as a suitable language for a project, I wouldn&amp;#8217;t emphasise these features. And there&amp;#8217;s also the problem of overloaded meaning, as Wikipedia goes on to point out.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Dynamic languages and dynamic typing are not identical concepts, and a dynamic language need not be dynamically typed, though many dynamic languages are dynamically typed.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;So, if we describe a language as &lt;em&gt;dynamic&lt;/em&gt;, there&amp;#8217;s a risk our C++-biased manager assumes &lt;em&gt;dynamically typed&lt;/em&gt;; and there&amp;#8217;s a common misconception that dynamic typing equals weak typing. There&amp;#8217;s also a danger our audience fears the volatility associated with dynamism (how can a &lt;em&gt;dynamic&lt;/em&gt; language be used to build a &lt;em&gt;solid&lt;/em&gt; application?)
&lt;/p&gt;

&lt;h4&gt;Scripting?&lt;/h4&gt;
&lt;p&gt;None of the languages mentioned describes itself as a scripting language. Nonetheless, the term is commonly used, especially for Perl. Perhaps many of us first pick up these languages when we have a scripting task to do: copy a bunch of files around, change their contents in some way, pull a page from a web server and parse it, convert a spreadsheet into HTML and post it on the intranet &amp;#8212; the kind of quotidian task which is tiresome to implement in a low-level language.
&lt;/p&gt;
&lt;p&gt;By scripting we tend to mean one-shot tasks such as these, where perhaps we can squander a few CPU cycles or expend more memory than strictly necessary. The focus is on getting the job done. Scripts are just little programs.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Little&lt;/strong&gt; is &lt;strong&gt;good&lt;/strong&gt; in this context. &lt;span /&gt;When we say we want readable code, we don&amp;#8217;t mean we want to sit in a comfortable chair and page through a Java-saga. We prefer something succinct: something easy to understand, something which fits in our heads. I can imagine the term &lt;em&gt;scripting&lt;/em&gt; being reclaimed as a badge of pride rather like &lt;em&gt;hacker&lt;/em&gt; has been &amp;#8212; but for now scripting means writing little programs, and belittles the language used.
&lt;/p&gt;

&lt;h4&gt;Well what then?&lt;/h4&gt;
&lt;p&gt;Having snubbed the popular terms, scripting and dynamic, what shall we use in their place? Reviewing the original four one-sentence descriptions we find open source, simple, cross platform, agile, object-oriented, productive, used in many kinds of software development &amp;#8212; all of which are fine attributes and true enough, but none of which, on its own, goes far enough.
&lt;/p&gt;

&lt;h4&gt;High Level!&lt;/h4&gt;
&lt;p&gt;Python is a &lt;strong&gt;high-level&lt;/strong&gt; language. Ruby, Groovy and Perl are high-level languages. High-level has become my preferred term.
&lt;/p&gt;
&lt;p&gt;High-level doesn&amp;#8217;t tell the whole story, of course &amp;#8212; nor can any one word. It&amp;#8217;s also relative: C is high-level compared to assembler which itself is high-level compared to machine code &amp;#8212; but these days C is a low-level language and &lt;a href="http://www.networkrail.co.uk/aspx/779.aspx"&gt;Birmingham New Street&lt;/a&gt; is old.
&lt;/p&gt;
&lt;p&gt;Management may think of C++ as high-level. It isn&amp;#8217;t. You must manage memory by hand, understand pointers, budget for each of the bits in each of the various integral types on each of your platforms. Java is better, but not much.
&lt;/p&gt;
&lt;p&gt;High-level no longer applies to C++ etc. and that&amp;#8217;s one reason why I want to appropriate it for today&amp;#8217;s real high-level languages. The benefits of using high-level languages are understood: the language does more for you.
&lt;/p&gt;
&lt;p&gt;One day, Python may not be high-level. Today, it is.
&lt;/p&gt;
&lt;hr /&gt;


&lt;h4&gt;Footnotes&lt;/h4&gt;
&lt;ol&gt;
 &lt;li&gt;
     I delivered this as a lightning speech at &lt;a href="http://www.pyconuk.org/"&gt;PyCon UK&lt;/a&gt; yesterday. Lightning speeches are limited to 5 minutes, and I had to skip some bits and race through others. This is what I meant to say!
 &lt;/li&gt;

 &lt;li&gt;
     I don&amp;#8217;t mean to criticise &lt;a href="http://boost.org"&gt;Boost&lt;/a&gt;, which sets standards very high indeed. If you&amp;#8217;re going to use C++, Boost is the next best thing to the C++ standard library. I would treat any hearsay about Boost not working on particular platforms with skepticism: you don&amp;#8217;t have to look hard to find Boost library test reports for common platforms.
 &lt;/li&gt;

 &lt;li&gt;
     Birmingham New Street opened in 1854.
 &lt;/li&gt;
&lt;/ol&gt;</description>
<dc:date>2007-09-09</dc:date>
<guid>http://wordaligned.org/articles/pitching-python-in-three-syllables</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/pitching-python-in-three-syllables</link>
<category>Perl</category>
</item>

<item>
<title>How green you are</title>
<description>&lt;p&gt;Remember when email signatures supplied contact information, possibly some dodgy ascii art and a pithy quotation, maybe even some &lt;a href="http://www.cpan.org/misc/japh"&gt;obfuscated perl&lt;/a&gt;?
&lt;/p&gt;
&lt;p&gt;Now they come loaded with adverts for anti-virus software and legal nonsense:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;If you weren&amp;#8217;t meant to receive this email &lt;strong&gt;don&amp;#8217;t read it&lt;/strong&gt;, let us know immediately, &lt;strong&gt;destroy it&lt;/strong&gt; and all copies of it, and by the way it&amp;#8217;s your fault if it contains any &lt;strong&gt;viruses&lt;/strong&gt;. Don&amp;#8217;t believe us? &lt;strong&gt;We&amp;#8217;ll sue you!&lt;/strong&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Not very friendly, is it? Is that really how you want to sign your email correspondence? Does your organisation pay people to come up with this? The anti-virus message is ironic since it is itself viral &amp;#8212; a nasty self-replicating block of text.
&lt;/p&gt;
&lt;p&gt;Such signatures annoyed me to start with but now, like everyone else, I ignore them. Often the sender is powerless to edit their own signature anyway. I do notice when signatures change, though, and the latest fashion seems to be a plea to save trees:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Think before you print this email.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;span /&gt;I do think, thanks.
&lt;/p&gt;</description>
<dc:date>2007-08-09</dc:date>
<guid>http://wordaligned.org/articles/how-green-you-are</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/how-green-you-are</link>
<category>Perl</category>
</item>

<item>
<title>Perlish Wisdom</title>
<description>&lt;p&gt;Here&amp;#8217;s an interesting &lt;a href="http://www.oreillynet.com/onlamp/blog/2007/05/the_perl_job_market_blues.html"&gt;article&lt;/a&gt; in which Curtis Poe explains why there&amp;#8217;s a shortage of &lt;a href="http://www.perl.org"&gt;Perl&lt;/a&gt; programmers on the market at the moment. I&amp;#8217;m not qualified to comment on whether the shortage exists or his analysis of it is correct, but I certainly wouldn&amp;#8217;t fancy maintaining Perl code. The Perl mantra, &amp;#8220;There&amp;#8217;s more than one way to do it&amp;#8221;, appears to be liberating but all too often results in unnecessary inconsistency. I prefer &lt;a href="http://www.python.org"&gt;Python&lt;/a&gt;&amp;#8217;s &amp;#8220;There should be one &amp;#8212; and preferably only one &amp;#8212; obvious way to do it&amp;#8221;.
&lt;/p&gt;
&lt;p&gt;That said, I do have a soft spot for Perl. &lt;span /&gt;It was the first very high-level language I fell for. This was at a time when I routinely worked on different flavours of Unix and Windows machines; and I routinely had problems with the different environments. There wasn&amp;#8217;t even a command shell which worked well across the board. Perl effectively gave me a platform independent way of writing scripts to perform simple file, text and job processing.
&lt;/p&gt;
&lt;p&gt;I say &amp;#8220;scripts&amp;#8221; rather than &amp;#8220;programs&amp;#8221; because I never wrote anything more than a few dozen lines long. &lt;span /&gt;I never had to go through the tiresome business of compiling, sorting out dependencies, locating include- and library- paths, declaring object types &amp;ndash; tasks which I&amp;#8217;d always associated with real programming.
&lt;/p&gt;
&lt;p&gt;Scripting was more direct, more fun.
&lt;/p&gt;
&lt;p&gt;A few dozen lines of Perl easily accomplishes as much as a few hundred lines of C. In fact, &lt;a href="http://sial.org/howto/perl/one-liner/"&gt;one line&lt;/a&gt; of Perl can get a surprising amount done. Surely the performance of an interpreted language would be a problem? Maybe it can be, but time after time, I was impressed just how quickly Perl allowed me to chew through data.
&lt;/p&gt;
&lt;p&gt;&lt;span /&gt;I had to admire the way the language grabbed all the characters on the keyboard and squeezed the juice out of them. It even allowed variables to dissolve away into defaults which you could then omit and which, as if by magic, did just what you wanted: &lt;code&gt;$variable&lt;/code&gt;, &lt;code&gt;$_&lt;/code&gt;, .
&lt;/p&gt;
&lt;p&gt;Ultimately, though, there were things I never quite got and probably never will get. I never managed to build complex structures without referring to the manual. Oh, and I never really got to grips with the Perl documentation system. I never found an editor mode I was completely happy with &amp;#8212; or perhaps the overloaded syntax just started to grate. Finger saving tricks turned out to be expensive in the long run.
&lt;/p&gt;
&lt;p&gt;Adopting Perl changed me, though. I prefer powerful languages with comprehensive libraries. Wrestling with build systems seems too much pain for too little gain. And explicit type declarations make software frigid.
&lt;/p&gt;</description>
<dc:date>2007-05-10</dc:date>
<guid>http://wordaligned.org/articles/perlish-wisdom</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/perlish-wisdom</link>
<category>Perl</category>
</item>

<item>
<title>Shells, Logs and Pipes</title>
<description>&lt;p&gt;I needed to make sense of a lengthy log file. The server had been
   running over the weekend and the log file showed an increasing packet
   error count.  (Don&amp;#8217;t worry what a packet error is, it doesn&amp;#8217;t really
   matter as far as this post goes).  This post explains how the standard
   Unix tools helped me dissect the log file, and indeed any other log
   file.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Heads and Tails&lt;/h3&gt;
&lt;p&gt;First, I needed the initial and final error counts.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Initial and final error counts&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ head logfile | grep "packet errors"
Info: Fri 17:34:05, packet errors: 0
$ tail logfile | grep "packet errors"
Info: Mon 08:32:11, packet errors: 11323

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So what exactly had gone wrong, and when? Paging through the filtered output
   would take some time since the number of reported packet error counts
   ran to five figures.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Paging through the filtered output&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ grep "packet errors" logfile | less

&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;How many errors were reported?&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ grep "packet errors" logfile | wc -l
125220

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Uniq&lt;/h3&gt;
&lt;p&gt;Part of the problem was that whatever logged the message simply
   printed out the error count every couple of seconds, whether or not
   this error count had changed. Going back to Friday, reconfiguring
   the logger and re-running the experiment wasn&amp;#8217;t an option, but luckily
   I had too much information rather than too little: all I had to do was
   process it correctly.
&lt;/p&gt;
&lt;p&gt;What looked more useful was filtering just the lines at which the
   error count had changed. Filtering out repeated lines using &lt;code&gt;uniq&lt;/code&gt;
   wouldn&amp;#8217;t work, since every line&amp;#8217;s timestamp made it unique. Happily,
   &lt;code&gt;uniq&lt;/code&gt; has an option to ignore a specified number of fields.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Finding when the error count changed&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ grep "packet errors" logfile | uniq -f 3

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Piping this command to &lt;code&gt;wc -l&lt;/code&gt; indicated that the number of
   interesting lines had been thinned down to around three thousand &amp;#8212;
   the kind of report which could be paged through comfortably enough.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Counting error count changes&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ grep "packet errors" logfile | uniq -f 3 | wc -l
3432

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Sort&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s also possible to home in on other points of
   interest. For example, we could investigate the maximum period of
   stability by finding when the error count doesn&amp;#8217;t change for
   longest. This can be done using the &lt;code&gt;-c&lt;/code&gt; option to &lt;code&gt;uniq&lt;/code&gt;, which
   precedes each output line with a count of the the number of times that
   line was repeated in the input; then sorting using this count field as
   a numeric key; then picking the last output value from the
   pipeline.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Locating the most stable period&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ grep "packet errors" logfile | \
  uniq -f 3 -c | sort -k1 -n | tail -1
    277 Info: Sat 23:00:15, packet errors: 4645

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This tells us that on Saturday evening the error count remained stable
   for longest &amp;#8212; in fact, an error count of 4645 repeated 277 times
   in the logfile, a duration of just 9 minutes (given that the packet
   error count repeated every couple of seconds).
&lt;/p&gt;

&lt;h3&gt;Et cetera&lt;/h3&gt;
&lt;p&gt;This is just a flavour of what the Unix shell tools can do when piped
   together. We&amp;#8217;ve combined some simple tools (&lt;code&gt;less&lt;/code&gt;,
   &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;tail&lt;/code&gt;, &lt;code&gt;uniq&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;wc&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;) into complex and powerful commands
   using just a few keystrokes. Imagine trying to design a GUI which
   would allow you to analyse a log file as shown above. &lt;span /&gt;Now try
   designing a GUI which can analyse any log file ever.
&lt;/p&gt;
&lt;p&gt;I wouldn&amp;#8217;t pretend the Unix shell tools are user-friendly. In fact some
   are distinctly arcane (&lt;code&gt;find&lt;/code&gt; comes to mind). When I started out, I
   found the Unix manual difficult to use, and although &lt;code&gt;info&lt;/code&gt; has
   improved things it&amp;#8217;s still hard to find out about a command without
   knowing its name. And if there&amp;#8217;s a decent, hyper-linked online
   reference, I&amp;#8217;ve yet to find it.
&lt;/p&gt;

&lt;h3&gt;Extending the Toolset&lt;/h3&gt;
&lt;p&gt;Shell tools aren&amp;#8217;t always capable of even the kind of text processing
   described in this article. For example, if the logfile had more
   structure to it &amp;#8212; or even was written out as XML &amp;#8212; then we&amp;#8217;d
   probably be find ourselves struggling.  Fortunately a scripting
   language is very happy to help out in such cases. Perl remains a good
   choice, if it&amp;#8217;s one-liners you like. &lt;a href="http://python.org"&gt;Python&lt;/a&gt; and &lt;a href="http://www.ruby-lang.org"&gt;Ruby&lt;/a&gt; are
   better for longer-lived scripts.
&lt;/p&gt;
&lt;p&gt;Equally, there&amp;#8217;s a point at which you need to convert text into
   something more visual &amp;#8212; a graph or a histogram, perhaps. Text
   processing can be used to generate a format suitable for importing
   into a &lt;a href="http://www.gnuplot.info/"&gt;plotting&lt;/a&gt; package.
&lt;/p&gt;

&lt;h3&gt;Further Reading&lt;/h3&gt;
&lt;p&gt;A Unix expert once told me that the difference between a Unix expert
   and a non-expert wasn&amp;#8217;t aptitude or years of accumulated knowledge
   &amp;#8212; rather it came down to a willingness to read carefully through the
   manual.  I&amp;#8217;m no expert, but regard this as sound advice.
&lt;/p&gt;
&lt;p&gt;For more on the Unix philosophy, and how it applies to software
   development in general, I recommend &lt;a href="http://www.catb.org/~esr/writings/taoup/"&gt;&amp;#8220;The Art of Unix Programming&amp;#8221;&lt;/a&gt; by
   &lt;a href="http://www.catb.org/~esr"&gt;Eric S. Raymond&lt;/a&gt;.
&lt;/p&gt;</description>
<dc:date>2007-03-05</dc:date>
<guid>http://wordaligned.org/articles/shells-logs-and-pipes</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/shells-logs-and-pipes</link>
<category>Perl</category>
</item>

</channel>
</rss>
