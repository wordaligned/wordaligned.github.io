<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Sausages, sausages, sausages - slice, slice, slice</title>
<description>&lt;p&gt;A friend asked for help reaching the next level of a puzzle game. The test which stalled her involves machine placement in a sausage factory.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; each sausage was branded with a letter for quality control purposes, thus:
   &lt;strong&gt;ypbtkizfgxptclcoirdsuhjwulqkoszrabfc&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;The string was then drawn through seven machines which rearranged the sausages in flavour enhancing ways.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine A: The Reversifier&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;Reverses the order of the sausages, so they get tastier as you go along.
&lt;/p&gt;
&lt;p&gt;&amp;#8230;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine G: Secondhalffirstifier&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;move the second half of the string to the beginning, as the earlier sausages are too spicy to eat early in the morning.
&lt;/p&gt;
&lt;p&gt;He attached these machines in a certain sequence, though one of them was out for repair so only six were used. He then fed a string of sausages through and was surprised to discover the string that came out at the other end said &lt;strong&gt;lickyourlips&lt;/strong&gt;. What order were the machines in?
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;It&amp;#8217;s nicely phrased, but what&amp;#8217;s really wanted is the sequence of simple transformations that takes input &amp;#8220;ypbtkizfgxptclcoirdsuhjwulqkoszrabfc&amp;#8221; and produces output &amp;#8220;lickyourlips&amp;#8221;.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s no doubt possible to work backwards and figure out a solution using no more than logic, pencil and paper. For example, only two of the machines change the length of the string, and &amp;#8212; looking at the before and after lengths &amp;#8212; these must both be used. It&amp;#8217;s rather easier to write a short program to find a solution.
&lt;/p&gt;
&lt;p&gt;First we must simulate the seven sausage machines, A-G, which perform the following sequence operations.
&lt;/p&gt;
&lt;ol type="A"&gt;
&lt;li&gt;reverse the order of a sequence&lt;/li&gt;
&lt;li&gt;remove every other element of a sequence&lt;/li&gt;
&lt;li&gt;remove every third element of a sequence&lt;/li&gt;
&lt;li&gt;pairwise reverse elements of a sequence&lt;/li&gt;
&lt;li&gt;move even numbered elements to the front of a sequence&lt;/li&gt;
&lt;li&gt;move the last element of a sequence to the front&lt;/li&gt;
&lt;li&gt;swap the front and back half of a sequence&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;None of these is difficult, especially in a high-level language which builds in support for sequence operations. What I found noteworthy is that a solution can be found without any &lt;a href="https://docs.python.org/3/reference/compound_stmts.html"&gt;loops or if statements&lt;/a&gt;. What&amp;#8217;s more, every operation can handled using nothing more than &lt;a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range"&gt;slice operations&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s my solution. The machines consist of slice operations, helped by a couple of conditional expressions and recursive calls. The solution can then be brute-forced: there are only 5040 ways of permuting 6 out of 7 machines.
&lt;/p&gt;
&lt;script src="https://gist.github.com/wordaligned/a04308eac7ee2aa37e01.js"&gt;&lt;/script&gt;

&lt;p&gt;I&amp;#8217;ve used &lt;code&gt;reduce&lt;/code&gt; to apply a chain of functions to a string of sausages &amp;#8212; an explicit loop might be clearer, but I want a loop-free solution. For this same reason I use recursion in the pairwise swapper and the element dropper. Generally in Python, recursion is a poor choice. In this case I know I&amp;#8217;m starting with a string of just 36 elements which cannot get any longer; there&amp;#8217;s no risk of exceeding the &lt;a href="https://docs.python.org/3/library/sys.html#sys.getrecursionlimit"&gt;system recursion limit&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;The sequence reversal &lt;code&gt;s[::-1]&lt;/code&gt; is idiomatic but alarming to the uninitiated. Slices have &lt;code&gt;[start:stop:stride]&lt;/code&gt; fields, any of which may be defaulted. Usually &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; default to the start and end of the sequence, but in this case the negative stride reverses them.
&lt;/p&gt;
&lt;p&gt;To rotate the last element of a sequence to the front, prefer:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return s[-1:] + s[:-1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return [s[-1]] + s[:-1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;because the latter raises an &lt;code&gt;IndexError&lt;/code&gt; for an empty sequence.
&lt;/p&gt;
&lt;p&gt;Slicing is a formidable tool for sequence manipulation, especially when combined with the option of using negative indices to count back from the end. Slices allow you to reverse, rotate and partition sequences, to pairwise swap elements, and to drop every nth element.
&lt;/p&gt;
&lt;p&gt;The miniature recipes presented here don&amp;#8217;t even use slice assignment, which gives me an excuse to reproduce this elegant prime sieve function, which does.
&lt;/p&gt;
&lt;script src="https://gist.github.com/wordaligned/09c17eaabb6cd4c6bcfb.js"&gt;&lt;/script&gt;</description>
<dc:date>2016-03-21</dc:date>
<guid>http://wordaligned.org/articles/sausages-slices</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/sausages-slices</link>
<category>Puzzles</category>
</item>

<item>
<title>Reverse, Esrever</title>
<description>&lt;p&gt;&lt;code&gt;&lt;a href="http://en.cppreference.com/w/cpp/algorithm/reverse"&gt;Reverse&lt;/a&gt;&lt;/code&gt; is a member of the C++ standard library, but its reverse, &lt;code&gt;esrever&lt;/code&gt;, isn&amp;#8217;t. Similarly &lt;code&gt;keep&lt;/code&gt; isn&amp;#8217;t but &lt;code&gt;&lt;a href="http://en.cppreference.com/w/cpp/io/basic_istream/peek"&gt;peek&lt;/a&gt;&lt;/code&gt; is.
&lt;/p&gt;
&lt;p&gt;Can anyone think of a C++ standard library member whose reverse &lt;strong&gt;is also a member&lt;/strong&gt;?
&lt;/p&gt;
&lt;p&gt;Answers in the comments below.
&lt;/p&gt;
&lt;p&gt;Go!
&lt;/p&gt;</description>
<dc:date>2013-09-27</dc:date>
<guid>http://wordaligned.org/articles/reverse-esrever</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/reverse-esrever</link>
<category>Puzzles</category>
</item>

<item>
<title>Clown, Flee, Jump</title>
<description>&lt;p&gt;The clown is running away from the circus. The contortionist wants nothing more to do with him. She&amp;#8217;s confessed everything to her husband, the strongman, who&amp;#8217;s after the clown&amp;#8217;s blood. The clown has no time to pack. Hurrying from the big top he snatches up his most treasured possessions and some refreshments:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     a makeup case
 &lt;/li&gt;

 &lt;li&gt;
     a box camera, with tripod attached
 &lt;/li&gt;

 &lt;li&gt;
     a cactus
 &lt;/li&gt;

 &lt;li&gt;
     a roasted goose
 &lt;/li&gt;

 &lt;li&gt;
     a magnum of champagne
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each item weighs exactly 3kg.
&lt;/p&gt;
&lt;p&gt;Soon he reaches the edge of a ravine. A rope bridge connected to the other side has a sign in front of it.
&lt;/p&gt;
&lt;pre style="align:center;width:400px;border: 2px solid red; background: white;font-size:200%;"&gt;WARNING
UNSTABLE STRUCTURE
SAFE TO A MAXIMUM OF 75KG&lt;/pre&gt;

&lt;p&gt;The bridge is 100m long. The clown weighs 70kg. The strongman, who&amp;#8217;s closing in, weighs considerably more. The clown must cross the bridge at once to effect his escape. &lt;strong&gt;How can he do so without abandoning any of his baggage&lt;/strong&gt;?
&lt;/p&gt;
&lt;p style="text-align:center;font-size:200%"&gt;?&lt;/p&gt;

&lt;p&gt;Elsewhere, it&amp;#8217;s school sports day. Conditions are perfect for the high jump &amp;#8212; warm, sunny, still &amp;#8212; and a talented young athlete has raised the bar to 1.85m, which happens to be his own height. On the first two attempts he fails. On the third attempt he succeeds.
&lt;/p&gt;
&lt;img alt="High Jump" src="http://wordaligned.org/images/high-jump.jpg"/&gt;

&lt;p&gt;&amp;#8220;Chapeau!&amp;#8221; says the French teacher.
&lt;/p&gt;
&lt;p&gt;&amp;#8220;Awesome!&amp;#8221; says the Chaplain.
&lt;/p&gt;
&lt;p&gt;&amp;#8220;Unbelievable!&amp;#8221; says the head of Mathematics.
&lt;/p&gt;
&lt;p&gt;&amp;#8220;Actually,&amp;#8221; the sports coach says, &amp;#8220;it&amp;#8217;s quite simple: a combination of talent, training, and technique. He cleared his own height &lt;strong&gt;but his centre of gravity didn&amp;#8217;t&lt;/strong&gt;.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;&amp;#8220;What nonsense!&amp;#8221; says the mathematician.
&lt;/p&gt;
&lt;p style="text-align:center;font-size:300%"&gt;??&lt;/p&gt;

&lt;img alt="Grimaldi" src="http://wordaligned.org/images/grimaldi.jpg"/&gt;

&lt;p&gt;The clown barely breaks stride. Juggling with mismatched objects is part of his act and quick as a flash case, camera, cactus, fowl and fizz are in the air. At no point does he have more than one object in either hand so his weight never exceeds 73kg. The bridge holds. The clown gets away.
&lt;/p&gt;
&lt;p&gt;&amp;#8220;Grrrr!&amp;#8221; says the strongman, shaking his fists.
&lt;/p&gt;
&lt;p style="text-align:center;font-size:400%"&gt;???&lt;/p&gt;</description>
<dc:date>2013-09-11</dc:date>
<guid>http://wordaligned.org/articles/clown-flee-jump</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/clown-flee-jump</link>
<category>Puzzles</category>
</item>

<item>
<title>Patience Sorted</title>
<description>&lt;p&gt;I gave a lightning talk today about patience sorting and its application to the longest increasing subsequence problem. It&amp;#8217;s a subject I&amp;#8217;ve &lt;a href="http://wordaligned.org/articles/patience-sort.html" title="Patience sort and the longest increasing subsequence"&gt;written about&lt;/a&gt; before. My computer has been put through several million simulations. I&amp;#8217;ve even coded up a &lt;a href="http://wordaligned.org/pages/psort"&gt;javascript demo&lt;/a&gt; which deals out virtual playing cards and sorts them at the click of a button.
&lt;/p&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
var zz = 0;

var xtop  = ["330px", "302px", "275px", "255px", "234px", "209px", "187px", "158px", "128px", "99px", "70px", "43px", "15px"];
var ytop  = ["26px", "30px", "28px", "29px", "31px", "28px", "27px", "28px", "28px", "30px", "26px", "30px", "29px"];
var xpile = ["10px", "13px", "12px", "115px", "14px", "220px", "220px", "319px", "15px", "216px", "118px", "118px", "321px"];
var ypile = ["205px", "233px", "266px", "206px", "295px", "206px", "236px", "209px", "325px", "267px", "235px", "263px", "234px"];
var result = ["#card7", "#card6", "#card3", "#card2"];

function reset_cards() {
    jQuery("img").stop();
    zz += 13;
    for (var j = 0; j != 13; ++j, --zz) {
        jQuery("#card" + j)
        .css({"z-index":zz, "margin-left":xtop[j], "margin-top":ytop[j], "border-width":0});
    }
    zz += 13;
}

function lis(j) {
    var it = jQuery(result[j]);
    if (it.length &gt; 0) {
        it.animate({borderWidth : "5px"}, "slow", 0, function(){lis(++j);});
    }
}

function psort(j) {
    var it = jQuery("#card"+j);
    if (it.length != 0) {
        it
        .animate({marginLeft : xpile[j], marginTop: ypile[j]}, "slow", 0, function(){psort(++j);})
        .css({"z-index" : ++zz});
    } else {
        lis(0);
    }
}

function animate() {
    reset_cards();
    psort(0);
}
&lt;/script&gt;

&lt;div class="cardtable" style="background-color: #093; width:440px; height:480px;"&gt;
&lt;img id="card0" style="border: 0 orange solid; position: absolute; margin-left: 330px; margin-top: 27px; z-index: 13;" src="http://wordaligned.org/images/cards/1s.png" alt="Ace of Spades"/&gt;
&lt;img id="card1" style="border: 0 orange solid; position: absolute; margin-left: 302px; margin-top: 27px; z-index: 12;" src="http://wordaligned.org/images/cards/10s.png" alt="10 of Spades"/&gt;
&lt;img id="card2" style="border: 0 orange solid; position: absolute; margin-left: 275px; margin-top: 27px; z-index: 11;" src="http://wordaligned.org/images/cards/6s.png" alt="6 of Spades"/&gt;
&lt;img id="card3" style="border: 0 orange solid; position: absolute; margin-left: 255px; margin-top: 26px; z-index: 10;" src="http://wordaligned.org/images/cards/7s.png" alt="7 of Spades"/&gt;
&lt;img id="card4" style="border: 0 orange solid; position: absolute; margin-left: 234px; margin-top: 28px; z-index: 9;" src="http://wordaligned.org/images/cards/5s.png" alt="5 of Spades"/&gt;
&lt;img id="card5" style="border: 0 orange solid; position: absolute; margin-left: 209px; margin-top: 26px; z-index: 8;" src="http://wordaligned.org/images/cards/13s.png" alt="King of Spades"/&gt;
&lt;img id="card6" style="border: 0 orange solid; position: absolute; margin-left: 187px; margin-top: 31px; z-index: 7;" src="http://wordaligned.org/images/cards/9s.png" alt="9 of Spades"/&gt;
&lt;img id="card7" style="border: 0 orange solid; position: absolute; margin-left: 158px; margin-top: 27px; z-index: 6;" src="http://wordaligned.org/images/cards/12s.png" alt="Queen of Spades"/&gt;
&lt;img id="card8" style="border: 0 orange solid; position: absolute; margin-left: 128px; margin-top: 29px; z-index: 5;" src="http://wordaligned.org/images/cards/2s.png" alt="2 of Spades"/&gt;
&lt;img id="card9" style="border: 0 orange solid; position: absolute; margin-left: 99px; margin-top: 29px; z-index: 4;" src="http://wordaligned.org/images/cards/8s.png" alt="8 of Spades"/&gt;
&lt;img id="card10" style="border: 0 orange solid; position: absolute; margin-left: 70px; margin-top: 26px; z-index: 3;" src="http://wordaligned.org/images/cards/4s.png" alt="4 of Spades"/&gt;
&lt;img id="card11" style="border: 0 orange solid; position: absolute; margin-left: 43px; margin-top: 27px; z-index: 2;" src="http://wordaligned.org/images/cards/3s.png" alt="3 of Spades"/&gt;
&lt;img id="card12" style="border: 0 orange solid; position: absolute; margin-left: 15px; margin-top: 28px; z-index: 1;" src="http://wordaligned.org/images/cards/11s.png" alt="Knave of Spades"/&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;button onclick="reset_cards();"&gt;Reset&lt;/button&gt;&lt;button onclick="animate();"&gt;Play&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Today I used real playing cards; a linen-finished standard deck. For any talk it&amp;#8217;s nice to have a prop.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/8558343442/" title="Rock &amp;amp; Pop Legends by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm9.staticflickr.com/8100/8558343442_0402f04e83.jpg" width="500" height="361" alt="Rock &amp;amp; Pop Legends"&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Now, I &lt;strong&gt;thought&lt;/strong&gt; I understood the patience sort algorithm but until yesterday I&amp;#8217;d never actually played it with real cards. I&amp;#8217;ve been surprised by how much this physical dimension has developed my understanding.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ll be testing my new cards on some other sorting algorithms; I have high hopes. It would be good to find a similarly simple prop for linked data structures so I can balance trees, flip lists and walk graphs.
&lt;/p&gt;</description>
<dc:date>2013-03-14</dc:date>
<guid>http://wordaligned.org/articles/patience-sorted</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/patience-sorted</link>
<category>Puzzles</category>
</item>

<item>
<title>Next permutation: When C++ gets it right</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocthe-next-number-problem" name="toc0" id="toc0"&gt;The Next Number Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocchoice-of-algorithm" name="toc1" id="toc1"&gt;Choice of Algorithm&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toclexicographical-ordering" name="toc2" id="toc2"&gt;Lexicographical Ordering&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocnext-permutation-in-action" name="toc3" id="toc3"&gt;Next permutation in action&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocsnail-sorts-revenge" name="toc4" id="toc4"&gt;Snail sort&amp;#8217;s revenge&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocthe-next-number-solved" name="toc5" id="toc5"&gt;The Next Number, Solved&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocimplementation" name="toc6" id="toc6"&gt;Implementation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocwhats-happening-here" name="toc7" id="toc7"&gt;What&amp;#8217;s happening here?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocbeautiful-c" name="toc8" id="toc8"&gt;Beautiful C++?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocpermutations-in-python" name="toc9" id="toc9"&gt;Permutations in Python&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc0" name="tocthe-next-number-problem" id="tocthe-next-number-problem"&gt;The Next Number Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose you have a fixed list of digits chosen from the range 1..9. What numbers can you make with them? You&amp;#8217;re allowed as many zeros as you want. Write the numbers in increasing order.
&lt;/p&gt;
&lt;p&gt;Exactly &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;this puzzle&lt;/a&gt; came up in the recent &lt;a href="http://code.google.com/codejam"&gt;Google Code Jam&lt;/a&gt; programming contest:
&lt;/p&gt;
&lt;blockquote&gt;You are writing out a list of numbers. Your list contains all numbers with exactly &lt;strong&gt;D&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt; digits in its decimal representation which are equal to i, for each i between 1 and 9, inclusive. You are writing them out in ascending order.&lt;/p&gt;&lt;p&gt;For example, you might be writing every number with two &amp;#8216;1&amp;#8217;s and one &amp;#8216;5&amp;#8217;. Your list would begin 115, 151, 511, 1015, 1051.&lt;/p&gt;&lt;p&gt;Given N, the last number you wrote, compute what the next number in the list will be.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The competition has closed now, but if you&amp;#8217;d like to give it a go sample input files can be found on the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;website&lt;/a&gt;, where you can also upload your results and have them checked.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a short section from a trial I ran on my computer. Input numbers are in the left-hand column: the corresponding output numbers are in the right-hand column.
&lt;/p&gt;
&lt;pre style="font-size:150%"&gt;
50110812884911623516 &amp;rarr; 50110812884911623561
82454322474161687049 &amp;rarr; 82454322474161687094
82040229261723155710 &amp;rarr; 82040229261723157015
43888989554234187388 &amp;rarr; 43888989554234187838
76080994872481480636 &amp;rarr; 76080994872481480663
31000989133449480678 &amp;rarr; 31000989133449480687
20347716554681051891 &amp;rarr; 20347716554681051918
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc1" name="tocchoice-of-algorithm" id="tocchoice-of-algorithm"&gt;Choice of Algorithm&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like many of the code jam challenges, you&amp;#8217;ll need to write a program which runs fast enough; but choosing the right algorithm is more important than choosing the right language. Typically a high-level interpreted language like Python allows me to code and test a solution far more quickly than using a low-level language like C or C++.
&lt;/p&gt;
&lt;p&gt;In this particular case, though, like most &lt;a href="http://www.go-hero.net/jam/09/problems/2/2"&gt;successful candidates&lt;/a&gt;, I used C++. &lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;Here&amp;#8217;s why&lt;/a&gt;.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;&lt;code&gt;Next_permutation&lt;/code&gt;&lt;/a&gt; transforms the range of elements &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically next greater permutation of the elements. [&amp;#8230;] If such a permutation exists, &lt;code&gt;next_permutation&lt;/code&gt; transforms &lt;code&gt;[first, last)&lt;/code&gt; into that permutation and returns true. Otherwise it transforms &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically smallest permutation and returns &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Although the next number problem appears to be about numbers and lexicographical ordering appears to be about words, &lt;code&gt;std::next_permutation&lt;/code&gt; is exactly what&amp;#8217;s needed here.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc2" name="toclexicographical-ordering" id="toclexicographical-ordering"&gt;Lexicographical Ordering&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/4099819327/" title="Lexicographical order by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2449/4099819327_4063635302.jpg" width="500" height="216" alt="Lexicographical order" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;A dictionary provides the canonical example of lexicographical ordering. Words are built from characters, which can be alphabetically ordered A, B, C, &amp;#8230; , so in the dictionary words which begin with &lt;strong&gt;A&lt;/strong&gt; appear before words which begin with &lt;strong&gt;B&lt;/strong&gt;, which themselves come in front of words beginning with &lt;strong&gt;C&lt;/strong&gt;, etc. If two words start with the same letter, pop that letter from the head of the word and compare their tails, which puts AARDVARK before ANIMAL, and &amp;#8212; applying this rule recursively &amp;#8212; after &lt;a href="http://www.aardman.com/" title="Bristol's finest"&gt;AARDMAN&lt;/a&gt;. Imagine there&amp;#8217;s an empty word marking position zero, before A, right at the front of the dictionary, and our recursive  definition is complete.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc3" name="tocnext-permutation-in-action" id="tocnext-permutation-in-action"&gt;Next permutation in action&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple program which shows &lt;code&gt;next_permutation()&lt;/code&gt; in action.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int main()
{
    char xs[] = "123";
    do
    {
        std::puts(xs);
    }
    while (std::next_permutation(xs, xs + sizeof(xs) - 1));
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This program outputs lexicographically ordered permutations of 1, 2 and 3. When the main function returns, the array &lt;code&gt;xs&lt;/code&gt; will have cycled round to hold the lexicographically smallest arrangement of its elements, which is &lt;code&gt;"123"&lt;/code&gt;. Note that we never convert the characters &lt;code&gt;'1'&lt;/code&gt;, &lt;code&gt;'2'&lt;/code&gt;, &lt;code&gt;'3'&lt;/code&gt; into the numbers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;. The values of both sets of data types appear in the same order, so all works as expected.
&lt;/p&gt;
&lt;pre&gt;
123
132
213
231
312
321
&lt;/pre&gt;

&lt;p&gt;If we tweak and rerun the same program with &lt;code&gt;xs&lt;/code&gt; initialised to &lt;code&gt;"AAADKRRV"&lt;/code&gt; we get rather more output.
&lt;/p&gt;
&lt;pre&gt;
AAADKRRV
AAADKRVR
AAADKVRR
...
AARDVARK
...
VRRKAADA
VRRKADAA
VRRKDAAA
&lt;/pre&gt;

&lt;p&gt;The sequence &lt;strong&gt;doesn&amp;#8217;t&lt;/strong&gt; start by repeating &lt;code&gt;"AAADKRRV"&lt;/code&gt; 6 times, once for every permutation of the 3 A&amp;#8217;s. Only strictly increasing permutations are included. And although the repeated calls to &lt;code&gt;next_permutation&lt;/code&gt; generate a series of permutations, the algorithm holds no state. Each function call works on its input range afresh.
&lt;/p&gt;
&lt;p&gt;This second run of the program yields 3360 lines of output, even though there are 8! = 40320 possible permutations of 8 characters. Each unique permutation corresponds to 3! &amp;times; 2! = 12 actual permutations of the 8 characters (because there are 3 A&amp;#8217;s and 2 R&amp;#8217;s), and 40320 &amp;divide; 12 is 3360.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc4" name="tocsnail-sorts-revenge" id="tocsnail-sorts-revenge"&gt;Snail sort&amp;#8217;s revenge&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/tim_norris/2789759648/"&gt;&lt;img src="http://farm4.static.flickr.com/3143/2789759648_ab4bfb5ea8.jpg" width="500px" height="333px" alt="...and in last place. By Tim Norris"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;As you can see, &lt;code&gt;next_permutation&lt;/code&gt; sorts an input range, one step at a time.  When &lt;code&gt;next_permutation&lt;/code&gt; eventually returns false, the range will be perfectly ordered. Hence we have &lt;code&gt;snail_sort()&lt;/code&gt;, hailed by the SGI STL &lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;documentation&lt;/a&gt; as the worst known deterministic sorting algorithm.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;class Iter&amp;gt; 
void snail_sort(Iter first, Iter last)
{
    while (next_permutation(first, last)) {}
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Very witty, and evidence that code can be both &lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html"&gt;elegant and inefficient&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;In two important edge cases, though, &lt;code&gt;snail_sort&lt;/code&gt; performs on a par with super-charged &lt;code&gt;quicksort&lt;/code&gt;!
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     I snail sorted an array filled with 100000000 zeros in 0.502 seconds. Running quicksort on the same array took 5.504 seconds. 
 &lt;/li&gt;

 &lt;li&gt;
     Starting with an array of the same size filled with the values 99999999, 99999998, 99999997, &amp;#8230; 1, 0 snail sort&amp;#8217;s 0.500 seconds trounced quicksort&amp;#8217;s 4.08 seconds.
 &lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc5" name="tocthe-next-number-solved" id="tocthe-next-number-solved"&gt;The Next Number, Solved&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s an outline solution to the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;next number problem&lt;/a&gt;. (I&amp;#8217;ve glossed over the exact input and output file formats for clarity.) It reads numbers from standard input and writes next numbers to standard output. &lt;code&gt;Next_permutation&lt;/code&gt; does the hard work, and there&amp;#8217;s a bit of fiddling when we have to increase the number of digits by adding a zero.&lt;a id="fn1link" href="http://wordaligned.org/articles/next-permutation#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

/*
 Given a string of digits, shift any leading '0's
 past the first non-zero digit and insert an extra zero.
 
 Examples:
  
 123 -&amp;gt; 1023
 008 -&amp;gt; 8000
 034 -&amp;gt; 3004
*/
void insert_a_zero(std::string &amp;amp; number)
{
    size_t nzeros = number.find_first_not_of('0');
    number = number.substr(nzeros);
    number.insert(1, nzeros + 1, '0');
}

/*
 Outline solution to the 2009 code jam Next Number problem.
 
 Given a string representing a decimal number, find the next
 number which can be formed from the same set of digits. Add
 another zero if necessary. Repeat for all such strings read
 from standard input.
*/
int main()
{
    std::string number;
    while (std::cin &amp;gt;&amp;gt; number)
    {
        if (!next_permutation(number.begin(), number.end()))
        {
            insert_a_zero(number);
        }
        std::cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; '\n';
    }
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc6" name="tocimplementation" id="tocimplementation"&gt;Implementation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having used the C++ standard library to solve the puzzle, let&amp;#8217;s take a look at how it works. Next permutation is a clever algorithm which shuffles a collection in place. My system implements it like this&lt;a id="fn2link" href="http://wordaligned.org/articles/next-permutation#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;
        
    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We start with a range delimited by a pair of bi-directional iterators, &lt;code&gt;[first, last)&lt;/code&gt;. If the range contains one item or fewer, there can be no next permutation, so leave the range as is and return &lt;code&gt;false&lt;/code&gt;. Otherwise, enter the &lt;code&gt;for&lt;/code&gt; loop with an iterator &lt;code&gt;i&lt;/code&gt; pointing at the final item in the range.
&lt;/p&gt;
&lt;p&gt;At each pass through the body of this for loop we decrement &lt;code&gt;i&lt;/code&gt; by one, stepping towards the first item in the range. We are looking for one of two conditions:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     the value pointed to by &lt;code&gt;i&lt;/code&gt; is smaller than the one it pointed to previously
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;i&lt;/code&gt; reaches into the first item in the range
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Put another way, we divide the range into a head and tail, where the tail is the longest possible decreasing tail of the range.
&lt;/p&gt;
&lt;p&gt;If this tail is the whole range (the second condition listed above) then the whole range is in reverse order, and we have the lexicographical maximum formed from its elements. Reversing the range returns it to its lexicographical minimum, and we can return &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;If this tail is not the whole range, then the final item in the head of the range, the item &lt;code&gt;i&lt;/code&gt; points to, this item is smaller than at least one of the items in the tail of the range, and we can certainly generate a greater permutation by moving the item towards the end of the range. To find the next permutation, we reverse iterate from the end of the range until we find an item &lt;code&gt;*j&lt;/code&gt; bigger than &lt;code&gt;*i&lt;/code&gt; &amp;#8212; that&amp;#8217;s what the while loop does. Swapping the items pointed to by &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; ensures the head of the range is bigger than it was, and the tail of the range remains in reverse order. Finally, we reverse the tail of the range, leaving us with a permutation exactly one beyond the input permutation, and we return &lt;code&gt;true&lt;/code&gt;. 
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc7" name="tocwhats-happening-here" id="tocwhats-happening-here"&gt;What&amp;#8217;s happening here?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s clear from this paper analysis that the algorithm is of linear complexity. Essentially, it walks up and down the tail of the list, comparing and swapping. But why does it work?
&lt;/p&gt;
&lt;p&gt;Let &lt;code&gt;xs&lt;/code&gt; be the range &lt;code&gt;(first, last)&lt;/code&gt;. As described above, divide this range into prefix and suffix subranges, &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, where &lt;code&gt;tail&lt;/code&gt; is the longest monotonically decreasing tail of the range.
&lt;/p&gt;
&lt;p&gt;If the &lt;code&gt;head&lt;/code&gt; of the range is empty, then the range &lt;code&gt;xs&lt;/code&gt; is clearly at its lexicographical maximum. 
&lt;/p&gt;
&lt;p&gt;Otherwise, &lt;code&gt;tail&lt;/code&gt; is a lexicographical maximum of the elements it contains, and &lt;code&gt;xs&lt;/code&gt; is therefore the largest permutation which starts with the subrange &lt;code&gt;head&lt;/code&gt;. What will the &lt;code&gt;head&lt;/code&gt; of the next permutation be? We have to swap the final item in &lt;code&gt;head&lt;/code&gt; with the smallest item of &lt;code&gt;tail&lt;/code&gt; which exceeds it: the definition of &lt;code&gt;tail&lt;/code&gt; guarantees at least one such item exists. Now we want to permute the new &lt;code&gt;tail&lt;/code&gt; to be at a its lexicographical minimum, which is a matter of sorting it from low to high.
&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;tail&lt;/code&gt; is in reverse order, finding the smallest item larger than &lt;code&gt;head[-1]&lt;/code&gt; is a matter of walking back from the end of the range to find the first such items; and once we&amp;#8217;ve swapped these items, &lt;code&gt;tail&lt;/code&gt; remains in reverse order, so a simple reversed will sort it.
&lt;/p&gt;
&lt;p&gt;As an example consider finding the next permutation of:
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8342666411
&lt;/pre&gt;

&lt;p&gt;The longest monotonically decreasing tail is &lt;code&gt;666411&lt;/code&gt;, and the corresponding head is &lt;code&gt;8342&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8342 666411
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;666411&lt;/code&gt; is, by definition, reverse-ordered, and cannot be increased by permuting its elements. To find the next permutation, we must increase the head; a matter of finding the smallest tail element larger than the head&amp;#8217;s final &lt;code&gt;2&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;2&lt;/span&gt; 666411
&lt;/pre&gt;

&lt;p&gt;Walking back from the end of tail, the first element greater than &lt;code&gt;2&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;2&lt;/span&gt;  666&lt;span style="color:#930"&gt;4&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Swap the &lt;code&gt;2&lt;/code&gt; and the &lt;code&gt;4&lt;/code&gt;
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;4&lt;/span&gt; 666&lt;span style="color:#930"&gt;2&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Since head has increased, we now have a greater permutation. To reduce to the next permutation, we reverse tail, putting it into increasing order.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8344 112666
&lt;/pre&gt;

&lt;p&gt;Join the head and tail back together. The permutation one greater than &lt;code&gt;8342666411&lt;/code&gt; is &lt;code&gt;8344112666&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc8" name="tocbeautiful-c" id="tocbeautiful-c"&gt;Beautiful C++?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/looping-forever-and-ever.html"&gt;&lt;img  src="http://wordaligned.org/images/mite.jpg" alt="for(;;) dust mite"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;C++ has its &lt;a href="http://yosefk.com/c++fqa/defective.html" title="If you are an expert in the intricacies of C++, please consider this knowledge a kind of martial art - something a real master never uses. Yossi Keinin"&gt;detractors&lt;/a&gt;, who characterise it as subtle, &lt;a href="http://twitter.com/dabeaz/status/5677453478" title="C++0x reminds me of blocks stacked by my toddler. Really wobbly and one block too many makes it topple. @dabeaz"&gt;complex&lt;/a&gt;, and &lt;a href="http://www2.research.att.com/~bs/bs_faq.html#really-say-that" title="C++ can blow your whole leg off. Bjarne Stroustrup"&gt;dangerous&lt;/a&gt;; but sometimes it excels. Look once more at the C++ implementation of this algorithm.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;
    
    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span /&gt;With its special cases, boolean literals, multiple returns (4, count them!), disembodied and infinite loops, this code fails to exhibit conventional beauty. Yet &lt;em&gt;it is&lt;/em&gt; beautiful. All the next permutation algorithm needs are iterators which can advance forwards or backwards, step by step. And that&amp;#8217;s all this implementation uses.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m as excited as anyone by the mathematical rigour of &lt;a href="http://www.informit.com/articles/article.aspx?p=1407357&amp;amp;seqNum=3" title="Great article by Andrei Alexandrescu, which questions a pure Haskell quicksort implementation"&gt;functional programming&lt;/a&gt;, but sometimes computer science is about algorithms with virtually no space overhead, algorithms which loop rather than recurse. Sometimes it&amp;#8217;s about shuffling, nudging and swapping &amp;#8212; operations which map directly to the machine&amp;#8217;s most primitive operations. In such cases, C++ gets it right.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc9" name="tocpermutations-in-python" id="tocpermutations-in-python"&gt;Permutations in Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For the code jam, though, as mentioned earlier, having a super-fast program rarely matters. More often, it&amp;#8217;s about developing a fast enough program super-quickly.
&lt;/p&gt;
&lt;p&gt;I find Python a far quicker language for developing code than C++. (Indeed, sometimes when it&amp;#8217;s obvious from the outset that a final program will need implementing in C++, I put together a working prototype using Python, which I then translate.) Could we solve the next number problem using code from the standard Python library?
&lt;/p&gt;
&lt;p&gt;At a first glance, &lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.permutations"&gt;itertools.permutations&lt;/a&gt; looks promising.
&lt;/p&gt;
&lt;blockquote&gt;&lt;h3&gt;&lt;tt&gt;itertools.permutations(&lt;em&gt;iterable&lt;/em&gt;, &lt;em&gt;r=None&lt;/em&gt;)&lt;/tt&gt;&lt;/h3&gt;&lt;p&gt;Return successive &lt;em&gt;r&lt;/em&gt; length permutations of elements in the &lt;em&gt;iterable&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;If &lt;em&gt;r&lt;/em&gt; is not specified or is &lt;tt&gt;None&lt;/tt&gt;, then &lt;em&gt;r&lt;/em&gt; defaults to the length
of the &lt;em&gt;iterable&lt;/em&gt; and all possible full-length permutations
are generated.&lt;/p&gt;&lt;p&gt;Permutations are emitted in lexicographic sort order.  So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the permutation tuples will be produced in sorted order.&lt;/p&gt;&lt;p&gt;Elements are treated as unique based on their position, not on their value.  So if the input elements are unique, there will be no repeat values in each permutation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;However, this algorithm doesn&amp;#8217;t care about the values of the items in the iterable, and the lexicographic sort order applies to the indices of these items. So although the ordering of the generated items is well-defined:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     we get repeats, and
 &lt;/li&gt;

 &lt;li&gt;
     it&amp;#8217;s not the ordering we want (in this case)
 &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; concat = ''.join
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations('AAA')))
['AAA', 'AAA', 'AAA', 'AAA', 'AAA', 'AAA']
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations('231')))
['231', '213', '321', '312', '123', '132']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It &lt;strong&gt;is&lt;/strong&gt; possible to code up &lt;code&gt;next_permutation&lt;/code&gt; using nothing more than the standard itertools, but it isn&amp;#8217;t advisable.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Snail permute&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import permutations, groupby

def next_permutation(xs):
    """Calculate the next permutation of the sequence xs.
    
    Returns a pair (yn, xs'), where yn is a boolean and xs' is the 
    next permutation. If yn is True, xs' will be the lexicographic 
    next permutation of xs, otherwise xs' is the lexicographic 
    smallest permutation of xs.
    """
    xs = tuple(xs)
    if not xs:
        return False, xs
    else:
        ps = [p for p, gp in groupby(sorted(permutations(xs)))]
        np = len(ps)
        ix = ps.index(xs) + 1
        if ix == len(ps):
            return False, ps[0]
        else:
            return True, ps[ix]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As it happens, a solution based on this exhaustive search would score points in the code jam since it copes with the small input set. For the large input set its factorial complexity rules it out, and we&amp;#8217;d need to implement the next permutation algorithm &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1"&gt;from scratch&lt;/a&gt;.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/next-permutation#fn1link"&gt;[1]&lt;/a&gt;: A more cunning &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1"&gt;solution&lt;/a&gt; avoids the special case by pushing the extra zero to head of the string before applying &lt;code&gt;next_permutation&lt;/code&gt;, then popping it if it hasn&amp;#8217;t been moved.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/next-permutation#fn2link"&gt;[2]&lt;/a&gt;: I&amp;#8217;ve tweaked the layout and parameter names for use on this site.
&lt;/p&gt;</description>
<dc:date>2009-11-19</dc:date>
<guid>http://wordaligned.org/articles/next-permutation</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/next-permutation</link>
<category>Puzzles</category>
</item>

<item>
<title>Favicon</title>
<description>&lt;p&gt;On the subject of &lt;a href="http://wordaligned.org/"&gt;this site&lt;/a&gt;, I wanted to mention the recent addition of a favicon &lt;img src="http://wordaligned.org/images/favicon.png" alt="Little chap favicon"/&gt;. Per pixel, it&amp;#8217;s cost me more effort than any other feature; but then it&amp;#8217;s accessed more than any other asset. It&amp;#8217;s meant to be a piece from a jigsaw puzzle. I got the idea when &lt;a href="http://wordaligned.org/articles/recursive-pictures.html"&gt;re-reading Life A User&amp;#8217;s Manual&lt;/a&gt;. I like &lt;a href="http://wordaligned.org/tag/puzzles/"&gt;puzzles&lt;/a&gt; and piecing things together.
&lt;/p&gt;
&lt;div class="amazon"&gt;&lt;a href="http://www.amazon.com/gp/product/0002719991?ie=UTF8&amp;amp;tag=wordalig-20"&gt;&lt;img src="http://wordaligned.org/images/books/life-a-users-manual.jpg" alt="Life A User's Manual"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Perec&amp;#8217;s great masterpiece is packed with interwoven stories and trickery, but at its heart is the epic battle between the millionaire, Bartlebooth, and the puzzle-maker Gaspard Winckler. Bartlebooth begins his campaign by learning how to paint, which takes him 10 years. For the next 20 years he travels the world, painting a water colour picture of a different port every couple of weeks. He sends the paintings back home to Paris. On receipt, Winckler glues each picture to a board which he then cuts, making a series of jigsaw puzzles for Bartlebooth to solve on his return. Once Bartlebooth completes each puzzle, an ingenious process is used to glue its pieces together and re-join the cut fibres of the paper; then the picture itself is lifted from the board, returned to the port it depicts, and washed clean in the sea; and finally the paper is returned in something close to its original state to Bartlebooth.
&lt;/p&gt;
&lt;p&gt;Thus, after 50 years of work, there will be nothing to show.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/images/jigsaw-fr.png" alt="French jigsaw pieces"/&gt;

&lt;p&gt;In the book&amp;#8217;s preamble Perec describes familiar die-cut jigsaws, classifying the best known pieces of such puzzles as &amp;#8220;little chaps&amp;#8221;, &amp;#8220;double crosses&amp;#8221; and &amp;#8220;crossbars&amp;#8221;. Such diversions are eschewed by the true puzzler:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The art of jigsaw puzzling begins with wooden puzzles cut by hand, whose maker undertakes to ask himself all the questions the player will have to solve, and, instead of allowing chance to cover his tracks, aims to replace it with cunning, trickery and subterfuge. All the elements occurring in the image to be reassembled &amp;#8212; this armchair covered in gold brocade, that three-pointed black hat with its rather ruined black plume, or that silver-braided bright yellow livery &amp;#8212; serve by design as points of departure for trails that lead to false information.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;hr /&gt;

&lt;p&gt;My thanks to Tim Beard for scanning a couple of pages from his edition of &lt;a href="http://en.wikipedia.org/wiki/La_Vie_mode_d%27emploi" title="Life A User's Manual, Wikipedia"&gt;La Vie, Mode d&amp;#8217;Emploi&lt;/a&gt;. I wanted to know what the &amp;#8220;little chaps&amp;#8221; etc. were before they got translated into English. I realise my favicon &lt;img src="http://wordaligned.org/images/favicon.png" alt="Little chap favicon"/&gt; could be &lt;a href="http://typophile.com/node/60577" title="Astonishing exploded view of improved YouTube favicon"&gt;improved&lt;/a&gt; but I don&amp;#8217;t know how to go about it. Anyone?
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://typophile.com/node/60577" title="YouTube Favicon - improved"&gt;&lt;img src="http://wordaligned.org/images/youtube1.png" width="52px" height="26px" alt="YouTube Favicon - improved"/&gt;&lt;/a&gt;&lt;a href="http://typophile.com/node/60577" title="YouTube Favicon - improved"&gt;&lt;img src="http://wordaligned.org/images/youtube2.png" width="104px" height="52px" alt="YouTube Favicon - improved"/&gt;&lt;/a&gt;&lt;a href="http://typophile.com/node/60577" title="YouTube Favicon - improved"&gt;&lt;img src="http://wordaligned.org/images/youtube3.png" width="208px" height="104px" alt="YouTube Favicon - improved"/&gt;&lt;/a&gt;
&lt;/p&gt;</description>
<dc:date>2009-09-16</dc:date>
<guid>http://wordaligned.org/articles/favicon</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/favicon</link>
<category>Puzzles</category>
</item>

<item>
<title>Blackmail made easy using Python counters</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocthe-obsessive-blackmailer" name="toc0" id="toc0"&gt;The Obsessive Blackmailer&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocmodeling-the-problem" name="toc1" id="toc1"&gt;Modeling the Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocthe-evolution-of-multisets-in-python" name="toc2" id="toc2"&gt;The evolution of multisets in Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocwait-theres-more" name="toc3" id="toc3"&gt;Wait, there&amp;#8217;s more!&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocback-to-blackmail" name="toc4" id="toc4"&gt;Back to Blackmail&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocgeneric-code" name="toc5" id="toc5"&gt;Generic Code&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocend-of-message" name="toc6" id="toc6"&gt;End of Message&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc0" name="tocthe-obsessive-blackmailer" id="tocthe-obsessive-blackmailer"&gt;The Obsessive Blackmailer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;An obsessive blackmailer writes anonymous messages by by cut-and-pasting letters from newspapers. Being obsessive, the blackmailer only writes messages which can be composed entirely from a single newspaper.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3754867981/" title="word aligned by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2567/3754867981_a752d15f74_o.png" width="480" height="309" alt="word aligned" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Devise an algorithm which determines whether a given message can be written using a given newspaper.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc1" name="tocmodeling-the-problem" id="tocmodeling-the-problem"&gt;Modeling the Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This is a nice little problem but I&amp;#8217;m about to spoil it since I&amp;#8217;m using it here as a study in Python&amp;#8217;s evolution. So if you&amp;#8217;d like to try it yourself, look away now.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;We can represent both inputs to the algorithm as sequences of characters: a message string, length M, and a newspaper string, length N. We &lt;em&gt;could&lt;/em&gt; process the message string one character at a time, at each step scanning through the newspaper and noting the first occurrence of that character we haven&amp;#8217;t used before; but this is inefficient since we potentially read the whole paper M times.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s better to think of this problem in terms of multisets, sometimes known as bags. A multiset is a set which can have repeated elements. Our blackmailer can proceed if the multiset of letters used in the message is contained entirely within the multiset of letters used in the newspaper.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc2" name="tocthe-evolution-of-multisets-in-python" id="tocthe-evolution-of-multisets-in-python"&gt;The evolution of multisets in Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A dictionary provides a compact and efficient way to represent a multiset in Python: each dictionary key represents an item in the multiset, and the value associated with that key is the number of times the key appears in the multiset. Python dictionaries are implemented as hashed arrays, meaning that member insertion and access take constant time, on average.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s not hard to create such a multiset from a sequence but it&amp;#8217;s interesting to see how advances in the Python language have simplified the code. 
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python.org/doc/1.4/lib/node13.html#SECTION00316000000000000000"&gt;&lt;img src="http://python.org/doc/1.4/lib/img7.gif" height="181px" width="469px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The complete documentation for &lt;a href="http://python.org/doc/1.4/"&gt;Python 1.4&lt;/a&gt;, released in 1996, is still available on the Python website. In version 1.4 you could write:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_14(xs):
    multiset = {}
    for x in xs:
        if multiset.has_key(x):
            multiset[x] = multiset[x] + 1
        else:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code works unchanged in the current Python release, 2.6 (though note &lt;code&gt;dict.has_key()&lt;/code&gt; doesn&amp;#8217;t exist in Python 3.*). Alternatively, you might catch the &lt;code&gt;KeyError&lt;/code&gt; raised when trying to access the dict with an invalid key:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_14(xs):
    multiset = {}        
    for x in xs:
        try:
            multiset[x] = multiset[x] + 1
        except KeyError:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Python 1.5 introduces an exception-free dictionary access method, &lt;code&gt;dict.get()&lt;/code&gt;, which returns a user supplied default (defaulting to &lt;code&gt;None&lt;/code&gt;) for missing keys.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_15(xs):
    multiset = {}        
    for x in xs:
        multiset[x] = multiset.get(x, 0) + 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s certainly shorter, a little cleaner maybe, but perhaps it takes more effort for readers to see what exactly is going on.
&lt;/p&gt;
&lt;p&gt;At Python 2.2, &lt;code&gt;x in multiset&lt;/code&gt; improves on the equivalent &lt;code&gt;multiset.has_key(x)&lt;/code&gt; and we can use augmented arithmetic operators (&lt;code&gt;+=, -=, *=, /=, %=, **=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;amp;=, =, |=&lt;/code&gt;), allowing:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_22(xs):
    multiset = {}
    for x in xs:
        if x in multiset:
            multiset[x] += 1
        else:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I think I prefer the &lt;code&gt;dict.get()&lt;/code&gt; version, though.
&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;collections&lt;/code&gt; module makes its first appearance in Python 2.4 offering a &lt;code&gt;deque&lt;/code&gt; and a promise of more high performance container types to come. Python 2.5 makes good on this promise, adding &lt;code&gt;defaultdict&lt;/code&gt; to the module. A &lt;code&gt;defaultdict&lt;/code&gt; is a specialised dictionary which calls a client supplied factory function for missing keys. Setting this factory function to &lt;code&gt;int&lt;/code&gt; turns the &lt;code&gt;defaultdict&lt;/code&gt; into a multiset. No need for &lt;code&gt;dict.get()&lt;/code&gt; any more.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from collections import defaultdict

def multiset_25(xs):
    multiset = defaultdict(int)
    for x in xs:
        multiset[x] += 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc3" name="tocwait-theres-more" id="tocwait-theres-more"&gt;Wait, there&amp;#8217;s more!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The final improvement is available in Python 3.1 right now (or in Python 2.7, coming soon), courtesy once again of the collections module. &lt;a href="http://docs.python.org/dev/library/collections.html#collections.Counter"&gt;Collections.Counter&lt;/a&gt; is exactly what we&amp;#8217;ve been waiting for.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from collections import Counter

def multiset_31(xs):
    return Counter(xs)

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc4" name="tocback-to-blackmail" id="tocback-to-blackmail"&gt;Back to Blackmail&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So our blackmailer should first generate a multiset representation of the letters in the message. Then it&amp;#8217;s a matter of iterating through the newspaper and reducing the multiset each time a letter matches up. We keep a tally of the number of letters we still need to match, and stop when this tally is zero or when we get to the end of the newspaper. Here&amp;#8217;s a sketch of an implementation.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def blackmailable(message, newspaper):
    """Return True if newspaper can be used to write the blackmail 
    message, False otherwise.
    """
    m = len(message)
    if m == 0:
        return True
    counts = multiset(message)
    for ch in newspaper:
        if counts[ch] &amp;gt; 0:
            counts[ch] -= 1
            m -= 1
            if m == 0:
                return True
    return False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code assumes the multiset is represented as a &lt;code&gt;Counter&lt;/code&gt; or a &lt;code&gt;defaultdict&lt;/code&gt;, since it depends on &lt;code&gt;counts[ch]&lt;/code&gt; returning 0 for any character not in the message. If we&amp;#8217;d used a plain dict, we&amp;#8217;d need to employ &lt;code&gt;dict.get(ch, 0)&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m not entirely happy with the code shown. It&amp;#8217;s what I first came up with. Here&amp;#8217;s an alternative, which I also find a bit clunky. I&amp;#8217;d welcome any improvements. It&amp;#8217;s also worth noting that the algorithm locates the matching characters in the newspaper, so we might want to cache some indices for later use.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def blackmailable(message, newspaper):
    """Return True if newspaper can be used to write the blackmail 
    message, False otherwise.
    """
    counts = multiset(message)
    m = len(message)
    n = len(newspaper)
    i = 0
    while m != 0 and i != n:
        ch = newspaper[i]
        if counts[ch] &amp;gt; 0:
            counts[ch] -= 1
            m -= 1
        i += 1
    return m == 0

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can avoid the ugly code by persuading the obssessive blackmailer to generate and maintain multiset representations of the entire newspaper library. Then &lt;code&gt;blackmailable()&lt;/code&gt; can be implemented as multiset containment, something which the &lt;code&gt;Counter&lt;/code&gt; class handles nicely using the subtraction operator. Note here that multiset subtraction never results in any negative counts, even though a &lt;code&gt;Counter&lt;/code&gt; instance could itself have negative counts.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Counter
&amp;gt;&amp;gt;&amp;gt; missing_letters = Counter(message) - Counter(newspaper)
&amp;gt;&amp;gt;&amp;gt; blackmailable = len(missing_letters) == 0

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Alternatively:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; blackmailable = not missing_letters

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc5" name="tocgeneric-code" id="tocgeneric-code"&gt;Generic Code&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose the blackmailer prefers to compose a message from words, rather than letters? (For an example, see the threat to stay away from Grimpen Moor delivered to Sir Henry Baskerville discussed later in this article.) The code works as is &amp;#8212; just pass in message and newspaper as word sequences, rather than character sequences. Anything we can hash can be counted.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc6" name="tocend-of-message" id="tocend-of-message"&gt;End of Message&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In the age of the interweb anonymous cowardice is far easier and blackmailers don&amp;#8217;t need to resort to manual cut and paste techniques unless they&amp;#8217;re after a retro threatening effect.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Never_Mind_the_Bollocks,_Here's_the_Sex_Pistols"&gt;&lt;img src="http://wordaligned.org/images/never-mind-the-bollocks.jpg" alt="Never Mind the Bollocks"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;img style="float:right" alt="Sherlock Holmes" src="http://wordaligned.org/images/sherlock-holmes.png"/&gt;

&lt;p&gt;What&amp;#8217;s more, a detective can figure out plenty from these messages: so when Sir Henry Baskerville receives a threatening letter during his stay at the Northumberland Hotel, he shows it promptly to Sherlock Holmes:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Across the middle of it a single sentence had been formed by the expedient of pasting printed words upon it. It ran: &amp;#8220;As you value your life or your reason keep away from the moor.&amp;#8221; The word &amp;#8220;moor&amp;#8221; only was printed in ink.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;In a virtuso display of deductive reasoning, Holmes shows the author of the message was in a hurry, afraid of being interrupted, and working in a hotel room using nail-scissors. (He also deduces something else, which he does not reveal at the time.) Identifying the source of the words to be yesterday&amp;#8217;s Times leader is elementary.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The detection of types is one of the most elementary branches of knowledge to the special expert in crime, though I confess that once when I was very young I confused the Leeds Mercury with the Western Morning News. But a Times leader is entirely distinctive, and these words could have been taken from nothing else.
&lt;/p&gt;
&lt;p&gt;&amp;#8212; Sherlock Holmes, &lt;a href="http://www.gutenberg.org/dirs/etext02/bskrv11a.txt"&gt;The Hound of the Baskervilles&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Can anyone identify the newspaper I used to create the image at the start of this article?
&lt;/p&gt;
&lt;p&gt;&lt;hr /&gt;
   My thanks to jay for a &lt;a href="http://wordaligned.org/articles/python-counters#comment-13418772"&gt;correction&lt;/a&gt; to the original version of this article.
&lt;/p&gt;</description>
<dc:date>2009-07-27</dc:date>
<guid>http://wordaligned.org/articles/python-counters</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/python-counters</link>
<category>Puzzles</category>
</item>

<item>
<title>Partitioning with Python</title>
<description>&lt;h3&gt;Sums and Splits&lt;/h3&gt;
&lt;p&gt;On the subject of &lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;hunting for eodermdromes&lt;/a&gt;, here are a couple of semi-related partitioning problems.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     for a positive integer, N, find the positive integer sequences which sum to N
 &lt;/li&gt;

 &lt;li&gt;
     for a sequence, S, find the distinct partitions of that sequence
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As an example of the first, the 16 distinct integer sequences which sum to 5 are:
&lt;/p&gt;
&lt;pre&gt;
5
4 + 1
3 + 1 + 1
3 + 2
2 + 1 + 2
2 + 1 + 1 + 1
2 + 2 + 1
2 + 3
1 + 1 + 3
1 + 1 + 2 + 1
1 + 1 + 1 + 1 + 1
1 + 1 + 1 + 2
1 + 2 + 2
1 + 2 + 1 + 1
1 + 3 + 1
1 + 4
&lt;/pre&gt;

&lt;p&gt;and of the second, the 8 distinct ways of partitioning the sequence ABCD are:
&lt;/p&gt;
&lt;pre&gt;
ABCD
A BCD
AB CD
ABC D
A B CD
A BC D
AB C D
A B C D
&lt;/pre&gt;

&lt;p&gt;Note that I&amp;#8217;ve counted 2 + 1 + 2, 2 + 2 + 1, and 1 + 2 + 2 as distinct sums totalling 5. That happens to be the formulation of the problem which interested me.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Context&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;&lt;img src="http://wordaligned.org/images/eodermdrome.png" width="200px" height="200px" style="float:right" alt="eodermdrome"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Before discussing a solution to these problems, some context. Recall that an &lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;eodermdrome&lt;/a&gt; is a sequence which forms an Eulerian circuit through the fully connected graph whose vertices are the set of its elements. Put more simply: when you trace through the letters you get the figure shown, with no edge covered twice. Examples include:
&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;span style="color:#930"&gt;O&lt;/span&gt;&lt;span style="color:#036"&gt;D&lt;/span&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;R&lt;/span&gt;&lt;span style="color:#e50"&gt;M&lt;/span&gt;&lt;span style="color:#036"&gt;D&lt;/span&gt;&lt;span style="color:#555"&gt;R&lt;/span&gt;&lt;span style="color:#930"&gt;O&lt;/span&gt;&lt;span style="color:#e50"&gt;M&lt;/span&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;N&lt;/span&gt;&lt;span style="color:#036"&gt;H&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#555"&gt;N&lt;/span&gt;&lt;span style="color:#888"&gt;C&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt; &lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#888"&gt;C&lt;/span&gt;&lt;span style="color:#036"&gt;H&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#888"&gt;X&lt;/span&gt; &lt;span style="color:#e50"&gt;D&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#e50"&gt;D&lt;/span&gt; &lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#888"&gt;X&lt;/span&gt;&lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Eodermdromes turn out to be surprisingly rare. Writing a computer program to find them is a nice exercise in searching and text processing. Clearly, we should start with a collection of words. Then we can generate combinations of words from this collection and filter out the eodermdromes.
&lt;/p&gt;
&lt;pre&gt;
(filter eodermdrome? (combinations words))
&lt;/pre&gt;

&lt;p&gt;A large set of words (note: &amp;#8220;set&amp;#8221; not &amp;#8220;collection&amp;#8221;, we don&amp;#8217;t need duplicates) gives the best chance of success. I started with a file containing more than 35 thousand distinct words. This gives over a billion possible word pairs, and when we consider word triples and quartets the numbers get silly even for a modern computer.
&lt;/p&gt;
&lt;p&gt;As is so often the case in computing, we have a tension between opposing concerns. We&amp;#8217;d like code which separates the task of generating candidates and the task of testing these candidates for eodermdromicity, but in order to run this code in a timely manner we need some of the eodermdrome testing to leak into the candidate generation. For example, we could preprocess the word set removing words which contain double Ls (all, ball, call, ill, Bill, kill &amp;#8230;) since these can never appear in an eodermdrome. And we could similarly remove words which end ETE (delete, Pete, effete). As I hope you can see, it&amp;#8217;s easy to end up with finickity code and co-dependent functions.
&lt;/p&gt;
&lt;p&gt;I chose a simple but effective strategy to reduce the search space to something manageable, based on word length. First, then, I loaded my word set into a Python dict collecting lists of words keyed by their length.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import defaultdict
&amp;gt;&amp;gt;&amp;gt; words = defaultdict(list)
&amp;gt;&amp;gt;&amp;gt; for word in open('word-set.txt').read().split():
...     words[len(word)].append(word)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Given this dict, picking out single word eodermdromes is easy.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; list(filter(is_eodermdrome, words[11]))
['eodermdrome']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about eodermdromes composed of a 6 letter word followed by a 5 letter word? We can form the &lt;a href="http://docs.python.org/library/itertools.html#itertools.product"&gt;cartesian product&lt;/a&gt; of the lists of 6 and 5 letter words and filter out the ones we want.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import product
&amp;gt;&amp;gt;&amp;gt; eod_6_5 = filter(is_eodermdrome, product(words[6], words[5]))
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
('earned', 'andre')
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
('yearly', 'relay')

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about &lt;em&gt;all eodermdromes&lt;/em&gt; of length 11?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import chain.from_iterable as seq
&amp;gt;&amp;gt;&amp;gt; word_lens = sum_to_n(11)
&amp;gt;&amp;gt;&amp;gt; candidates = seq(product(*[words[i] for i in s]) for s in word_lens)
&amp;gt;&amp;gt;&amp;gt; eods = filter(is_eodermdrome, candidates)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note here that I&amp;#8217;m using Python 3.0, and that &lt;a href="http://docs.python.org/py3k/library/functions.html#filter"&gt;filter&lt;/a&gt; is therefore a lazy function. The interactive session shown above hasn&amp;#8217;t actually started taking anything from these lazily-evaluated streams.
&lt;/p&gt;
&lt;p&gt;I certainly don&amp;#8217;t claim this is the quickest way to search for eodermdromes. In fact, this little program took several hours to complete. But a back-of-an-envelope calculation showed it &lt;em&gt;would&lt;/em&gt; complete in a few hours, and that was good enough.
&lt;/p&gt;
&lt;p&gt;Note also that we haven&amp;#8217;t shown an implementation of &lt;code&gt;sum_to_n()&lt;/code&gt; yet, which takes us back to the problems posed at the start of this article.
&lt;/p&gt;

&lt;h3&gt;Sum to N&lt;/h3&gt;
&lt;p&gt;Finding the positive integer series which sum to a positive integer N is a job for &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;itertools.combinations&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import combinations, chain

def sum_to_n(n):
    'Generate the series of +ve integer lists which sum to a +ve integer, n.'
    from operator import sub
    b, mid, e = [0], list(range(1, n)), [n]
    splits = (d for i in range(n) for d in combinations(mid, i)) 
    return (list(map(sub, chain(s, e), chain(b, s))) for s in splits)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The idea here is straightforward: there&amp;#8217;s a 1-to-1 correspondence between the sums we want and ordered combinations drawn from the series 1, 2, &amp;#8230; n-1. For example, if n is 11 one such combination would be:
&lt;/p&gt;
&lt;pre&gt;
(1, 5, 7, 10)
&lt;/pre&gt;

&lt;p&gt;we can extend this by pushing 0 in front and n at the end
&lt;/p&gt;
&lt;pre&gt;
(0, 1, 5, 7, 10, 11)
&lt;/pre&gt;

&lt;p&gt;This extended tuple can now be seen as partial sums of a series which sums to 11. Taking differences gives the series
&lt;/p&gt;
&lt;pre&gt;
(1-0, 5-1, 7-5, 10-7, 11-10)
&lt;/pre&gt;

&lt;p&gt;which is
&lt;/p&gt;
&lt;pre&gt;
(1, 4, 2, 3, 1)
&lt;/pre&gt;

&lt;p&gt;which does indeed sum to 11
&lt;/p&gt;
&lt;pre&gt;
1 + 4 + 2 + 3 + 1 = 11
&lt;/pre&gt;

&lt;p&gt;The Python code shown uses a clever idea to implement this staggered differencing, an idea I &lt;a href="http://newsimg.bbc.co.uk/media/images/45909000/jpg/_45909582_badartists.jpg" title="Bristol's famous artist and thief"&gt;cleverly stole&lt;/a&gt; from one of &lt;a href="http://code.activestate.com/recipes/users/178123/"&gt;Raymond Hettinger&amp;#8217;s brilliant Python recipes&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;Partitioning a Sequence&lt;/h3&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Python Cookbook: Recipe 576795&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import chain, combinations

def partition(iterable, chain=chain, map=map):
    s = iterable if hasattr(iterable, '__getslice__') else tuple(iterable)
    n = len(s)
    first, middle, last = [0], range(1, n), [n]
    getslice = s.__getslice__
    return [map(getslice, chain(first, div), chain(div, last))
            for i in range(n) for div in combinations(middle, i)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This &lt;a href="http://code.activestate.com/recipes/576795"&gt;recipe&lt;/a&gt; shows sum-to-n and partitioning to be very similar problems. In fact, we could easily implement &lt;code&gt;sum_to_n()&lt;/code&gt; on top of  &lt;code&gt;partition()&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def sum_to_n(n):
    return ([len(t) for t in p] for p in partition(range(n)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The posted recipe needs a minor overhaul to get it working with Python 3.0, &lt;a href="http://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods"&gt;which does away&lt;/a&gt; with &lt;code&gt;__getslice__&lt;/code&gt;: getting a slice is simply what &lt;code&gt;__getitem__&lt;/code&gt; does when given a slice object. The 2to3 tool fails to convert the recipe, which must be recast as something like:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import chain, combinations

def sliceable(xs):
    '''Return a sliceable version of the iterable xs.'''
    try:
        xs[:0]
        return xs
    except TypeError:
        return tuple(xs)

def partition(iterable):
    s = sliceable(iterable)
    n = len(s)
    b, mid, e = [0], list(range(1, n)), [n]
    getslice = s.__getitem__
    splits = (d for i in range(n) for d in combinations(mid, i))
    return [[s[sl] for sl in map(slice, chain(b, d), chain(d, e))]
            for d in splits]

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Sum to N, again&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a variant implementation of &lt;code&gt;sum_to_n()&lt;/code&gt;. The idea here is to fill N slots with a pattern of 0&amp;#8217;s and 1&amp;#8217;s. We then reduce this pattern to the lengths of runs of repeated elements, giving a series which sums to N. &lt;code&gt;Itertools.product('01', repeat=n)&lt;/code&gt; generates all possible binary patterns of length N, which turns out to be twice as many as we want since (e.g.) 00001111100 and 11110000011 represent the same sum, 4 + 5 + 2; hence the n-1 &lt;code&gt;repeat&lt;/code&gt; count and the call to &lt;code&gt;chain&lt;/code&gt; in the code below&lt;a id="fn1link" href="http://wordaligned.org/articles/partitioning-with-python#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import groupby, chain, product

def ilen(it):
    return sum(1 for _ in it)

def sum_to_n(n):
    return ([ilen(gp) for _, gp in groupby(chain('1', O1))]
            for O1 in product('01', repeat=n-1))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Fun, but the version using &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;combinations&lt;/a&gt; is better!
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/partitioning-with-python#fn1link"&gt;[1]&lt;/a&gt; My first thought was to use &lt;code&gt;itertools.islice&lt;/code&gt; to limit the stream to the first 2&lt;sup&gt;n-1&lt;/sup&gt; values, but I discovered &lt;code&gt;islice&lt;/code&gt; has a surprising &lt;a href="http://bugs.python.org/issue6305" title="I've reported this as a bug"&gt;limitation&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import islice, count
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31) - 1)
&amp;lt;itertools.islice object at 0x63a0c0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31))
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
ValueError: Stop argument for islice() must be a non-negative integer or None.

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;
&lt;p style="text-align:center"&gt;so reuse ours&lt;/p&gt;</description>
<dc:date>2009-06-17</dc:date>
<guid>http://wordaligned.org/articles/partitioning-with-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/partitioning-with-python</link>
<category>Puzzles</category>
</item>

<item>
<title>Oulipo and the Eodermdrome challenge</title>
<description>&lt;p style="margin:0;font-size:500%"&gt;&lt;span style="color:#888"&gt;S&lt;/span&gt;&lt;span style="color:#930"&gt;H&lt;/span&gt;&lt;span style="color:#036"&gt;O&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#888"&gt;S&lt;/span&gt; &lt;span style="color:#036"&gt;O&lt;/span&gt;&lt;span style="color:#e50"&gt;N&lt;/span&gt; &lt;span style="color:#930"&gt;H&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#e50"&gt;N&lt;/span&gt;&lt;span style="color:#888"&gt;S&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:500%"&gt;&lt;span style="color:#036"&gt;S&lt;/span&gt;&lt;span style="color:#888"&gt;A&lt;/span&gt;&lt;span style="color:#930"&gt;M&lt;/span&gt;&lt;span style="color:#036"&gt;S&lt;/span&gt;&lt;span style="color:#555"&gt;O&lt;/span&gt;&lt;span style="color:#e50"&gt;N&lt;/span&gt; &lt;span style="color:#930"&gt;M&lt;/span&gt;&lt;span style="color:#555"&gt;O&lt;/span&gt;&lt;span style="color:#888"&gt;A&lt;/span&gt;&lt;span style="color:#e50"&gt;N&lt;/span&gt;&lt;span style="color:#036"&gt;S&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:500%"&gt;&lt;span style="color:#555"&gt;D&lt;/span&gt;&lt;span style="color:#930"&gt;R&lt;/span&gt;&lt;span style="color:#888"&gt;A&lt;/span&gt;&lt;span style="color:#036"&gt;B&lt;/span&gt; &lt;span style="color:#930"&gt;R&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;D&lt;/span&gt; &lt;span style="color:#036"&gt;B&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;span style="color:#888"&gt;A&lt;/span&gt;&lt;span style="color:#555"&gt;D&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;Oulipo&lt;/h3&gt;
&lt;p&gt;At the &lt;a href="http://www.dcs.warwick.ac.uk/bshm/meetings/Fiction.html"&gt;Mathematics and Fiction&lt;/a&gt; workshop held last weekend in Oxford I particularly enjoyed &lt;a href="http://web.princeton.edu/sites/fit/faculty/bellos.html"&gt;David Bellos&lt;/a&gt;&amp;#8217; wonderful talk about Oulipo, the world&amp;#8217;s longest running literary movement. &lt;a href="http://www.oulipo.net"&gt;The Oulipo&lt;/a&gt; is a group of writers interested in exploring the application of mathematical structures, patterns and algorithms to writing.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3597995774/" title="Queneau sonnets by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm4.static.flickr.com/3342/3597995774_857cdd8566_o.jpg" width="450" height="325" alt="Queneau sonnets" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;As an example, poet and novelist &lt;a href="http://en.wikipedia.org/wiki/Raymond_Queneau"&gt;Raymond Queneau&lt;/a&gt; unleashed the exponential power of combinatorics to write a &lt;a href="http://en.wikipedia.org/wiki/Sonnet"&gt;small book&lt;/a&gt; of sonnets which he hadn&amp;#8217;t finished reading himself!
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Constraints&lt;/h3&gt;
&lt;div class="amazon"&gt;&lt;a href="http://www.amazon.com/gp/product/0099477548?tag=wordalig-20"&gt;&lt;img src="http://wordaligned.org/images/books/damascus.jpg" alt="Damascus cover"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;The &lt;a href="http://en.wikipedia.org/wiki/Sonnet"&gt;sonnet&lt;/a&gt; is a highly constrained literary form: 14 lines, 10 syllables per line, and a well-defined rhyme pattern. More generally, the Oulipo discovered  such mathematical constraints can generate interesting results. Constraints can also provide inspiration &amp;#8212; tying things down helps give them shape. Consider two questions:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     What are you doing?
 &lt;/li&gt;

 &lt;li&gt;
     What are you doing? (Limit your answer to &lt;a href="http://twitter.com/thomasguest"&gt;140 characters&lt;/a&gt;.)
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first sounds plain nosey; but the second has spawned a whole new form of publishing.
&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://www.fox.com/24" title="24. Never seen it, but I get the idea!"&gt;day-in-a-life&lt;/a&gt; format is another &lt;a href="http://en.wikipedia.org/wiki/Bloomsday"&gt;famous&lt;/a&gt; literary constraint. Oulipo-inspired writer &lt;a href="http://richardbeard.info"&gt;Richard Beard&lt;/a&gt; explains how he notched this constraint up a level, creating a novel in which the action is formally and tightly bound to a single day.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In &amp;#8220;Damascus,&amp;#8221; I only use nouns that appeared in The Times of Nov. 1 1993. How does this work? In one paragraph some children are racing to the sea and one of them wants to say &amp;#8212; &amp;#8220;Last to touch the water&amp;#8217;s a donkey.&amp;#8221; But there&amp;#8217;s no &amp;#8220;donkey&amp;#8221; in the paper, so they end up saying, &amp;#8220;Last to touch the water&amp;#8217;s a walrus.&amp;#8221; So you end up with some interesting and novel linguistic formulations. &amp;#8212; &lt;a href="http://richardbeard.info/html/the_japan_times_.html"&gt;Richard Beard&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;The Eodermdrome challenge&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.oulipo.net/contraintes/docs/eodermdrome"&gt;&lt;img src="http://wordaligned.org/images/eodermdrome.png" width="200px" height="200px" style="float:right" alt="eodermdrome"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The simplest Oulipian structure David Bellos presented was the &lt;a href="http://www.oulipo.net/contraintes/docs/eodermdrome"&gt;eodermdrome&lt;/a&gt;. The word &amp;#8220;EODERMDROME&amp;#8221; is itself an eodermdrome &lt;a id="fn1link" href="http://wordaligned.org/articles/oulipo-eodermdrome#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;: if you place the letters E, O, D, R, M at the vertices of a pentagon, as shown, when you trace the sequence E&amp;rarr;O&amp;rarr;D&amp;rarr;E&amp;rarr;R&amp;rarr;M&amp;rarr;D&amp;rarr;R&amp;rarr;O&amp;rarr;M&amp;rarr;E you end up where you started, covering each line in the resulting figure exactly once. Mathematically speaking, the sequence EODERMDROME forms an Eulerian circuit within the fully connected graph whose vertices are the set of its constituent characters. Eodermdromes make naturally pleasing sequences, perhaps suitable for domain names or memorable phone numbers.
&lt;/p&gt;
&lt;p&gt;In his talk David Bellos offered three more eodermdromes. The second is credited to Jacques Roubaud. You&amp;#8217;ll notice that the elements in the third are words rather than characters: the pattern works at any scale, and a reader needn&amp;#8217;t be aware of it to appreciate its beauty.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     tears at rest
 &lt;/li&gt;

 &lt;li&gt;
     &amp;eacute;toile, ortie
 &lt;/li&gt;

 &lt;li&gt;
     figs, lizards, snakes, heat, light, figs, snakes, light, lizards, heat, figs
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Eodermdromes turn out to be surprisingly thin on the ground. I include three of my own discoveries &lt;a id="fn2link" href="http://wordaligned.org/articles/oulipo-eodermdrome#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt; at the start of this article. Can you can find any better ones?
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.withhugsandkisses.co.uk"&gt;&lt;img src="http://wordaligned.org/images/shoes-on-hens.jpg" alt="SHOES ON HENS"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/oulipo-eodermdrome#fn1link"&gt;[1]&lt;/a&gt; The word for such words is &amp;#8220;autological&amp;#8221;, as opposed to &amp;#8220;heterological&amp;#8221;. But is &lt;a href="http://en.wikipedia.org/wiki/Grelling-Nelson_paradox" title="Yes but no but"&gt;&amp;#8220;heterological&amp;#8221; itself heterological&lt;/a&gt;?
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/oulipo-eodermdrome#fn2link"&gt;[2]&lt;/a&gt; OK, so a computer did the hard work. It&amp;#8217;s a nice programming exercise.
&lt;/p&gt;
&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;
&lt;p style="text-align:center"&gt;end code once&lt;/p&gt;</description>
<dc:date>2009-06-05</dc:date>
<guid>http://wordaligned.org/articles/oulipo-eodermdrome</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/oulipo-eodermdrome</link>
<category>Puzzles</category>
</item>

<item>
<title>Ordered sublists. A brute force approach</title>
<description>&lt;h3&gt;Younger runners&lt;/h3&gt;
&lt;p&gt;Recently &lt;a href="http://wordaligned.org/articles/a-race-within-a-race.html"&gt;I posed a puzzle&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Starting with a list of runners ordered by their finishing time in a race, select a sublist of runners who are getting younger. &lt;strong&gt;What is the longest such sublist?&lt;/strong&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Below, I&amp;#8217;ve highlighted just such a sublist within the list of 8 runners who completed last year&amp;#8217;s &lt;a href="http://www.nycmarathon.org"&gt;New York marathon&lt;/a&gt; in under two and a quarter hours. As you can see, MARILSON GOMES DO SANTOS, 31, is older and faster than RONO, 30, who is older and faster in turn than ROHATINSKY, 26.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     &lt;strong&gt;MARILSON GOMES DOS SANTOS, 31&lt;/strong&gt;, M, 2:08:43
 &lt;/li&gt;

 &lt;li&gt;
     ABDERRAHIM GOUMRI, 32, M, 2:09:07
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;DANIEL RONO, 30&lt;/strong&gt;, M, 2:11:22
 &lt;/li&gt;

 &lt;li&gt;
     PAUL TERGAT, 39, M, 2:13:10
 &lt;/li&gt;

 &lt;li&gt;
     ABDERRAHIME BOURAMDANE, 30, M, 2:13:33
 &lt;/li&gt;

 &lt;li&gt;
     ABDI ABDIRAHMAN, 31, M, 2:14:17
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;JOSH ROHATINSKY, 26&lt;/strong&gt;, M, 2:14:23
 &lt;/li&gt;

 &lt;li&gt;
     JASON LEHMKUHLE, 31, M, 2:14:30
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a deceptively tricky problem. Even on such a small input list it&amp;#8217;s hard to be absolutely sure our solution is optimal. Certainly there are other ordered triples with decreasing ages, but might there be a quartet? And even if we&amp;#8217;re convinced Gomes, Rono, Rohatinsky &lt;strong&gt;do&lt;/strong&gt; form a longest ordered sublist, I think it&amp;#8217;s already clear that as more runners finish, there may be no longer be a longest ordered sublist which starts with these three.
&lt;/p&gt;

&lt;h3&gt;Dumb computers&lt;/h3&gt;
&lt;p&gt;Rather than invent a clever strategy to find an optimal solution, why not get a computer to exhaust the possibilities? If we generate all possible sublists then filter out the ones whose age fields decrease, then our answer will be the longest of these.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Exhaustive search&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import combinations as sublists
from functools import partial

def is_ordered(xs, comp):
    '''Return True if the sequence xs is ordered, False otherwise.
    
    &amp;gt;&amp;gt;&amp;gt; from operator import gt
    &amp;gt;&amp;gt;&amp;gt; is_ordered((3, 2, 1), gt)
    True
    '''
    return all(comp(xs[i], xs[i+1]) for i in range(len(xs)-1))

def longest_ordered_sublist(xs, comp):
    '''Find a longest sublist of "xs" which is ordered by "comp"
    
    (Note: there may be no unique solution, and this function makes
    no guarantees about which longest sublist is returned.)
    
    &amp;gt;&amp;gt;&amp;gt; from operator import lt
    &amp;gt;&amp;gt;&amp;gt; items = 2, 1, 5, 2, 2, 3, 1
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist(items, lt)
    (1, 2, 3)
    '''
    in_order = partial(is_ordered, comp=comp)
    xss = (xss for n in range(len(xs)) for xss in sublists(xs, n))
    return max(filter(in_order, xss), key=len)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The heavy lifting here is done by a recent addition to the &lt;code&gt;itertools&lt;/code&gt; module, &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;itertools.combinations&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;itertools.combinations(iterable, r)
&lt;/p&gt;
&lt;p&gt;Return r length subsequences of elements from the input iterable.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Generating all possible sublists is as easy (too easy!) as looping over &lt;code&gt;r&lt;/code&gt;. All that remains is to filter the ordered sublists, then use the &lt;code&gt;max&lt;/code&gt; builtin function keyed by length.
&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s apply this function to our top 8 finishers.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; results = (
... ("Gomes", 31), ("Goumri", 32), ("Rono", 30),
... ("Tergat", 39), ("Bouramdane", 30), ("Abdirahman", 31),
... ("Rohatinsky", 26), ("Lehmkuhle", 31))
&amp;gt;&amp;gt;&amp;gt; def older(runner_a, runner_b):
...     return runner_a[1] &amp;gt; runner_b[1]
&amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist(results, older)
(('Gomes', 31), ('Rono', 30), ('Rohatinsky', 26))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So, the longest ordered sublist has length 3, and Gomes, Rono, Rohatinsky is such a sublist.
&lt;/p&gt;
&lt;p&gt;Adapting &lt;code&gt;longest_ordered_sublist&lt;/code&gt; to return &lt;strong&gt;all&lt;/strong&gt; longest ordered sublists is easy enough:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     replace &lt;code&gt;max(filter(in_order, xss), key=len)&lt;/code&gt; with &lt;code&gt;sorted(filter(in_order, xss), key=len)&lt;/code&gt;
 &lt;/li&gt;

 &lt;li&gt;
     feed the sorted results through &lt;code&gt;itertools.groupby&lt;/code&gt; 
 &lt;/li&gt;

 &lt;li&gt;
     and capture the final group. 
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It turns out there are no fewer than 7 longest subsequences ordered by decreasing age.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;All longest ordered subsequences&lt;/div&gt;

&lt;pre class="prettyprint"&gt;(('Gomes', 31), ('Rono', 30), ('Rohatinsky', 26))
(('Gomes', 31), ('Bouramdane', 30), ('Rohatinsky', 26))
(('Goumri', 32), ('Rono', 30), ('Rohatinsky', 26))
(('Goumri', 32), ('Bouramdane', 30), ('Rohatinsky', 26))
(('Goumri', 32), ('Abdirahman', 31), ('Rohatinsky', 26))
(('Tergat', 39), ('Bouramdane', 30), ('Rohatinsky', 26))
(('Tergat', 39), ('Abdirahman', 31), ('Rohatinsky', 26))

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Dumber programmers&lt;/h3&gt;
&lt;p&gt;Did you spot the defects in &lt;code&gt;longest_ordered_sublist()&lt;/code&gt;? It gets the answer wrong for empty sequences and totally ordered sequences.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; import operator
&amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist([], operator.lt)
Traceback (most recent call last):
....
ValueError: max() arg is an empty sequence
&amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist((1, 2, 3), operator.lt)
(1, 2)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Fixing the code is easy enough, but what should we do about the documentation, and indeed about testing these edge cases? Certainly edge cases &lt;strong&gt;should&lt;/strong&gt; be tested, and it&amp;#8217;s tempting to add a couple more examples to the function&amp;#8217;s docstring and let &lt;a href="http://docs.python.org/library/doctest.html"&gt;doctest&lt;/a&gt; confirm correctness.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def longest_ordered_sublist(xs, comp):
    '''Find a longest sublist of "xs" which is ordered by "comp"
    
    (Note: there may be no unique solution, and this function makes
    no guarantees about which longest sublist is returned.)
    
    &amp;gt;&amp;gt;&amp;gt; from operator import lt
    &amp;gt;&amp;gt;&amp;gt; items = 2, 1, 5, 2, 2, 3, 1
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist(items, lt)
    (1, 2, 3)
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist((1, 2, 3), lt)
    (1, 2, 3)
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist((), lt)
    ()
    '''
    in_order = partial(is_ordered, comp=comp)
    xss = (xss for n in range(len(xs) + 1) for xss in sublists(xs, n))
    return max(filter(in_order, xss), key=len)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Tempting, yes. Good idea? Not really!
&lt;/p&gt;
&lt;p&gt;As &lt;a href="http://nedbatchelder.com/blog/200811/things_i_dont_like_about_doctest.html"&gt;Ned Batchelder puts it&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Docstrings, and the long sequence of code they encourage, may be good ways to explain what code does, but explaining and testing are two different tasks, and the code you write for each will be different. So why try to serve two masters at once?
&lt;/p&gt;
&lt;p&gt;Either your expository text will be cluttered with uninformative edge cases, or your tests will merely skim the surface of what your code can do.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;In the case of the revised version of &lt;code&gt;longest_ordered_sublist()&lt;/code&gt;, the first example in the docstring explains clearly what the function does, but the second and third count as &lt;a href="http://docs.python.org/library/doctest.html#soapbox"&gt;clutter&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;Ignorant machines&lt;/h3&gt;
&lt;p&gt;Returning to our combinatorial algorithm, this kind of exhaustive search approach is often referred to as brute force. When you&amp;#8217;ve got a machine which can do billions of things every second without breaking a sweat, it&amp;#8217;s a great technique.
&lt;/p&gt;
&lt;p&gt;In this case, though, brute force turns out to be machine ignorance. If a list has N items, then each item will be either in or out of any particular combination, giving a total of 2&lt;sup&gt;N&lt;/sup&gt; possible combinations. On my machine it took over 5 seconds to confirm the longest ordered subsequence of the &lt;a href="http://wordaligned.org/articles/a-race-within-a-race.html"&gt;first 20 runners&lt;/a&gt; in the New York marathon was of length 7.
&lt;/p&gt;
&lt;p&gt;5 seconds isn&amp;#8217;t so very long but every additional runner doubles up the time, and we can predict this particular algorithm would fail to process a result list of just 32 entries within the 2 and a bit hours it took Mar&amp;iacute;lson Gomes dos Santos to complete the course.
&lt;/p&gt;
&lt;p&gt;We need to do better.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.nycmarathon.org/2008_coverage.htm"&gt;&lt;img src="http://www.nyrr.org/resources/photos/images/2008/marathon/men/pro_men_15.jpg" alt="Marilson Gomes dos Santos"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;We can do better! This problem has been studied and some particularly interesting solutions have been found. All talk here about races, ages, etc. only exists to disguise the real problem and encourage you to consider it afresh. If you want an answer now, search for &lt;a href="http://www.google.com/search?q=longest+ordered+subsequence"&gt;&amp;#8220;longest ordered subsequence&amp;#8221;&lt;/a&gt; or &lt;a href="http://www.google.com/search?q=longest+increasing+subsequence"&gt;&amp;#8220;longest increasing subsequence&amp;#8221;&lt;/a&gt;. If you&amp;#8217;d like to have a crack at the problem yourself, the 2008 New York marathon results can be found &lt;a href="http://www.nycmarathon.org/Results.htm"&gt;online&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;I get an answer of 1724 for the length of the longest sublist of these results formed of runners whose ages are non-increasing, and 60 for the longest sublist formed of runners whose ages are strictly decreasing.
&lt;/p&gt;
&lt;p&gt;Alternatively, stick around &amp;#8212; I&amp;#8217;ll be writing up my own notes in the next couple of articles.
&lt;/p&gt;
&lt;hr /&gt;


&lt;h3&gt;Python 3.0 notes&lt;/h3&gt;
&lt;p&gt;As I mentioned at the start of the year, &lt;a href="http://wordaligned.org/articles/perl-6-python-3.html"&gt;I intend to use Python 3.0 for all new code examples&lt;/a&gt; posted here on &lt;a href="http://wordaligned.org/"&gt;Word Aligned&lt;/a&gt;. I&amp;#8217;ll also be making notes about what I discover about using this new version of Python, starting right here.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     my emacs python editing mode stopped working when I moved to Python 3.0. (I was using whatever came as standard with Carbon Emacs 22). The fix was to use &lt;a href="http://svn.python.org/view/python/tags/r30/Misc/python-mode.el?rev=67506"&gt;Python-3.0/Misc/python-mode.el&lt;/a&gt; straight out of the Python 3.0 tarball. Happily this also works with Python 2.6 and earlier.
 &lt;/li&gt;

 &lt;li&gt;
     the code presented runs out of time before running out of memory since, in Python 3.0, the &lt;code&gt;filter&lt;/code&gt; builtin function generates elements on demand. Use &lt;code&gt;future_builtins.filter&lt;/code&gt; or &lt;code&gt;itertools.ifilter&lt;/code&gt; if you want this behaviour with 2.6.
 &lt;/li&gt;

 &lt;li&gt;
     while not strictly Python 3.0 (it appears in 2.6 as well) &lt;code&gt;itertools.combinations&lt;/code&gt; is worth mentioning again, as is another related member of the itertools module. Check out &lt;a href="http://code.activestate.com/recipes/576647/"&gt;Raymond Hettinger&amp;#8217;s clever solution&lt;/a&gt; of the eight Queens puzzle, which uses &lt;code&gt;itertools.permutations&lt;/code&gt; to shuffle pieces around a chessboard. Unlike other itertools, &lt;code&gt;combinations&lt;/code&gt; and &lt;code&gt;permutations&lt;/code&gt; won&amp;#8217;t cope with infinite streams. 
 &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Another way to exhaust your computer&lt;/div&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import combinations, count
&amp;gt;&amp;gt;&amp;gt; pairs = combinations(count(), 2)

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2009-03-09</dc:date>
<guid>http://wordaligned.org/articles/ordered-sublists-a-brute-force-approach</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/ordered-sublists-a-brute-force-approach</link>
<category>Puzzles</category>
</item>

<item>
<title>A race within a race</title>
<description>&lt;p&gt;In 2003 the route of the Bristol half marathon took runners out of the city, following the Portway along the base of the Avon Gorge before turning 180&amp;deg; and taking them straight back again. So runners heading out along one side of the road got to watch the faster runners in front of them, heading back.
&lt;/p&gt;
&lt;p&gt;&lt;a style="align:top;" href="http://www.runnerslife.co.uk/Guest-Runners/Nick-Rose"&gt;&lt;img width="150" height="200" src="http://wordaligned.org/images/nick-rose-then.jpg" alt="Nick Rose then"/&gt;&lt;/a&gt;
   &lt;a style="align:top;" href="http://www.upandrunning.co.uk/shops/bristol.php"&gt;&lt;img width="150" height="200" src="http://wordaligned.org/images/nick-rose-now.jpg" alt="Nick Rose now"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The beauty of the Avon Gorge was probably lost on most competitors, myself included. What did impress me, though, was the sight of Nick Rose sprinting back along the Portway, his white hair swept back by his astonishing speed. Despite being 13 years older than me he completed the 13 mile race 13 minutes ahead of me. (I did beat &lt;a href="http://en.wikipedia.org/wiki/Steve_Cram"&gt;Steve Cram&lt;/a&gt; though!)
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;The &lt;a href="http://www.bristolhalfmarathon.com/about/race-history/"&gt;2003 Bristol half marathon&lt;/a&gt; featured a &lt;strong&gt;race within a race&lt;/strong&gt;, the &amp;#8220;Legends Challenge&amp;#8221;, which reunited veteran British athletes Nick Rose, Steve Cram, Tim Hutchings, Hugh Jones, Steve Jones and Mike McLeod to compete against each other for the first time since the 1984 Los Angeles Olympics. Nick Rose won this race within a race, aged 52, in 16&lt;sup&gt;th&lt;/sup&gt; place overall, with a time of just 1:11:08. This inspiring result set me wondering about another slice of the results: starting with a list of runners ordered by their finishing time in a race, select, in order, a sublist of runners who are getting younger. &lt;strong&gt;What is the longest such sublist?&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;Unfortunately I don&amp;#8217;t have access to the full results for the Bristol 2003 half marathon. Instead, here are the top 20 finishers in the 2008 &lt;a href="http://www.nycmarathon.org"&gt;New York marathon&lt;/a&gt;&lt;a id="fn1link" href="http://wordaligned.org/articles/a-race-within-a-race#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     MARILSON GOMES DOS SANTOS, 31, M, 2:08:43
 &lt;/li&gt;

 &lt;li&gt;
     ABDERRAHIM GOUMRI, 32, M, 2:09:07
 &lt;/li&gt;

 &lt;li&gt;
     DANIEL RONO, 30, M, 2:11:22
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;PAUL TERGAT, 39&lt;/strong&gt;, M, 2:13:10
 &lt;/li&gt;

 &lt;li&gt;
     ABDERRAHIME BOURAMDANE, 30, M, 2:13:33
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;ABDI ABDIRAHMAN, 31&lt;/strong&gt;, M, 2:14:17
 &lt;/li&gt;

 &lt;li&gt;
     JOSH ROHATINSKY, 26, M, 2:14:23
 &lt;/li&gt;

 &lt;li&gt;
     JASON LEHMKUHLE, 31, M, 2:14:30
 &lt;/li&gt;

 &lt;li&gt;
     HOSEA ROTICH, 29, M, 2:15:25
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;BOLOTA ASMEROM, 30&lt;/strong&gt;, M, 2:16:37
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;LUKE HUMPHREY, 27&lt;/strong&gt;, M, 2:18:38
 &lt;/li&gt;

 &lt;li&gt;
     HENDRICK RAMAALA, 36, M, 2:19:11
 &lt;/li&gt;

 &lt;li&gt;
     MOHAMMED AWOL, 30, M, 2:19:13
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;KASSAHUN KABISO, 25&lt;/strong&gt;, M, 2:19:54
 &lt;/li&gt;

 &lt;li&gt;
     JACOB FREY, 27, M, 2:20:17
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;GENNA TUFA, 24&lt;/strong&gt;, M, 2:20:23
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;KYLE SHACKLETON, 22&lt;/strong&gt;, M, 2:20:38
 &lt;/li&gt;

 &lt;li&gt;
     TEKLU TEFERA DENEKE, 29, M, 2:20:47
 &lt;/li&gt;

 &lt;li&gt;
     BOAZ CHEBOIYWO, 30, M, 2:21:40
 &lt;/li&gt;

 &lt;li&gt;
     DERESSE DENIBOBA, 26, M, 2:21:54
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As you can see Paul Tergat, 39, finished ahead of the younger runner Abdi Abdirahman, 31, who beat Bolota Asmerom, 30, etc., giving a sublist of 7 runners which fits our criteria. Certainly this isn&amp;#8217;t the only such sublist of this small sample, but is there a longer one?
&lt;/p&gt;
&lt;p&gt;After a few minutes we may convince ourselves we&amp;#8217;ve found an optimal solution. How would you approach this problem for the full results list, ending with YURIKO OKADA, 59, F, 9:59:58 in 38096&lt;sup&gt;th&lt;/sup&gt; place?
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.nyc-architecture.com/BRI/BR-010.htm" title="How many runners?"&gt;&lt;img width="300" src="http://www.nyc-architecture.com/BRI/Verrazano-Narrows_Bridge_New_York_City_Marathon_2.jpg" alt="How many runners?"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ll be discussing this problem in the next few posts, so please make sure you&amp;#8217;re &lt;a href="http://feeds.wordaligned.org/wordaligned"&gt;subscribed&lt;/a&gt; to read on. In the meanwhile, here&amp;#8217;s a picture of the Avon Gorge taken from the western pier of the Clifton Suspension bridge. You can see the Portway down at the bottom. Nick Rose is a past winner of the Bristol Half Marathon. In 1979 &lt;a href="http://www.nationmaster.com/encyclopedia/Half-marathon#World_record_progression_-_Men"&gt;he set a world record time&lt;/a&gt; for the distance of 1:02:36, and his &lt;a href="http://hem.bredband.net/athletics/atb-m59.htm"&gt;personal best of 1:01:03&lt;/a&gt; still stands as a British record. He lives in Bristol, now working at &lt;a href="http://www.upandrunning.co.uk/shops/bristol.php"&gt;&amp;#8220;Up and Running&amp;#8221;&lt;/a&gt; in Westbury Park, and he continues to participate in the sport.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3163729064/" title="Avon Gorge and Clifton Suspension Bridge by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm4.static.flickr.com/3120/3163729064_6f0feec1b8.jpg" width="500" height="154" alt="Avon Gorge and Clifton Suspension Bridge" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/a-race-within-a-race#fn1link"&gt;[1]&lt;/a&gt; I&amp;#8217;m using capital letters since these names are scraped directly from the &lt;a href="http://www.nycmarathon.org"&gt;New York Marathon website&lt;/a&gt;, which uses capital letters almost exclusively, except for non-ascii athletes such as CORN&amp;eacute; VAN OIRSCHOT.
&lt;/p&gt;</description>
<dc:date>2009-03-04</dc:date>
<guid>http://wordaligned.org/articles/a-race-within-a-race</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/a-race-within-a-race</link>
<category>Puzzles</category>
</item>

<item>
<title>What&#8217;s in the box?</title>
<description>&lt;p&gt;Last week I posted &lt;a href="http://wordaligned.org/articles/a-little-teaser.html"&gt;a little teaser&lt;/a&gt; which hid a series of clues in and around the page&amp;#8217;s HTML and the referenced graphic. Thanks to everyone who joined in. Some of you said you learned something in the process, which is good; and &lt;a href="http://netpbm.sourceforge.net/"&gt;I did too&lt;/a&gt;, which is better!
&lt;/p&gt;
&lt;p&gt;Filip Salomonsson completed the treasure hunt first. Extra credits go to Robin Stocker for his &lt;a href="http://www.flickr.com/photos/thomasguest/3106269463/"&gt;Swiss version&lt;/a&gt;, &lt;a href="http://chneukirchen.org/"&gt;Christian Neukirchen&lt;/a&gt; for a solution which requires no programming, and to Shiar who spotted the answer at once but nevertheless followed the clues to the end! 
&lt;/p&gt;
&lt;p&gt;A full solution appears below, &lt;a href="http://fliptitle.com"&gt;ROT-180&amp;deg;&lt;/a&gt; encoded.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/a-little-teaser.html"&gt;&lt;img src="http://wordaligned.org/images/top-row-flipped.png" alt="What's this? Answer below!"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;div style="text-align:right;"&gt;&lt;p&gt;&amp;#x02D9;&amp;#x01DD;&amp;#x0279;&amp;#x01DD;&amp;#x0265; p&amp;#x01DD;&amp;#x028C;&amp;#x0131;&amp;#x0279;&amp;#x0279;&amp;#x0250; &amp;#x01DD;&amp;#x028C;,no&amp;#x028E; &amp;#x028D;ou&amp;#x029E; &amp;#x01DD;&amp;#x026F; &amp;#x0287;&amp;#x01DD;l o&amp;#x0287; &amp;#x0183;&amp;#x0279;o&amp;#x02D9;p&amp;#x01DD;u&amp;#x0183;&amp;#x0131;l&amp;#x0250;p&amp;#x0279;o&amp;#x028D;@s&amp;#x028E;&amp;#x01DD;&amp;#x029E;&amp;#x0287;l&amp;#x0250;:o&amp;#x0287;l&amp;#x0131;&amp;#x0250;&amp;#x026F; &amp;#x01DD;s&amp;#x0250;&amp;#x01DD;ld &amp;#x02D9;(-&amp;#x061B; p&amp;#x01DD;u&amp;#x0183;&amp;#x0131;l&amp;#x0250; p&amp;#x0279;o&amp;#x028D; o&amp;#x0287; uo&amp;#x0131;&amp;#x0287;d&amp;#x0131;&amp;#x0279;&amp;#x0254;sqns &amp;#x0183;uol&amp;#x01DD;&amp;#x025F;&amp;#x0131;l &amp;#x01DD;&amp;#x01DD;&amp;#x0279;&amp;#x025F; &amp;#x0250; s&amp;#x0131; &amp;#x01DD;z&amp;#x0131;&amp;#x0279;d &amp;#x0279;no&amp;#x028E; &amp;#x00A1;&amp;#x01DD;uop ll&amp;#x01DD;&amp;#x028D; &amp;#x02D9;&lt;a href="http://www.flickr.com/photos/thomasguest/3104398656/"&gt;&amp;#x01DD;&amp;#x0279;&amp;#x01DD;&amp;#x0265;&lt;/a&gt; s&amp;#x0279;&amp;#x01DD;&amp;#x0287;&amp;#x0254;&amp;#x0250;&amp;#x0279;&amp;#x0250;&amp;#x0265;&amp;#x0254; &amp;#x025F;o s&amp;#x028D;o&amp;#x0279; &amp;#x01DD;&amp;#x01DD;&amp;#x0279;&amp;#x0265;&amp;#x0287; ll&amp;#x0250; &amp;#x01DD;&amp;#x01DD;s u&amp;#x0250;&amp;#x0254; no&amp;#x028E; &amp;#x02D9;&amp;#x028E;&amp;#x01DD;&amp;#x029E; &amp;#x0287;l&amp;#x0250; &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x028D;op &amp;#x0183;u&amp;#x0131;plo&amp;#x0265; &amp;#x01DD;l&amp;#x0131;&amp;#x0265;&amp;#x028D; p&amp;#x0279;&amp;#x0250;oq&amp;#x028E;&amp;#x01DD;&amp;#x029E; &amp;#x028E;&amp;#x0287;&amp;#x0279;&amp;#x01DD;&amp;#x028D;b &amp;#x0254;&amp;#x0250;&amp;#x026F; &amp;#x01DD;ldd&amp;#x0250; u&amp;#x0250; uo s&amp;#x0279;&amp;#x01DD;&amp;#x0287;&amp;#x0254;&amp;#x0250;&amp;#x0279;&amp;#x0250;&amp;#x0265;&amp;#x0254; &amp;#x025F;o &amp;#x028D;o&amp;#x0279; do&amp;#x0287; &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; &amp;#x01DD;d&amp;#x028E;&amp;#x0287; &amp;#8216;&amp;#x01DD;&amp;#x0183;&amp;#x0250;&amp;#x026F;&amp;#x0131; s&amp;#x0131;&amp;#x0265;&amp;#x0287; &amp;#x01DD;&amp;#x0287;&amp;#x0250;&amp;#x0279;&amp;#x01DD;u&amp;#x01DD;&amp;#x0183; o&amp;#x0287; :uo&amp;#x0131;&amp;#x0287;nlos&lt;/p&gt;&lt;p&gt;&amp;#x02D9;004 &amp;#x0254;- p&amp;#x0250;&amp;#x01DD;&amp;#x0265; | &amp;#x0183;ud&amp;#x02D9;&amp;#x028D;o&amp;#x0279;-do&amp;#x0287; &amp;#x0250;&amp;#x0265;dl&amp;#x0250;- &amp;#x026F;udo&amp;#x0287;&amp;#x0183;ud :&amp;#x0183;u&amp;#x0131;&amp;#x026F;&amp;#x026F;&amp;#x0250;&amp;#x0279;&amp;#x0183;o&amp;#x0279;d &amp;#x028E;u&amp;#x0250; &amp;#x0183;u&amp;#x0131;&amp;#x0279;&amp;#x0131;nb&amp;#x01DD;&amp;#x0279; &amp;#x0287;no&amp;#x0265;&amp;#x0287;&amp;#x0131;&amp;#x028D; &amp;#x0279;&amp;#x01DD;&amp;#x028D;su&amp;#x0250; &amp;#x01DD;&amp;#x0265;&amp;#x0287; s&amp;#x0287;&amp;#x01DD;&amp;#x0183; &amp;#x0265;&amp;#x0254;&amp;#x0131;&amp;#x0265;&amp;#x028D; &amp;#x026F;udo&amp;#x0287;&amp;#x0183;ud &amp;#x0287;&amp;#x0250; &amp;#x01DD;&amp;#x026F; p&amp;#x01DD;&amp;#x0287;u&amp;#x0131;od u&amp;#x01DD;&amp;#x0265;&amp;#x0254;&amp;#x0279;&amp;#x0131;&amp;#x029E;n&amp;#x01DD;u u&amp;#x0250;&amp;#x0131;&amp;#x0287;s&amp;#x0131;&amp;#x0279;&amp;#x0265;&amp;#x0254; &amp;#x02D9;s&amp;#x01DD;nl&amp;#x0250;&amp;#x028C; &amp;#x0250;&amp;#x0265;dl&amp;#x0250; &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0287;&amp;#x01DD;&amp;#x0183; o&amp;#x0287; &amp;#x0287;d&amp;#x0131;&amp;#x0279;&amp;#x0254;s &amp;#x01DD;ld&amp;#x026F;&amp;#x0131;s &amp;#x0250; &amp;#x01DD;&amp;#x0287;&amp;#x0131;&amp;#x0279;&amp;#x028D; o&amp;#x0287; &amp;#x028E;&amp;#x0279;&amp;#x0250;&amp;#x0279;q&amp;#x0131;l &amp;#x0183;u&amp;#x0131;&amp;#x0183;&amp;#x0250;&amp;#x026F;&amp;#x0131; uo&amp;#x0265;&amp;#x0287;&amp;#x028E;d &amp;#x01DD;&amp;#x0265;&amp;#x0287; p&amp;#x01DD;sn &amp;#x0131;&lt;/p&gt;&lt;p&gt;&amp;#x02D9;&amp;#x01DD;nl&amp;#x0254; &amp;#x0287;x&amp;#x01DD;u &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0287;no ll&amp;#x01DD;ds &amp;#x0183;ud s&amp;#x0131;&amp;#x0265;&amp;#x0287; &amp;#x025F;o &amp;#x028D;o&amp;#x0279; do&amp;#x0287; &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; s&amp;#x01DD;nl&amp;#x0250;&amp;#x028C; &amp;#x0250;&amp;#x0265;dl&amp;#x0250; &amp;#x01DD;&amp;#x0265;&amp;#x0287; :s&amp;#x028E;&amp;#x0250;s &amp;#x0265;&amp;#x0254;&amp;#x0131;&amp;#x0265;&amp;#x028D; &amp;#8216;&amp;#x0287;u&amp;#x01DD;&amp;#x026F;&amp;#x026F;o&amp;#x0254; &amp;#x01DD;&amp;#x0265;&amp;#x0287; p&amp;#x0250;&amp;#x01DD;&amp;#x0279; o&amp;#x0287; &amp;#x0183;ud&amp;#x02D9;&amp;#x028D;o&amp;#x0279;-do&amp;#x0287; &amp;#x01DD;soq&amp;#x0279;&amp;#x01DD;&amp;#x028C;- &amp;#x028E;&amp;#x025F;&amp;#x0131;&amp;#x0287;u&amp;#x01DD;p&amp;#x0131; &amp;#x029E;&amp;#x0254;&amp;#x0131;&amp;#x0183;&amp;#x0250;&amp;#x026F;&amp;#x01DD;&amp;#x0183;&amp;#x0250;&amp;#x026F;&amp;#x0131; p&amp;#x01DD;sn &amp;#x0131; &amp;#x02D9;&amp;#x028E;ll&amp;#x0250;&amp;#x0254;ol &amp;#x0183;ud &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x01DD;&amp;#x028C;&amp;#x0250;s&lt;/p&gt;&lt;p&gt;&amp;#x02D9;&amp;#x0183;ud &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x025F;o &amp;#x029E;un&amp;#x0265;&amp;#x0254; &amp;#x0287;x&amp;#x0287;z &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; &amp;#x0287;u&amp;#x01DD;&amp;#x026F;&amp;#x026F;o&amp;#x0254; &amp;#x01DD;&amp;#x0265;&amp;#x0287; p&amp;#x0250;&amp;#x01DD;&amp;#x0279; &amp;#8216;&amp;#x01DD;nl&amp;#x0254; &amp;#x0287;x&amp;#x01DD;u &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0279;o&amp;#x025F; :&amp;#x01DD;&amp;#x01DD;s ll,no&amp;#x028E; &amp;#x02D9;&amp;#x01DD;sno&amp;#x026F; &amp;#x0279;no&amp;#x028E; &amp;#x0183;u&amp;#x0131;sn &amp;#x0279;&amp;#x0250;q&amp;#x01DD;p&amp;#x0131;s &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0287;&amp;#x0254;&amp;#x01DD;l&amp;#x01DD;s&lt;/p&gt;&lt;p&gt;&amp;#x02D9;&amp;#x0279;&amp;#x0250;q&amp;#x01DD;p&amp;#x0131;s &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; &amp;#x0287;x&amp;#x01DD;&amp;#x0287; &amp;#x01DD;&amp;#x0287;&amp;#x0131;&amp;#x0265;&amp;#x028D; uo &amp;#x01DD;&amp;#x0287;&amp;#x0131;&amp;#x0265;&amp;#x028D; &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0287;&amp;#x0265;&amp;#x0183;&amp;#x0131;l&amp;#x0265;&amp;#x0183;&amp;#x0131;&amp;#x0265; &amp;#8216;&amp;#x01DD;nl&amp;#x0254; &amp;#x0287;x&amp;#x01DD;u &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x01DD;&amp;#x01DD;s o&amp;#x0287; :sp&amp;#x0250;&amp;#x01DD;&amp;#x0279; l&amp;#x026F;&amp;#x0287;&amp;#x0265; &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; &amp;#x0287;u&amp;#x01DD;&amp;#x026F;&amp;#x026F;o&amp;#x0254; &amp;#x0250; &amp;#x02D9;xo&amp;#x025F;&amp;#x01DD;&amp;#x0279;&amp;#x0131;&amp;#x025F; uo n+l&amp;#x0279;&amp;#x0287;&amp;#x0254; (&amp;#x02D9;&amp;#x0183;&amp;#x02D9;&amp;#x01DD;) &amp;#x0183;u&amp;#x0131;sn l&amp;#x026F;&amp;#x0287;&amp;#x0265; &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x028D;&amp;#x01DD;&amp;#x0131;&amp;#x028C;&lt;/p&gt;&lt;/div&gt;

&lt;span id="continue-reading"/&gt;

&lt;p&gt;Some found the teaser too easy. Others asked if I&amp;#8217;d be posting a follow up.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3122529935/" title="What's in the box?"&gt;&lt;img src="http://farm4.static.flickr.com/3264/3122529935_dfe6550cf6_o.png" width="294" height="450" alt="What's in the box?" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Sorry. Maybe.
&lt;/p&gt;</description>
<dc:date>2008-12-20</dc:date>
<guid>http://wordaligned.org/articles/whats-in-the-box</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/whats-in-the-box</link>
<category>Puzzles</category>
</item>

<item>
<title>A Little Teaser. Keen Eyes? You&#8217;ll See!</title>
<description>&lt;p&gt;This curious document turned up in the lost+found. Can anyone help me &lt;a href="http://www.imagemagick.org/www/identify.html" title="First hint!"&gt;identify&lt;/a&gt; it?
&lt;/p&gt;
&lt;img src="http://wordaligned.org/images/top-row.png" alt="What's this?"/&gt;

&lt;p&gt;(View &lt;a href="http://wordaligned.org/articles/a-little-teaser.html"&gt;this page&amp;#8217;s&lt;/a&gt; source for a clue.)
&lt;/p&gt;
&lt;!-- To see the next clue, highlight the white on white text in the sidebar --&gt;</description>
<dc:date>2008-12-12</dc:date>
<guid>http://wordaligned.org/articles/a-little-teaser</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/a-little-teaser</link>
<category>Puzzles</category>
</item>

<item>
<title>Sums and sums of squares in C++</title>
<description>&lt;h3&gt;C++ question&lt;/h3&gt;
&lt;p&gt;Suppose you have a collection, &lt;code&gt;xs&lt;/code&gt;, of floating point values.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef std::vector&amp;lt;double&amp;gt; doubles;
doubles xs;
.... code which fills xs

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How would you sum the elements of &lt;code&gt;xs&lt;/code&gt;? 
&lt;/p&gt;
&lt;p&gt;Now how would you calculate the sum of squares of these elements?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;It&amp;#8217;s not a trick question but there is more than one plausible answer &amp;#8212; a fact I was reminded of when I read a recent &lt;a href="http://www.johndcook.com/blog/2008/10/20/comparing-two-ways-to-fit-a-line-to-data/"&gt;article by John D. Cook&lt;/a&gt; which demonstrates how to recast a curve fitting equation to avoid loss of precision. An obvious and idiomatic approach is to loop through the values of &lt;code&gt;xs&lt;/code&gt; accumulating the required sums&lt;a id="fn1link" href="http://wordaligned.org/articles/sums-and-sums-of-squares#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double sum_xs = 0.0;
double sum_squares_xs = 0.0;

for (doubles::const_iterator xi = xs.begin(); xi != xs.end(); ++xi)
{
    double const x = *xi;
    sum_xs += x;
    sum_squares_xs += x * x;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Functional programmers might sniff at this double purpose loop which repeatedly rewrites the values of &lt;code&gt;sum_xs&lt;/code&gt; and &lt;code&gt;sum_squares_xs&lt;/code&gt; to achieve the desired result. Surely this code ought to be expressed as an application of that well-known higher order function, &lt;a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)"&gt;reduce&lt;/a&gt;? 
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s hard for an imperative programmer accept this complaint: the code, as it stands, is simple, idiomatic and efficient. However &amp;#8230; consider the same problem in Python.
&lt;/p&gt;

&lt;h3&gt;Reduce in Python&lt;/h3&gt;
&lt;p&gt;Python is far from being a pure functional programming language. As it happens, &lt;a href="http://docs.python.org/library/functions.html#reduce"&gt;reduce()&lt;/a&gt; is being demoted from a builtin to a library function in the next major release of the language. Here&amp;#8217;s the deprecation warning Python 2.6 spits out:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ python -3 -c "print reduce(lambda x, y: x + y, range(10))"
-c:1: DeprecationWarning: reduce() not supported in 3.x; use functools.reduce()
45

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I&amp;#8217;ve no real quibble about this decision: the truth is, reduce can move aside because Python already &lt;a href="http://wordaligned.org/articles/paralipsis.html"&gt;builds in specialisations&lt;/a&gt; of the most common reductions. In this case &lt;code&gt;sum&lt;/code&gt; answers our first question. Combine &lt;code&gt;sum&lt;/code&gt; with a generator expression and we&amp;#8217;ve answered the second one nicely too.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;sum_xs = sum(xs)
sum_squares_xs = sum(x * x for x in xs)

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Reduce in C++&lt;/h3&gt;
&lt;p&gt;&lt;span /&gt;Idiomatic C++ varies across both time and team. The C++ standard library does include &lt;code&gt;reduce&lt;/code&gt;, and it deserves to be better known. You can find it in &lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt; under the name of &lt;a href="http://www.sgi.com/tech/stl/accumulate.html"&gt;std::accumulate()&lt;/a&gt;. Accumulate accepts as arguments an iterator range, an initial value, and optionally a binary function. From the SGI STL &lt;a href="http://www.sgi.com/tech/stl/accumulate.html"&gt;documentation&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3&gt;Prototype&lt;/h3&gt;
&lt;p&gt;&lt;tt&gt;Accumulate&lt;/tt&gt; is an overloaded name; there are actually two &lt;tt&gt;accumulate&lt;/tt&gt;functions.&lt;/p&gt;
&lt;pre&gt;
template &amp;lt;class InputIterator, class T&amp;gt;
T accumulate(InputIterator first, InputIterator last, T init);

template &amp;lt;class InputIterator, class T, class BinaryFunction&amp;gt;
T accumulate(InputIterator first, InputIterator last, T init,
             BinaryFunction binary_op);
&lt;/pre&gt;
&lt;h3&gt;Description&lt;/h3&gt;
&lt;p&gt;&lt;tt&gt;Accumulate&lt;/tt&gt; is a generalization of summation: it computes the sum
(or some other binary operation) of &lt;tt&gt;init&lt;/tt&gt; and all of the elements
in the range &lt;tt&gt;[first, last)&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The function object &lt;tt&gt;binary_op&lt;/tt&gt; is not required to be either commutative or associative: the order of all of &lt;tt&gt;accumulate&lt;/tt&gt;&amp;#8217;s operations is specified.  The result is first initialized to &lt;tt&gt;init&lt;/tt&gt;.  Then, for each
iterator &lt;tt&gt;i&lt;/tt&gt; in &lt;tt&gt;[first, last)&lt;/tt&gt;, in order from beginning to end,
it is updated by &lt;tt&gt;result = result + *i&lt;/tt&gt; (in the first version) or &lt;tt&gt;result = binary_op(result, *i)&lt;/tt&gt; (in the second version).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thus, in its simpler form, &lt;code&gt;std::accumulate&lt;/code&gt; returns the sum of elements in the input range. Like Python, we can sum numbers; unlike Python we can also sum (i.e. concatenate) &lt;code&gt;strings&lt;/code&gt; or &lt;code&gt;valarrays&lt;/code&gt;&lt;a id="fn2link" href="http://wordaligned.org/articles/sums-and-sums-of-squares#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt; &amp;#8212; or indeed any other type we choose, provided we implement a suitable overload of &lt;code&gt;operator+()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;So, to sum the elements of &lt;code&gt;xs&lt;/code&gt;, we write:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double sum_xs = accumulate(xs.begin(), xs.end(), 0.0);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Include &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; and we can find their product too:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double product_xs 
    = accumulate(xs.begin(), xs.end(), 1.0, std::multiplies&amp;lt;double&amp;gt;());

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To sum the squares of elements of &lt;code&gt;xs&lt;/code&gt; we might supply a custom binary function.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double accum_sq(double sum_so_far, double x)
{
    return sum_so_far + x * x;
}

.... double sum_squares_xs 
         = accumulate(xs.begin(), xs.end(), 0.0, accum_sq);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Or have we got the arguments to &lt;code&gt;accum_sq()&lt;/code&gt; the wrong way round? This is the kind of code which risks giving &lt;code&gt;reduce()&lt;/code&gt; a bad name. Maybe we could avoid confusion by creating an intermediate container to hold the squared values?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;doubles xxs;

transform(xs.begin(), xs.end(), xs.begin(),
          back_inserter(xxs), std::multiplies&amp;lt;double&amp;gt;());
double sum_squares_xs = accumulate(xxs.begin(), xxs.end(), 0.0);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the first three arguments to &lt;code&gt;std::transform()&lt;/code&gt; cause &lt;code&gt;xs&lt;/code&gt; to be zipped with itself and &lt;code&gt;std::multiplies&lt;/code&gt; ensures &lt;code&gt;xxs&lt;/code&gt; gets filled with squares of elements of &lt;code&gt;xs&lt;/code&gt;. Feed the resulting range into &lt;code&gt;accumulate&lt;/code&gt; and we&amp;#8217;re done. It&amp;#8217;s cute that C++ lets you do this but a programmer may well fret about the extra storage and wonder where the original simple loop went!
&lt;/p&gt;

&lt;h3&gt;Std::inner_product&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Std::accumulate()&lt;/code&gt; &lt;strong&gt;is&lt;/strong&gt; reduce but sadly C++ doesn&amp;#8217;t do functional programming well enough to really exploit its power. Nonetheless, the algorithm deserves to be better known. As it happens there&amp;#8217;s &lt;a href="http://www.sgi.com/tech/stl/inner_product.html"&gt;an even less well known member&lt;/a&gt; of the standard library which can solve our sum of squares puzzle.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Std::inner_product&lt;/code&gt; is yet another reduction. It zips up two iterator ranges multiplying together elements from the resulting pairs and summing these multiples to produce a final result. You can use it to find the scalar product of two vectors, or to calculate a weighted sum or, indeed, if we feed the range &lt;code&gt;xs.begin()&lt;/code&gt;, &lt;code&gt;xs.end()&lt;/code&gt; to it twice, to sum the squares of elements of &lt;code&gt;xs&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double sum_squares_xs 
    = inner_product(xs.begin(), xs.end(), xs.begin(), 0.0);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This form is undeniably compact. If you know about &lt;code&gt;std::inner_product&lt;/code&gt; it&amp;#8217;s easy to understand. I&amp;#8217;ll &lt;a href="http://ccgi.hashpling.plus.com/blog/new-things-are-always-better/" title="Chris Bailey explores a typical C++ conundrum"&gt;leave you to decide if it&amp;#8217;s better&lt;/a&gt; than a hand-written loop.
&lt;/p&gt;

&lt;h3&gt;Example program&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple program designed to demonstrate the use of accumulate and inner_product.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;// Examples of std::accumulate and std::inner_product
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;valarray&amp;gt;
#include &amp;lt;vector&amp;gt;

typedef std::valarray&amp;lt;double&amp;gt; xyz;

// Xyz output operator
std::ostream &amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp; os, xyz const &amp;amp; pt)
{
    os &amp;lt;&amp;lt; '(';
    char const * sep = "";
    for (size_t i = 0; i != pt.size(); sep = ", ", ++i)
    {
        os &amp;lt;&amp;lt; sep &amp;lt;&amp;lt; pt[i];
    }
    os &amp;lt;&amp;lt; ')';
    return os;
}

// Bitwise or function, for use in reductions
unsigned bit_or(unsigned u, unsigned v)
{
    return u | v;
}

// Create and return a triangle
std::vector&amp;lt;xyz&amp;gt; create_triangle()
{
    std::vector&amp;lt;xyz&amp;gt; pts;
    double const p[9] = {1.,1.,0.,1.,0.,1.,0.,1.,1.};
    pts.push_back(xyz(p + 0, 3));
    pts.push_back(xyz(p + 3, 3));
    pts.push_back(xyz(p + 6, 3));
    return pts;
}

// Set up some test arrays, accumulate them and print the results to stdout.
int main()
{
    int const a[3] = { 1, 2, 3 };
    int const b[3] = { 3, 2, 1 };
    std::string const s[3] = { "http://", "wordaligned", ".org" };
    bool const t[3] = { false, true, false };
    std::vector&amp;lt;xyz&amp;gt; tri = create_triangle();
    unsigned m[3] = { 1&amp;lt;&amp;lt;1, 1&amp;lt;&amp;lt;3, 1&amp;lt;&amp;lt;5 };
    
    std::cout
        &amp;lt;&amp;lt; "sum(a) "
        &amp;lt;&amp;lt; std::accumulate(a, a + 3, 0)
        &amp;lt;&amp;lt; "\nprod(a) "
        &amp;lt;&amp;lt; std::accumulate(a, a + 3, 1, std::multiplies&amp;lt;int&amp;gt;())
        &amp;lt;&amp;lt; "\nsum_sqs(a) "
        &amp;lt;&amp;lt; std::inner_product(a, a + 3, a, 0)
        &amp;lt;&amp;lt; "\ndot(a, b) "
        &amp;lt;&amp;lt; std::inner_product(a, a + 3, b, 0)
        &amp;lt;&amp;lt; "\nconcat(s) "
        &amp;lt;&amp;lt; std::accumulate(s, s + 3, std::string(""))
        &amp;lt;&amp;lt; "\nany(t) " &amp;lt;&amp;lt; std::boolalpha
        &amp;lt;&amp;lt; std::accumulate(t, t + 3, false, std::logical_or&amp;lt;bool&amp;gt;())
        &amp;lt;&amp;lt; "\ncentroid(tri) "
        &amp;lt;&amp;lt; std::accumulate(tri.begin(), tri.end(), xyz(0., 3)) / 3.
        &amp;lt;&amp;lt; "\nbitor(m) " &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; "0x"
        &amp;lt;&amp;lt; std::accumulate(m, m + 3, 0, bit_or)
        &amp;lt;&amp;lt; '\n';
    
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This program outputs:
&lt;/p&gt;
&lt;pre&gt;
sum(a) 6
prod(a) 6
sum_sqs(a) 14
dot(a, b) 10
concat(s) http://wordaligned.org
any(t) true
centroid(tri) (0.666667, 0.666667, 0.666667)
bitor(m) 0x2a
&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/sums-and-sums-of-squares#fn1link"&gt;[1]&lt;/a&gt; In the case of &lt;a href="http://www.johndcook.com/blog/2008/10/20/comparing-two-ways-to-fit-a-line-to-data/"&gt;John D. Cook&amp;#8217;s article&lt;/a&gt;, which draws attention to the nuts and bolts of a calculation, the explicit loop is an ideal formulation.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/sums-and-sums-of-squares#fn2link"&gt;[2]&lt;/a&gt; &amp;#x2621; A note of caution! Although you can add &lt;code&gt;std::string&lt;/code&gt;s together, using &lt;code&gt;std::accumulate&lt;/code&gt; to concatenate a large number of strings may class as &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;premature pessimization&lt;/a&gt; since each addition is likely to involve dynamic memory allocation. I must also point out that &lt;code&gt;std::valarray&lt;/code&gt; has an uncertain footing in the C++ Standard Library. In his excellent C++ standard library reference book &lt;a href="http://www.josuttis.com/libbook/"&gt;Nicolai Josuttis&lt;/a&gt; sticks the boot in:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The valarray classes were not designed very well. In fact, nobody tried to determine whether the final specification worked. This happened because nobody felt &amp;#8220;responsible&amp;#8221; for these classes. The person who introduced valarrays to the C++ standard library left the committee a long time before the standard was finished.
&lt;/p&gt;
&lt;/blockquote&gt;</description>
<dc:date>2008-10-30</dc:date>
<guid>http://wordaligned.org/articles/sums-and-sums-of-squares</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/sums-and-sums-of-squares</link>
<category>Puzzles</category>
</item>

<item>
<title>Stop the clock, squash the bug</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocsoftware-bugs" name="toc0" id="toc0"&gt;Software Bugs&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocleaks-and-races" name="toc1" id="toc1"&gt;Leaks and Races&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc75-correct-vs-50-correct" name="toc2" id="toc2"&gt;75% correct vs 50% correct&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocprobabilistic-algorithms" name="toc3" id="toc3"&gt;Probabilistic algorithms&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocfixing-isfprime" name="toc4" id="toc4"&gt;Fixing is_fprime&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocdefensive-programming" name="toc5" id="toc5"&gt;Defensive programming&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocdefect-halflife" name="toc6" id="toc6"&gt;Defect halflife&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tochow-did-that-code-ever-work" name="toc7" id="toc7"&gt;How did that code ever work?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocconclusions" name="toc8" id="toc8"&gt;Conclusions&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocsource-code" name="toc9" id="toc9"&gt;Source code&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;Which clock is the best?
&lt;/p&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/images/stopped-clock.gif" alt="Stopped clock"/&gt;
   &lt;img src="http://wordaligned.org/images/slow-clock.gif" alt="Slow clock"/&gt;
   &lt;img src="http://wordaligned.org/images/fast-clock.gif" alt="Fast clock"/&gt;
&lt;/p&gt;
&lt;p&gt;We can easily rule the one which has stopped &amp;#8230; 
&lt;/p&gt;
&lt;p&gt;Or can we? In &amp;#8220;The Rectory Umbrella&amp;#8221; Lewis Carroll &lt;a href="http://www.gavagai.de/themen/HHPT02.htm"&gt;argues otherwise&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Which is better, a clock that is right only once a year, or a clock that is right twice every day?
&lt;/p&gt;
&lt;p&gt;&amp;#8220;The latter,&amp;#8221; you reply, &amp;#8220;unquestionably.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;Very good, now attend.
   I have two clocks: one doesn&amp;#8217;t go at all, and the other loses a minute a day: which would you prefer? &amp;#8220;The losing one,&amp;#8221; you answer, &amp;#8220;without a doubt.&amp;#8221; Now observe: the one which loses a minute a day has to lose twelve hours, or seven hundred and twenty minutes before it is right again, consequently it is only right once in two years, whereas the other is evidently right as often as the time it points to comes round, which happens twice a day. 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;span id="continue-reading"/&gt;

&lt;p&gt;It&amp;#8217;s an amusing diversion, but not really that puzzling: &lt;em&gt;of course&lt;/em&gt; the clock which loses time is of more practical use, even if, somewhat paradoxically, the less time it loses the less often it tells the right time. A clock which loses just a second a day only tells the right time every 118 years or so.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc0" name="tocsoftware-bugs" id="tocsoftware-bugs"&gt;Software Bugs&lt;/a&gt;&lt;/h3&gt;
&lt;img style="float:right;" src="http://wordaligned.org/images/buttons/spider.jpg" alt="Bug"/&gt;

&lt;p&gt;I mention these defective clocks because I&amp;#8217;m thinking about bugs in software and how we go about finding and fixing them. 
&lt;/p&gt;
&lt;p&gt;Code which is obviously wrong is easier to spot than code which is almost right, and spotting bugs is the precursor to fixing them. This implies &amp;#8212; building on Carroll&amp;#8217;s terminology &amp;#8212; that we&amp;#8217;re unlikely to ship many stopped clocks but if we&amp;#8217;re not careful we may end up delivering a few which lose time. And, in general, code which is obviously wrong is easier to fix than code which is almost right. A badly-broken function clearly needs a rethink; whereas one which &lt;em&gt;almost&lt;/em&gt; works may simply get tweaked until it &lt;em&gt;appears&lt;/em&gt; to work, often resulting in a more subtle bug.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc1" name="tocleaks-and-races" id="tocleaks-and-races"&gt;Leaks and Races&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;C and C++ provide a good example of what I&amp;#8217;m talking about. Consider a program which misuses memory. An attempt to allocate workspace of 4294967295 bytes fails instantly&lt;a id="fn1link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;; a slow memory leak, like a slow running clock, may cause no perceptible damage for an extended period.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://valgrind.org"&gt;Decent tools&lt;/a&gt; detect memory leaks. Race conditions in multi-threaded code are harder to track and may prove elusive during system testing. More than once I&amp;#8217;ve left a program running under a debugger, being fed random inputs, in the hope some rare and apparently random condition will trigger a break in execution. Give me truly broken code any day!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc2" name="toc75-correct-vs-50-correct" id="toc75-correct-vs-50-correct"&gt;75% correct vs 50% correct&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here are two implementations of a C function to find an integer midway between a pair of ordered, positive integer values, truncating downwards. Before reading on, ask yourself which is better.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;int midpoint1(int low, int high)
{
    return low/2 + high/2;
}

int midpoint2(int low, int high)
{
    return (low + high)/2;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Midpoint1&lt;/code&gt; is a &amp;#8220;stopped clock&amp;#8221;, returning 3 instead of 4 as the mid-point of 3 and 5, for example. It gets the wrong answer 25% of the time &amp;#8212; fatally wrong were it to be used at the heart of, say, a binary search. I think we&amp;#8217;d quickly detect the problem.
&lt;/p&gt;
&lt;p&gt;An obvious fix would be the one shown in &lt;code&gt;midpoint2&lt;/code&gt; which does indeed return 4 as the mid-point of 3 and 5. 
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Midpoint2&lt;/code&gt; turns out to be a losing clock, though. If the sum &lt;code&gt;low + high&lt;/code&gt; overflows then the result is undefined. On my implementation I get a negative value &amp;#8212; a dangerous thing to use as an array index. This is a notorious and very real defect, nicely documented in a &lt;a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html"&gt;note by Joshua Bloch&lt;/a&gt; subtitled &amp;#8220;Nearly all Binary Searches and Mergesorts are broken&amp;#8221;. 
&lt;/p&gt;
&lt;p&gt;Bloch offers more than one fix so I&amp;#8217;ll just note here that:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     this defect simply doesn&amp;#8217;t exist in a high-level language like Python or Haskell, where integers are bounded only by machine resources
 &lt;/li&gt;

 &lt;li&gt;
     I think Bloch is unfair to suggest Jon Bentley&amp;#8217;s analysis in chapter 4 of Programming Pearls is wrong. The pseudo-code in this chapter is written in a C-like language somewhere between C and Python, and in fact one of Bentley&amp;#8217;s exercises is to examine what effect word size has on this analysis.
 &lt;/li&gt;

 &lt;li&gt;
     in a sense, &lt;code&gt;midpoint2&lt;/code&gt; is more broken than &lt;code&gt;midpoint1&lt;/code&gt;: over the range of possible low and high inputs, the sum overflows and triggers the defect 50% of the time.
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc3" name="tocprobabilistic-algorithms" id="tocprobabilistic-algorithms"&gt;Probabilistic algorithms&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Computers are supposed to be predictable and we typically aim for correct programs. There&amp;#8217;s no reason why we shouldn&amp;#8217;t consider aiming for programs which are good enough, though, and indeed many programs which are good enough to be useful are also flawed. Google adverts, for example, analyse the contents of web pages and serve up related links. The algorithm used is secret, clever and quick, but often results in &lt;a href="http://wordaligned.org/articles/mistargeted-ads.html"&gt;semantic blunders&lt;/a&gt; and, on occasion, &lt;a href="http://www.bofh.org.uk/articles/2008/04/15/ads-are-gone"&gt;offensive mistakes&lt;/a&gt;. Few could deny how useful to Google this program has been, though.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a more interesting example of an algorithm which, like a losing clock, is nearly right.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def is_fprime(n):
    """Use Fermat's little theorem to guess if n is prime.
    """
    from random import randrange
    tries = 3
    xs = (randrange(1, n) for _ in range(tries))
    return all((x ** n) % n == x for x in xs)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We won&amp;#8217;t go into the &lt;a href="http://mathworld.wolfram.com/FermatsLittleTheorem.html"&gt;mathematics&lt;/a&gt; here. A quick play with this function looks promising.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; all(is_fprime(n) for n in [2, 3, 5, 7, 11, 13, 17, 19])
True
&amp;gt;&amp;gt;&amp;gt; any(is_fprime(n) for n in [4, 6, 8, 9, 10, 12, 14, 15])
False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In fact, if we give it a real work-out on some large numbers, it does well. I used it to guess which of the numbers between 100000 and 102000 were prime, comparing the answer with the correct result (the code is at the end of this article). It had a better than 99% success rate (in clock terms, it lost around 8 minutes a day) and increasing &lt;code&gt;tries&lt;/code&gt; will boost its performance.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc4" name="tocfixing-isfprime" id="tocfixing-isfprime"&gt;Fixing is_fprime&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The better &lt;code&gt;is_fprime&lt;/code&gt; performs, the less likely we are to spot that it&amp;#8217;s wrong. What&amp;#8217;s worse, though, is that &lt;em&gt;it cannot be fixed&lt;/em&gt; by simple tweaking. However high we set &lt;code&gt;tries&lt;/code&gt; we won&amp;#8217;t have a correct function. We could even take the random probing out of the function and shove every single value of &lt;code&gt;x&lt;/code&gt; in the range 1 to n into the predicate:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def exhaustive_is_fprime(n):
    return all((x ** n) % n == x for x in range(1, n))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Exhaustive_is_fprime&lt;/code&gt; is expensive to run and will (very) occasionally return &lt;code&gt;True&lt;/code&gt; for a composite number&lt;a id="fn2link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;. If you want to know more, &lt;a href="http://www.google.com/search?q=carmichael+numbers"&gt;search for Carmichael numbers&lt;/a&gt;. 
&lt;/p&gt;
&lt;p&gt;The point I&amp;#8217;m making is that code which is almost right can be dangerous. We are tempted to fix it by adjusting the existing implementation, even if, as in this case, a complete overhaul is required. By contrast, we all know what needs doing with code which is plainly wrong.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc5" name="tocdefensive-programming" id="tocdefensive-programming"&gt;Defensive programming&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We&amp;#8217;ve all seen nervous functions which go beyond their stated interface in an attempt to protect themselves from careless users.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;/**
 * Return the maximum value found in the input array.
 * Pre-condition: the input array must not be empty.
 */
int nervy_maximum_value(int const * items, size_t count)
{
    int M = -INT_MAX;
    
    if (items == NULL || count == 0)
    {
        return M;
    }
    for ( ; count-- != 0; ++items)
    {
        if (*items &amp;gt; M)
        {
            M = *items;
        }
    }
    return M;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;What&amp;#8217;s really wanted is both simpler and easier for clients to code against.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;int maximum_value(int const * items, size_t count)
{
    int const * const end = items + count;
    int M = *items++;
    
    for ( ; items != end; ++items)
    {
        if (*items &amp;gt; M)
        {
            M = *items;
        }
    }
    return M;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Did you spot the subtle bug in &lt;code&gt;nervy_maximum_value&lt;/code&gt;? It uses &lt;code&gt;-INT_MAX&lt;/code&gt; instead of &lt;code&gt;INT_MIN&lt;/code&gt; which will cause trouble if clients code against this undocumented behaviour; if &lt;code&gt;nervy_maximum_value&lt;/code&gt; is subsequently fixed, this client code back-fires.
&lt;/p&gt;
&lt;p&gt;Note that I&amp;#8217;m not against the use of assertions to check pre-conditions, and a simple &lt;code&gt;assert(items != NULL &amp;amp;&amp;amp; count != 0)&lt;/code&gt; works well in &lt;code&gt;maximum_value&lt;/code&gt;; it&amp;#8217;s writing code which swallows these failed pre-conditions I consider wrong.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc6" name="tocdefect-halflife" id="tocdefect-halflife"&gt;Defect halflife&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The occurrence of defects in complex software systems can be modelled in the same way as radioactive decay. I haven&amp;#8217;t studied this theory and my physics is rusty&lt;a id="fn3link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn3"&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;, but the basic idea is that the population of bugs in some software is rather like a population of radioactive particles. Any given bug fires (any given particle decays) at random, so we can&amp;#8217;t predict when this event will happen, but it is equally likely to fire at any particular time. This gives each defect an average lifetime: a small lifetime for howling defects, such as dereferencing NULL pointers, and a longer one for more subtle problems, such as accumulated rounding errors. Assuming we fix a bug once it occurs, the population of defects decays exponentially, and we get the classic tailing-off curve.
&lt;/p&gt;
&lt;img src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Exponential+Defect+Decay
&amp;amp;chs=500x200
&amp;amp;chxt=x,y
&amp;amp;chxl=0:||Time|1:||Bugs
&amp;amp;chd=t:95.0,70.3,52.1,38.6,28.6,21.1,15.7,11.6,8.61,6.38
&amp;amp;chco=ff0000
&amp;amp;chm=B,dddddd,0,0,0
&amp;amp;chls=3,1,0" alt="Classic exponential decay curve"/&gt;

&lt;p&gt;&lt;span /&gt;Anyone who has ever tried to release a software product knows how it feels to slide down the slope of this curve. We system test, find bugs, fix them, repeat. At the start it can be exhilarating as bugs with short half-lives fall out and get squashed, but the end game is demoralising as defects get reported which then cannot be reproduced, and we find ourselves clawing out progress. When we eventually draw the line and ship the product we do so suspecting the worst problems are yet to be found. To put it more succinctly&lt;a id="fn4link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn4"&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Ship happens!
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;A combination of techniques can help us escape this depressing picture. The most obvious one would be to avoid it: rather than aim for &amp;#8220;big-bang&amp;#8221; releases every few years, we can move towards continual and incremental delivery. A modular, decoupled architecture helps. So does insistence on unit testing. Rather than shake the system and sweep up the bugs which fall off we should develop a suite of automated tests which actively seek the various paths through the code, and exercise edge cases. Within the code-base, as already mentioned, &lt;span /&gt;defensive programming can cause defects to become entrenched. Instead, we should adopt a more confident style, where code fails hard and fast.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc7" name="tochow-did-that-code-ever-work" id="tochow-did-that-code-ever-work"&gt;How did that code ever work?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Have you ever fixed a defect and wondered how the code ever even appeared to work before your fix? It&amp;#8217;s an important question and one which requires investigation. Perhaps the bug you&amp;#8217;ve fixed is compensated for by defensive programming elsewhere. Or perhaps there are vast routes through the code which have yet to be exercised.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc8" name="tocconclusions" id="tocconclusions"&gt;Conclusions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/images/stopped-clock.gif" alt="Stopped clock"/&gt;
   &lt;img src="http://wordaligned.org/images/slow-clock.gif" alt="Slow clock"/&gt;
   &lt;img src="http://wordaligned.org/images/fast-clock.gif" alt="Fast clock"/&gt;
&lt;/p&gt;
&lt;p&gt;None of these clocks is much good. The first has stopped, the second loses a second every minute, the third gains a second every minute. At least it&amp;#8217;s easy to see the problem with the first: we won&amp;#8217;t be tempted to patch it.
&lt;/p&gt;
&lt;p&gt;We should never expect our code to work first time and we should be suspicious if it appears to do so. Defensive programming seems to mean different things to different people. If I&amp;#8217;ve misused the term here, I&amp;#8217;m sorry. Our best defence is to assume code is broken until we&amp;#8217;ve tested it, to assume it will break in future if our tests are not automated, and to fail hard and fast when we detect errors.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc9" name="tocsource-code" id="tocsource-code"&gt;Source code&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import math
from itertools import islice, count
from random import randrange

def primes(lo, hi):
    '''Return the list of primes in the range [lo, hi).
    
    &amp;gt;&amp;gt;&amp;gt; primes(0, 19)
    [2, 3, 5, 7, 11, 13, 17]
    &amp;gt;&amp;gt;&amp;gt; primes(5, 10)
    [5, 7]
    '''
    sqrt_hi = int(math.sqrt(hi))
    sieve = range(hi)
    zeros = [0] * hi
    sieve[1] = 0
    for i in islice(count(2), sqrt_hi):
        if sieve[i] != 0:
            remove = slice(i * i, hi, i)
            sieve[remove] = zeros[remove]
    return [p for p in sieve[lo:] if p != 0]

def is_fprime(n, tries=3):
    '''Use Fermat little theorem to guess if n is prime.
    '''
    xs = (randrange(1, n) for _ in range(tries))
    return all((x ** n) % n == x for x in xs)

def fprimes(lo, hi, tries=10):
    '''Alternative implementation of primes.
    '''
    return filter(is_fprime, range(lo, hi))

if __name__ == '__main__':
    import doctest
    doctest.testmod()
    lo, hi = 100000, 102000
    primes_set = set(primes(lo, hi))
    fprimes_set = set(fprimes(lo, hi))
    print "Range [%r, %r)" % (lo, hi)
    print "Actual number of primes", len(primes_set)
    print "Number of fprimes", len(fprimes_set)
    print "Primes missed", primes_set - fprimes_set
    print "False fprimes", fprimes_set - primes_set

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Running this program produced output:
&lt;/p&gt;
&lt;pre&gt;
Range [100000, 102000)
Actual number of primes 174
Number of fprimes 175
Primes missed set([])
False fprimes set([101101])
&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn1link"&gt;[1]&lt;/a&gt; In the first version of this article I wrote that an attempt to allocate 4294967295 bytes would cause the program to crash, which isn&amp;#8217;t quite right. &lt;code&gt;Malloc&lt;/code&gt; returns NULL in the event of failure; standard C++ operator new behaviour is to throw a &lt;code&gt;bad_alloc&lt;/code&gt; exception. My thanks to R Samuel Klatchko for the &lt;a href="http://www.haloscan.com/comments/wordaligned/stop_the_clock_squash_the_bug/#16928"&gt;correction&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn2link"&gt;[2]&lt;/a&gt;
   &lt;a href="http://mitpress.mit.edu/sicp"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt; discusses Carmichael numbers in a &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#call_footnote_Temp_80"&gt;footnote&lt;/a&gt;
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Numbers that fool the Fermat test are called &lt;em&gt;Carmichael numbers&lt;/em&gt;, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a &amp;#8220;correct&amp;#8221; algorithm. Considering an algorithm to be inadequate for the first reason but not for the second illustrates the difference between mathematics and engineering.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;a id="fn3" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn3link"&gt;[3]&lt;/a&gt;
   Being lazy and online I thought I&amp;#8217;d search for a nice radioactive decay graphic rather than draw my own. I found a real gem on the &lt;a href="http://www.colorado.edu/physics/2000/isotopes/radioactive_decay3.html"&gt;University of Colarado site&lt;/a&gt;, where Kyla and Bob discuss radioactive decay.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;img src="http://www.colorado.edu/physics/2000/images/kyla-set/kyla3.jpg" alt="Kyla" style="float:left;"/&gt;&lt;/p&gt;&lt;p&gt;Hmmm&amp;#8230;so a lot of decays happen really fast when there are lots of atoms, and then things slow down when there aren&amp;#8217;t so many. The halflife is always the same, but the &lt;i&gt;half&lt;/i&gt; gets smaller and smaller.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://www.colorado.edu/physics/2000/images/bob-set/bob2.jpg" alt="Bob" style="float:left;"/&gt;&lt;/p&gt;&lt;p&gt;That&amp;#8217;s exactly right.  Here&amp;#8217;s another applet that illustrates radioactive decay in action.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="http://www.colorado.edu/physics/2000/isotopes/radioactive_decay3.html"&gt;Visit the site&lt;/a&gt; to play with the applet Bob mentions. You&amp;#8217;ll find more Kyla and Bob pictures there too.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn4" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn4link"&gt;[4]&lt;/a&gt;
   I&amp;#8217;m unable to provide a definitive attribution for the &amp;#8220;Ship happens!&amp;#8221; quotation. I first heard it from &lt;a href="http://erdani.org"&gt;Andrei Alexandrescu&lt;/a&gt; at an &lt;a href="http://accu.org/index.php/conferences"&gt;ACCU conference&lt;/a&gt;, who in turn thinks he got it from Erich Gamma. I haven&amp;#8217;t managed to contact Erich Gamma. Matthew B. Doar &lt;a href="http://www.haloscan.com/comments/wordaligned/stop_the_clock_squash_the_bug/#17002"&gt;reports&lt;/a&gt; using the term back in 2002, and it appears as a &lt;a href="http://www.oreilly.com/catalog/practicalde/toc.html"&gt;section heading&lt;/a&gt; in his book &lt;a href="http://www.oreilly.com/catalog/practicalde"&gt;&amp;#8220;Practical Development Environments&amp;#8221;&lt;/a&gt;.
&lt;/p&gt;</description>
<dc:date>2008-04-16</dc:date>
<guid>http://wordaligned.org/articles/stop-the-clock-squash-the-bug</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/stop-the-clock-squash-the-bug</link>
<category>Puzzles</category>
</item>

<item>
<title>Drawing Chessboards</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocthe-python-imaging-library" name="toc0" id="toc0"&gt;The Python Imaging Library&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocimagemagick" name="toc1" id="toc1"&gt;ImageMagick&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocgoogle-chart-api" name="toc2" id="toc2"&gt;Google Chart API&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocascii-text" name="toc3" id="toc3"&gt;ASCII Text&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocunicode-block-elements" name="toc4" id="toc4"&gt;Unicode Block Elements&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocand-more" name="toc5" id="toc5"&gt;And more&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocwhy" name="toc6" id="toc6"&gt;Why?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocteaser" name="toc7" id="toc7"&gt;Teaser&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocthanks" name="toc8" id="toc8"&gt;Thanks&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;I wanted a picture of a chessboard. Rather than boot up some drawing software and cut and paste black and white squares I decided to write a program to create the picture.
&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;d like to know &lt;strong&gt;why&lt;/strong&gt; anyone would ever create work for themselves in this way, skip to the end of this article, where you&amp;#8217;ll find justification and a more challenging &lt;a href="http://wordaligned.org/articles/drawing-chessboards.html#why"&gt;follow-on problem&lt;/a&gt;. Otherwise, please read on from top to bottom in the usual way.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc0" name="tocthe-python-imaging-library" id="tocthe-python-imaging-library"&gt;The Python Imaging Library&lt;/a&gt;&lt;/h3&gt;
&lt;img style="border-style:double;" src="http://wordaligned.org/images/chessboard-pil.png" alt="Chessboard created by PIL"/&gt;

&lt;p&gt;Fredrik Lundh&amp;#8217;s &lt;a href="http://effbot.org/imagingbook/pil-index.htm"&gt;Python Imaging Library&lt;/a&gt; (commonly known as &lt;a href="http://effbot.org/imagingbook/pil-index.htm"&gt;PIL&lt;/a&gt;) must surely rank as one of the most popular Python libraries which doesn&amp;#8217;t come as standard&lt;sup&gt;&lt;a id="fn1link" href="http://wordaligned.org/articles/drawing-chessboards.html#fn1"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. It&amp;#8217;s a fabulous tool which I&amp;#8217;ve used to create the graphic above (though note that the double border around this graphic and subsequent ones is applied by a CSS style property). Here&amp;#8217;s how.
   &lt;span id="continue-reading"/&gt;
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;PIL chessboard&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def draw_chessboard(n=8, pixel_width=200):
    "Draw an n x n chessboard using PIL."
    import Image, ImageDraw
    from itertools import cycle
    def sq_start(i):
        "Return the x/y start coord of the square at column/row i."
        return i * pixel_width / n
    
    def square(i, j):
        "Return the square corners, suitable for use in PIL drawings" 
        return map(sq_start, [i, j, i + 1, j + 1])
    
    image = Image.new("L", (pixel_width, pixel_width))
    draw_square = ImageDraw.Draw(image).rectangle
    squares = (square(i, j)
               for i_start, j in zip(cycle((0, 1)), range(n))
               for i in range(i_start, n, 2))
    for sq in squares:
        draw_square(sq, fill='white')
    image.save("chessboard-pil.png")

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     We don&amp;#8217;t draw any black squares, instead relying on the default image background being black.
 &lt;/li&gt;

 &lt;li&gt;
     The &amp;#8220;L&amp;#8221; image type (Luminance?) specifies a greyscale image.
 &lt;/li&gt;

 &lt;li&gt;
     PIL adopts the usual raster graphics convention, of the origin being in the top-left corner.
 &lt;/li&gt;

 &lt;li&gt;
     As we progress &lt;strong&gt;down&lt;/strong&gt; the board row by row, the first white square alternates between being the first and second square of each row. &lt;code&gt;Itertools.cycle((0, 1))&lt;/code&gt; achieves this nicely. 
 &lt;/li&gt;

 &lt;li&gt;
     A regular 8 x 8 chessboard will, then, have a black square at the bottom left, which is the usual convention. For odd values of n the bottom-left square would be white.
 &lt;/li&gt;

 &lt;li&gt;
     There may be rounding problems with this code if the supplied pixel width isn&amp;#8217;t an integral multiple of &lt;code&gt;n&lt;/code&gt;. It&amp;#8217;s probably better to guarantee the image size, rather than round down the board size.
 &lt;/li&gt;

 &lt;li&gt;
     It would be better to parametrise the output file name, or even return the created image to clients. For now, we&amp;#8217;ll just save to a fixed-name PNG.
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc1" name="tocimagemagick" id="tocimagemagick"&gt;ImageMagick&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;PIL is a general purpose image processing library and it takes a little head-scratching and maths before we can even create something as simple as a chessboard. &lt;a href="http://www.imagemagick.org/script/index.php"&gt;ImageMagick&lt;/a&gt; provides tools to perform a similar job from the command-line, making the chessboard a one-liner.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;ImageMagick chessboard&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ N=8
$ PIXEL_WIDTH=200
$ convert -size $((N*15))x$((N*15)) pattern:checkerboard \
  -monochrome -resize $PIXEL_WIDTH chessboard-magick.png

&lt;/pre&gt;

&lt;/div&gt;

&lt;img style="border-style:double;float:right;margin-left:4px;" src="http://wordaligned.org/images/chessboard-magick.png" alt="Chessboard created by ImageMagick"/&gt;

&lt;p&gt;Here, the checkerboard pattern is an ImageMagick built-in which, inspecting its output, happens to generate 15x15 squares (hence the 15&amp;#8217;s in the script above). The &lt;code&gt;-monochrome&lt;/code&gt; filter renders the pattern in black and white, rather than its native light- on dark-grey. The &lt;code&gt;-size&lt;/code&gt; and &lt;code&gt;-resize&lt;/code&gt; parameters should need no further explanation. The ((double parentheses)) perform Bash shell arithmetic.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.imagemagick.org/script/index.php"&gt;ImageMagick&lt;/a&gt; masquerades as a shell tool but really it&amp;#8217;s a powerful and fully featured programmer&amp;#8217;s imaging tool &amp;#8212; a bit like a command-line version of &lt;a href="http://www.gimp.org"&gt;Gimp&lt;/a&gt;&lt;a id="fn2link" href="http://wordaligned.org/articles/drawing-chessboards#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;. Although well documented, my gut reaction is that it pushes the command-line interface too far. For more advanced image mangling, you&amp;#8217;ll probably need a program to generate the one-liner needed to drive &lt;code&gt;convert&lt;/code&gt;. Despite this reservation, it does the simple things simply, and it can do complex things too. Recommended!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc2" name="tocgoogle-chart-api" id="tocgoogle-chart-api"&gt;Google Chart API&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For a bit of fun, we can persuade Google to render the chessboard for us &amp;#8212; in this case as a scatter plot using a square black markers&lt;a id="fn3link" href="http://wordaligned.org/articles/drawing-chessboards#fn3"&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;. We flip the PIL processing around, drawing black squares on the (default) white background, and using the usual plotting convention which places the origin at the bottom left.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Google chart chessboard&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def chessboard_url(n=8, pixel_width=200):
    "Returns the URL of a chessboard graphic."
    def sq_midpt(i):
        "Return the x/y midpt of a square in column/row i."
        # For text encoding, the graphic's logical width is 100
        return (0.5 + i) * 100. / n
    
    xys = [(sq_midpt(i), sq_midpt(j))
           for i_start, j in zip(cycle((0, 1)), range(n))
           for i in range(i_start, n, 2)]
    fields = dict(width=pixel_width, sqside=pixel_width/n,
                  xs=",".join("%.02f" % x for x, _ in xys),
                  ys=",".join("%.02f" % y for _, y in xys))
    return (
        "http://chart.apis.google.com/chart?"
        "cht=s&amp;amp;"                        # Draw a scatter graph
        "chd=t:%(xs)s|%(ys)s&amp;amp;"          # using text encoding and
        "chm=s,000000,1,2.0,%(sqside)r&amp;amp;"# square black markers
        "chs=%(width)rx%(width)r"       # at this size.
        ) % fields

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that we plot our chart on a logical 100 x 100 rectangle, the coordinate space mandated by the encoding we&amp;#8217;ve chosen, then resize it to the physical dimensions supplied by the client.
&lt;/p&gt;
&lt;p&gt;This function actually returns the URL of a PNG which the &lt;a href="http://code.google.com/apis/chart/"&gt;Google chart API&lt;/a&gt; serves up. Paste this URL into your browser address bar to see the graphic, or curl it to a local file.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://chart.apis.google.com/chart?cht=s&amp;amp;chd=t:6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75|6.25,6.25,6.25,6.25,18.75,18.75,18.75,18.75,31.25,31.25,31.25,31.25,43.75,43.75,43.75,43.75,56.25,56.25,56.25,56.25,68.75,68.75,68.75,68.75,81.25,81.25,81.25,81.25,93.75,93.75,93.75,93.75&amp;amp;chm=s,000000,1,2.0,25.0&amp;amp;chs=200x200"&gt;http://chart.apis.google.com/chart?cht=s&amp;amp;chd=t:6.25,31.25&amp;#8230;&amp;amp;chs=200x200&lt;/a&gt;
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ url=`python chessboard_url.py`
$ curl $url &amp;gt; chessboard.png

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We could embed the image into HTML using the IMG element, which is how I&amp;#8217;ve embedded the image which you should see below.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from cgi import escape
&amp;gt;&amp;gt;&amp;gt; img = '&amp;lt;img src="%s" alt="chessboard graphic"/&amp;gt;'
&amp;gt;&amp;gt;&amp;gt; img % escape(chessboard_url())

&lt;/pre&gt;

&lt;/div&gt;

&lt;img src="http://chart.apis.google.com/chart?cht=s&amp;amp;chd=t:6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75|6.25,6.25,6.25,6.25,18.75,18.75,18.75,18.75,31.25,31.25,31.25,31.25,43.75,43.75,43.75,43.75,56.25,56.25,56.25,56.25,68.75,68.75,68.75,68.75,81.25,81.25,81.25,81.25,93.75,93.75,93.75,93.75&amp;amp;chm=s,000000,1,2.0,25.0&amp;amp;chs=200x200" alt="Chessboard chart" style="float:right;border-style:double;margin-left:4px;"/&gt;

&lt;p&gt;As you can see, we have plenty of options, but unfortunately the image itself isn&amp;#8217;t suitable. You can&amp;#8217;t get rid of the axes &amp;#8212; or at least, I haven&amp;#8217;t found a way to &amp;#8212; and the rendered chart has some padding to the top and the right. And worse, we&amp;#8217;re pretty much at the end of the line for this hack: if we wanted to do something more interesting, such as place pieces on the board, we&amp;#8217;re out of luck. 
&lt;/p&gt;
&lt;p&gt;Of course this isn&amp;#8217;t a flaw in the &lt;a href="http://code.google.com/apis/chart/"&gt;Google Chart API&lt;/a&gt;: we&amp;#8217;ve actually asked it to draw a scatter plot of the centres of black squares on a chessboard, using square black markers, a job it&amp;#8217;s done well enough. Some examples showing the proper use of Google charts can be found in an &lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html"&gt;article I wrote about maximum sum subsequences&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc3" name="tocascii-text" id="tocascii-text"&gt;ASCII Text&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The chart URL might be considered a text encoding of the image; the actual graphic is returned by a server. There are other, more direct, textual representations.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;ASCII art chessboard&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def outer_join(sep, ss):
    """Like string.join, but encloses the result with outer separators.
    
    Example:
    &amp;gt;&amp;gt;&amp;gt; outer_join('|', ['1', '2', '3'])
    '|1|2|3|'
    """
    return "%s%s%s" % (sep, sep.join(ss), sep)
    
def ascii_chessboard(n=8):
    """Draws an ASCII art chessboard.
    
    Returns a string representation of an n x n board.
    """
    from itertools import islice, cycle
    divider = outer_join("+", "-" * n) + "\n"
    row0 = outer_join("|", islice(cycle(" B"), n)) + "\n"
    row1 = outer_join("|", islice(cycle("B "), n)) + "\n"
    return outer_join(divider, islice(cycle([row0, row1]), n))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I suspect this code was easier for me to write than it is for you to read! It treats the chessboard as a sequence of alternating rows of alternating squares, which are then joined together for output.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; print ascii_chessboard(8)
+-+-+-+-+-+-+-+-+
| |B| |B| |B| |B|
+-+-+-+-+-+-+-+-+
|B| |B| |B| |B| |
+-+-+-+-+-+-+-+-+
| |B| |B| |B| |B|
+-+-+-+-+-+-+-+-+
|B| |B| |B| |B| |
+-+-+-+-+-+-+-+-+
| |B| |B| |B| |B|
+-+-+-+-+-+-+-+-+
|B| |B| |B| |B| |
+-+-+-+-+-+-+-+-+
| |B| |B| |B| |B|
+-+-+-+-+-+-+-+-+
|B| |B| |B| |B| |
+-+-+-+-+-+-+-+-+

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Not pretty, but such graphics may be useful in source code, which is typically viewed in a plain-text editor, and where ASCII art provides a way of embedding pictures right where they&amp;#8217;re needed. 
&lt;/p&gt;
&lt;p&gt;On which point: if you&amp;#8217;re working through &amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221; you may like to know the book is &lt;a href="http://www.neilvandyke.org/sicp-texi/"&gt;available in Texinfo format&lt;/a&gt;, with the pictures all rendered in ASCII art. So you can split your editor window and run the code on one side, while browsing the book on the other. Here&amp;#8217;s one of the figures:
&lt;/p&gt;
&lt;pre&gt;
*Figure 4.6:* The `or' combination of two queries is produced by
operating on the stream of frames in parallel and merging the
results.
    
            +---------------------------+
            |          (or A B)         |
            |    +---+                  |
 input      | +-&amp;gt;| A |------------+     |  output
 stream of  | |  +---+            V     |  stream of
 frames     | |    ^          +-------+ |  frames
 -------------*    |          | merge +---------------&amp;gt;
            | |    |          +-------+ |
            | |    |              ^     |
            | |    |   +---+      |     |
            | +-------&amp;gt;| B +------+     |
            |      |   +---+            |
            |      |     ^              |
            |      |     |              |
            |      +--*--+              |
            +---------|-----------------+
                      |
                  data base
&lt;/pre&gt;

&lt;p&gt;Even though I own a copy of the book and the &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;full text is available on-line&lt;/a&gt;, this primitive info version has become my preferred format when actually running the code examples and exercises.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc4" name="tocunicode-block-elements" id="tocunicode-block-elements"&gt;Unicode Block Elements&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Most programming languages may be &lt;a href="http://wordaligned.org/articles/a-yen-for-more-symbols.html"&gt;stuck in ASCII&lt;/a&gt;, but we needn&amp;#8217;t restict ourselves in this way. I found some block elements in the &lt;a href="http://www.unicode.org/charts/symbols.html"&gt;Geometrical Symbols&lt;/a&gt; section of the Unicode code charts (&lt;a href="http://www.unicode.org/charts/PDF/U2580.pdf"&gt;Unicode Block Elements (PDF)&lt;/a&gt;). Here&amp;#8217;s a pre-rendered block of text composed of the light and dark shade block characters, U+2591 LIGHT SHADE and U+2593 DARK SHADE.
&lt;/p&gt;
&lt;pre&gt;
&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;
&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;
&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;
&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;
&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;
&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;
&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;
&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc5" name="tocand-more" id="tocand-more"&gt;And more&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I can think of plenty of other ways to draw a chessboard. My favourite &lt;a href="http://wordaligned.org/articles/drawing-software-design.htmls"&gt;drawing&lt;/a&gt; environments are the &lt;a href="http://blogoscoped.com/archive/2008-02-11-n78.html"&gt;pencil and paper&lt;/a&gt;, and the pen and whiteboard; combine the former with a scanner and the latter with a digital camera and you&amp;#8217;ve got an easy route to an electronic version of your design.
&lt;/p&gt;
&lt;p&gt;For an HTML document I suspect &lt;a href="http://www.w3.org/Graphics/SVG/"&gt;SVG&lt;/a&gt; would be a good choice, but I don&amp;#8217;t know enough about SVG to state this with confidence. I bet you could go a long way with &lt;a href="http://www.w3.org/Style/CSS/"&gt;CSS&lt;/a&gt; too. &lt;a href="http://en.wikipedia.org/wiki/Chessboard"&gt;Wikipedia&amp;#8217;s chess board&lt;/a&gt; is a table built on top of two small images, a light and a dark square, which I guess saves on bandwidth.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc6" name="tocwhy" id="tocwhy"&gt;Why?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Why ever bother programming when all we want is a simple graphic?
&lt;/p&gt;
&lt;p&gt;Well, for one thing, there&amp;#8217;s not &lt;strong&gt;that&lt;/strong&gt; much programming. The actual work of pushing pixels around is done by &lt;a href="http://code.google.com/apis/chart/"&gt;Google&lt;/a&gt;, or &lt;a href="http://effbot.org/imagingbook/pil-index.htm"&gt;PIL&lt;/a&gt;, or &lt;a href="http://www.imagemagick.org/script/index.php"&gt;ImageMagick&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Once we&amp;#8217;ve got a program written, it should be easy to adapt it. We&amp;#8217;ve already put in hooks to specify the number of squares and the image dimensions. It&amp;#8217;s equally easy to, for example, write out a JPEG rather than a PNG, or use different colours.
&lt;/p&gt;
&lt;p&gt;A programmatic solution is dynamic. Google&amp;#8217;s chart API generates pictures on the fly, based on data points, ranges etc. which clients choose as and when. It&amp;#8217;s rather  like lazy-evaluation: pre-rendering all possibilities isn&amp;#8217;t just expensive, it&amp;#8217;s out of the question.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc7" name="tocteaser" id="tocteaser"&gt;Teaser&lt;/a&gt;&lt;/h3&gt;
&lt;img src="http://tbn0.google.com/images?q=tbn:AmRSkxMo-1W5iM:http://web.usna.navy.mil/~wdj/images_chess/chess011.gif" alt="Lurid chessboard" style="float:right;margin-left:4px;"/&gt;

&lt;p&gt;That&amp;#8217;s quite enough pixels and characters for now, so this article will have to appear in two parts. If I&amp;#8217;ve still not convinced you of the merits of creating images programmatically, please consider the following puzzle.
&lt;/p&gt;
&lt;p&gt;&lt;span /&gt;How would you draw a position reached in a game of chess, showing both the board and the pieces?
&lt;/p&gt;
&lt;p&gt;And if I &lt;strong&gt;have&lt;/strong&gt; convinced you, this exercise makes for a good workout.
&lt;/p&gt;
&lt;p&gt;Some Q&amp;amp;A&amp;#8217;s.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     &lt;strong&gt;Q&lt;/strong&gt;: What position, exactly?
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;A&lt;/strong&gt;: Any!
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;Q&lt;/strong&gt;: How will the position be described?
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;A&lt;/strong&gt;: Your choice &amp;#8212; it&amp;#8217;s an interesting part of the puzzle.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A great starting point would be to solve the puzzle using an ASCII art representation.
&lt;/p&gt;
&lt;p&gt;You can find my solution in &lt;a href="http://wordaligned.org/articles/drawing-chess-positions.html"&gt;this follow-up article&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc8" name="tocthanks" id="tocthanks"&gt;Thanks&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Thanks to &lt;a href="http://gedmin.as"&gt;Marius Gedminas&lt;/a&gt; and Johannes Hoff for their help bug-fixing this article.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/drawing-chessboards#fn1link"&gt;[1]&lt;/a&gt;
   I&amp;#8217;m confused about where exactly PIL belongs; the official homepage seems to be on the PythonWare website (&lt;a href="http://www.pythonware.com/library/pil/handbook/"&gt;http://www.pythonware.com/library/pil/handbook/&lt;/a&gt;), but I usually head for the Effbot site, &lt;a href="http://effbot.org/imagingbook/"&gt;http://effbot.org/imagingbook/&lt;/a&gt;. I think the sites mirror the same information, so it boils down to whether you prefer a blue or green theme, and how off-putting you find all the ads-by-google.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/drawing-chessboards#fn2link"&gt;[2]&lt;/a&gt;
   Actually, you can use &lt;a href="http://www.gimp.org/tutorials/Basic_Batch/"&gt;Gimp from the command-line&lt;/a&gt;, and it comes with some tools for creating and editing batch files, and indeed for creating a personal suite of image processing scripts. I&amp;#8217;ve never used &lt;a href="http://www.gimp.org"&gt;Gimp&lt;/a&gt; in this way, so I can&amp;#8217;t say much more about this.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn3" href="http://wordaligned.org/articles/drawing-chessboards#fn3link"&gt;[3]&lt;/a&gt;
   In theory you could use the Google Chart API to render any image in a pointillist manner: just plot enough pixels in the right places.
&lt;/p&gt;</description>
<dc:date>2008-03-18</dc:date>
<guid>http://wordaligned.org/articles/drawing-chessboards</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/drawing-chessboards</link>
<category>Puzzles</category>
</item>

<item>
<title>Sugar Pie</title>
<description>&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; in the code snippet bleow, what does the result stream, &lt;code&gt;rs&lt;/code&gt;, approximate?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import count, ifilter, izip
from random import random as xy
from math import hypot
    
pt = lambda: (xy(), xy())
on = ifilter(lambda n: hypot(*pt()) &amp;lt; 1., count(1))
rs = (4. * j / i for i, j in izip(on, count(1)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The code isn&amp;#8217;t wilfully obscure but I&amp;#8217;ll admit it&amp;#8217;s unusual. Although written in a functional style, the source of the stream, &lt;code&gt;pt&lt;/code&gt;, is utterly impure, generating a sequence of random results: it sprinkles points in a unit square. Despite this random input the results stream always tends to the same value. Well, in theory it should!
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a picture of a round pie on a square baking tray being dusted with sugar.    &lt;br /&gt;
&lt;/p&gt;
&lt;img alt="Dusting a pie" src="http://wordaligned.org/images/sugar-pie.gif"/&gt;

&lt;p&gt;Thanks again to &lt;a href="http://gedmin.as"&gt;Marius Gedminas&lt;/a&gt; for pointing me at
   &lt;code&gt;math.hypot&lt;/code&gt;, the best way to find the length of a 2D vector. (The
   previous version of this note used &lt;code&gt;abs(complex(*pt())&lt;/code&gt;, which it
   claimed to be better than &lt;code&gt;math.sqrt(x * x + y * y)&lt;/code&gt;).
&lt;/p&gt;</description>
<dc:date>2008-03-06</dc:date>
<guid>http://wordaligned.org/articles/sugar-pie</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/sugar-pie</link>
<category>Puzzles</category>
</item>

<item>
<title>Animated pair streams</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocname-that-series" name="toc0" id="toc0"&gt;Name that Series&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocbounded-pairs" name="toc1" id="toc1"&gt;Bounded Pairs&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocstreams-of-pairs" name="toc2" id="toc2"&gt;Streams of Pairs&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toca-recursive-scheme" name="toc3" id="toc3"&gt;A Recursive Scheme&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocinterleaving" name="toc4" id="toc4"&gt;Interleaving&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocdouble-trouble" name="toc5" id="toc5"&gt;Double Trouble&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocmemory-use" name="toc6" id="toc6"&gt;Memory Use&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#tocproblem-solved" name="toc7" id="toc7"&gt;Problem Solved?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toctying-up" name="toc8" id="toc8"&gt;Tying up&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toccredits" name="toc9" id="toc9"&gt;Credits&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc0" name="tocname-that-series" id="tocname-that-series"&gt;Name that Series&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;What&amp;#8217;s going on in the animation below?
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-stream.gif" alt="Pair stream slideshow"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc1" name="tocbounded-pairs" id="tocbounded-pairs"&gt;Bounded Pairs&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While you&amp;#8217;re waiting for the graphic to load, recall a problem we encountered while hunting for &lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html#programming-pearl"&gt;maximum subsequences&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Given a number n, generate all the pairs (i, j) such that i and j are in the range 0 to n and j is greater than i.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;A Python solution reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def generate_pairs(n):
    "Generate all pairs (i, j) such that 0 &amp;lt;= i &amp;lt;= j &amp;lt; n"
    for i in range(n):
        for j in range(i, n):
            yield i, j

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can extend this to solve a more general version of the problem:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Given two sequences (S, T), generate all pairs (S&lt;sub&gt;i&lt;/sub&gt;, T&lt;sub&gt;j&lt;/sub&gt;) such that j is greater than i.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def generate_pairs(s, t):
    "Generate all pairs s[i], t[j]  such that 0 &amp;lt;= i &amp;lt;= j"
    s_count = len(s)
    t_count = len(t)
    for i in xrange(s_count):
        for j in xrange(i, t_count):
            yield s[i], t[j]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;This function requires complete and bounded collections as inputs since it asks for their lengths and accesses elements by index &amp;#8212; think &amp;#8220;lists&amp;#8221; or &amp;#8220;tuples&amp;#8221;. Yet it generates results lazily, giving clients control over just how many pairs they require. This is why I&amp;#8217;ve chosen &lt;code&gt;xrange&lt;/code&gt; in preference to &lt;code&gt;range&lt;/code&gt;, since it too generates numbers, rather than returning a complete list. (Python 3000 simplifies things: &lt;code&gt;range&lt;/code&gt; becomes &lt;code&gt;xrange&lt;/code&gt; and &lt;code&gt;xrange&lt;/code&gt; disappears.)
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;There&amp;#8217;s no need for extra logic to handle &lt;code&gt;S&lt;/code&gt; being shorter than &lt;code&gt;T&lt;/code&gt; or vice-versa: &lt;code&gt;xrange(start, stop)&lt;/code&gt; is smart enough to handle the case when &lt;code&gt;stop&lt;/code&gt; is less than &lt;code&gt;start&lt;/code&gt;. I&amp;#8217;d say adding such extra logic would count as premature optimisation.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&amp;#8217;s an example of this function in action. We run the generator to exhaustion collecting its output in a list.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; pairs = list(generate_pairs('ABC', (1, 2, 3, 4)))
&amp;gt;&amp;gt;&amp;gt; print pairs
[('A', 1), ('A', 2), ('A', 3), ('A', 4), ('B', 2), ('B', 3), ('B', 4), ('C', 3), ('C', 4)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A second example builds a &lt;a href="http://docs.python.org/ref/genexpr.html"&gt;generator expression&lt;/a&gt; from &lt;code&gt;generate_pairs()&lt;/code&gt;. We plug this expression into the built in &lt;code&gt;any&lt;/code&gt; function to determine whether the pair &lt;code&gt;('A', 2)&lt;/code&gt; is in the pair sequence. Note that &lt;code&gt;any&lt;/code&gt; only pulls two elements from the sequence to produce an answer.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; any((p == 'A', 2) for p in generate_pairs('ABC', (1, 2, 3, 4)))
True

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So far, so what? For the toy examples shown, lazy evaluation isn&amp;#8217;t an important consideration. But what if our input sequences were very large? What if they were infinite?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc2" name="tocstreams-of-pairs" id="tocstreams-of-pairs"&gt;Streams of Pairs&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Generate_pairs()&lt;/code&gt; yields results row by row. Here&amp;#8217;s a slideshow for the case when &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; have 5 and 20 elements respectively. Brightness indicates age, so the white circle represents the current head of the generated sequence, and the greying circles represent previous elements &amp;#8212; the older the greyer. Remember, it&amp;#8217;s up to clients just how many grey pairs to hold: the generator only ever yields a shiny white new pair.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-list.gif" alt="Pair list slideshow"/&gt;

&lt;p&gt;A text representation would be as follows, where, as usual, we read top to bottom, left to right.
&lt;/p&gt;
&lt;pre&gt;
S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;0&lt;/sub&gt;, S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;2&lt;/sub&gt; ...                             S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;20&lt;/sub&gt;
      S&lt;sub&gt;1&lt;/sub&gt;T&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;1&lt;/sub&gt;T&lt;sub&gt;2&lt;/sub&gt;, ...                            S&lt;sub&gt;1&lt;/sub&gt;T&lt;sub&gt;20&lt;/sub&gt;
            S&lt;sub&gt;2&lt;/sub&gt;T&lt;sub&gt;2&lt;/sub&gt;, ...                           S&lt;sub&gt;2&lt;/sub&gt;T&lt;sub&gt;20&lt;/sub&gt;
                  ...
&lt;/pre&gt;

&lt;p&gt;It&amp;#8217;s clear this mode of traversal isn&amp;#8217;t suitable for generating pairs from very large inputs: we don&amp;#8217;t advance through S quickly enough. In fact, if T were infinite, we&amp;#8217;d be stuck on the top row, forever generating pairs of the form &lt;code&gt;S&lt;sub&gt;0&lt;/sub&gt;T&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc3" name="toca-recursive-scheme" id="toca-recursive-scheme"&gt;A Recursive Scheme&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt; describes an elegant recursive scheme for &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_Temp_476"&gt;generating pairs&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Call the general stream of pairs (pairs S T), and consider it to be composed of three parts: the pair (S&lt;sub&gt;0&lt;/sub&gt;,T&lt;sub&gt;0&lt;/sub&gt;), the rest of the pairs in the first row, and the remaining pairs:&lt;br/&gt;&lt;br/&gt;
   &lt;img src="http://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-47.gif" alt="Stream of pairs structure"/&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Based on this insight, we can generate our stream of pairs:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     yielding the pair, (S&lt;sub&gt;0&lt;/sub&gt;,T&lt;sub&gt;0&lt;/sub&gt;)
 &lt;/li&gt;

 &lt;li&gt;
     yield pairs from the first row combined with the stream of remaining pairs
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note the recursion: the definition of the pairs stream refers to itself. That&amp;#8217;s not a problem so long as we&amp;#8217;re lazy about evaluating the tail of the stream. Since we always know how to pull the first pair from the stream, we can both bootstrap the process and keep going forever.
&lt;/p&gt;
&lt;p&gt;All we now need is a suitable method of combining two the first row and the remaining pairs.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc4" name="tocinterleaving" id="tocinterleaving"&gt;Interleaving&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The simplest way to combine the two streams is just to interleave them, pulling elements from each in turn. A simple (too simple!) implementation of &lt;code&gt;interleave()&lt;/code&gt; reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Simple interleave&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def interleave(s, t):
    while True:
        yield s.next()
        yield t.next()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(The problem here is that &lt;code&gt;interleave()&lt;/code&gt; stops as soon as either of the the input streams is exhausted, which isn&amp;#8217;t an issue for infinite streams, but isn&amp;#8217;t ideal in the case when either of the inputs are bounded. You get the idea. I&amp;#8217;ll provide better implementation &lt;a href="http://wordaligned.org/articles/animated-pair-streams#tying-up"&gt;later&lt;/a&gt;.)
&lt;/p&gt;
&lt;p&gt;We can now code our pairs generator:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Pairs generator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;import itertools

def pairs(s, t):
    """ Generate a stream of pairs taken from s, t.
    
    Yields a stream of pairs (si, tj) where i &amp;lt;= j.
    The input streams may be finite or bounded, but must be iterable.
    """
    first = s.next(), t.next()
    yield first
    t, t_top = itertools.tee(t)
    s0 = first[0]
    top_row = ((s0, tt) for tt in t_top)
    for st in interleave(top_row, pairs(s, t)):
        yield st

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a slideshow of this algorithm in action.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-stream.gif" alt="Pair stream slideshow"/&gt;

&lt;p&gt;Even though Python (CPython, to be specific) and recursion don&amp;#8217;t generally get along well (unlike in a proper functional programming language), this implementation doesn&amp;#8217;t &lt;em&gt;appear&lt;/em&gt; to fall foul of CPython&amp;#8217;s maximum recursion limits &lt;strong&gt;even though pairs() repeatedly calls itself&lt;/strong&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;No maximum recursion depth exceeded error here!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; integers = itertools.count
&amp;gt;&amp;gt;&amp;gt; for ij in pairs(integers, integers):
... 	print ij
... 
(0, 0)
(0, 1)
(1, 1)
(0, 2)
(1, 2)
(0, 3)
(2, 2)
....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;When I dug a little deeper, I started to understand why: the function can&amp;#8217;t run indefinitely since it eats up memory. It continually tees up iterators over &lt;code&gt;t&lt;/code&gt; and creates new generator expressions.
&lt;/p&gt;
&lt;p&gt;That said, I was surprised just how quickly it consumes memory. After all, generator expressions and iterators shouldn&amp;#8217;t take up much space. For the purposes of comparison, I compared how it fared against a Scheme program designed to do the same thing. Both had consumed a gigabyte of memory after running just a few minutes (and, for what it&amp;#8217;s worth, the Python program had generated an order of magnitude more pairs by this point).
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Scheme pair generator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;(require (lib "40.ss" "srfi")) ;; Scheme stream support

(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (stream-cons (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define (pairs s t)
  (stream-cons
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))

(define ones (stream-cons 1 ones))

(define (stream-add s t) (stream-map + s t))

(define integers
  (stream-cons 0 (stream-add ones integers)))

(stream-for-each
  (lambda (x) (newline) (display x))
  (pairs integers integers))

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc5" name="tocdouble-trouble" id="tocdouble-trouble"&gt;Double Trouble&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s look a little further into the stream. Here&amp;#8217;s the genesis of the first 120 pairs.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/files/animated-pair-stream-120.gif" alt="Pair stream slideshow"/&gt;

&lt;p&gt;Now the pattern becomes clear. Evidently the interleave strategy gives a heavy bias towards advancing rightwards; downwards motion is relatively slow.
&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s filter out the &lt;code&gt;i == j&lt;/code&gt; diagonal to try and quantify this.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; ints = itertools.count
&amp;gt;&amp;gt;&amp;gt; izip = itertools.izip
&amp;gt;&amp;gt;&amp;gt; pp = pairs(ints(), ints())
&amp;gt;&amp;gt;&amp;gt; diagonal = ((ix, (i, j))
...             for ix, (i, j) in izip(ints(1), pp) if i == j))
&amp;gt;&amp;gt;&amp;gt; for d in itertools.islice(diagonal, 10):
...     print d
...
(1, (0, 0))
(3, (1, 1))
(7, (2, 2))
(15, (3, 3))
(31, (4, 4))
(63, (5, 5))
(127, (6, 6))
(255, (7, 7))
(511, (8, 8))
(1023, (9, 9))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The output shows that pair (0, 0) is the 1&lt;sup&gt;st&lt;/sup&gt; element of the stream, (1, 1) the 3&lt;sup&gt;rd&lt;/sup&gt;, (2, 2) the 7&lt;sup&gt;th&lt;/sup&gt;, and so on.
&lt;/p&gt;
&lt;p&gt;Any computer scientist ought to quickly spot the pattern, and any mathematician ought to be able to prove why diagonal advances are exponentially infrequent.
&lt;/p&gt;
&lt;p&gt;Loosely speaking, if D&lt;sub&gt;i&lt;/sub&gt; is the stream of positions in the pairs stream of elements which lie on the diagonal (i.e. the stream 1, 3, 7, 15, &amp;#8230; shown in the interpreted Python session), then the elements of D must satisfy the recurrence relation:
&lt;/p&gt;
&lt;pre&gt;
D&lt;sub&gt;i+1&lt;/sub&gt; = 1 + 2&amp;times;D&lt;sub&gt;i&lt;/sub&gt;
&lt;/pre&gt;

&lt;p&gt;This relation derives directly from the recursive definition of &lt;code&gt;pairs()&lt;/code&gt;: yield a single element, then alternate the rest of yourself with the generated top row.
&lt;/p&gt;
&lt;p&gt;Here are some slides showing the points at which the first 5 diagonal elements appear. Watch the recursive pattern emerge.
&lt;/p&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/files/pairs-1.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-3.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-7.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-15.png" alt="diagonal pairs image"/&gt;
   &lt;img src="http://wordaligned.org/files/pairs-31.png" alt="diagonal pairs image"/&gt;
&lt;/p&gt;
&lt;p&gt;The solution to the recurrence relation is &lt;code&gt;D&lt;sub&gt;i&lt;/sub&gt; = 2&lt;sup&gt;i&lt;/sup&gt; &amp;minus; 1&lt;/code&gt;. These diagonal advances correspond to recursive calls to &lt;code&gt;pairs()&lt;/code&gt;. So if our Python session has a recursion limit set to 1000 (try &lt;code&gt;sys.getrecursionlimit()&lt;/code&gt;), and our pairs generator were to yield a result every nanosecond, and we had a machine with infinite memory, it would take quite a few millenia before we run into this limit.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;How many millenia until we hit the recursion limit?&lt;/div&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; (2 ** 1000 - 1)/(1.e9 * 60 * 60 * 24 * 365 * 1000) 
3.3977315042689856e+281

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc6" name="tocmemory-use" id="tocmemory-use"&gt;Memory Use&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It should also now be clear why this particular algorithm burns memory. Teeing an iterator doesn&amp;#8217;t magically mean we don&amp;#8217;t have to store any elements we&amp;#8217;ve iterated past. The greater the distance between the teed iterators, the more that need storing.
&lt;/p&gt;
&lt;p&gt;If that&amp;#8217;s not clear, run the following Python session and keep an eye on memory consumption (and be ready to interrupt the infinite loop!). You&amp;#8217;ll see memory use rapidly increase as &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; diverge, since &lt;code&gt;j&lt;/code&gt; needs to remember everything &lt;code&gt;i&lt;/code&gt; produces.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import *
&amp;gt;&amp;gt;&amp;gt; i, j = tee(repeat(0))
&amp;gt;&amp;gt;&amp;gt; for x in i: pass

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;By contrast, if we zip through &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; in parallel, memory use is stable.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; i, j = tee(repeat(0))
&amp;gt;&amp;gt;&amp;gt; for ij in izip(i, j): pass

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Our pair generator has to remember more and more elements from the &lt;code&gt;T&lt;/code&gt; stream (and also, to a lesser extent, from the &lt;code&gt;S&lt;/code&gt; stream). That&amp;#8217;s why it&amp;#8217;s so hungry. Any general purpose infinite pair generator function must suffer this problem, I think, since we &lt;strong&gt;have&lt;/strong&gt; to accumulate increasing portions of the streams into memory, but if it&amp;#8217;s just integer pairs we want we can work around the issue:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def integer_pairs(i=0):
    "Generate a stream of integer pairs (i, j) with i &amp;lt;= j"
    yield i, i
    top_row = ((i, j) for j in itertools.count(i + 1))
    for ij in interleave(top_row, integer_pairs(i + 1)):
        yield ij

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, rather than &lt;code&gt;tee()&lt;/code&gt; streams of integers, we use &lt;code&gt;itertools.count()&lt;/code&gt; to create new ones as required. This pair generator will run happily for extended periods. It will very gradually ask for more memory, as numbers get bigger and the number of rows increases. As before, it won&amp;#8217;t hit any embarrassing recursion limits in the lifetime of this galaxy.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc7" name="tocproblem-solved" id="tocproblem-solved"&gt;Problem Solved?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So, does &lt;code&gt;integer_pairs()&lt;/code&gt; solve the problem of generating an infinite stream of pairs for the special case when both input streams are integers? 
&lt;/p&gt;
&lt;p&gt;Not really, no!
&lt;/p&gt;
&lt;p&gt;The interleave strategy for combining the top row with the remaining pairs has the great merit of simplicity, but is otherwise far from ideal. I don&amp;#8217;t think a one-size-fits-all strategy for streaming pairs exists, so we should allow clients to supply one. And that will have to be the subject of another article.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc8" name="toctying-up" id="toctying-up"&gt;Tying up&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s not hard to fix the problem we noticed with &lt;code&gt;interleave()&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def interleave(s, t):
    """Generate an interleaved stream of elements from s and t.
    
    If one of the streams finishes, elements continue to be generated
    from the other until it too is finished. 
    """
    for ss, tt in itertools.izip(s, t):
        yield ss
        yield tt
    for s_or_t in itertools.chain(s, t):
        yield s_or_t

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s the script I used to generate the animated GIFs. Although it&amp;#8217;s very much geared to doing the single job which it was designed to do, it&amp;#8217;s short enough to be used as a basis for similar tasks. I hope this article helps demonstrate the merits of visualising an algorithm in action.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;pairs-animation.py&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#! /usr/bin/env python
"""Script which accepts a list of (i, j) pairs, creating slides and
   an animated GIF showing the positions of these pairs.

Example use:
$ echo '((0, 0) (0, 1) (1, 1) (0, 2) (1, 2) (0, 3) (2, 2)' | pairs-animation.py

Dependencies:
- Python Imaging Library (PIL), http://effbot.org/imagingbook/
- aggdraw, anti-aliased graphics drawing package,
  http://effbot.org/zone/pythondoc-aggdraw.htm
- ImageMagick, http://www.imagemagick.org
"""
import Image
import aggdraw
import itertools

# Script wide drawing configuration
block_w = 16
block_pad = 2

def fading_brushes():
    "Generate a sequence of fading grey brushes."
    darkgrey = itertools.repeat(16)
    greyscale = itertools.chain(range(255, 0, -16), darkgrey)
    def brush(g):
        "Return a grey brush."
        return aggdraw.Brush('rgb(%d,%d,%d)' % (g, g, g))
    return itertools.imap(brush, greyscale)

def block_start(i):
    "Return the coordinate (X or Y) at which the ith block starts."
    return (block_w + block_pad) * i + block_pad

def read_ij(data):
    """Return pairs of integers found in the input string.
    
    Note: this function is extremely unfussy about the string format!
    &amp;gt;&amp;gt;&amp;gt; read_ij('1 2 3 4')
    [(1, 2), (3, 4)]
    &amp;gt;&amp;gt;&amp;gt; read_ij('(1, 2), (3, 4)')
    [(1, 2), (3, 4)]
    """
    import re
    ij = itertools.imap(int, re.compile(r'-?\d+').findall(data))
    return zip(ij, ij)

def dimensions(ij):
    "Return dimensions of an image big enough to contain blocks at ij positions."
    import operator
    max_i = max(map(operator.itemgetter(0), ij))
    max_j = max(map(operator.itemgetter(1), ij))
    return block_start(max_j + 1), block_start(max_i + 1)

def block_xy(ij):
    "Return the left, top, right, bottom coords of a block at ij."
    ylo, xlo = map(block_start, ij)
    return xlo, ylo, xlo + block_w, ylo + block_w

def draw_blocks(image, blocks):
    "Draws the supplied blocks onto the input image."
    draw = aggdraw.Draw(image)
    brushes = fading_brushes()
    # Reverse the blocks so the newest are brightest
    for block, brush in itertools.izip(reversed(blocks), brushes):
        # The 'ellipse' will be circular since the block is square
        draw.ellipse(block_xy(block), brush)
    draw.flush()

def main(ij_data):
    "Creates slides and an animation from the ij block positions."
    import os
    ij = read_ij(ij_data)
    dims = dimensions(ij)
    # Create the slides
    slides = ['pairs-%d.gif' % n for n in range(len(ij) + 1)]
    for n, slide in enumerate(slides):
        image = Image.new('L', dims)
        draw_blocks(image, ij[:n])
        image.save(slide)
    # Use ImageMagick to create an animation
    # -loop 0 =&amp;gt; loop forever, -delay units are .01 seconds
    os.system('convert -delay 100 -loop 0 %s animation.gif'
              % ' '.join(slides))

if __name__ == '__main__':
    import sys
    main(sys.stdin.read())

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/animated-pair-streams#toc9" name="toccredits" id="toccredits"&gt;Credits&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The inspiration for this article comes directly from &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_Temp_476"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt;, which presents some great examples of how to develop and use these pair streams.
&lt;/p&gt;</description>
<dc:date>2008-01-13</dc:date>
<guid>http://wordaligned.org/articles/animated-pair-streams</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/animated-pair-streams</link>
<category>Puzzles</category>
</item>

<item>
<title>The Maximum Sum contiguous subsequence problem</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocwelcome-to-the-pearly-gates" name="toc0" id="toc0"&gt;Welcome to the Pearly Gates&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocprogramming-pearl" name="toc1" id="toc1"&gt;Programming Pearl&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toclinear-solution" name="toc2" id="toc2"&gt;Linear Solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstreaming-solution" name="toc3" id="toc3"&gt;Streaming Solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstream-accumulate" name="toc4" id="toc4"&gt;Stream Accumulate&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstream-floor" name="toc5" id="toc5"&gt;Stream Floor&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstream-diff" name="toc6" id="toc6"&gt;Stream Diff&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstreams-and-collections" name="toc7" id="toc7"&gt;Streams and Collections&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#tocstream-on" name="toc8" id="toc8"&gt;Stream on&amp;#8230;&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc0" name="tocwelcome-to-the-pearly-gates" id="tocwelcome-to-the-pearly-gates"&gt;Welcome to the Pearly Gates&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Pearly Gates club never closes. Its public entrance, a revolving door, just keeps on spinning. With each rotation some punters enter and others leave. The club&amp;#8217;s owners would like to track this traffic. Specifically, they&amp;#8217;d like to know the maximum increase in people entering the club over a given period.
&lt;/p&gt;
&lt;p&gt;The starting point is to track the people who enter/leave with each spin of the door. Here&amp;#8217;s a 5 minute sample of that information. Negative numbers mean more people left than entered during a particular cycle.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Entries Log&lt;/div&gt;

&lt;pre class="prettyprint"&gt;0 1 2 -3 3 -1 0 -4 0 -1 -4 2 4 1 1 3 1 0 -2 -3 -3 -2 3 1 1 4 5 -3 -2 -1 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s the same information plotted on a graph.
&lt;/p&gt;
&lt;img alt="Graph of entries to Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Entries+to+the+Pearly+Gates+club
&amp;amp;chs=500x200
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-5.0,6.0
&amp;amp;chd=t:45.5,45.5|45.5,54.5,63.6,18.2,72.7,36.4,45.5,9.1,45.5,36.4,9.1,63.6,81.8,54.5,54.5,72.7,54.5,45.5,27.3,18.2,18.2,27.3,72.7,54.5,54.5,81.8,90.9,18.2,27.3,36.4
&amp;amp;chco=BBBBBB,0000CC
&amp;amp;chls=1,1,0|4,1,0
" /&gt;

&lt;p&gt;The archetypal problem we&amp;#8217;d like to solve can be stated:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;Given a sequence of numbers, find the maximum sum of a contiguous subsequence of those numbers.&lt;/strong&gt; 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;As an example, the maximum sum contiguous subsequence of 0, -1, &lt;strong&gt;2, -1, 3&lt;/strong&gt;, -1, 0 would be 4 (= 2 + -1 + 3).
&lt;/p&gt;
&lt;p&gt;This problem is generally known as &lt;strong&gt;the maximum sum contiguous subsequence problem&lt;/strong&gt; and if you haven&amp;#8217;t encountered it before, I&amp;#8217;d recommend trying to solve it before reading on. Even if you have encountered it before, I&amp;#8217;ll invite you to read on anyway &amp;#8212; it&amp;#8217;s well worth another look.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc1" name="tocprogramming-pearl" id="tocprogramming-pearl"&gt;Programming Pearl&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The maximum sum contiguous subsequence problem appears in Jon Bentley&amp;#8217;s &lt;a href="http://www.cs.bell-labs.com/cm/cs/pearls/"&gt;&amp;#8220;Programming Pearls&amp;#8221;&lt;/a&gt;. He first presents a brute force solution which examines all possible contiguous subsequences of the initial sequence and returns the maximum sum of these subsequences.
&lt;/p&gt;
&lt;p&gt;A Python implementation might read:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def generate_pairs(n):
    "Generate all pairs (i, j) such that 0 &amp;lt;= i &amp;lt;= j &amp;lt; n"
    for i in range(n):
        for j in range(i, n):
            yield i, j

def max_sum_subsequence(seq):
    "Return the max-sum contiguous subsequence of the input sequence."
    return max(sum(seq[i:j])
               for i, j in generate_pairs(len(seq) + 1))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s a straightforward piece of code, though note the &lt;code&gt;+ 1&lt;/code&gt; which ensures that we slice to the end of &lt;code&gt;seq&lt;/code&gt;, and also that we include empty slices, which sum to &lt;code&gt;0&lt;/code&gt;, handling the case when every item in the sequence is negative. The trouble is, the algorithm is of cubic complexity: to process just 6 hours of logged activity takes over 2 minutes on a 2GHz Intel Core Duo MacBook, and the cubic nature of the algorithm means we&amp;#8217;d quickly fail to process more substantial log files in real time.
&lt;/p&gt;
&lt;img alt="Graph plotting accumulated entries to the Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Accumulated+entries+to+the+Pearly+Gates+club
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-8.0,10.0
&amp;amp;chd=t:44.4,50.0,55.6,27.8,61.1,38.9,44.4,22.2,44.4,38.9,22.2,55.6,66.7,50.0,50.0,61.1,50.0,44.4,33.3,27.8,27.8,33.3,61.1,50.0,50.0,66.7,72.2,27.8,33.3,38.9|44.4,50.0,61.1,44.4,61.1,55.6,55.6,33.3,33.3,27.8,5.6,16.7,38.9,44.4,50.0,66.7,72.2,72.2,61.1,44.4,27.8,16.7,33.3,38.9,44.4,66.7,94.4,77.8,66.7,61.1
&amp;amp;chco=CCCCCC,CC0000
&amp;amp;chls=3,1,0|3,1,0
&amp;amp;chdl=Entries|Accum.+Entries
" /&gt;

&lt;p&gt;A simple optimisation eliminates the repeated calls to &lt;code&gt;sum&lt;/code&gt; by accumulating the input sequence &amp;#8212; the red line in the graph above. Subtracting element &lt;code&gt;i-1&lt;/code&gt; from element &lt;code&gt;j&lt;/code&gt; of this cumulative sequence gives us the sum of elements in the range i, j of the original sequence. We won&amp;#8217;t study the code for this quadratic solution &amp;#8212; it doesn&amp;#8217;t add much to our analysis. Again, some care is needed to avoid &lt;a href="http://wordaligned.org/articles/joined-output-and-the-fencepost-problem.html"&gt;fencepost problems&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;We won&amp;#8217;t look at the divide-and-conquer NlogN solution either. It&amp;#8217;s hard to understand, and we can do far better.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc2" name="toclinear-solution" id="toclinear-solution"&gt;Linear Solution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There is a linear solution. The idea is to scan the sequence from start to finish keeping track of &lt;code&gt;maxsofar&lt;/code&gt;, the maximum sum of a contiguous subsequence seen so far, and &lt;code&gt;maxendinghere&lt;/code&gt;, the maximum sum of a contiguous subsequence which ends at the current position. Bentley&amp;#8217;s pseudo-code reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;maxsofar = 0
maxendinghere = 0
for i = [0, n)
    /* invariant: maxendinghere and maxsofar are accurate
       are accurate for x[0..i-1] */
    maxendinghere = max(maxendinghere + x[i], 0)
    maxsofar = max(maxsofar, maxendinghere)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This translates directly into Python.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def max_sum_subsequence(seq):
    maxsofar = 0
    maxendinghere = 0
    for s in seq:
        # invariant: maxendinghere and maxsofar are accurate
        # are accurate up to s
        maxendinghere = max(maxendinghere + s, 0)
        maxsofar = max(maxsofar, maxendinghere)
    return maxsofar

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now, this is a fabulous solution. Bentley describes it as subtle. Such a succinct code snippet hardly &lt;strong&gt;looks&lt;/strong&gt; subtle, but I agree, the loop body &lt;strong&gt;does&lt;/strong&gt; take a bit of understanding:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;maxendinghere = max(maxendinghere + s, 0)
maxsofar = max(maxsofar, maxendinghere)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Why does this work?&lt;/strong&gt; 
&lt;/p&gt;
&lt;p&gt;Well, essentially maxendinghere is what&amp;#8217;s accumulating the subsequences &amp;#8212; it keeps rolling the next element into itself. Should this accumulated sum ever become negative we know that the subsequence-which-ends-here we&amp;#8217;re currently tracking is worse than the empty subsequence-which-restarts-here; so we can reset our subsequence accumulator, and the first clause of the loop invariant still holds. Combine this with the observation that maxsofar tracks peaks in maxendinghere and we&amp;#8217;re done.
&lt;/p&gt;
&lt;p&gt;The loop-invariant comment provides a good example of how comments can help us understand an algorithm, even though the code is minimal and the variable names are well-chosen.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc3" name="tocstreaming-solution" id="tocstreaming-solution"&gt;Streaming Solution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I prefer to think of this problem in terms of streams &amp;#8212; lazily evaluated sequences. Think of our log file as generating a stream of numbers:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;... 0 1 2 -3 3 -1 0 -4 0 -1 -4 2 4 1 1 3 1 0 -2 -3 -3 -2 3 1 1 4 5 -3 -2 -1 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The first thing we do is transform this stream to generate another stream, the cumulative sum of numbers seen so far. It&amp;#8217;s an integration of sorts. You&amp;#8217;ll remember we already used this stream, or an in-memory version of it, in our quadratic solution to the problem: the difference between points on it yields subsequence-sums.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc4" name="tocstream-accumulate" id="tocstream-accumulate"&gt;Stream Accumulate&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;We generate the accumulated stream from our original stream like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def stream_accumulate(stream):
    total = 0
    for s in stream:
        total += s
        yield total

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The graph below samples the first five minutes of this stream. The red line accumulates values from the pale grey line.
&lt;/p&gt;
&lt;img alt="Graph plotting accumulated entries to the Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-8.0,10.0
&amp;amp;chd=t:44.4,50.0,55.6,27.8,61.1,38.9,44.4,22.2,44.4,38.9,22.2,55.6,66.7,50.0,50.0,61.1,50.0,44.4,33.3,27.8,27.8,33.3,61.1,50.0,50.0,66.7,72.2,27.8,33.3,38.9|44.4,50.0,61.1,44.4,61.1,55.6,55.6,33.3,33.3,27.8,5.6,16.7,38.9,44.4,50.0,66.7,72.2,72.2,61.1,44.4,27.8,16.7,33.3,38.9,44.4,66.7,94.4,77.8,66.7,61.1
&amp;amp;chm=x,FFCC33,1,10.0,20.0|x,FFCC33,1,26.0,20.0
&amp;amp;chco=CCCCCC,CC0000
&amp;amp;chls=3,1,0|3,1,0
&amp;amp;chdl=Entries|Accum.+Entries
" /&gt;

&lt;p&gt;These accumulated numbers represent the number of members who have entered the club since we started tracking them. On our graph, the maximum sum contiguous subsequence is simply the greatest Y-increase between any two points on this graph. X&amp;#8217;s mark these points on the graph above. (Note: it&amp;#8217;s &lt;strong&gt;not&lt;/strong&gt; the Y-range of the graph we want since our X-values are time-ordered, and we require X1 &amp;lt;= X2). 
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc5" name="tocstream-floor" id="tocstream-floor"&gt;Stream Floor&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;A second transformation yields the floor of the accumulated stream.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import sys

def stream_floor(stream):
    m = 0
    for s in stream:
        m = min(m, s)
        yield m

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Note that, for our purposes, the floor of the stream isn&amp;#8217;t exactly the stream of minimum values taken by the stream &amp;#8212; we enforce a baseline at zero. It would be better to allow clients of this function to supply an optional baseline value, but I wanted the simplest possible code that shows the idea.)
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a graph plotting the accumulated entries alongside the floor of these entries.
&lt;/p&gt;
&lt;img alt="Graph plotting accumulated entries and floor of accumulated entries to the Pearly Gates club" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,-8.0,10.0
&amp;amp;chd=t:44.4,50.0,61.1,44.4,61.1,55.6,55.6,33.3,33.3,27.8,5.6,16.7,38.9,44.4,50.0,66.7,72.2,72.2,61.1,44.4,27.8,16.7,33.3,38.9,44.4,66.7,94.4,77.8,66.7,61.1|44.4,44.4,44.4,44.4,44.4,44.4,44.4,33.3,33.3,27.8,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6,5.6
&amp;amp;chco=CC0000,333333
&amp;amp;chls=3,1,0|3,1,0
&amp;amp;chm=b,CCCCCC,0,1,0
&amp;amp;chdl=Accum.+Entries|Floor+Accum.+Entries
" /&gt;

&lt;p&gt;We&amp;#8217;re very close to what we want now. We can track Y-increases on the graph just by generating the difference between the accumulated stream and its floor &amp;#8212; the shading on the graph.
&lt;/p&gt;

&lt;h4&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc6" name="tocstream-diff" id="tocstream-diff"&gt;Stream Diff&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Here&amp;#8217;s an implementation of &lt;code&gt;stream_diff&lt;/code&gt;. We can&amp;#8217;t just plug a minus sign &amp;#8220;-&amp;#8221; into the mapping function, so we have to use the less wieldy &lt;code&gt;operator.sub&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools
import operator

def stream_diff(s, t):
    return itertools.imap(operator.sub, s, t)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Alternatively, we could generate the new stream with an explicit loop:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools

def stream_diff(s, t):
    for ss, tt in itertools.izip(s, t):
        yield ss - tt

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The final graph shows us the difference between the accumulated entry count and its floor. I&amp;#8217;ve also added the ceiling of this stream as a thick red line (I&amp;#8217;m sure you can figure out how to implement &lt;code&gt;stream_ceiling&lt;/code&gt;), and this ceiling represents the stream of maximum sum contiguous subsequences. 
&lt;/p&gt;
&lt;img alt="Graph plotting Max-ends-here and Max-so-far" src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Maximum+Subsequences+at+the+Pearly+Gates+club
&amp;amp;chs=500x250
&amp;amp;chxt=x,y
&amp;amp;chxl=0:|0min|1min|2min|3min|4min|5min
&amp;amp;chxr=1,0.0,17.0
&amp;amp;chd=t:0.0,5.9,17.6,17.6,17.6,17.6,17.6,17.6,17.6,17.6,17.6,17.6,35.3,41.2,47.1,64.7,70.6,70.6,70.6,70.6,70.6,70.6,70.6,70.6,70.6,70.6,94.1,94.1,94.1,94.1|0.0,5.9,17.6,0.0,17.6,11.8,11.8,0.0,0.0,0.0,0.0,11.8,35.3,41.2,47.1,64.7,70.6,70.6,58.8,41.2,23.5,11.8,29.4,35.3,41.2,64.7,94.1,76.5,64.7,58.8|0.0,0.0
&amp;amp;chco=aa0000,333333
&amp;amp;chls=4,1,0|2,1,0
&amp;amp;chm=b,CCCCCC,1,2,0
&amp;amp;chdl=Max-so-far|Max-ending-here
" /&gt;

&lt;p&gt;We&amp;#8217;ve re-labelled the lines &lt;code&gt;Max-so-far&lt;/code&gt; and &lt;code&gt;Max-ending-here&lt;/code&gt; because they&amp;#8217;re the stream of values taken by the variables &lt;code&gt;maxsofar&lt;/code&gt; and &lt;code&gt;maxendinghere&lt;/code&gt; during Bentley&amp;#8217;s clever solution to the maximum sum contiguous subsequence problem. I think we&amp;#8217;re in a better position to understand how this solution works now.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc7" name="tocstreams-and-collections" id="tocstreams-and-collections"&gt;Streams and Collections&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Please don&amp;#8217;t imagine these streams are bloated. &lt;span /&gt;They may be infinite (remember the Pearly Gates club never closes!) but that doesn&amp;#8217;t mean they take up much space. The graphs shown represent snapshots of their activity, and at no point do our presented algorithms actually store a five minute buffer of entries.
&lt;/p&gt;
&lt;p&gt;A final solution to the maximum sum contiguous subsequence problem reads like this. We&amp;#8217;ve pushed the general purpose stream transformation functions into a separate module, &lt;code&gt;stream.py&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools
import stream

def max_sum_subsequence_stream(ss):
    "Return the stream of max sum contiguous subsequences of the input iterable."
    accu1, accu2 = itertools.tee(stream.accumulate(ss))
    return stream.ceil(stream.diff(accu1, 
                       stream.floor(accu2, baseline=0)))

def max_sum_subsequence(ss):
    "Return the max sum of a contiguous subsequence of the input iterable."
    return stream.last(max_sum_subsequence_stream(ss))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The iterable supplied to &lt;code&gt;max_sum_subsequence&lt;/code&gt; has its last value read, and should therefore be bounded if we want the function to return. We haven&amp;#8217;t supplied arguments to extract a portion of this iterable (to generate maximum subsequences for the club on a particular day, for example) because that&amp;#8217;s what &lt;code&gt;itertools.islice&lt;/code&gt; is for.
&lt;/p&gt;
&lt;p&gt;Note that &lt;code&gt;max_sum_subsequence_stream()&lt;/code&gt; may be more useful to clients than &lt;code&gt;max_sum_subsequence()&lt;/code&gt;. Suppose, for example, we&amp;#8217;re only interested when the maximum sum subsequence exceeds 100. We can do this directly by connecting &lt;code&gt;itertools.dropwhile()&lt;/code&gt; to our function.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def max_subseq_exceeds(seq, limit=100):
    max_sub_s = max_sum_subsequence_stream(seq)
    return itertools.dropwhile(lambda s: s &amp;lt;= limit, max_sub_s)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Perhaps we&amp;#8217;d like to know if the maximum sum subsequence reaches a plateau; that is, it stays on a level for a while.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s the stream module.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;stream.py&lt;/div&gt;

&lt;pre class="prettyprint"&gt;"General purpose stream generation functions."
import itertools

def floor(stream, baseline=None):
    """Generate the stream of minimum values from the input stream.
    
    The baseline, if supplied, is an upper limit for the floor.
    &amp;gt;&amp;gt;&amp;gt; ff = floor((1, 2, -2, 3))
    &amp;gt;&amp;gt;&amp;gt; assert list(ff) == [1, 1, -2, -2]
    &amp;gt;&amp;gt;&amp;gt; ff = floor((1, 2, -2, 3), 0)
    &amp;gt;&amp;gt;&amp;gt; assert list(ff) == [0, 0, -2, -2]    
    """
    stream = iter(stream)
    m = baseline
    if m is None:
        try:
            m = stream.next()
            yield m
        except StopIteration:
            pass
    for s in stream:
        m = min(m, s)
        yield m

def ceil(stream):
    """Generate the stream of maximum values from the input stream.
    
    &amp;gt;&amp;gt;&amp;gt; top = ceil([0, -1, 2, -2, 3])
    &amp;gt;&amp;gt;&amp;gt; assert list(top) == [0, 0, 2, 2, 3]
    """
    stream = iter(stream)
    try:
        M = stream.next()
        yield M
    except StopIteration:
        pass
    for s in stream:
        M = max(M, s)
        yield M

def accumulate(stream):
    """Generate partial sums from the stream.
    
    &amp;gt;&amp;gt;&amp;gt; accu = accumulate([1, 2, 3, 4])
    &amp;gt;&amp;gt;&amp;gt; assert list(accu) == [1, 3, 6, 10]
    """
    total = 0
    for s in stream:
        total += s
        yield total

def diff(s, t):
    """Generate the differences between two streams
    
    If the streams are of unequal length, the shorter is truncated.
    &amp;gt;&amp;gt;&amp;gt; dd = diff([2, 4, 6, 8], [1, 2, 3])
    &amp;gt;&amp;gt;&amp;gt; assert list(dd) == [1, 2, 3]
    """
    import operator
    return itertools.imap(operator.sub, s, t)

def last(stream, default=None):
    """Return the last item in the stream or the default if the stream is empty.
    
    &amp;gt;&amp;gt;&amp;gt; last('abc')
    'c'
    &amp;gt;&amp;gt;&amp;gt; last([], default=-1)
    -1
    """
    s = default
    for s in stream:
        pass
    return s

if __name__ == "__main__":
    import doctest
    doctest.testmod()

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem#toc8" name="tocstream-on" id="tocstream-on"&gt;Stream on&amp;#8230;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;The maximum sum contiguous subsequence problem is described in &lt;a href="http://www.cs.bell-labs.com/cm/cs/pearls/"&gt;&amp;#8220;Programming Pearls&amp;#8221;&lt;/a&gt; by Jon Bentley. 
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;My favourite introduction to computer programming, &amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;, has &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5"&gt;lots to say about streams&lt;/a&gt;, and suggests they have a role in concurrent programming and modelling time. 
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;Streams are a natural fit with functional programming, and well supported by languages like &lt;a href="http://www.schemers.org"&gt;Scheme&lt;/a&gt; and &lt;a href="http://haskell.org"&gt;Haskell&lt;/a&gt;. Python also handles them nicely: look into &lt;a href="http://www.python.org/dev/peps/pep-0255/"&gt;generators&lt;/a&gt;, &lt;a href="http://www.python.org/dev/peps/pep-0289/"&gt;generator expressions&lt;/a&gt;, the &lt;a href="http://docs.python.org/lib/module-itertools.html"&gt;itertools module&lt;/a&gt;, and study &lt;code&gt;test_generators.py&lt;/code&gt; carefully.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;If you liked this article, try more Word Aligned articles &lt;a href="http://wordaligned.org/tag/streams/"&gt;tagged &amp;#8220;streams&amp;#8221;&lt;/a&gt;. And if you like puzzles, there are more articles &lt;a href="http://wordaligned.org/tag/puzzles/"&gt;tagged &amp;#8220;puzzles&amp;#8221;&lt;/a&gt; too.
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;The graphs in this article are generated using the &lt;a href="http://code.google.com/apis/chart/"&gt;Google chart API&lt;/a&gt;, which is both useful and &lt;span /&gt;a fine example of how to design and document a programming interface.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;</description>
<dc:date>2007-12-17</dc:date>
<guid>http://wordaligned.org/articles/the-maximum-subsequence-problem</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/the-maximum-subsequence-problem</link>
<category>Puzzles</category>
</item>

<item>
<title>Zippy triples served with Python</title>
<description>&lt;h3&gt;The Problem&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a problem I encountered when writing the HTML generator for this site. Logically, Word Aligned is a time-ordered collection of articles. I wanted each article to link to its predecessor and successor. So the general problem is: 
   &lt;strong&gt;How do you iterate through a collection yielding (previous, this, next) triples?&lt;/strong&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Specification&lt;/h3&gt;
&lt;p&gt;Some test cases make things clearer. Let&amp;#8217;s name the function we&amp;#8217;re developing &lt;code&gt;prev_this_next()&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; long_weekend = 'Fri', 'Sat', 'Sun', 'Mon',
&amp;gt;&amp;gt;&amp;gt; yesterday_today_tomorrow = prev_this_next(long_weekend)
&amp;gt;&amp;gt;&amp;gt; yesterday_today_tomorrow.next()
(None, 'Fri', 'Sat')
&amp;gt;&amp;gt;&amp;gt; yesterday_today_tomorrow.next()
('Fri', 'Sat', 'Sun')
&amp;gt;&amp;gt;&amp;gt; yesterday_today_tomorrow.next()
('Sat', 'Sun', 'Mon')
&amp;gt;&amp;gt;&amp;gt; yesterday_today_tomorrow.next()
('Sun', 'Mon', None)
&amp;gt;&amp;gt;&amp;gt; yesterday_today_tomorrow.next()
Traceback (most recent call last):
    ...
StopIteration
&amp;gt;&amp;gt;&amp;gt; for ptn in prev_this_next(range(5)):
...     print ptn
... 
(None, 0, 1)
(0, 1, 2)
(1, 2, 3)
(2, 3, 4)
(3, 4, None)
&amp;gt;&amp;gt;&amp;gt; print "\n".join(map(repr, prev_this_next("XYZ")))
(None, 'X', 'Y')
('X', 'Y', 'Z')
('Y', 'Z', None)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;You&amp;#8217;ll notice we&amp;#8217;ve specified behaviour at the boundaries: the first item in the collection has no predecessor, thus the first triple returned has its first item set to &lt;code&gt;None&lt;/code&gt;; and similarly the final triple has its third item set to &lt;code&gt;None&lt;/code&gt;. We might equally well have chosen to return a user supplied default, or to wrap the collection at its ends. For now, let&amp;#8217;s go with the simple behaviour shown.
&lt;/p&gt;
&lt;p&gt;You&amp;#8217;ll also have noticed I&amp;#8217;m writing Python &amp;#8212; fair enough, since this web site is generated off-line using Python. The &lt;code&gt;long_weekend&lt;/code&gt; example drives the Python iterator protocol by hand, calling &lt;code&gt;yesterday_today_tomorrow.next()&lt;/code&gt; until a &lt;code&gt;StopIteration&lt;/code&gt; exception terminates the iteration. It&amp;#8217;s quite rare to use iterators in this way: more commonly, you just loop through them using &lt;code&gt;for&lt;/code&gt;, or plug them into container operations. The second and third test cases show more typical usage.
&lt;/p&gt;

&lt;h3&gt;First Implementation&lt;/h3&gt;
&lt;p&gt;If this were C++, we&amp;#8217;d prefer our collection to support bi-directional iteration: think of a doubly-linked &lt;code&gt;std::list&lt;/code&gt;, or a plain old random access &lt;code&gt;std::vector&lt;/code&gt;. Then we could just decrement/increment each iterator from the collection to find its neighbours. 
&lt;/p&gt;
&lt;p&gt;In Python, we might decide to assume a random access container and write something like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def get_default(items):
    "Return an item getter function."
    n_items = len(items)
    def inner(index):
        "Return items[index] or None if index is out of range."
        if index &amp;lt; 0 or index &amp;gt;= n_items:
            return None
        else:
            return items[index]
    return inner

def prev_this_next(items):
    get = get_default(items)
    for ix, item in enumerate(items):
        yield get(ix - 1), item, get(ix + 1)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code isn&amp;#8217;t elegant but it does pass our tests. Incidentally, an attempt to implement &lt;code&gt;get_default&lt;/code&gt; using &lt;a href="http://wordaligned.org/articles/permission-and-forgiveness.html"&gt;EAFP&lt;/a&gt;, as shown below, would fail. Can you see why?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def inner(index):
    try:
        return items[index]
    except IndexError:
        return None

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This fails because accessing &lt;code&gt;items[-1]&lt;/code&gt; doesn&amp;#8217;t raise an &lt;code&gt;IndexError&lt;/code&gt; (unless &lt;code&gt;items&lt;/code&gt; is empty); it&amp;#8217;s a convenient way to access the final element of &lt;code&gt;items&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Even with the correct version of &lt;code&gt;get_default&lt;/code&gt;, if our collection of items is a stream &amp;#8212; by which I mean a lazily-evaluated iterable &amp;#8212; this code raises an exception. We don&amp;#8217;t know how long the stream will be (indeed, it could be infinite) and we can&amp;#8217;t just access elements from it at random. For C++ programmers, think of sequentially reading a file using an input iterator.
&lt;/p&gt;

&lt;h3&gt;Stream Test Case&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s adapt one of our test cases to expose this flaw.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; long_weekend = iter(('Fri', 'Sat', 'Sun', 'Mon'))
&amp;gt;&amp;gt;&amp;gt; yesterday_today_tomorrow = prev_this_next(long_weekend)
...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Running this code raises an exception:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;Traceback (most recent call last):
    ...
TypeError: object of type 'tupleiterator' has no len()

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Stream Solution&lt;/h3&gt;
&lt;p&gt;Thinking of this problem in terms of streams gives us a solution which is both more general and more simple. All we have to do is tee up three independent iterators into the stream, stagger them, then zip them back together. &lt;span /&gt;The itertools module supplies the components. We connect.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools

def prev_this_next(items):
    extend = itertools.chain([None], items, [None])
    prev, this, next = itertools.tee(extend, 3)
    try:
        this.next()
        next.next()
        next.next()
    except StopIteration:
        pass
    return itertools.izip(prev, this, next)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code works on any iterable, infinite, finite or empty, lazy or eager. Some more testcases:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; [ptn for ptn in prev_this_next(list())]
[]
&amp;gt;&amp;gt;&amp;gt; [ptn for ptn in prev_this_next(set([1]))]
[(None, 1, None)]
&amp;gt;&amp;gt;&amp;gt; ptn = prev_this_next(itertools.count())
&amp;gt;&amp;gt;&amp;gt; itertools.islice(ptn, 100, 101).next()
(99, 100, 101)

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Triples Times Two&lt;/h3&gt;
&lt;p&gt;Now suppose you want to peel items from an iterable, three at a time. Let&amp;#8217;s call this function &lt;code&gt;three_at_a_time()&lt;/code&gt; and let&amp;#8217;s specify its behaviour with some simple tests:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; t = three_at_a_time((1, 2, 3, 4, 5, 6))
&amp;gt;&amp;gt;&amp;gt; t.next()
(1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; t.next()
(4, 5, 6)
&amp;gt;&amp;gt;&amp;gt; t.next()
Traceback (most recent call last):
    ...
StopIteration
&amp;gt;&amp;gt;&amp;gt; ttt = three_at_a_time((1, 2, 3, 4))
&amp;gt;&amp;gt;&amp;gt; [t for t in ttt]
[(1, 2, 3)]
&amp;gt;&amp;gt;&amp;gt; ttt = three_at_a_time(itertools.count())
&amp;gt;&amp;gt;&amp;gt; ttt = itertools.islice(ttt, 0, 9, 3)
&amp;gt;&amp;gt;&amp;gt; [t for t in ttt]
[(0, 1, 2), (9, 10, 11), (18, 19, 20)]
&amp;gt;&amp;gt;&amp;gt; "".join(chain(*three_at_a_time("Word Aligned")))
'Word Aligned'

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that any trailing single element or pair at the end of the collection is discarded. We might equally have decided to pad the collection with a user-supplied default or throw an exception.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s one implementation.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def three_at_a_time(items):
    it = iter(items)
    return itertools.izip(it, it, it)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s another.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def n_at_a_time(items, n):
    it = iter(items)
    return itertools.izip(* [it] * n)

three_at_a_time = lambda items: n_at_a_time(items, 3)

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2007-11-20</dc:date>
<guid>http://wordaligned.org/articles/zippy-triples-served-with-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/zippy-triples-served-with-python</link>
<category>Puzzles</category>
</item>

</channel>
</rss>
