<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>https://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Binary search gets a sort key</title>
<description>&lt;p&gt;Suppose you have an list of distinct elements which has been sorted
and rotated. How would you look up an element within that list?&lt;/p&gt;
&lt;p&gt;For example, the list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[7, 11, 13, 19, 2, 3, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is sorted (the first 7 primes, in order) and rotated (to put 7 first).&lt;/p&gt;
&lt;p&gt;With this list as input, then:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;look up &lt;code&gt;13&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; since &lt;code&gt;13&lt;/code&gt; is at index &lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;look up &lt;code&gt;2&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;look up &lt;code&gt;4&lt;/code&gt; returns the sentinel value &lt;code&gt;-1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The obvious technique is to just search the list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def lookup(values, v):
    try:
        return values.index(v)
    except IndexError:
        return -1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a linear algorithm which processes the entire list. Is there a way
to take advantage of its sorted+rotated-ness?&lt;/p&gt;
&lt;p&gt;If the list &lt;strong&gt;was&lt;/strong&gt; sorted then we could apply a binary search for a
logarithmic lookup. And in fact, by applying a custom ordering, the
list &lt;strong&gt;is&lt;/strong&gt; sorted.&lt;/p&gt;
&lt;p&gt;How can we apply a custom ordering in Python?&lt;/p&gt;
&lt;p&gt;The way to do this has changed as Python has developed. The table below shows
the evolution of standard Python functions which sort and compare.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;th&gt;Year&lt;/th&gt;
&lt;th&gt;Functions&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;td&gt;2000&lt;/td&gt;
&lt;td&gt;max, min, list.sort([cmp]), bisect.bisect&lt;/td&gt;
&lt;td&gt;Note that [cmp] slows the sorting process down considerably&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.3&lt;/td&gt;
&lt;td&gt;2003&lt;/td&gt;
&lt;td&gt;heapq&lt;/td&gt;
&lt;td&gt;Also known as the priority queue algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.4&lt;/td&gt;
&lt;td&gt;2004&lt;/td&gt;
&lt;td&gt;sorted(iterable[, cmp[, key[, reverse]]]), list.sort([cmp[, key[, reverse]]]), itertools.groupby(iterable[, key)&lt;/td&gt;
&lt;td&gt;In general, the key and reverse conversion processes are much faster than specifying an equivalent cmp function&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.4&lt;/td&gt;
&lt;td&gt;2004&lt;/td&gt;
&lt;td&gt;heapq.nlargest, heapq.nsmallest&lt;/td&gt;
&lt;td&gt;Heapq extended&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.5&lt;/td&gt;
&lt;td&gt;2006&lt;/td&gt;
&lt;td&gt;max([key]), min([key]), heapq.nlargest(&amp;#8230;[, key]), heapq.smallest(&amp;#8230;[, key])&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.6&lt;/td&gt;
&lt;td&gt;2008&lt;/td&gt;
&lt;td&gt;heapq.merge&lt;/td&gt;
&lt;td&gt;Heapq extended again&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;2008&lt;/td&gt;
&lt;td&gt;sorted(iterable, key[, reverse]), list.sort(key[, reverse])&lt;/td&gt;
&lt;td&gt;No more &lt;code&gt;cmp&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.5&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;td&gt;heapq.merge(&amp;#8230;, key)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.10&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;bisect.bisect(&amp;#8230;, key) etc&lt;/td&gt;
&lt;td&gt;That leaves the low-level &lt;code&gt;heapq&lt;/code&gt; functions&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The earliest versions of Python allowed you to sort lists, and
the sort was customised using a &lt;code&gt;cmp&lt;/code&gt; function &amp;#8212; though the documentation
warned there would be a performance penalty[*]. The builtin &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;
functions could not be cutomised, and nor could the comparison used in
the &lt;code&gt;bisect&lt;/code&gt; module &amp;#8212; which is Python&amp;#8217;s binary search implementation.&lt;/p&gt;
&lt;p&gt;At 2.3 the &lt;code&gt;heapq&lt;/code&gt; module appeared, but, like &lt;code&gt;bisect&lt;/code&gt;, there was no way
to customise the ordering of heap elements.&lt;/p&gt;
&lt;p&gt;2.4 introduced the &lt;code&gt;key&lt;/code&gt; argument to customise ordering,
noting this should be preferred to &lt;code&gt;cmp&lt;/code&gt;. Unlike &lt;code&gt;cmp&lt;/code&gt; which compares two
elements, &lt;code&gt;key&lt;/code&gt; takes a single element and returns a sort rank for that element.
The &lt;code&gt;key&lt;/code&gt; argument was added alongside &lt;code&gt;cmp&lt;/code&gt; in &lt;code&gt;list.sort&lt;/code&gt; and the new &lt;code&gt;sorted&lt;/code&gt;
builtin function; and &lt;code&gt;key&lt;/code&gt; was the only way to customise the grouping in
&lt;code&gt;itertools.groupby&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;2.5 added &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;, and also to &lt;code&gt;heapq.nlargest&lt;/code&gt;, &lt;code&gt;heapq.nsmallest&lt;/code&gt;.
Although these &lt;code&gt;heapq&lt;/code&gt; functions now accept a &lt;code&gt;key&lt;/code&gt;, the lower level heap functions
to heapify, push, pop and replace do not.&lt;/p&gt;
&lt;p&gt;2.6 introduced &lt;code&gt;heapq.merge&lt;/code&gt;, a handy function to merge sorted inputs
using a heap, but with no option to specify a sort key.&lt;/p&gt;
&lt;p&gt;3.0 got rid of &lt;code&gt;cmp&lt;/code&gt;, making &lt;code&gt;key&lt;/code&gt; the only way to customise
sorting. To migrate from Python 2 to 3 any &lt;code&gt;cmp&lt;/code&gt; functions need
converting to &lt;code&gt;key&lt;/code&gt; functions. As with Python 2.5, at 3.0 you could
apply a key to &lt;code&gt;list.sort&lt;/code&gt;, &lt;code&gt;sorted&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;,
&lt;code&gt;itertools.groupby&lt;/code&gt;, &lt;code&gt;heapq.nlargest&lt;/code&gt;, &lt;code&gt;heapq.nsmallest&lt;/code&gt; &amp;#8212; but not to
&lt;code&gt;bisect&lt;/code&gt; or other &lt;code&gt;heapq&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;3.5 added &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;heapq.merge&lt;/code&gt;, aligning it with &lt;code&gt;heapq.nlargest&lt;/code&gt;
and &lt;code&gt;heapq.nsmallest&lt;/code&gt;, though it remained impossible to use a sort key
with the lower level heap functions.&lt;/p&gt;
&lt;p&gt;The next change came in 3.10, when the &lt;code&gt;key&lt;/code&gt; parameter was
added to the &lt;code&gt;bisect&lt;/code&gt; module. As far as I can tell that means the only part of
standard Python which doesn&amp;#8217;t let you fully customise ordering is the &lt;code&gt;heapq&lt;/code&gt; module.&lt;/p&gt;
&lt;h2 id=&quot;bisect-with-a-search-key&quot;&gt;Bisect with a search key&lt;/h2&gt;
&lt;p&gt;So, to return to the original puzzle, consider our example
sorted+rotated list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; values = [7, 11, 13, 19, 2, 3, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first four elements are greater than or equal to the first
element, 7. The last three elements are less than 7.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [v &amp;lt; values[0] for v in values]
[False, False, False, False, True, True, True]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;code&gt;False&lt;/code&gt; &amp;lt; &lt;code&gt;True&lt;/code&gt; the result of the list comprehension above is sorted.
Extending this idea, the following comprehension is also sorted.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [(v &amp;lt; values[0], v) for v in values]
[(False, 7), (False, 11), (False, 13), (False, 19), (True, 2), (True, 3), (True, 5)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have a logarithmic lookup using binary search:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from bisect import bisect_left

def lookup(values, v):
    key = lambda x: (x &amp;lt; values[0], x)
    i = bisect_left(values, key(v), key=key)
    return i if (i &amp;lt; len(values) and values[i] == v) else -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;dont-search-for-v-search-for-its-key&quot;&gt;Don&amp;#8217;t search for v, search for its key&lt;/h2&gt;
&lt;p&gt;I was surprised to realise the value &lt;code&gt;v&lt;/code&gt; being looked up has to have the &lt;code&gt;key&lt;/code&gt;
function applied &lt;strong&gt;before&lt;/strong&gt; calling &lt;code&gt;bisect_left&lt;/code&gt;. That is, to find where &lt;code&gt;v&lt;/code&gt;
should go in &lt;code&gt;values&lt;/code&gt; to maintain the sort order, we pass &lt;code&gt;key(v)&lt;/code&gt; to &lt;code&gt;bisect_left&lt;/code&gt;.
This doesn&amp;#8217;t match the interface to binary search in other languages. It also means
in our example we have to handle empty lists as a special case.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def lookup(values, v):
    if not values: return -1
    key = lambda x: (x &amp;lt; values[0], x)
    i = bisect_left(values, key(v), key=key)
    return i if (i &amp;lt; len(values) and values[i] == v) else -1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[*] Before the introduction of the sort &lt;code&gt;key&lt;/code&gt;, the standard pattern was
&lt;a href=&quot;https://docs.python.org/3/howto/sorting.html#the-old-way-using-decorate-sort-undecorate&quot;&gt;decorate-sort-undecorate&lt;/a&gt;.&lt;/p&gt;</description>
<dc:date>2022-02-15</dc:date>
<guid>https://wordaligned.org/articles/binary-search-gets-a-sort-key</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/binary-search-gets-a-sort-key</link>
<category>Puzzles</category>
</item>

<item>
<title>Fearless Debugging</title>
<description>&lt;h2 id=&quot;jurassic-jigsaw&quot;&gt;Jurassic Jigsaw&lt;/h2&gt;
&lt;p&gt;My thanks to &lt;a href=&quot;http://was.tl&quot;&gt;Eric Wastl&lt;/a&gt; for another excellent &lt;a href=&quot;https://adventofcode.com/&quot;&gt;Advent of Code&lt;/a&gt;. I&amp;#8217;ve now &lt;a href=&quot;https://github.com/wordaligned/advent-of-code-2020&quot;&gt;worked through all 25 puzzles&lt;/a&gt;, some simple, some tough, some familiar, some new; all beautifully set and highly enjoyable.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://adventofcode.com/2020/day/20&quot;&gt;Day 20, Jurrasic Jigsaw&lt;/a&gt;, took me longest by far to complete. The puzzle is easy to understand. You have to assemble jigsaw pieces into a seascape. For part one, you need to find the corner pieces. For part two, you must locate monsters in the seascape.&lt;/p&gt;
&lt;p&gt;Here, a jigsaw piece is a monochrome square, represented like so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;..##.#..#.
##..#.....
#...##..#.
####.#...#
##.##.###.
##...#.###
.#.#.#..##
..#....#..
###...#.#.
..###..###
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this is the sea monster:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                   # 
#    ##    ##    ###
 #  #  #  #  #  #
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The twist was that the jigsaw pieces could be rotated and flipped over before matching them up. Once matched, the edges of the pieces were to be removed. Implementing the rotate, flip, match and remove code proved fiddly, and I was pleased to get this working and producing correct results for the supplied example.&lt;/p&gt;
&lt;p&gt;Unfortunately my code produced the wrong answer for part two, the bit where you have to locate sea monsters. So, I would need to debug.&lt;/p&gt;
&lt;h2 id=&quot;fear-of-debugging&quot;&gt;Fear of Debugging&lt;/h2&gt;
&lt;p&gt;Like it or not, debugging is a key part of software development.&lt;/p&gt;
&lt;p&gt;Generally, I do like it. There&amp;#8217;s satisfaction to be had in paring scope, retracing steps, then making the right fix, improving test coverage, and generally leaving the world a better place.&lt;/p&gt;
&lt;p&gt;What I don&amp;#8217;t like, though &amp;#8212; what scares me &amp;#8212; is the suspicion the bug lurks in the worst possible place. What if it&amp;#8217;s in a library we don&amp;#8217;t have the source for? Or if it&amp;#8217;s a timing issue caused by some erratic locking? Or if there&amp;#8217;s an issue with the compiler for the most obscure platform. Or, in this particular case, that the code to fiddle with jigsaw pieces has a bug &amp;#8212; a bug subtle enough to pass the examples but fail the real thing.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s not unreasonable to fear the worst. At some point the issues mentioned above &lt;strong&gt;will&lt;/strong&gt; cause bugs, bugs which &lt;strong&gt;are&lt;/strong&gt; hard to fix. We need to be ready.&lt;/p&gt;
&lt;p&gt;Fear, though, is the wrong mindset. Debugging requires you to be calm, methodical and detached. Much as an artist draws what they see and not what they know, a programmer must observe and follow the evidence. A second pair of eyes is always useful; simply explaining the issue to a colleague gives you another perspective.&lt;/p&gt;
&lt;h2 id=&quot;here-be-monsters&quot;&gt;Here be Monsters&lt;/h2&gt;
&lt;p&gt;I was working on my own on the Advent of Code. I could have tried explaining to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Rubber_duck_debugging&quot;&gt;rubber duck&lt;/a&gt;, but didn&amp;#8217;t. Instead I examined and traced my code. I checked and double-checked the flip, rotate, match and remove logic. I printed out intermediate state. I walked to the sea-front and back. I slept on it.&lt;/p&gt;
&lt;p&gt;Fearing the worst turned out to be the wrong strategy.&lt;/p&gt;
&lt;p&gt;What did work was reading the problem statement again, carefully. At last I saw it! Somehow, a rogue character had wormed its way into my inputs. The sea monster I had used looked like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                   #
#    ##    ##    ###
 #  #  #  #  #  #
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when it should have been:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                  # 
#    ##    ##    ###
 #  #  #  #  #  #
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since both monsters appear the same number of times in the example seascape, my test case failed to catch the bug.&lt;/p&gt;
&lt;p&gt;So, with a single, simple, whitespace correction, my advent of code was complete. One of life&amp;#8217;s ironies is that when you lose something you find it in the last place you look. It&amp;#8217;s not always so with debugging: a bug can exist in many different places and sometimes the fix causes the codebase to unravel, requiring a chain of additional fixes, but, in this case, finding the bug fixed it.&lt;/p&gt;
&lt;p&gt;&lt;image src=&quot;https://wordaligned.org/images/seascape.png&quot; alt=&quot;Seascape with monsters&quot; /&gt;&lt;/p&gt;
&lt;p&gt;A monster can exist in many different places, and in this case finding the monster fixed it&lt;/p&gt;</description>
<dc:date>2021-01-02</dc:date>
<guid>https://wordaligned.org/articles/fearless-debugging</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/fearless-debugging</link>
<category>Puzzles</category>
</item>

<item>
<title>Complex numbers for planar geometry</title>
<description>&lt;p&gt;Once again, I&amp;#8217;m enjoying solving &lt;a href=&quot;http://was.tl&quot;&gt;Eric Wastl&lt;/a&gt;&amp;#8217;s excellent &lt;a href=&quot;https://adventofcode.com&quot;&gt;Advent of Code&lt;/a&gt; puzzles.&lt;/p&gt;
&lt;p&gt;Today, &lt;a href=&quot;day12&quot;&gt;day 12&lt;/a&gt; involved a ship navigating in a 2D plane. The ship follows a series of instructions taking the form of actions and values such as &lt;code&gt;F10 N3 F7 R90 F11 ...&lt;/code&gt;, where, for the first part:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;actions N, S, E, W step by the value in the compass directions N, S, E, W&lt;/li&gt;
&lt;li&gt;actions L, R turn the ship left and right by the number of degrees specified by the value&lt;/li&gt;
&lt;li&gt;action F advances the ship in the direction it faces by the given value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Perhaps the most obvious way to model this is by implementing a &lt;code&gt;Point&lt;/code&gt; class, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; values, and suitable methods to advance and rotate.&lt;/p&gt;
&lt;p&gt;Another way is to use complex numbers, which are natively supported by Python &amp;#8212; and many other languages. The complex plane &lt;em&gt;is&lt;/em&gt; a 2D plane. The point &lt;code&gt;(x, y)&lt;/code&gt; is represented by a single complex number &lt;code&gt;p = x + y * j&lt;/code&gt;. Stepping in any direction corresponds to addition, and rotation to multiplication.&lt;/p&gt;
&lt;p&gt;So, the instructions &lt;code&gt;N, S, E, W&lt;/code&gt; map to adding complex numbers &lt;code&gt;j, -j, 1, -1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Quarter turns left and right map to multiplication by &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;-j&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def ship_position(instructions):
    &amp;#x27;&amp;#x27;&amp;#x27;Return the final position of the ship after following the instructions

    Instructions are a series of (action, value) pairs.
    &amp;#x27;&amp;#x27;&amp;#x27;
    ship, direction = 0, 1 # Start at the origin facing E
    step = {&amp;#x27;N&amp;#x27;:1j, &amp;#x27;W&amp;#x27;:-1, &amp;#x27;S&amp;#x27;:-1j, &amp;#x27;E&amp;#x27;: 1}
    turn = {&amp;#x27;R&amp;#x27;:-1j, &amp;#x27;L&amp;#x27;:1j}
    for action, value in instructions:
        if action in &amp;#x27;NSEW&amp;#x27;:
            ship += value * step[action]
        elif action in &amp;#x27;LR&amp;#x27;:
            assert value % 90 == 0 # check rectilinear motion
            direction *= turn[action] ** (value//90)
        else:
            assert action == &amp;#x27;F&amp;#x27;
            ship += value * direction
    return ship

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s also possible to implement the conditionals above arithmetically. We can think of each instruction advancing the ship (possibly by zero) and turning it (possibly by zero degrees).&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def ship_position(instructions):
    ship, direction = 0, 1
    step = {&amp;#x27;N&amp;#x27;:1j, &amp;#x27;W&amp;#x27;:-1, &amp;#x27;S&amp;#x27;:-1j, &amp;#x27;E&amp;#x27;: 1}
    turn = {&amp;#x27;R&amp;#x27;:-1j, &amp;#x27;L&amp;#x27;:1j}
    for action, value in instructions:
        ship += value * (step.get(action, 0) + (action==&amp;#x27;F&amp;#x27;) * direction)
        direction *= turn.get(action, 1) ** (value//90)
    return ship

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;More solutions &lt;a href=&quot;https://github.com/wordaligned/advent-of-code-2020&quot;&gt;here&lt;/a&gt;, and thanks again to Eric Wastl.&lt;/p&gt;</description>
<dc:date>2020-12-12</dc:date>
<guid>https://wordaligned.org/articles/complex-numbers-for-planar-geometry</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/complex-numbers-for-planar-geometry</link>
<category>Puzzles</category>
</item>

<item>
<title>Cryptic Message</title>
<description>&lt;p&gt;Anyone able to help make sense of this bizarre tweet which appeared on my timeline?&lt;/p&gt;
&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;The challenge is to decipher the message&lt;/p&gt;&amp;mdash; Thomas Guest (@thomasguest) &lt;a href=&quot;https://twitter.com/thomasguest/status/1137215876271415297?ref_src=twsrc%5Etfw&quot;&gt;June 8, 2019&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;Please answer using the same style so others can find their own solution. Bonus points for both quality and quantity.&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://wordaligned.org/images/laboratory.jpg&quot; alt=&quot;Laboratory&quot; title=&quot;Searching for clues&quot; /&gt;&lt;/div&gt;</description>
<dc:date>2019-06-08</dc:date>
<guid>https://wordaligned.org/articles/cryptic-message</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/cryptic-message</link>
<category>Puzzles</category>
</item>

<item>
<title>Dr G&#8217;s Award Winning Puzzles</title>
<description>&lt;p&gt;A colleague of mine shares my love of puzzles. Whilst I like solving them, he also likes to design and build them. What I hadn&amp;#8217;t realised is that there&amp;#8217;s a community of puzzlers out there, who hold conventions, share designs, and generally celebrate and advance the art of puzzling.&lt;/p&gt;
&lt;p&gt;Dr G &amp;#8212; my colleague &amp;#8212; is part of that community and also owns a 3D printer. He works from home but whenever he visits the office there&amp;#8217;ll be a freshly-printed puzzle for us to play with. I feel as excited as a young hobbit when Gandalf visits the Shire.&lt;/p&gt;
&lt;p&gt;The best puzzles have just a few simple pieces. You can see how the parts must finally align but the geometry conspires to confound. There &lt;em&gt;will&lt;/em&gt; be a sequence of twists and turns. There &lt;em&gt;must&lt;/em&gt; be.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/casino-unpacked.jpg&quot; alt=&quot;Casino&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Casino, designed by Dr Volker Latussek, is both mould breaking and an instant classic. You have to slot 6 identical casino chips into a cubic box. The lip which makes the opening to the box rectangular rather than square is the single asymmetry which makes this task almost impossible rather than utterly trivial.&lt;/p&gt;
&lt;p&gt;I fiddled with it, rolling the chips into position, sliding and shunting. After many minutes of manipulation I put it down, the chips loosely arranged in and on top of the box. After a lunch break I picked it up, and to my amazement the chips slid easily and directly into place.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/casino-solved.jpg&quot; alt=&quot;Casino&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/packtic-unpacked.jpg&quot; alt=&quot;PackTIC&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PackTIC, designed by Andrew Crowell is a very different puzzle. The TIC stands for Turning Interlocking Cube. A bit like a 3D version of Tetris, you have to manipulate a 5 very different cubilinear pieces so they fuse into an irregular chassis. I took this one on the train with me. At the end of the journey I had figured out how the pieces would fit, but not how to assemble them. The following morning, as with the Casino puzzle, everything just clicked into place.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/packtic-solved.jpg&quot; alt=&quot;PackTIC&quot;/&gt;&lt;/p&gt;</description>
<dc:date>2019-04-09</dc:date>
<guid>https://wordaligned.org/articles/dr-gs-award-winning-puzzles</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/dr-gs-award-winning-puzzles</link>
<category>Puzzles</category>
</item>

<item>
<title>Advent of Code 2017</title>
<description>&lt;p&gt;A big thanks to &lt;a href=&quot;http://was.tl&quot;&gt;Eric Wastl&lt;/a&gt; for another great &lt;a href=&quot;http://adventofcode.com/2017&quot;&gt;Advent of Code&lt;/a&gt;. Inspired by &lt;a href=&quot;https://github.com/norvig/pytudes/blob/master/ipynb/Advent%20of%20Code.ipynb&quot;&gt;Peter Norvig&lt;/a&gt;, I&amp;#8217;ve published &lt;a href=&quot;https://github.com/wordaligned/advent-of-code-2017/blob/master/advent-of-code-2017.ipynb&quot;&gt;my solutions&lt;/a&gt; as a Jupyter notebook.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wordaligned/advent-of-code-2017/blob/master/advent-of-code-2017.ipynb&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wordaligned/advent-of-code-2017/8e8344b4c5fc00827e42576059f36389dcfa453c/done.png&quot; alt=&quot;Done!&quot;/&gt;&lt;/a&gt;&lt;/p&gt;</description>
<dc:date>2018-01-12</dc:date>
<guid>https://wordaligned.org/articles/advent-of-code-2017</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/advent-of-code-2017</link>
<category>Puzzles</category>
</item>

<item>
<title>24 Puzzles</title>
<description>&lt;p&gt;On &lt;a href=&quot;http://blog.plover.com&quot;&gt;The Universe of Discourse&lt;/a&gt; Mark Dominus discusses the classic &lt;a href=&quot;http://blog.plover.com/math/24-puzzle.html&quot;&gt;24 Puzzle&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given a sequence of four digits, say 1, 2, 3, 4, and your job is to combine them with ordinary arithmetic operations (+, -, &amp;times;, and &amp;divide;) in any order to make a target number, typically 24. For example, with 1, 2, 3, 4, you can go with &lt;code&gt;((1+2)+3)&amp;times;4=24&lt;/code&gt; or with &lt;code&gt;4&amp;times;((2&amp;times;3)&amp;times;1)=24&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here&amp;#8217;s a solver for such puzzles. It uses &lt;code&gt;itertools&lt;/code&gt; to generate possible expressions, &lt;code&gt;fractions&lt;/code&gt; to get the arithmetic right, and &lt;code&gt;eval&lt;/code&gt; to evaluate expressions. It&amp;#8217;s limited to expressions formed from 4 numbers which means I don&amp;#8217;t have to programmatically calculate different ways of parenthesising: there are only 5.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;# http://blog.plover.com/math/24-puzzle.html
import re
import math

# Use fractions for exact calculations
from fractions import Fraction

# Solve for 4 numbers only!
N = 4 

# So these are the only expression templates
# where X is a number and @ is an operation
templates = &amp;#x27;&amp;#x27;&amp;#x27;\
((X @ X) @ X) @ X
(X @ (X @ X)) @ X
X @ ((X @ X) @ X)
X @ (X @ (X @ X))
(X @ X) @ (X @ X)&amp;#x27;&amp;#x27;&amp;#x27;.splitlines()

import itertools as its

def defrac(s):
    return re.compile(r&amp;#x27;Fraction\((\d+)\)&amp;#x27;).sub(r&amp;#x27;\1&amp;#x27;, s)

def evaluate(nums, ops, template):
    fracs = (&amp;#x27;Fraction(%s)&amp;#x27; % n for n in nums)
    ops = iter(ops)
    expr = &amp;#x27;&amp;#x27;.join(next(fracs) if c == &amp;#x27;X&amp;#x27; else
                   next(ops) if c == &amp;#x27;@&amp;#x27; else c
                   for c in template)
    try:
        return expr, eval(expr)
    except ZeroDivisionError:
        return expr, None        

def solve(spec, ops):
    numbers = re.compile(r&amp;#x27;\d+&amp;#x27;).findall(spec)
    assert len(numbers) == N + 1
    result = Fraction(numbers.pop())
    seqs = its.product(its.permutations(numbers),
                       its.product(ops, repeat=N-1),
                       templates)
    print(defrac(next((e for e, v in its.starmap(evaluate, seqs)
                       if v == result),
                      &amp;#x27;Impossible&amp;#x27;)))

def main():
    solve(&amp;#x27;2,5,6,6 =&amp;gt; 17&amp;#x27;, &amp;#x27;+-/*&amp;#x27;)
    solve(&amp;#x27;3,3,8,8 =&amp;gt; 24&amp;#x27;, &amp;#x27;+-/*&amp;#x27;)

main()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a second attempt, which doesn&amp;#8217;t assume there will just be 4 numbers on the left hand side of the equation. Given a sequence of numbers and a set of operators, it repeatedly reduces the sequence length by picking pair of numbers and combining them using one of the operators, iterating over all possible ways of doing this. The first sequence of length 1 which equals the target value gives a solution and terminates the search.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;# http://blog.plover.com/math/24-puzzle.html
from fractions import Fraction
import itertools as its
import operator
import re

def pick2(xs):
    return ((p[:2], p[2:]) for p in its.permutations(xs))

def allow(op, l, r):
    return op != &amp;#x27;/&amp;#x27; or eval(r) != 0

def apply(op, l, r):
    return &amp;#x27;(%s%s%s)&amp;#x27;%(l, op, r)

def values(xs, ops):
    L = [xs]
    while L:
        xs = L.pop()
        if len(xs) == 1:
            yield xs.pop()
        else:
            L.extend([apply(op, *lr)] + list(tl)
                     for op, (lr, tl) in its.product(ops, pick2(xs))
                     if allow(op, *lr))

def solve(spec, ops):
    numbers = [&amp;#x27;Fraction(%s)&amp;#x27;%n for n in re.compile(r&amp;#x27;\d+&amp;#x27;).findall(spec)]
    target = eval(numbers.pop())
    print(next((v for v in values(numbers, ops) if eval(v) == target), &amp;#x27;Impossible&amp;#x27;))

def main():
    solve(&amp;#x27;2,5,6,6 =&amp;gt; 17&amp;#x27;, &amp;#x27;+-/*&amp;#x27;)
    solve(&amp;#x27;3,3,8,8 =&amp;gt; 24&amp;#x27;, &amp;#x27;+-/*&amp;#x27;)

main()

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2017-03-08</dc:date>
<guid>https://wordaligned.org/articles/24-puzzles</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/24-puzzles</link>
<category>Puzzles</category>
</item>

<item>
<title>Python Streams vs Unix Pipes</title>
<description>&lt;p&gt;I chanced upon an interesting puzzle:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Find the smallest number that can be expressed as the sum of 5, 17, 563, 641 consecutive prime numbers, and is itself a prime number.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/primes.png&quot; alt=&quot;Small primes graphic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here, the prime numbers are an infinite steam:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;2, 3, 5, 7, 11, 13 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;and sums of N consecutive primes are similarly infinite. For example, the sum of 2 consecutive primes would be the stream:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;2+3, 3+5, 5+7, 7+11, 11+13 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;which is:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;5, 8, 12, 18, 24 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;and the sum of 3 consecutive primes is:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;10 (=2+3+5), 15, 23, 31 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Had we been asked to find the smallest number which can be expressed as the sum of 3 consecutive primes and as the sum of 5 consecutive primes and is itself prime, the answer would be &lt;code&gt;83&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 23 + 29 + 31
83
&amp;gt;&amp;gt;&amp;gt; 11 + 13 + 17 + 19 + 23
83

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;infinite-series-and-python&quot;&gt;Infinite series and Python&lt;/h3&gt;
&lt;p&gt;My first thought was to tackle this puzzle using Python iterators and generators. Here&amp;#8217;s the outline of a strategy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;starting with a stream of primes&lt;/li&gt;
&lt;li&gt;tee the stream to create 4 additional copies&lt;/li&gt;
&lt;li&gt;transform these copies into the consecutive sums of 5, 17, 563 and 641 primes&lt;/li&gt;
&lt;li&gt;now merge these consecutive sums back with the original primes stream&lt;/li&gt;
&lt;li&gt;group the elements of this merged stream by value&lt;/li&gt;
&lt;li&gt;the first group which contains 5 elements must have occurred in every source, and is therefore a prime and representable as the consecutive sum of 5, 17, 563 and 641 primes&lt;/li&gt;
&lt;li&gt;which solves the puzzle!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that when we copy an infinite stream we cannot consume it first. We will have to be lazy or we&amp;#8217;ll get exhausted.&lt;/p&gt;
&lt;p&gt;Courtesy of the Python Cookbook, I already had a couple of &lt;a href=&quot;http://www.onlamp.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=2&quot;&gt;useful&lt;/a&gt; &lt;a href=&quot;http://code.activestate.com/recipes/491285-iterator-merge/&quot;&gt;recipes&lt;/a&gt; to help implement this strategy:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def primes():
    &amp;#x27;&amp;#x27;&amp;#x27;Generate the sequence of prime numbers: 2, 3, 5 ... &amp;#x27;&amp;#x27;&amp;#x27;
    ....

def stream_merge(*ss):
    &amp;#x27;&amp;#x27;&amp;#x27;Merge a collection of sorted streams.

    Example: merge multiples of 2, 3, 5
    &amp;gt;&amp;gt;&amp;gt; from itertools import count, islice
    &amp;gt;&amp;gt;&amp;gt; def multiples(x): return (x * n for n in count(1))
    &amp;gt;&amp;gt;&amp;gt; s = stream_merge(multiples(2), multiples(3), multiples(5))
    &amp;gt;&amp;gt;&amp;gt; list(islice(s, 10))
    [2, 3, 4, 5, 6, 6, 8, 9, 10, 10]
    &amp;#x27;&amp;#x27;&amp;#x27;
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Both these functions merit a closer look for the cunning use they make of standard containers, but we&amp;#8217;ll defer this inspection until later. In passing, note that &lt;code&gt;stream_merge()&lt;/code&gt;&amp;#8217;s docstring suggests we might try using it as basis for &lt;code&gt;primes()&lt;/code&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;form the series of composite (non-prime) numbers by merging the streams formed by multiples of prime numbers; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the primes remain when you remove these composites from the series of natural numbers.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This scheme is hardly original &amp;#8212; it&amp;#8217;s a variant of &lt;a href=&quot;http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&quot;&gt;Eratosthenes&amp;#8217; sieve&lt;/a&gt; &amp;#8212; but if you look carefully you&amp;#8217;ll notice the self-reference. Unfortunately recursive definitions of infinite series don&amp;#8217;t work well with Python&lt;a id=&quot;fn1link&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn1&quot;&gt;&lt;sup&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;, hence &lt;code&gt;primes()&lt;/code&gt; requires a little more finesse. We&amp;#8217;ll take a look at it later.&lt;/p&gt;
&lt;p&gt;Moving on, to solve the original puzzle we need a consecutive sum filter. This will transform a stream of numbers into a stream of consecutive sums of these numbers:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def consecutive_sum(s, n):
    &amp;#x27;&amp;#x27;&amp;#x27;Generate the series of sums of n consecutive elements of s

    Example: 0, 1, 2, 3, 4 ... =&amp;gt; 0+1, 1+2, 2+3, 3+4, ...
    &amp;gt;&amp;gt;&amp;gt; from itertools import count, islice
    &amp;gt;&amp;gt;&amp;gt; list(islice(consecutive_sum(count(), 2), 10))
    [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    &amp;#x27;&amp;#x27;&amp;#x27;
    lo, hi = itertools.tee(s)
    csum = sum(next(hi) for _ in range(n))
    while True:
        yield csum
        csum += next(hi) - next(lo)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here we can think of the summed elements as lying within a sliding window: each time we slide the window an element gets added to the top and an element gets removed from the bottom, and we adjust &lt;code&gt;csum&lt;/code&gt; accordingly.&lt;/p&gt;
&lt;p&gt;So, now we have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the series of prime numbers, &lt;code&gt;primes()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;stream_merge()&lt;/code&gt; connector&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;consecutive_sum()&lt;/code&gt; filter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The remaining stream adaptors come from the standard &lt;a href=&quot;http://docs.python.org/lib/itertools-functions.html&quot;&gt;itertools module&lt;/a&gt;. Note that the &lt;code&gt;stream_merge()&lt;/code&gt; works here since all the consecutive sum series are strictly increasing. Note also that the stream of prime numbers can be treated as &lt;code&gt;consecutive_sum(s=primes(), n=1)&lt;/code&gt;, handling the &amp;#8220;and is itself a prime number&amp;#8221; requirement.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; lens = 1, 5, 17, 563, 641
&amp;gt;&amp;gt;&amp;gt; N = len(lens)
&amp;gt;&amp;gt;&amp;gt; from itertools import tee, groupby
&amp;gt;&amp;gt;&amp;gt; ps = tee(primes(), N)
&amp;gt;&amp;gt;&amp;gt; csums = [consecutive_sum(p, n) for p, n in zip(ps, lens)]
&amp;gt;&amp;gt;&amp;gt; solns = (n for n, g in groupby(stream_merge(*csums)) 
             if len(list(g)) == N)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;solns&lt;/code&gt; is yet another stream, the result of merging the &lt;code&gt;N&lt;/code&gt; input consecutive sum streams then filtering out the numbers which appear &lt;code&gt;N&lt;/code&gt; times; that is, the numbers which can be expressed as sums of 1, 5, 17, 563 and 641 consecutive primes.&lt;/p&gt;
&lt;p&gt;The first such number solves the original puzzle.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; next(solns)
7002221

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a picture of how these stream tools link up to solve this particular puzzle. The great thing is that we can reconnect these same tools to solve a wide range of puzzles, and indeed more practical &lt;a href=&quot;http://www.dabeaz.com/generators/&quot;&gt;processing tasks&lt;/a&gt;. To use the common analogy, we direct data streams along pipes.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;Stream connections&quot; src=&quot;https://wordaligned.org/images/pipeline.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;infinite-series-in-other-languages&quot;&gt;Infinite series in Other Languages&lt;/h3&gt;
&lt;p&gt;Python is the language I find most convenient most of the time, which explains why I reached for it first. It&amp;#8217;s an increasingly popular language, which helps explain why I didn&amp;#8217;t need to write the tricky parts of my solution from scratch: they&amp;#8217;d already been done. Python is also a language which makes compromises. Having used Python to find a solution to the puzzle I wondered if there wasn&amp;#8217;t some other language better suited to this kind of problem.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; makes no compromises when it comes to functional programming. Its lazy evaluation and inductive recursion make it a perfect fit for this kind of puzzle &amp;#8212; but my  approach of teeing, filtering and merging made me consider the Unix Shell. Now, I use Bash every day and page through its manual at least once a week. Scripting appeals and I&amp;#8217;m comfortable at the command line. How hard could it be to solve this puzzle using Bash? After all, I already knew the answer!&lt;/p&gt;
&lt;h3 id=&quot;partial-sums&quot;&gt;Partial sums.&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple shell function to generate partial sums. I&amp;#8217;ve used &lt;code&gt;awk&lt;/code&gt;, a little language I gave up on a long time ago in favour of more rounded scripting languages like Perl and then Python. Now I look at it again, it seems to fill a useful gap. Awk processes a file sequentially, applying pattern-action rules to each line, a processing template which I&amp;#8217;ve reinvented less cleanly many times. Despite my rediscovery of &lt;code&gt;awk&lt;/code&gt;, I&amp;#8217;ll be keeping its use strongly in check in what follows.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ psum() { awk &amp;#x27;{ print s += $1 }&amp;#x27;; }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Much like Perl, &lt;code&gt;awk&lt;/code&gt; guesses what you want to do. Here, it conjures the summation variable, &lt;code&gt;s&lt;/code&gt;, into existence, assigning it a default initial value of 0. (Good guess!) Since we&amp;#8217;re doing arithmetic &lt;code&gt;awk&lt;/code&gt; converts the first field of each input line into a number. We can test &lt;code&gt;psum&lt;/code&gt; by using &lt;code&gt;jot&lt;/code&gt; to generate the sequence 1, 2, 3, 4, 5 (this is on a Mac &amp;#8212; on a Linux platform use &lt;code&gt;seq&lt;/code&gt; instead of &lt;code&gt;jot&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ jot 5 | psum
1
3
6
10
15

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;consecutive-sums&quot;&gt;Consecutive sums&lt;/h3&gt;
&lt;p&gt;You may be wondering why we&amp;#8217;ve bothered creating this partial sum filter since it&amp;#8217;s the sums of consecutive elements we&amp;#8217;re after, rather than the sum of the series so far. Well, notice that if &lt;code&gt;P[i]&lt;/code&gt; and &lt;code&gt;P[i+n]&lt;/code&gt; are two elements from the series of partial sums of S, then their difference, &lt;code&gt;P[i+n] - P[i]&lt;/code&gt;, is the sum of the &lt;code&gt;n&lt;/code&gt; consecutive elements from S.&lt;/p&gt;
&lt;p&gt;So to form an n-element consecutive sum series we can tee the partial sums streams, advance one of these by n, then zip through them in parallel finding their differences. An example makes things clear:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ mkfifo pipe
$ jot 5 | psum | tee pipe | tail -n +2 | paste - pipe
3       1
6       3
10      6
15      10
        15

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;jot 5&lt;/code&gt; generates the sequence 1, 2, 3, 4, 5, which &lt;code&gt;psum&lt;/code&gt; progressively accumulates to 1, 3, 6, 10, 15. We then &lt;code&gt;tee&lt;/code&gt; this partial sum series through two pipes: the first, &lt;code&gt;pipe&lt;/code&gt;, is an explicitly created named pipe created by &lt;code&gt;mkfifo&lt;/code&gt;, the second is implicitly created by the pipeline operator, &lt;code&gt;|&lt;/code&gt;. The remainder of the command line delays one series by one (note that &lt;code&gt;tail&lt;/code&gt; numbers lines from &lt;code&gt;1&lt;/code&gt;, not &lt;code&gt;0&lt;/code&gt;, so &lt;code&gt;tail -n +1&lt;/code&gt; is the identity filter) then pastes the two series back together&lt;a id=&quot;fn2link&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn2&quot;&gt;&lt;sup&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;By appending a single &lt;code&gt;awk&lt;/code&gt; action to the pipeline we get a consecutive sum series.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ jot 5 | psum | tee pipe | tail -n +2 | paste - pipe | awk &amp;#x27;{print $1 - $2}&amp;#x27;
2
3
4
5
15

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The output 2, 3, 4, 5 is the series of consecutive sums of length 1 taken from the original series 1, 2, 3, 4, 5. The trailing 15 and the 1 missed from the start are edge case problems, and easily corrected.&lt;/p&gt;
&lt;p&gt;Accumulating an increasing series of numbers in order to find the differences between elements lying a given distance apart on this series isn&amp;#8217;t a very smart idea on a computer with a fixed word-size, but it&amp;#8217;s good to know (e.g.) that &lt;code&gt;awk&lt;/code&gt; doesn&amp;#8217;t stop counting at 32 bits.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ let &quot;N=1&amp;lt;&amp;lt;32&quot; &amp;amp;&amp;amp; echo $N | tee &amp;gt;(awk &amp;#x27;{print $1 * $1}&amp;#x27;)
4294967296
18446744073709551616

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Exactly if and when awk stops counting, I&amp;#8217;m not sure. The documentation doesn&amp;#8217;t say and I haven&amp;#8217;t looked at the source code.&lt;/p&gt;
&lt;h3 id=&quot;bug-fixes&quot;&gt;Bug Fixes&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s capture these tiny functions and name them. Here, then, are revised &lt;code&gt;psum()&lt;/code&gt; and &lt;code&gt;sdiff()&lt;/code&gt; filters. The edge case problems should now be fixed.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ psum()  { awk &amp;#x27;BEGIN { print 0 }{print s += $1 }&amp;#x27;; }
$ delay() { let &quot;n = $1 + 1&quot; &amp;amp;&amp;amp; tail +$n; } 
$ sdiff() { mkfifo p.$1 &amp;amp;&amp;amp; tee p.$1 | delay $1 | paste - p.$1 | \
            awk &amp;#x27;NF == 2 {print $1 - $2 }&amp;#x27;; }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A quick test:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ jot 5 | psum | sdiff 3
6
9
12

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The output is, as expected, the series of sums of consecutive triples taken from 1, 2, 3, 4, 5 (6=1+2+3, 9=2+3+4, 12=3+4+5).&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s a pernicious bug, though. These functions can&amp;#8217;t handle infinite series so they are of limited use as pipeline tools. For example, if we stream in the series 0, 1, 2, &amp;#8230; (generated here as the partial sums of the series 1, 1, 1, &amp;#8230;) nothing gets output and we have to interrupt the process.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;# This command appears to hang
$ yes 1 | psum | sdiff 1
^C

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To work around this is, we can use Gnu &lt;code&gt;stdbuf&lt;/code&gt; to prohibit &lt;code&gt;tail&lt;/code&gt; and &lt;code&gt;paste&lt;/code&gt; from using output buffers.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ psum()  { awk &amp;#x27;BEGIN { print 0 }{print s += $1 }&amp;#x27;; }
$ delay() { let &quot;n = $1 + 1&quot; &amp;amp;&amp;amp; stdbuf -o 0 tail +$n; } 
$ sdiff() { mkfifo p.$1 &amp;amp;&amp;amp; tee p.$1 | delay $1 | \
            stdbuf -o 0 paste - p.$1 | \
            awk &amp;#x27;NF == 2 {print $1 - $2 }&amp;#x27;; }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now the data flows again:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;# Accumulate the stream 1 1 1 ...
# and print the difference between successive elements
$ yes 1 | psum | sdiff 1
1
1
1
1
^C

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;merging-streams&quot;&gt;Merging Streams&lt;/h3&gt;
&lt;p&gt;The Unix shell merges streams rather more succinctly than Python. &lt;code&gt;Sort -m&lt;/code&gt; does the job directly. Note that a standard &lt;code&gt;sort&lt;/code&gt; cannot yield any output until all its inputs are exhausted, since the final input item might turn out to be the one which should appear first in the output. Merge sort, &lt;code&gt;sort -m&lt;/code&gt;, can and does produce output without delay&lt;a id=&quot;fn3link&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn3&quot;&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ yes | sort
^C
$ yes | sort -m
y
y
y
y
y
^C

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;generating-primes&quot;&gt;Generating Primes&lt;/h3&gt;
&lt;p&gt;No doubt it&amp;#8217;s possible to generate the infinite series of prime numbers using native Bash code, but I chose to reuse the &lt;a href=&quot;http://www.onlamp.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=2&quot;&gt;Python Cookbook recipe&lt;/a&gt; for the job.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;primes&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#!/usr/bin/env python
import itertools

def primes():
    &amp;#x27;&amp;#x27;&amp;#x27;Generate the prime number series: 2, 3, 5 ... &amp;#x27;&amp;#x27;&amp;#x27;
    D = {}
    for n in itertools.count(2):
        p = D.pop(n, None)
        if p is None:
            yield n
            D[n * n] = n
        else:
            x = n + p
            while x in D:
                x += p
            D[x] = p

for p in primes():
    print(p)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This is a subtle little program which makes clever use of Python&amp;#8217;s native hashed array container, the dictionary. In this case dictionary values are the primes less than &lt;code&gt;n&lt;/code&gt; and the keys are composite multiples of these primes. The loop invariant, roughly speaking, is that the dictionary values are the primes less than &lt;code&gt;n&lt;/code&gt;, and the corresponding keys are the lowest multiples of these primes greater than or equal to &lt;code&gt;n&lt;/code&gt;. It&amp;#8217;s a lazy, recursion-free take of Eratosthenes&amp;#8217; sieve.&lt;/p&gt;
&lt;p&gt;For the purposes of this article the important things about this program are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it generates an infinite series of numbers to standard output&lt;a id=&quot;fn4link&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn4&quot;&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/a&gt;, making it a good source for a shell pipeline&lt;/li&gt;
&lt;li&gt;by making it executable and adding the usual shebang incantation, we can invoke this Python program seamlessly from the shell.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;pipe-connection&quot;&gt;Pipe Connection&lt;/h3&gt;
&lt;p&gt;Recall the original puzzle:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Find the smallest number that can be expressed as the sum of 5, 17, 563, 641 consecutive prime numbers, and is itself a prime number.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First, let&amp;#8217;s check the connections by solving a simpler problem which we can manually verify: to find prime numbers which are also the sum of 2 consecutive primes. As we noted before, this is the same as finding primes numbers which are the consecutive sums of 1 and 2 primes.&lt;/p&gt;
&lt;p&gt;In one shell window we create a couple of named pipes, &lt;code&gt;c.1&lt;/code&gt; and &lt;code&gt;c.2&lt;/code&gt;, which we&amp;#8217;ll use to stream the consecutive sum series of 1 and 2 primes respectively. The results series comprises the duplicates when we merge these pipes.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Shell 1&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ mkfifo c.{1,2}
$ sort -mn c.{1,2} | uniq -d

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In another shell window, stream data into c.1 and c.2:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Shell 2&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ for i in 1 2; do (primes | psum | sdiff $i &amp;gt; c.$i) &amp;amp; done

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In the first window we see the single number &lt;code&gt;5&lt;/code&gt;, which is the first and only prime number equal to the sum of two consecutive primes.&lt;/p&gt;
&lt;p&gt;Prime numbers equal to the sum of three consecutive primes are more interesting. In each shell window recall the previous commands and switch the 2s to 3s (a simple command history recall and edit, &lt;code&gt;^2^3^&lt;/code&gt;, does the trick). The merged output now looks like this:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ sort -mn c.1 c.3 | uniq -d
23
31
41
...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can check the first few values:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;23 = 5 + 7 + 11
31 = 7 + 11 + 13
41 = 11 + 13 + 17

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;At this point we&amp;#8217;re confident enough to give the actual puzzle a try. Start up the solutions stream.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ mkfifo c.{1,5,17,563,641}
$ sort -mn c.{1,5,17,563,641} | uniq -c | grep &quot;5 &quot;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, we use a standard &lt;a href=&quot;https://wordaligned.org/articles/shell-script-sets&quot;&gt;shell script set intersection&lt;/a&gt; recipe: &lt;code&gt;uniq -c&lt;/code&gt; groups and counts repeated elements, and the &lt;code&gt;grep&lt;/code&gt; pattern matches those numbers common to all five input streams.&lt;/p&gt;
&lt;p&gt;Now we can kick off the processes which will feed into the consecutive sum streams, which &lt;code&gt;sort&lt;/code&gt; is waiting on.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ for i in 1 5 17 563 641; do (primes | psum | sdiff $i &amp;gt; c.$i) &amp;amp; done

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Sure enough, after about 15 seconds elapsed time&lt;a id=&quot;fn5link&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn5&quot;&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/a&gt;, out pops the result:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ sort -mn c.{1,5,17,563,641} | uniq -c | grep &quot;5 &quot;
    5 7002221

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;15 seconds seems an eternity for arithmetic on a modern computer (you could start up a word processor in less time!), and you might be inclined to blame the overhead of all those processes, files, large numbers, etc. In fact it took around 6 seconds for the Python program simply to generate prime numbers up to 7002221, and my pure Python solution ran in 9 seconds.&lt;/p&gt;
&lt;h3 id=&quot;portability&quot;&gt;Portability&lt;/h3&gt;
&lt;p&gt;One of the most convenient things about Python is its portability. I don&amp;#8217;t mean &amp;#8220;portable so long as you conform to the language standard&amp;#8221; or &amp;#8220;portable if you stick to a subset of the language&amp;#8221; &amp;#8212; I mean that a Python program works whatever platform I use without me having to worry about it.&lt;/p&gt;
&lt;p&gt;Non-portability put me off the Unix shell when I first encountered it: there seemed too many details, too many platform differences &amp;#8212; which shell are you using? which extensions? which implementation of the core utilities, etc, etc? Readily available and well-written documentation didn&amp;#8217;t help much here: generally I want the shell to just do what I mean, which is why I switched so happily to Perl when I discovered it.&lt;/p&gt;
&lt;p&gt;Since then this situation has, for me, improved in many ways. Non-Unix platforms are declining as are the different flavours of Unix. Bash seems to have become the standard shell of choice and Cygwin gets better all the time. GNU coreutils predominate. As a consequence I&amp;#8217;ve forgotten almost all the Perl I ever knew and am actively rediscovering the Unix shell.&lt;/p&gt;
&lt;p&gt;Writing this article, though, I was reminded of the platform dependent behaviour which used to discourage me. On a Linux platform close to hand I had to use &lt;code&gt;seq&lt;/code&gt; instead of &lt;code&gt;jot&lt;/code&gt;, and &lt;code&gt;awk&lt;/code&gt; formatted large integers in a scientific form with a loss of precision.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Loss of precision&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ echo &amp;#x27;10000000001 0&amp;#x27; | awk &amp;#x27;{print $1 - $2}&amp;#x27;
1e+10

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;On OS X the same command outputs 10000000001. I couldn&amp;#8217;t tell you which implementation is more correct. The fix is to explicitly format these numbers as decimal integers, but the danger is that the shell silently swallows these discrepancies and you&amp;#8217;ve got a portability problem you don&amp;#8217;t even notice.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Precision recovered&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ echo &amp;#x27;10000000001 0&amp;#x27; | awk &amp;#x27;{printf &quot;%d\n&quot;, $1 - $2}&amp;#x27;
10000000001

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;stream-merge&quot;&gt;Stream Merge&lt;/h3&gt;
&lt;p&gt;I mentioned &lt;code&gt;stream_merge()&lt;/code&gt; at the start of this article, a general purpose function written by Raymond Hettinger which I originally found in the Python Cookbook. As with the prime number generator, you might imagine the merge algorithm to be recursively defined:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;to merge a pair of streams, take items from the first which are less than the head of the second, then swap;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;to merge N streams, merge the first stream with the merged (N-1) rest.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Again the Python solution does it differently, this time using a heap as a priority queue of items from the input streams. It&amp;#8217;s ingenious and efficient. Look how easy it is in Python to shunt functions and pairs in and out of queues.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from heapq import heapify, heappop, heapreplace

def stream_merge(*ss):
    &amp;#x27;&amp;#x27;&amp;#x27;Merge a collection of sorted streams.&amp;#x27;&amp;#x27;&amp;#x27;
    pqueue = []
    for i in map(iter, ss):
        try:
            pqueue.append((i.next(), i.next))
        except StopIteration:
            pass
    heapify(pqueue)
    while pqueue:
        val, it = pqueue[0]
        yield val
        try:
            heapreplace(pqueue, (it(), it))
        except StopIteration:
            heappop(pqueue)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A more sophisticated version of this code has made it into the Python standard library, where it goes by the name of &lt;a href=&quot;http://docs.python.org/dev/library/heapq.html#heapq.merge&quot;&gt;heapq.merge&lt;/a&gt; (I wonder why it wasn&amp;#8217;t filed in &lt;a href=&quot;http://docs.python.org/lib/itertools-functions.html&quot;&gt;itertools&lt;/a&gt;?)&lt;/p&gt;
&lt;h3 id=&quot;alternative-solutions&quot;&gt;Alternative Solutions&lt;/h3&gt;
&lt;p&gt;As usual Haskell wins the elegance award, so I&amp;#8217;ll quote in full a solution built without resorting to cookbookery which produces the (correct!) answer in 20 seconds.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;module Main where

import List

isPrime x = all (\i -&amp;gt; 0/=x`mod`i) $ takeWhile (\i -&amp;gt; i*i &amp;lt;= x) primes

primes = 2:filter (\x -&amp;gt; isPrime x) [3..]

cplist n = map (sum . take n) (tails primes)

meet (x:xs) (y:ys) | x &amp;lt; y = meet xs (y:ys)
                   | y &amp;lt; x = meet (x:xs) ys
                   | x == y =  x:meet xs ys

main = print $ head $ \
(primes `meet` cplist 5) `meet` (cplist 17 `meet` cplist 563) `meet` cplist 641

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;a id=&quot;fn1&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn1link&quot;&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/a&gt; CPython, more precisely &amp;#8212; I don&amp;#8217;t think anything in the Python language itself prohibits tail recursion. Even using CPython, yet another &lt;a href=&quot;http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/496691&quot;&gt;recipe&lt;/a&gt; from the online Python Cookbook explores the idea of an &lt;code&gt;@tail_recursion&lt;/code&gt; decorator.&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn2&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn2link&quot;&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/a&gt; &lt;code&gt;Tail&lt;/code&gt; is more commonly used to yield a fixed number of lines from the end of the file: by prefixing the line count argument with a &lt;code&gt;+&lt;/code&gt; sign, it skips lines from the head of the file. The GNU version of &lt;code&gt;head&lt;/code&gt; can similarly be used with a &lt;code&gt;-&lt;/code&gt; prefix to skip lines at the tail of a file. The notation is {compact,powerful,subtle,implementation dependent}.&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn3&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn3link&quot;&gt;[3]&lt;/a&gt; &lt;code&gt;Sort -m&lt;/code&gt; is a sort which doesn&amp;#8217;t really sort &amp;#8212; its inputs should already be sorted &amp;#8212; rather like the &lt;code&gt;+n&lt;/code&gt; option turning &lt;code&gt;tail&lt;/code&gt; on its head.&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn4&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn4link&quot;&gt;[4]&lt;/a&gt; The series is infinite in theory only: at time &lt;code&gt;n&lt;/code&gt; the number of items in the &lt;code&gt;has_prime_factors&lt;/code&gt; dictionary equals the number of primes less than &lt;code&gt;n&lt;/code&gt;, and each key in this dictionary is larger than &lt;code&gt;n&lt;/code&gt;. So resource use increases steadily as &lt;code&gt;n&lt;/code&gt; increases.&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn5&quot; href=&quot;https://wordaligned.org/articles/python-streams-vs-unix-pipes#fn5link&quot;&gt;[5]&lt;/a&gt; I used a MacBook laptop used to run these scripts. &lt;/p&gt;
&lt;pre&gt;
  Model Name:               MacBook
  Model Identifier:         MacBook1,1
  Processor Name:           Intel Core Duo
  Processor Speed:          2 GHz
  Number Of Processors:     1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;</description>
<dc:date>2016-07-28</dc:date>
<guid>https://wordaligned.org/articles/python-streams-vs-unix-pipes</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/python-streams-vs-unix-pipes</link>
<category>Puzzles</category>
</item>

<item>
<title>8 Queens Puzzle++</title>
<description>&lt;p&gt;&lt;a href=&quot;https://wordaligned.org/articles/8-queens-puzzle&quot;&gt;Yesterday I wrote about&lt;/a&gt; a Python solution to the 8 Queens puzzle.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n = 8
sqs = range(n)

Qs = (Q for Q in itertools.permutations(sqs)
      if n == len({Q[i]+i for i in sqs})
           == len({Q[i]-i for i in sqs}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;#8217;s possible to reproduce this strategy in C++:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;range(n) &amp;#8594; &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/iota&quot;&gt;std::iota&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;itertools.permutations &amp;#8594; &lt;a href=&quot;https://wordaligned.org/articles/next-permutation&quot;&gt;std::next_permutation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;set comprehension &amp;#8594; set insertion&lt;/li&gt;
&lt;/ul&gt;
&lt;script src=&quot;https://gist.github.com/wordaligned/c94649d6b37ec08a9bda16e53c43b888.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;The &lt;code&gt;std::next_permutation&lt;/code&gt; algorithm stands alone in the C++ standard library. Used here, it pairs well with the similarly uncommon &lt;code&gt;do ... while&lt;/code&gt; loop. The solution depends on the vector &lt;code&gt;sqs&lt;/code&gt; starting off in sorted order, and by the end of the loop the vector will have been returned to &lt;a href=&quot;https://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort&quot;&gt;this state&lt;/a&gt;.&lt;/p&gt;</description>
<dc:date>2016-04-05</dc:date>
<guid>https://wordaligned.org/articles/8-queens-puzzle-cpp</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/8-queens-puzzle-cpp</link>
<category>Puzzles</category>
</item>

<item>
<title>8 Queens Puzzle</title>
<description>&lt;p style=&quot;font-size:4em&quot;&gt;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&lt;/p&gt;

&lt;p&gt;Here&amp;#8217;s one of my favourite &lt;a href=&quot;http://code.activestate.com/recipes/576647-eight-queens-six-lines&quot;&gt;recipes, by Raymond Hettinger&lt;/a&gt;, lightly adapted for Python 3.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from itertools import permutations

n = width_of_chessboard = 8
sqs = range(n)

Qs = (Q for Q in permutations(sqs)
      if n == len({Q[i]+i for i in sqs})
           == len({Q[i]-i for i in sqs}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We start by assigning &lt;code&gt;sqs&lt;/code&gt; to the range 0 through 7.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sqs = range(8)
&amp;gt;&amp;gt;&amp;gt; list(sqs)
[0, 1, 2, 3, 4, 5, 6, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The range has 8 indices. If each index represents a column on a standard 8x8 chessboard and the value at that index represents a row on the same chessboard, then our range represents 8 positions on the board. Using the built-in &lt;a href=&quot;https://docs.python.org/3/library/functions.html#enumerate&quot;&gt;enumerate&lt;/a&gt; function to generate these &lt;code&gt;(index, value)&lt;/code&gt; pairs we see that &lt;code&gt;sqs&lt;/code&gt; encodes the diagonal &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(7, 7)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(enumerate(sqs))
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, permute the values &amp;#8212; the rows.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; rooks = permutations(sqs)
&amp;gt;&amp;gt;&amp;gt; next(rooks)
(0, 1, 2, 3, 4, 5, 6, 7)
&amp;gt;&amp;gt;&amp;gt; next(rooks)
(0, 1, 2, 3, 4, 5, 7, 6)
&amp;gt;&amp;gt;&amp;gt; next(rooks)
(0, 1, 2, 3, 4, 6, 5, 7)
&amp;gt;&amp;gt;&amp;gt; list(rooks)[34567]
(6, 7, 0, 1, 3, 4, 5, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.permutations&quot;&gt;Itertools.permutations&lt;/a&gt; generates values lazily. The snippet above shows the first two results, then skips forward 34568 places. &lt;code&gt;Permutations(sqs)&lt;/code&gt; generates all possible arrangements of 8 pieces on a chessboard such that each row has exactly one piece on it and so does each column. That is, it generates all possible ways of placing 8 &lt;a href=&quot;http://mathworld.wolfram.com/RooksProblem.html&quot;&gt;rooks on a chessboard&lt;/a&gt; so that no pair attacks each other.&lt;/p&gt;
&lt;p&gt;In the final program, we filter these rook positions to generate solutions to the more challenging &amp;#8212; and more interesting &amp;#8212; &lt;a href=&quot;https://en.wikipedia.org/wiki/Eight_queens_puzzle&quot;&gt;eight Queens puzzle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Consider our starting point, the diagonal &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(7, 7)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; diagonal = range(8)
&amp;gt;&amp;gt;&amp;gt; {r-c for c,r in enumerate(diagonal)}
{0}
&amp;gt;&amp;gt;&amp;gt; {r+c for c,r in enumerate(diagonal)}
{0, 2, 4, 6, 8, 10, 12, 14}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, a set comprehension collects the distinct values taken by the difference between the row and column along this diagonal, which in this case gives &lt;code&gt;{0}&lt;/code&gt;. That is, if we placed 8 bishops along this &amp;#x2197; diagonal they would all attack each other along this diagonal. The sum of the row and column takes 8 distinct values, however, meaning no pair attacks along a &amp;#x2196; diagonal.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#comparisons&quot;&gt;Comparison operators chain in Python&lt;/a&gt;, so the expression:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n == len({Q[i]+i for i in sqs}) == len({Q[i]-i for i in sqs})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is &lt;code&gt;True&lt;/code&gt; if both sets have 8 elements, that is, if the squares in &lt;code&gt;Q&lt;/code&gt; are on distinct &amp;#x2196; and &amp;#x2197; diagonals; or, equivalently no pair of bishops placed on the squares in &lt;code&gt;Q&lt;/code&gt; would attack each other. Since we already know &lt;code&gt;Q&lt;/code&gt; positions 8 rooks so that no pair attacks each other, and a chess Queen combines the moves of a rook and a bishop, we can see that &lt;code&gt;Qs&lt;/code&gt; generates every possible way of placing 8 Queens on a chessboard so that no pair attacks each other: which is to say, we&amp;#8217;ve solved the &lt;a href=&quot;https://en.wikipedia.org/wiki/Eight_queens_puzzle&quot;&gt;8 Queens puzzle&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Qs = (Q for Q in permutations(sqs)
      if n == len({Q[i]+i for i in sqs})
           == len({Q[i]-i for i in sqs}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is beautiful code and there&amp;#8217;s one final twist.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Qs&lt;/code&gt; is a &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#generator-expressions&quot;&gt;generator expression&lt;/a&gt; primed to permute squares into neighbourly rooks filtered by amicable bishops yielding unthreatening Queens. Until asked, however, it does nothing.&lt;/p&gt;
&lt;p style=&quot;font-size:4em&quot;&gt;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&lt;/p&gt;</description>
<dc:date>2016-04-04</dc:date>
<guid>https://wordaligned.org/articles/8-queens-puzzle</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/8-queens-puzzle</link>
<category>Puzzles</category>
</item>

<item>
<title>Sausages, sausages, sausages - slice, slice, slice</title>
<description>&lt;p&gt;A friend asked for help reaching the next level of a puzzle game. The test which stalled her involves machine placement in a sausage factory.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;#8230; each sausage was branded with a letter for quality control purposes, thus:
&lt;strong&gt;ypbtkizfgxptclcoirdsuhjwulqkoszrabfc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The string was then drawn through seven machines which rearranged the sausages in flavour enhancing ways.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine A: The Reversifier&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Reverses the order of the sausages, so they get tastier as you go along.&lt;/p&gt;
&lt;p&gt;&amp;#8230;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine G: Secondhalffirstifier&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;move the second half of the string to the beginning, as the earlier sausages are too spicy to eat early in the morning.&lt;/p&gt;
&lt;p&gt;He attached these machines in a certain sequence, though one of them was out for repair so only six were used. He then fed a string of sausages through and was surprised to discover the string that came out at the other end said &lt;strong&gt;lickyourlips&lt;/strong&gt;. What order were the machines in?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It&amp;#8217;s nicely phrased, but what&amp;#8217;s really wanted is the sequence of simple transformations that takes input &amp;#8220;ypbtkizfgxptclcoirdsuhjwulqkoszrabfc&amp;#8221; and produces output &amp;#8220;lickyourlips&amp;#8221;.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s no doubt possible to work backwards and figure out a solution using no more than logic, pencil and paper. For example, only two of the machines change the length of the string, and &amp;#8212; looking at the before and after lengths &amp;#8212; these must both be used. It&amp;#8217;s rather easier to write a short program to find a solution.&lt;/p&gt;
&lt;p&gt;First we must simulate the seven sausage machines, A-G, which perform the following sequence operations.&lt;/p&gt;
&lt;ol type=&quot;A&quot;&gt;
&lt;li&gt;reverse the order of a sequence&lt;/li&gt;
&lt;li&gt;remove every other element of a sequence&lt;/li&gt;
&lt;li&gt;remove every third element of a sequence&lt;/li&gt;
&lt;li&gt;pairwise reverse elements of a sequence&lt;/li&gt;
&lt;li&gt;move even numbered elements to the front of a sequence&lt;/li&gt;
&lt;li&gt;move the last element of a sequence to the front&lt;/li&gt;
&lt;li&gt;swap the front and back half of a sequence&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;None of these is difficult, especially in a high-level language which builds in support for sequence operations. What I found noteworthy is that a solution can be found without any &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html&quot;&gt;loops or if statements&lt;/a&gt;. What&amp;#8217;s more, every operation can handled using nothing more than &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range&quot;&gt;slice operations&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s my solution. The machines consist of slice operations, helped by a couple of conditional expressions and recursive calls. The solution can then be brute-forced: there are only 5040 ways of permuting 6 out of 7 machines.&lt;/p&gt;
&lt;script src=&quot;https://gist.github.com/wordaligned/a04308eac7ee2aa37e01.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;I&amp;#8217;ve used &lt;code&gt;reduce&lt;/code&gt; to apply a chain of functions to a string of sausages &amp;#8212; an explicit loop might be clearer, but I want a loop-free solution. For this same reason I use recursion in the pairwise swapper and the element dropper. Generally in Python, recursion is a poor choice. In this case I know I&amp;#8217;m starting with a string of just 36 elements which cannot get any longer; there&amp;#8217;s no risk of exceeding the &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.getrecursionlimit&quot;&gt;system recursion limit&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The sequence reversal &lt;code&gt;s[::-1]&lt;/code&gt; is idiomatic but alarming to the uninitiated. Slices have &lt;code&gt;[start:stop:stride]&lt;/code&gt; fields, any of which may be defaulted. Usually &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; default to the start and end of the sequence, but in this case the negative stride reverses them.&lt;/p&gt;
&lt;p&gt;To rotate the last element of a sequence to the front, prefer:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return s[-1:] + s[:-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return [s[-1]] + s[:-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;because the latter raises an &lt;code&gt;IndexError&lt;/code&gt; for an empty sequence.&lt;/p&gt;
&lt;p&gt;Slicing is a formidable tool for sequence manipulation, especially when combined with the option of using negative indices to count back from the end. Slices allow you to reverse, rotate and partition sequences, to pairwise swap elements, and to drop every nth element.&lt;/p&gt;
&lt;p&gt;The miniature recipes presented here don&amp;#8217;t even use slice assignment, which gives me an excuse to reproduce this elegant prime sieve function, which does.&lt;/p&gt;
&lt;script src=&quot;https://gist.github.com/wordaligned/09c17eaabb6cd4c6bcfb.js&quot;&gt;&lt;/script&gt;</description>
<dc:date>2016-03-21</dc:date>
<guid>https://wordaligned.org/articles/sausages-slices</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/sausages-slices</link>
<category>Puzzles</category>
</item>

<item>
<title>Reverse, Esrever</title>
<description>&lt;p&gt;&lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/reverse&quot;&gt;Reverse&lt;/a&gt;&lt;/code&gt; is a member of the C++ standard library, but its reverse, &lt;code&gt;esrever&lt;/code&gt;, isn&amp;#8217;t. Similarly &lt;code&gt;keep&lt;/code&gt; isn&amp;#8217;t but &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/basic_istream/peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; is.&lt;/p&gt;
&lt;p&gt;Can anyone think of a C++ standard library member whose reverse &lt;strong&gt;is also a member&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Answers in the comments below.&lt;/p&gt;
&lt;p&gt;Go!&lt;/p&gt;</description>
<dc:date>2013-09-27</dc:date>
<guid>https://wordaligned.org/articles/reverse-esrever</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/reverse-esrever</link>
<category>Puzzles</category>
</item>

<item>
<title>Clown, Flee, Jump</title>
<description>&lt;p&gt;The clown is running away from the circus. The contortionist wants nothing more to do with him. She&amp;#8217;s confessed everything to her husband, the strongman, who&amp;#8217;s after the clown&amp;#8217;s blood. The clown has no time to pack. Hurrying from the big top he snatches up his most treasured possessions and some refreshments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a makeup case&lt;/li&gt;
&lt;li&gt;a box camera, with tripod attached&lt;/li&gt;
&lt;li&gt;a cactus&lt;/li&gt;
&lt;li&gt;a roasted goose&lt;/li&gt;
&lt;li&gt;a magnum of champagne&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each item weighs exactly 3kg.&lt;/p&gt;
&lt;p&gt;Soon he reaches the edge of a ravine. A rope bridge connected to the other side has a sign in front of it.&lt;/p&gt;
&lt;pre style=&quot;align:center;width:400px;border: 2px solid red; background: white;font-size:200%;&quot;&gt;WARNING
UNSTABLE STRUCTURE
SAFE TO A MAXIMUM OF 75KG&lt;/pre&gt;

&lt;p&gt;The bridge is 100m long. The clown weighs 70kg. The strongman, who&amp;#8217;s closing in, weighs considerably more. The clown must cross the bridge at once to effect his escape. &lt;strong&gt;How can he do so without abandoning any of his baggage&lt;/strong&gt;?&lt;/p&gt;
&lt;p style=&quot;text-align:center;font-size:200%&quot;&gt;?&lt;/p&gt;

&lt;p&gt;Elsewhere, it&amp;#8217;s school sports day. Conditions are perfect for the high jump &amp;#8212; warm, sunny, still &amp;#8212; and a talented young athlete has raised the bar to 1.85m, which happens to be his own height. On the first two attempts he fails. On the third attempt he succeeds.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;High Jump&quot; src=&quot;https://wordaligned.org/images/high-jump.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&amp;#8220;Chapeau!&amp;#8221; says the French teacher.&lt;/p&gt;
&lt;p&gt;&amp;#8220;Awesome!&amp;#8221; says the Chaplain.&lt;/p&gt;
&lt;p&gt;&amp;#8220;Unbelievable!&amp;#8221; says the head of Mathematics.&lt;/p&gt;
&lt;p&gt;&amp;#8220;Actually,&amp;#8221; the sports coach says, &amp;#8220;it&amp;#8217;s quite simple: a combination of talent, training, and technique. He cleared his own height &lt;strong&gt;but his centre of gravity didn&amp;#8217;t&lt;/strong&gt;.&amp;#8221;&lt;/p&gt;
&lt;p&gt;&amp;#8220;What nonsense!&amp;#8221; says the mathematician.&lt;/p&gt;
&lt;p style=&quot;text-align:center;font-size:300%&quot;&gt;??&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Grimaldi&quot; src=&quot;https://wordaligned.org/images/grimaldi.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The clown barely breaks stride. Juggling with mismatched objects is part of his act and quick as a flash case, camera, cactus, fowl and fizz are in the air. At no point does he have more than one object in either hand so his weight never exceeds 73kg. The bridge holds. The clown gets away.&lt;/p&gt;
&lt;p&gt;&amp;#8220;Grrrr!&amp;#8221; says the strongman, shaking his fists.&lt;/p&gt;
&lt;p style=&quot;text-align:center;font-size:400%&quot;&gt;???&lt;/p&gt;</description>
<dc:date>2013-09-11</dc:date>
<guid>https://wordaligned.org/articles/clown-flee-jump</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/clown-flee-jump</link>
<category>Puzzles</category>
</item>

<item>
<title>Patience Sorted</title>
<description>&lt;p&gt;I gave a lightning talk today about patience sorting and its application to the longest increasing subsequence problem. It&amp;#8217;s a subject I&amp;#8217;ve &lt;a href=&quot;https://wordaligned.org/articles/patience-sort.html&quot; title=&quot;Patience sort and the longest increasing subsequence&quot;&gt;written about&lt;/a&gt; before. My computer has been put through several million simulations. I&amp;#8217;ve even coded up a &lt;a href=&quot;https://wordaligned.org/pages/psort&quot;&gt;javascript demo&lt;/a&gt; which deals out virtual playing cards and sorts them at the click of a button.&lt;/p&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://wordaligned.org//ajax.googleapis.com/ajax/libs/jquery/1.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var zz = 0;

var xtop  = [&quot;330px&quot;, &quot;302px&quot;, &quot;275px&quot;, &quot;255px&quot;, &quot;234px&quot;, &quot;209px&quot;, &quot;187px&quot;, &quot;158px&quot;, &quot;128px&quot;, &quot;99px&quot;, &quot;70px&quot;, &quot;43px&quot;, &quot;15px&quot;];
var ytop  = [&quot;26px&quot;, &quot;30px&quot;, &quot;28px&quot;, &quot;29px&quot;, &quot;31px&quot;, &quot;28px&quot;, &quot;27px&quot;, &quot;28px&quot;, &quot;28px&quot;, &quot;30px&quot;, &quot;26px&quot;, &quot;30px&quot;, &quot;29px&quot;];
var xpile = [&quot;10px&quot;, &quot;13px&quot;, &quot;12px&quot;, &quot;115px&quot;, &quot;14px&quot;, &quot;220px&quot;, &quot;220px&quot;, &quot;319px&quot;, &quot;15px&quot;, &quot;216px&quot;, &quot;118px&quot;, &quot;118px&quot;, &quot;321px&quot;];
var ypile = [&quot;205px&quot;, &quot;233px&quot;, &quot;266px&quot;, &quot;206px&quot;, &quot;295px&quot;, &quot;206px&quot;, &quot;236px&quot;, &quot;209px&quot;, &quot;325px&quot;, &quot;267px&quot;, &quot;235px&quot;, &quot;263px&quot;, &quot;234px&quot;];
var result = [&quot;#card7&quot;, &quot;#card6&quot;, &quot;#card3&quot;, &quot;#card2&quot;];

function reset_cards() {
    jQuery(&quot;img&quot;).stop();
    zz += 13;
    for (var j = 0; j != 13; ++j, --zz) {
        jQuery(&quot;#card&quot; + j)
        .css({&quot;z-index&quot;:zz, &quot;margin-left&quot;:xtop[j], &quot;margin-top&quot;:ytop[j], &quot;border-width&quot;:0});
    }
    zz += 13;
}

function lis(j) {
    var it = jQuery(result[j]);
    if (it.length &gt; 0) {
        it.animate({borderWidth : &quot;5px&quot;}, &quot;slow&quot;, 0, function(){lis(++j);});
    }
}

function psort(j) {
    var it = jQuery(&quot;#card&quot;+j);
    if (it.length != 0) {
        it
        .animate({marginLeft : xpile[j], marginTop: ypile[j]}, &quot;slow&quot;, 0, function(){psort(++j);})
        .css({&quot;z-index&quot; : ++zz});
    } else {
        lis(0);
    }
}

function animate_cards() {
    reset_cards();
    psort(0);
}
&lt;/script&gt;

&lt;div class=&quot;cardtable&quot; style=&quot;background-color: #093; width:440px; height:480px;&quot;&gt;
&lt;img id=&quot;card0&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 330px; margin-top: 27px; z-index: 13;&quot; src=&quot;https://wordaligned.org/images/cards/1s.png&quot; alt=&quot;Ace of Spades&quot;/&gt;
&lt;img id=&quot;card1&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 302px; margin-top: 27px; z-index: 12;&quot; src=&quot;https://wordaligned.org/images/cards/10s.png&quot; alt=&quot;10 of Spades&quot;/&gt;
&lt;img id=&quot;card2&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 275px; margin-top: 27px; z-index: 11;&quot; src=&quot;https://wordaligned.org/images/cards/6s.png&quot; alt=&quot;6 of Spades&quot;/&gt;
&lt;img id=&quot;card3&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 255px; margin-top: 26px; z-index: 10;&quot; src=&quot;https://wordaligned.org/images/cards/7s.png&quot; alt=&quot;7 of Spades&quot;/&gt;
&lt;img id=&quot;card4&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 234px; margin-top: 28px; z-index: 9;&quot; src=&quot;https://wordaligned.org/images/cards/5s.png&quot; alt=&quot;5 of Spades&quot;/&gt;
&lt;img id=&quot;card5&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 209px; margin-top: 26px; z-index: 8;&quot; src=&quot;https://wordaligned.org/images/cards/13s.png&quot; alt=&quot;King of Spades&quot;/&gt;
&lt;img id=&quot;card6&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 187px; margin-top: 31px; z-index: 7;&quot; src=&quot;https://wordaligned.org/images/cards/9s.png&quot; alt=&quot;9 of Spades&quot;/&gt;
&lt;img id=&quot;card7&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 158px; margin-top: 27px; z-index: 6;&quot; src=&quot;https://wordaligned.org/images/cards/12s.png&quot; alt=&quot;Queen of Spades&quot;/&gt;
&lt;img id=&quot;card8&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 128px; margin-top: 29px; z-index: 5;&quot; src=&quot;https://wordaligned.org/images/cards/2s.png&quot; alt=&quot;2 of Spades&quot;/&gt;
&lt;img id=&quot;card9&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 99px; margin-top: 29px; z-index: 4;&quot; src=&quot;https://wordaligned.org/images/cards/8s.png&quot; alt=&quot;8 of Spades&quot;/&gt;
&lt;img id=&quot;card10&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 70px; margin-top: 26px; z-index: 3;&quot; src=&quot;https://wordaligned.org/images/cards/4s.png&quot; alt=&quot;4 of Spades&quot;/&gt;
&lt;img id=&quot;card11&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 43px; margin-top: 27px; z-index: 2;&quot; src=&quot;https://wordaligned.org/images/cards/3s.png&quot; alt=&quot;3 of Spades&quot;/&gt;
&lt;img id=&quot;card12&quot; style=&quot;border: 0 orange solid; position: absolute; margin-left: 15px; margin-top: 28px; z-index: 1;&quot; src=&quot;https://wordaligned.org/images/cards/11s.png&quot; alt=&quot;Knave of Spades&quot;/&gt;
&lt;/div&gt;
&lt;div&gt;&lt;p&gt;&lt;button onclick=&quot;reset_cards();&quot;&gt;Reset&lt;/button&gt;&lt;button onclick=&quot;animate_cards();&quot;&gt;Play&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Today I used real playing cards; a linen-finished standard deck. For any talk it&amp;#8217;s nice to have a prop.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/thomasguest/8558343442/&quot; title=&quot;Rock &amp;amp; Pop Legends by Thomas Guest, on Flickr&quot;&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8100/8558343442_0402f04e83.jpg&quot; width=&quot;500&quot; height=&quot;361&quot; alt=&quot;Rock &amp;amp; Pop Legends&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now, I &lt;strong&gt;thought&lt;/strong&gt; I understood the patience sort algorithm but until yesterday I&amp;#8217;d never actually played it with real cards. I&amp;#8217;ve been surprised by how much this physical dimension has developed my understanding.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ll be testing my new cards on some other sorting algorithms; I have high hopes. It would be good to find a similarly simple prop for linked data structures so I can balance trees, flip lists and walk graphs.&lt;/p&gt;</description>
<dc:date>2013-03-14</dc:date>
<guid>https://wordaligned.org/articles/patience-sorted</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/patience-sorted</link>
<category>Puzzles</category>
</item>

<item>
<title>Next permutation: When C++ gets it right</title>
<description>&lt;h3 id=&quot;the-next-number-problem&quot;&gt;The Next Number Problem&lt;/h3&gt;
&lt;p&gt;Suppose you have a fixed list of digits chosen from the range 1..9. What numbers can you make with them? You&amp;#8217;re allowed as many zeros as you want. Write the numbers in increasing order.&lt;/p&gt;
&lt;p&gt;Exactly &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=p1&quot;&gt;this puzzle&lt;/a&gt; came up in the recent &lt;a href=&quot;http://code.google.com/codejam&quot;&gt;Google Code Jam&lt;/a&gt; programming contest:&lt;/p&gt;
&lt;blockquote&gt;You are writing out a list of numbers. Your list contains all numbers with exactly &lt;strong&gt;D&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt; digits in its decimal representation which are equal to i, for each i between 1 and 9, inclusive. You are writing them out in ascending order.&lt;/p&gt;&lt;p&gt;For example, you might be writing every number with two &amp;#8216;1&amp;#8217;s and one &amp;#8216;5&amp;#8217;. Your list would begin 115, 151, 511, 1015, 1051.&lt;/p&gt;&lt;p&gt;Given N, the last number you wrote, compute what the next number in the list will be.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The competition has closed now, but if you&amp;#8217;d like to give it a go sample input files can be found on the &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=p1&quot;&gt;website&lt;/a&gt;, where you can also upload your results and have them checked.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a short section from a trial I ran on my computer. Input numbers are in the left-hand column: the corresponding output numbers are in the right-hand column.&lt;/p&gt;
&lt;pre style=&quot;font-size:150%&quot;&gt;
50110812884911623516 &amp;rarr; 50110812884911623561
82454322474161687049 &amp;rarr; 82454322474161687094
82040229261723155710 &amp;rarr; 82040229261723157015
43888989554234187388 &amp;rarr; 43888989554234187838
76080994872481480636 &amp;rarr; 76080994872481480663
31000989133449480678 &amp;rarr; 31000989133449480687
20347716554681051891 &amp;rarr; 20347716554681051918
&lt;/pre&gt;

&lt;h3 id=&quot;choice-of-algorithm&quot;&gt;Choice of Algorithm&lt;/h3&gt;
&lt;p&gt;Like many of the code jam challenges, you&amp;#8217;ll need to write a program which runs fast enough; but choosing the right algorithm is more important than choosing the right language. Typically a high-level interpreted language like Python allows me to code and test a solution far more quickly than using a low-level language like C or C++.&lt;/p&gt;
&lt;p&gt;In this particular case, though, like most &lt;a href=&quot;http://www.go-hero.net/jam/09/problems/2/2&quot;&gt;successful candidates&lt;/a&gt;, I used C++. &lt;a href=&quot;http://www.sgi.com/tech/stl/next_permutation.html&quot;&gt;Here&amp;#8217;s why&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sgi.com/tech/stl/next_permutation.html&quot;&gt;&lt;code&gt;Next_permutation&lt;/code&gt;&lt;/a&gt; transforms the range of elements &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically next greater permutation of the elements. [&amp;#8230;] If such a permutation exists, &lt;code&gt;next_permutation&lt;/code&gt; transforms &lt;code&gt;[first, last)&lt;/code&gt; into that permutation and returns true. Otherwise it transforms &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically smallest permutation and returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Although the next number problem appears to be about numbers and lexicographical ordering appears to be about words, &lt;code&gt;std::next_permutation&lt;/code&gt; is exactly what&amp;#8217;s needed here.&lt;/p&gt;
&lt;h3 id=&quot;lexicographical-ordering&quot;&gt;Lexicographical Ordering&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/thomasguest/4099819327/&quot; title=&quot;Lexicographical order by Thomas Guest, on Flickr&quot;&gt;&lt;img src=&quot;http://farm3.static.flickr.com/2449/4099819327_4063635302.jpg&quot; width=&quot;500&quot; height=&quot;216&quot; alt=&quot;Lexicographical order&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A dictionary provides the canonical example of lexicographical ordering. Words are built from characters, which can be alphabetically ordered A, B, C, &amp;#8230; , so in the dictionary words which begin with &lt;strong&gt;A&lt;/strong&gt; appear before words which begin with &lt;strong&gt;B&lt;/strong&gt;, which themselves come in front of words beginning with &lt;strong&gt;C&lt;/strong&gt;, etc. If two words start with the same letter, pop that letter from the head of the word and compare their tails, which puts AARDVARK before ANIMAL, and &amp;#8212; applying this rule recursively &amp;#8212; after &lt;a href=&quot;http://www.aardman.com/&quot; title=&quot;Bristol&#x27;s finest&quot;&gt;AARDMAN&lt;/a&gt;. Imagine there&amp;#8217;s an empty word marking position zero, before A, right at the front of the dictionary, and our recursive  definition is complete.&lt;/p&gt;
&lt;h3 id=&quot;next-permutation-in-action&quot;&gt;Next permutation in action&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple program which shows &lt;code&gt;next_permutation()&lt;/code&gt; in action.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int main()
{
    char xs[] = &quot;123&quot;;
    do
    {
        std::puts(xs);
    }
    while (std::next_permutation(xs, xs + sizeof(xs) - 1));
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This program outputs lexicographically ordered permutations of 1, 2 and 3. When the main function returns, the array &lt;code&gt;xs&lt;/code&gt; will have cycled round to hold the lexicographically smallest arrangement of its elements, which is &lt;code&gt;&quot;123&quot;&lt;/code&gt;. Note that we never convert the characters &lt;code&gt;&#x27;1&#x27;&lt;/code&gt;, &lt;code&gt;&#x27;2&#x27;&lt;/code&gt;, &lt;code&gt;&#x27;3&#x27;&lt;/code&gt; into the numbers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;. The values of both sets of data types appear in the same order, so all works as expected.&lt;/p&gt;
&lt;pre&gt;
123
132
213
231
312
321
&lt;/pre&gt;

&lt;p&gt;If we tweak and rerun the same program with &lt;code&gt;xs&lt;/code&gt; initialised to &lt;code&gt;&quot;AAADKRRV&quot;&lt;/code&gt; we get rather more output.&lt;/p&gt;
&lt;pre&gt;
AAADKRRV
AAADKRVR
AAADKVRR
...
AARDVARK
...
VRRKAADA
VRRKADAA
VRRKDAAA
&lt;/pre&gt;

&lt;p&gt;The sequence &lt;strong&gt;doesn&amp;#8217;t&lt;/strong&gt; start by repeating &lt;code&gt;&quot;AAADKRRV&quot;&lt;/code&gt; 6 times, once for every permutation of the 3 A&amp;#8217;s. Only strictly increasing permutations are included. And although the repeated calls to &lt;code&gt;next_permutation&lt;/code&gt; generate a series of permutations, the algorithm holds no state. Each function call works on its input range afresh.&lt;/p&gt;
&lt;p&gt;This second run of the program yields 3360 lines of output, even though there are 8! = 40320 possible permutations of 8 characters. Each unique permutation corresponds to 3! &amp;times; 2! = 12 actual permutations of the 8 characters (because there are 3 A&amp;#8217;s and 2 R&amp;#8217;s), and 40320 &amp;divide; 12 is 3360.&lt;/p&gt;
&lt;h3 id=&quot;snail-sorts-revenge&quot;&gt;Snail sort&amp;#8217;s revenge&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/tim_norris/2789759648/&quot;&gt;&lt;img src=&quot;http://farm4.static.flickr.com/3143/2789759648_ab4bfb5ea8.jpg&quot; width=&quot;500px&quot; height=&quot;333px&quot; alt=&quot;...and in last place. By Tim Norris&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As you can see, &lt;code&gt;next_permutation&lt;/code&gt; sorts an input range, one step at a time.  When &lt;code&gt;next_permutation&lt;/code&gt; eventually returns false, the range will be perfectly ordered. Hence we have &lt;code&gt;snail_sort()&lt;/code&gt;, hailed by the SGI STL &lt;a href=&quot;http://www.sgi.com/tech/stl/next_permutation.html&quot;&gt;documentation&lt;/a&gt; as the worst known deterministic sorting algorithm.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template &amp;lt;class Iter&amp;gt; 
void snail_sort(Iter first, Iter last)
{
    while (next_permutation(first, last)) {}
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Very witty, and evidence that code can be both &lt;a href=&quot;https://wordaligned.org/articles/elegance-and-efficiency.html&quot;&gt;elegant and inefficient&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In two important edge cases, though, &lt;code&gt;snail_sort&lt;/code&gt; performs on a par with super-charged &lt;code&gt;quicksort&lt;/code&gt;!&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I snail sorted an array filled with 100000000 zeros in 0.502 seconds. Running quicksort on the same array took 5.504 seconds. &lt;/li&gt;
&lt;li&gt;Starting with an array of the same size filled with the values 99999999, 99999998, 99999997, &amp;#8230; 1, 0 snail sort&amp;#8217;s 0.500 seconds trounced quicksort&amp;#8217;s 4.08 seconds.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;the-next-number-solved&quot;&gt;The Next Number, Solved&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s an outline solution to the &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=p1&quot;&gt;next number problem&lt;/a&gt;. (I&amp;#8217;ve glossed over the exact input and output file formats for clarity.) It reads numbers from standard input and writes next numbers to standard output. &lt;code&gt;Next_permutation&lt;/code&gt; does the hard work, and there&amp;#8217;s a bit of fiddling when we have to increase the number of digits by adding a zero.&lt;a id=&quot;fn1link&quot; href=&quot;https://wordaligned.org/articles/next-permutation#fn1&quot;&gt;&lt;sup&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

/*
 Given a string of digits, shift any leading &amp;#x27;0&amp;#x27;s
 past the first non-zero digit and insert an extra zero.

 Examples:

 123 -&amp;gt; 1023
 008 -&amp;gt; 8000
 034 -&amp;gt; 3004
*/
void insert_a_zero(std::string &amp;amp; number)
{
    size_t nzeros = number.find_first_not_of(&amp;#x27;0&amp;#x27;);
    number = number.substr(nzeros);
    number.insert(1, nzeros + 1, &amp;#x27;0&amp;#x27;);
}

/*
 Outline solution to the 2009 code jam Next Number problem.

 Given a string representing a decimal number, find the next
 number which can be formed from the same set of digits. Add
 another zero if necessary. Repeat for all such strings read
 from standard input.
*/
int main()
{
    std::string number;
    while (std::cin &amp;gt;&amp;gt; number)
    {
        if (!next_permutation(number.begin(), number.end()))
        {
            insert_a_zero(number);
        }
        std::cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    }
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;implementation&quot;&gt;Implementation&lt;/h3&gt;
&lt;p&gt;Having used the C++ standard library to solve the puzzle, let&amp;#8217;s take a look at how it works. Next permutation is a clever algorithm which shuffles a collection in place. My system implements it like this&lt;a id=&quot;fn2link&quot; href=&quot;https://wordaligned.org/articles/next-permutation#fn2&quot;&gt;&lt;sup&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;

    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We start with a range delimited by a pair of bi-directional iterators, &lt;code&gt;[first, last)&lt;/code&gt;. If the range contains one item or fewer, there can be no next permutation, so leave the range as is and return &lt;code&gt;false&lt;/code&gt;. Otherwise, enter the &lt;code&gt;for&lt;/code&gt; loop with an iterator &lt;code&gt;i&lt;/code&gt; pointing at the final item in the range.&lt;/p&gt;
&lt;p&gt;At each pass through the body of this for loop we decrement &lt;code&gt;i&lt;/code&gt; by one, stepping towards the first item in the range. We are looking for one of two conditions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the value pointed to by &lt;code&gt;i&lt;/code&gt; is smaller than the one it pointed to previously&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; reaches into the first item in the range&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Put another way, we divide the range into a head and tail, where the tail is the longest possible decreasing tail of the range.&lt;/p&gt;
&lt;p&gt;If this tail is the whole range (the second condition listed above) then the whole range is in reverse order, and we have the lexicographical maximum formed from its elements. Reversing the range returns it to its lexicographical minimum, and we can return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If this tail is not the whole range, then the final item in the head of the range, the item &lt;code&gt;i&lt;/code&gt; points to, this item is smaller than at least one of the items in the tail of the range, and we can certainly generate a greater permutation by moving the item towards the end of the range. To find the next permutation, we reverse iterate from the end of the range until we find an item &lt;code&gt;*j&lt;/code&gt; bigger than &lt;code&gt;*i&lt;/code&gt; &amp;#8212; that&amp;#8217;s what the while loop does. Swapping the items pointed to by &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; ensures the head of the range is bigger than it was, and the tail of the range remains in reverse order. Finally, we reverse the tail of the range, leaving us with a permutation exactly one beyond the input permutation, and we return &lt;code&gt;true&lt;/code&gt;. &lt;/p&gt;
&lt;h3 id=&quot;whats-happening-here&quot;&gt;What&amp;#8217;s happening here?&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s clear from this paper analysis that the algorithm is of linear complexity. Essentially, it walks up and down the tail of the list, comparing and swapping. But why does it work?&lt;/p&gt;
&lt;p&gt;Let &lt;code&gt;xs&lt;/code&gt; be the range &lt;code&gt;(first, last)&lt;/code&gt;. As described above, divide this range into prefix and suffix subranges, &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, where &lt;code&gt;tail&lt;/code&gt; is the longest monotonically decreasing tail of the range.&lt;/p&gt;
&lt;p&gt;If the &lt;code&gt;head&lt;/code&gt; of the range is empty, then the range &lt;code&gt;xs&lt;/code&gt; is clearly at its lexicographical maximum. &lt;/p&gt;
&lt;p&gt;Otherwise, &lt;code&gt;tail&lt;/code&gt; is a lexicographical maximum of the elements it contains, and &lt;code&gt;xs&lt;/code&gt; is therefore the largest permutation which starts with the subrange &lt;code&gt;head&lt;/code&gt;. What will the &lt;code&gt;head&lt;/code&gt; of the next permutation be? We have to swap the final item in &lt;code&gt;head&lt;/code&gt; with the smallest item of &lt;code&gt;tail&lt;/code&gt; which exceeds it: the definition of &lt;code&gt;tail&lt;/code&gt; guarantees at least one such item exists. Now we want to permute the new &lt;code&gt;tail&lt;/code&gt; to be at a its lexicographical minimum, which is a matter of sorting it from low to high.&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;tail&lt;/code&gt; is in reverse order, finding the smallest item larger than &lt;code&gt;head[-1]&lt;/code&gt; is a matter of walking back from the end of the range to find the first such items; and once we&amp;#8217;ve swapped these items, &lt;code&gt;tail&lt;/code&gt; remains in reverse order, so a simple reversed will sort it.&lt;/p&gt;
&lt;p&gt;As an example consider finding the next permutation of:&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
8342666411
&lt;/pre&gt;

&lt;p&gt;The longest monotonically decreasing tail is &lt;code&gt;666411&lt;/code&gt;, and the corresponding head is &lt;code&gt;8342&lt;/code&gt;.&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
8342 666411
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;666411&lt;/code&gt; is, by definition, reverse-ordered, and cannot be increased by permuting its elements. To find the next permutation, we must increase the head; a matter of finding the smallest tail element larger than the head&amp;#8217;s final &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
834&lt;span style=&quot;color:#930&quot;&gt;2&lt;/span&gt; 666411
&lt;/pre&gt;

&lt;p&gt;Walking back from the end of tail, the first element greater than &lt;code&gt;2&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
834&lt;span style=&quot;color:#930&quot;&gt;2&lt;/span&gt;  666&lt;span style=&quot;color:#930&quot;&gt;4&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Swap the &lt;code&gt;2&lt;/code&gt; and the &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
834&lt;span style=&quot;color:#930&quot;&gt;4&lt;/span&gt; 666&lt;span style=&quot;color:#930&quot;&gt;2&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Since head has increased, we now have a greater permutation. To reduce to the next permutation, we reverse tail, putting it into increasing order.&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
8344 112666
&lt;/pre&gt;

&lt;p&gt;Join the head and tail back together. The permutation one greater than &lt;code&gt;8342666411&lt;/code&gt; is &lt;code&gt;8344112666&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;beautiful-c&quot;&gt;Beautiful C++?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://wordaligned.org/articles/looping-forever-and-ever.html&quot;&gt;&lt;img  src=&quot;http://wordaligned.org/images/mite.jpg&quot; alt=&quot;for(;;) dust mite&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C++ has its &lt;a href=&quot;http://yosefk.com/c++fqa/defective.html&quot; title=&quot;If you are an expert in the intricacies of C++, please consider this knowledge a kind of martial art - something a real master never uses. Yossi Keinin&quot;&gt;detractors&lt;/a&gt;, who characterise it as subtle, &lt;a href=&quot;http://twitter.com/dabeaz/status/5677453478&quot; title=&quot;C++0x reminds me of blocks stacked by my toddler. Really wobbly and one block too many makes it topple. @dabeaz&quot;&gt;complex&lt;/a&gt;, and &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq.html#really-say-that&quot; title=&quot;C++ can blow your whole leg off. Bjarne Stroustrup&quot;&gt;dangerous&lt;/a&gt;; but sometimes it excels. Look once more at the C++ implementation of this algorithm.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;

    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span /&gt;With its special cases, boolean literals, multiple returns (4, count them!), disembodied and infinite loops, this code fails to exhibit conventional beauty. Yet &lt;em&gt;it is&lt;/em&gt; beautiful. All the next permutation algorithm needs are iterators which can advance forwards or backwards, step by step. And that&amp;#8217;s all this implementation uses.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m as excited as anyone by the mathematical rigour of &lt;a href=&quot;http://www.informit.com/articles/article.aspx?p=1407357&amp;amp;seqNum=3&quot; title=&quot;Great article by Andrei Alexandrescu, which questions a pure Haskell quicksort implementation&quot;&gt;functional programming&lt;/a&gt;, but sometimes computer science is about algorithms with virtually no space overhead, algorithms which loop rather than recurse. Sometimes it&amp;#8217;s about shuffling, nudging and swapping &amp;#8212; operations which map directly to the machine&amp;#8217;s most primitive operations. In such cases, C++ gets it right.&lt;/p&gt;
&lt;h3 id=&quot;permutations-in-python&quot;&gt;Permutations in Python&lt;/h3&gt;
&lt;p&gt;For the code jam, though, as mentioned earlier, having a super-fast program rarely matters. More often, it&amp;#8217;s about developing a fast enough program super-quickly.&lt;/p&gt;
&lt;p&gt;I find Python a far quicker language for developing code than C++. (Indeed, sometimes when it&amp;#8217;s obvious from the outset that a final program will need implementing in C++, I put together a working prototype using Python, which I then translate.) Could we solve the next number problem using code from the standard Python library?&lt;/p&gt;
&lt;p&gt;At a first glance, &lt;a href=&quot;http://docs.python.org/py3k/library/itertools.html#itertools.permutations&quot;&gt;itertools.permutations&lt;/a&gt; looks promising.&lt;/p&gt;
&lt;blockquote&gt;&lt;h3&gt;&lt;tt&gt;itertools.permutations(&lt;em&gt;iterable&lt;/em&gt;, &lt;em&gt;r=None&lt;/em&gt;)&lt;/tt&gt;&lt;/h3&gt;&lt;p&gt;Return successive &lt;em&gt;r&lt;/em&gt; length permutations of elements in the &lt;em&gt;iterable&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;If &lt;em&gt;r&lt;/em&gt; is not specified or is &lt;tt&gt;None&lt;/tt&gt;, then &lt;em&gt;r&lt;/em&gt; defaults to the length
of the &lt;em&gt;iterable&lt;/em&gt; and all possible full-length permutations
are generated.&lt;/p&gt;&lt;p&gt;Permutations are emitted in lexicographic sort order.  So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the permutation tuples will be produced in sorted order.&lt;/p&gt;&lt;p&gt;Elements are treated as unique based on their position, not on their value.  So if the input elements are unique, there will be no repeat values in each permutation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;However, this algorithm doesn&amp;#8217;t care about the values of the items in the iterable, and the lexicographic sort order applies to the indices of these items. So although the ordering of the generated items is well-defined:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;we get repeats, and&lt;/li&gt;
&lt;li&gt;it&amp;#8217;s not the ordering we want (in this case)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; concat = &amp;#x27;&amp;#x27;.join
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations(&amp;#x27;AAA&amp;#x27;)))
[&amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;]
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations(&amp;#x27;231&amp;#x27;)))
[&amp;#x27;231&amp;#x27;, &amp;#x27;213&amp;#x27;, &amp;#x27;321&amp;#x27;, &amp;#x27;312&amp;#x27;, &amp;#x27;123&amp;#x27;, &amp;#x27;132&amp;#x27;]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It &lt;strong&gt;is&lt;/strong&gt; possible to code up &lt;code&gt;next_permutation&lt;/code&gt; using nothing more than the standard itertools, but it isn&amp;#8217;t advisable.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Snail permute&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from itertools import permutations, groupby

def next_permutation(xs):
    &quot;&quot;&quot;Calculate the next permutation of the sequence xs.

    Returns a pair (yn, xs&amp;#x27;), where yn is a boolean and xs&amp;#x27; is the 
    next permutation. If yn is True, xs&amp;#x27; will be the lexicographic 
    next permutation of xs, otherwise xs&amp;#x27; is the lexicographic 
    smallest permutation of xs.
    &quot;&quot;&quot;
    xs = tuple(xs)
    if not xs:
        return False, xs
    else:
        ps = [p for p, gp in groupby(sorted(permutations(xs)))]
        np = len(ps)
        ix = ps.index(xs) + 1
        if ix == len(ps):
            return False, ps[0]
        else:
            return True, ps[ix]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As it happens, a solution based on this exhaustive search would score points in the code jam since it copes with the small input set. For the large input set its factorial complexity rules it out, and we&amp;#8217;d need to implement the next permutation algorithm &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1&quot;&gt;from scratch&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a id=&quot;fn1&quot; href=&quot;https://wordaligned.org/articles/next-permutation#fn1link&quot;&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/a&gt;: A more cunning &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1&quot;&gt;solution&lt;/a&gt; avoids the special case by pushing the extra zero to head of the string before applying &lt;code&gt;next_permutation&lt;/code&gt;, then popping it if it hasn&amp;#8217;t been moved.&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn2&quot; href=&quot;https://wordaligned.org/articles/next-permutation#fn2link&quot;&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/a&gt;: I&amp;#8217;ve tweaked the layout and parameter names for use on this site.&lt;/p&gt;</description>
<dc:date>2009-11-19</dc:date>
<guid>https://wordaligned.org/articles/next-permutation</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/next-permutation</link>
<category>Puzzles</category>
</item>

<item>
<title>Favicon</title>
<description>&lt;p&gt;On the subject of &lt;a href=&quot;https://wordaligned.org/&quot;&gt;this site&lt;/a&gt;, I wanted to mention the recent addition of a favicon &lt;img src=&quot;https://wordaligned.org/images/favicon.png&quot; alt=&quot;Little chap favicon&quot;/&gt;. Per pixel, it&amp;#8217;s cost me more effort than any other feature; but then it&amp;#8217;s accessed more than any other asset. It&amp;#8217;s meant to be a piece from a jigsaw puzzle. I got the idea when &lt;a href=&quot;https://wordaligned.org/articles/recursive-pictures.html&quot;&gt;re-reading Life A User&amp;#8217;s Manual&lt;/a&gt;. I like &lt;a href=&quot;https://wordaligned.org/tag/puzzles/&quot;&gt;puzzles&lt;/a&gt; and piecing things together.&lt;/p&gt;
&lt;div class=&quot;amazon&quot;&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/0002719991?ie=UTF8&amp;amp;tag=wordalig-20&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/books/life-a-users-manual.jpg&quot; alt=&quot;Life A User&#x27;s Manual&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Perec&amp;#8217;s great masterpiece is packed with interwoven stories and trickery, but at its heart is the epic battle between the millionaire, Bartlebooth, and the puzzle-maker Gaspard Winckler. Bartlebooth begins his campaign by learning how to paint, which takes him 10 years. For the next 20 years he travels the world, painting a water colour picture of a different port every couple of weeks. He sends the paintings back home to Paris. On receipt, Winckler glues each picture to a board which he then cuts, making a series of jigsaw puzzles for Bartlebooth to solve on his return. Once Bartlebooth completes each puzzle, an ingenious process is used to glue its pieces together and re-join the cut fibres of the paper; then the picture itself is lifted from the board, returned to the port it depicts, and washed clean in the sea; and finally the paper is returned in something close to its original state to Bartlebooth.&lt;/p&gt;
&lt;p&gt;Thus, after 50 years of work, there will be nothing to show.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/jigsaw-fr.png&quot; alt=&quot;French jigsaw pieces&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In the book&amp;#8217;s preamble Perec describes familiar die-cut jigsaws, classifying the best known pieces of such puzzles as &amp;#8220;little chaps&amp;#8221;, &amp;#8220;double crosses&amp;#8221; and &amp;#8220;crossbars&amp;#8221;. Such diversions are eschewed by the true puzzler:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The art of jigsaw puzzling begins with wooden puzzles cut by hand, whose maker undertakes to ask himself all the questions the player will have to solve, and, instead of allowing chance to cover his tracks, aims to replace it with cunning, trickery and subterfuge. All the elements occurring in the image to be reassembled &amp;#8212; this armchair covered in gold brocade, that three-pointed black hat with its rather ruined black plume, or that silver-braided bright yellow livery &amp;#8212; serve by design as points of departure for trails that lead to false information.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;My thanks to Tim Beard for scanning a couple of pages from his edition of &lt;a href=&quot;http://en.wikipedia.org/wiki/La_Vie_mode_d%27emploi&quot; title=&quot;Life A User&#x27;s Manual, Wikipedia&quot;&gt;La Vie, Mode d&amp;#8217;Emploi&lt;/a&gt;. I wanted to know what the &amp;#8220;little chaps&amp;#8221; etc. were before they got translated into English. I realise my favicon &lt;img src=&quot;https://wordaligned.org/images/favicon.png&quot; alt=&quot;Little chap favicon&quot;/&gt; could be &lt;a href=&quot;http://typophile.com/node/60577&quot; title=&quot;Astonishing exploded view of improved YouTube favicon&quot;&gt;improved&lt;/a&gt; but I don&amp;#8217;t know how to go about it. Anyone?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://typophile.com/node/60577&quot; title=&quot;YouTube Favicon - improved&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/youtube1.png&quot; width=&quot;52px&quot; height=&quot;26px&quot; alt=&quot;YouTube Favicon - improved&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;http://typophile.com/node/60577&quot; title=&quot;YouTube Favicon - improved&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/youtube2.png&quot; width=&quot;104px&quot; height=&quot;52px&quot; alt=&quot;YouTube Favicon - improved&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;http://typophile.com/node/60577&quot; title=&quot;YouTube Favicon - improved&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/youtube3.png&quot; width=&quot;208px&quot; height=&quot;104px&quot; alt=&quot;YouTube Favicon - improved&quot;/&gt;&lt;/a&gt;&lt;/p&gt;</description>
<dc:date>2009-09-16</dc:date>
<guid>https://wordaligned.org/articles/favicon</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/favicon</link>
<category>Puzzles</category>
</item>

<item>
<title>Blackmail made easy using Python counters</title>
<description>&lt;h3 id=&quot;the-obsessive-blackmailer&quot;&gt;The Obsessive Blackmailer&lt;/h3&gt;
&lt;p&gt;An obsessive blackmailer writes anonymous messages by by cut-and-pasting letters from newspapers. Being obsessive, the blackmailer only writes messages which can be composed entirely from a single newspaper.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/thomasguest/3754867981/&quot; title=&quot;word aligned by Thomas Guest, on Flickr&quot;&gt;&lt;img src=&quot;http://farm3.static.flickr.com/2567/3754867981_a752d15f74_o.png&quot; width=&quot;480&quot; height=&quot;309&quot; alt=&quot;word aligned&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Devise an algorithm which determines whether a given message can be written using a given newspaper.&lt;/p&gt;
&lt;h3 id=&quot;modeling-the-problem&quot;&gt;Modeling the Problem&lt;/h3&gt;
&lt;p&gt;This is a nice little problem but I&amp;#8217;m about to spoil it since I&amp;#8217;m using it here as a study in Python&amp;#8217;s evolution. So if you&amp;#8217;d like to try it yourself, look away now.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We can represent both inputs to the algorithm as sequences of characters: a message string, length M, and a newspaper string, length N. We &lt;em&gt;could&lt;/em&gt; process the message string one character at a time, at each step scanning through the newspaper and noting the first occurrence of that character we haven&amp;#8217;t used before; but this is inefficient since we potentially read the whole paper M times.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s better to think of this problem in terms of multisets, sometimes known as bags. A multiset is a set which can have repeated elements. Our blackmailer can proceed if the multiset of letters used in the message is contained entirely within the multiset of letters used in the newspaper.&lt;/p&gt;
&lt;h3 id=&quot;the-evolution-of-multisets-in-python&quot;&gt;The evolution of multisets in Python&lt;/h3&gt;
&lt;p&gt;A dictionary provides a compact and efficient way to represent a multiset in Python: each dictionary key represents an item in the multiset, and the value associated with that key is the number of times the key appears in the multiset. Python dictionaries are implemented as hashed arrays, meaning that member insertion and access take constant time, on average.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s not hard to create such a multiset from a sequence but it&amp;#8217;s interesting to see how advances in the Python language have simplified the code. &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://python.org/doc/1.4/lib/node13.html#SECTION00316000000000000000&quot;&gt;&lt;img src=&quot;http://python.org/doc/1.4/lib/img7.gif&quot; height=&quot;181px&quot; width=&quot;469px&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The complete documentation for &lt;a href=&quot;http://python.org/doc/1.4/&quot;&gt;Python 1.4&lt;/a&gt;, released in 1996, is still available on the Python website. In version 1.4 you could write:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def multiset_14(xs):
    multiset = {}
    for x in xs:
        if multiset.has_key(x):
            multiset[x] = multiset[x] + 1
        else:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code works unchanged in the current Python release, 2.6 (though note &lt;code&gt;dict.has_key()&lt;/code&gt; doesn&amp;#8217;t exist in Python 3.*). Alternatively, you might catch the &lt;code&gt;KeyError&lt;/code&gt; raised when trying to access the dict with an invalid key:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def multiset_14(xs):
    multiset = {}        
    for x in xs:
        try:
            multiset[x] = multiset[x] + 1
        except KeyError:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Python 1.5 introduces an exception-free dictionary access method, &lt;code&gt;dict.get()&lt;/code&gt;, which returns a user supplied default (defaulting to &lt;code&gt;None&lt;/code&gt;) for missing keys.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def multiset_15(xs):
    multiset = {}        
    for x in xs:
        multiset[x] = multiset.get(x, 0) + 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s certainly shorter, a little cleaner maybe, but perhaps it takes more effort for readers to see what exactly is going on.&lt;/p&gt;
&lt;p&gt;At Python 2.2, &lt;code&gt;x in multiset&lt;/code&gt; improves on the equivalent &lt;code&gt;multiset.has_key(x)&lt;/code&gt; and we can use augmented arithmetic operators (&lt;code&gt;+=, -=, *=, /=, %=, **=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;amp;=, =, |=&lt;/code&gt;), allowing:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def multiset_22(xs):
    multiset = {}
    for x in xs:
        if x in multiset:
            multiset[x] += 1
        else:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I think I prefer the &lt;code&gt;dict.get()&lt;/code&gt; version, though.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;collections&lt;/code&gt; module makes its first appearance in Python 2.4 offering a &lt;code&gt;deque&lt;/code&gt; and a promise of more high performance container types to come. Python 2.5 makes good on this promise, adding &lt;code&gt;defaultdict&lt;/code&gt; to the module. A &lt;code&gt;defaultdict&lt;/code&gt; is a specialised dictionary which calls a client supplied factory function for missing keys. Setting this factory function to &lt;code&gt;int&lt;/code&gt; turns the &lt;code&gt;defaultdict&lt;/code&gt; into a multiset. No need for &lt;code&gt;dict.get()&lt;/code&gt; any more.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from collections import defaultdict

def multiset_25(xs):
    multiset = defaultdict(int)
    for x in xs:
        multiset[x] += 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;wait-theres-more&quot;&gt;Wait, there&amp;#8217;s more!&lt;/h3&gt;
&lt;p&gt;The final improvement is available in Python 3.1 right now (or in Python 2.7, coming soon), courtesy once again of the collections module. &lt;a href=&quot;http://docs.python.org/dev/library/collections.html#collections.Counter&quot;&gt;Collections.Counter&lt;/a&gt; is exactly what we&amp;#8217;ve been waiting for.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from collections import Counter

def multiset_31(xs):
    return Counter(xs)

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;back-to-blackmail&quot;&gt;Back to Blackmail&lt;/h3&gt;
&lt;p&gt;So our blackmailer should first generate a multiset representation of the letters in the message. Then it&amp;#8217;s a matter of iterating through the newspaper and reducing the multiset each time a letter matches up. We keep a tally of the number of letters we still need to match, and stop when this tally is zero or when we get to the end of the newspaper. Here&amp;#8217;s a sketch of an implementation.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def blackmailable(message, newspaper):
    &quot;&quot;&quot;Return True if newspaper can be used to write the blackmail 
    message, False otherwise.
    &quot;&quot;&quot;
    m = len(message)
    if m == 0:
        return True
    counts = multiset(message)
    for ch in newspaper:
        if counts[ch] &amp;gt; 0:
            counts[ch] -= 1
            m -= 1
            if m == 0:
                return True
    return False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code assumes the multiset is represented as a &lt;code&gt;Counter&lt;/code&gt; or a &lt;code&gt;defaultdict&lt;/code&gt;, since it depends on &lt;code&gt;counts[ch]&lt;/code&gt; returning 0 for any character not in the message. If we&amp;#8217;d used a plain dict, we&amp;#8217;d need to employ &lt;code&gt;dict.get(ch, 0)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m not entirely happy with the code shown. It&amp;#8217;s what I first came up with. Here&amp;#8217;s an alternative, which I also find a bit clunky. I&amp;#8217;d welcome any improvements. It&amp;#8217;s also worth noting that the algorithm locates the matching characters in the newspaper, so we might want to cache some indices for later use.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def blackmailable(message, newspaper):
    &quot;&quot;&quot;Return True if newspaper can be used to write the blackmail 
    message, False otherwise.
    &quot;&quot;&quot;
    counts = multiset(message)
    m = len(message)
    n = len(newspaper)
    i = 0
    while m != 0 and i != n:
        ch = newspaper[i]
        if counts[ch] &amp;gt; 0:
            counts[ch] -= 1
            m -= 1
        i += 1
    return m == 0

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can avoid the ugly code by persuading the obssessive blackmailer to generate and maintain multiset representations of the entire newspaper library. Then &lt;code&gt;blackmailable()&lt;/code&gt; can be implemented as multiset containment, something which the &lt;code&gt;Counter&lt;/code&gt; class handles nicely using the subtraction operator. Note here that multiset subtraction never results in any negative counts, even though a &lt;code&gt;Counter&lt;/code&gt; instance could itself have negative counts.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Counter
&amp;gt;&amp;gt;&amp;gt; missing_letters = Counter(message) - Counter(newspaper)
&amp;gt;&amp;gt;&amp;gt; blackmailable = len(missing_letters) == 0

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Alternatively:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; blackmailable = not missing_letters

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;generic-code&quot;&gt;Generic Code&lt;/h3&gt;
&lt;p&gt;Suppose the blackmailer prefers to compose a message from words, rather than letters? (For an example, see the threat to stay away from Grimpen Moor delivered to Sir Henry Baskerville discussed later in this article.) The code works as is &amp;#8212; just pass in message and newspaper as word sequences, rather than character sequences. Anything we can hash can be counted.&lt;/p&gt;
&lt;h3 id=&quot;end-of-message&quot;&gt;End of Message&lt;/h3&gt;
&lt;p&gt;In the age of the interweb anonymous cowardice is far easier and blackmailers don&amp;#8217;t need to resort to manual cut and paste techniques unless they&amp;#8217;re after a retro threatening effect.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Never_Mind_the_Bollocks,_Here&#x27;s_the_Sex_Pistols&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/never-mind-the-bollocks.jpg&quot; alt=&quot;Never Mind the Bollocks&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;float:right&quot; alt=&quot;Sherlock Holmes&quot; src=&quot;https://wordaligned.org/images/sherlock-holmes.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s more, a detective can figure out plenty from these messages: so when Sir Henry Baskerville receives a threatening letter during his stay at the Northumberland Hotel, he shows it promptly to Sherlock Holmes:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Across the middle of it a single sentence had been formed by the expedient of pasting printed words upon it. It ran: &amp;#8220;As you value your life or your reason keep away from the moor.&amp;#8221; The word &amp;#8220;moor&amp;#8221; only was printed in ink.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In a virtuso display of deductive reasoning, Holmes shows the author of the message was in a hurry, afraid of being interrupted, and working in a hotel room using nail-scissors. (He also deduces something else, which he does not reveal at the time.) Identifying the source of the words to be yesterday&amp;#8217;s Times leader is elementary.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The detection of types is one of the most elementary branches of knowledge to the special expert in crime, though I confess that once when I was very young I confused the Leeds Mercury with the Western Morning News. But a Times leader is entirely distinctive, and these words could have been taken from nothing else.&lt;/p&gt;
&lt;p&gt;&amp;#8212; Sherlock Holmes, &lt;a href=&quot;http://www.gutenberg.org/dirs/etext02/bskrv11a.txt&quot;&gt;The Hound of the Baskervilles&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Can anyone identify the newspaper I used to create the image at the start of this article?&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;My thanks to jay for a &lt;a href=&quot;https://wordaligned.org/articles/python-counters#comment-13418772&quot;&gt;correction&lt;/a&gt; to the original version of this article.&lt;/p&gt;</description>
<dc:date>2009-07-27</dc:date>
<guid>https://wordaligned.org/articles/python-counters</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/python-counters</link>
<category>Puzzles</category>
</item>

<item>
<title>Partitioning with Python</title>
<description>&lt;h3 id=&quot;sums-and-splits&quot;&gt;Sums and Splits&lt;/h3&gt;
&lt;p&gt;On the subject of &lt;a href=&quot;https://wordaligned.org/articles/oulipo-eodermdrome.html&quot;&gt;hunting for eodermdromes&lt;/a&gt;, here are a couple of semi-related partitioning problems.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;for a positive integer, N, find the positive integer sequences which sum to N&lt;/li&gt;
&lt;li&gt;for a sequence, S, find the distinct partitions of that sequence&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As an example of the first, the 16 distinct integer sequences which sum to 5 are:&lt;/p&gt;
&lt;pre&gt;
5
4 + 1
3 + 1 + 1
3 + 2
2 + 1 + 2
2 + 1 + 1 + 1
2 + 2 + 1
2 + 3
1 + 1 + 3
1 + 1 + 2 + 1
1 + 1 + 1 + 1 + 1
1 + 1 + 1 + 2
1 + 2 + 2
1 + 2 + 1 + 1
1 + 3 + 1
1 + 4
&lt;/pre&gt;

&lt;p&gt;and of the second, the 8 distinct ways of partitioning the sequence ABCD are:&lt;/p&gt;
&lt;pre&gt;
ABCD
A BCD
AB CD
ABC D
A B CD
A BC D
AB C D
A B C D
&lt;/pre&gt;

&lt;p&gt;Note that I&amp;#8217;ve counted 2 + 1 + 2, 2 + 2 + 1, and 1 + 2 + 2 as distinct sums totalling 5. That happens to be the formulation of the problem which interested me.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;context&quot;&gt;Context&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://wordaligned.org/articles/oulipo-eodermdrome.html&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/eodermdrome.png&quot; width=&quot;200px&quot; height=&quot;200px&quot; style=&quot;float:right&quot; alt=&quot;eodermdrome&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Before discussing a solution to these problems, some context. Recall that an &lt;a href=&quot;https://wordaligned.org/articles/oulipo-eodermdrome.html&quot;&gt;eodermdrome&lt;/a&gt; is a sequence which forms an Eulerian circuit through the fully connected graph whose vertices are the set of its elements. Put more simply: when you trace through the letters you get the figure shown, with no edge covered twice. Examples include:&lt;/p&gt;
&lt;p style=&quot;margin:0;font-size:300%&quot;&gt;&lt;span style=&quot;color:#888&quot;&gt;E&lt;/span&gt;&lt;span style=&quot;color:#930&quot;&gt;O&lt;/span&gt;&lt;span style=&quot;color:#036&quot;&gt;D&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;E&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;R&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;M&lt;/span&gt;&lt;span style=&quot;color:#036&quot;&gt;D&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;R&lt;/span&gt;&lt;span style=&quot;color:#930&quot;&gt;O&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;M&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;margin:0;font-size:300%&quot;&gt;&lt;span style=&quot;color:#e50&quot;&gt;E&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;N&lt;/span&gt;&lt;span style=&quot;color:#036&quot;&gt;H&lt;/span&gt;&lt;span style=&quot;color:#930&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;N&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;C&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;E&lt;/span&gt; &lt;span style=&quot;color:#930&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;C&lt;/span&gt;&lt;span style=&quot;color:#036&quot;&gt;H&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;margin:0;font-size:300%&quot;&gt;&lt;span style=&quot;color:#036&quot;&gt;T&lt;/span&gt;&lt;span style=&quot;color:#930&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;X&lt;/span&gt; &lt;span style=&quot;color:#e50&quot;&gt;D&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;E&lt;/span&gt;&lt;span style=&quot;color:#930&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;D&lt;/span&gt; &lt;span style=&quot;color:#036&quot;&gt;T&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;E&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;X&lt;/span&gt;&lt;span style=&quot;color:#036&quot;&gt;T&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Eodermdromes turn out to be surprisingly rare. Writing a computer program to find them is a nice exercise in searching and text processing. Clearly, we should start with a collection of words. Then we can generate combinations of words from this collection and filter out the eodermdromes.&lt;/p&gt;
&lt;pre&gt;
(filter eodermdrome? (combinations words))
&lt;/pre&gt;

&lt;p&gt;A large set of words (note: &amp;#8220;set&amp;#8221; not &amp;#8220;collection&amp;#8221;, we don&amp;#8217;t need duplicates) gives the best chance of success. I started with a file containing more than 35 thousand distinct words. This gives over a billion possible word pairs, and when we consider word triples and quartets the numbers get silly even for a modern computer.&lt;/p&gt;
&lt;p&gt;As is so often the case in computing, we have a tension between opposing concerns. We&amp;#8217;d like code which separates the task of generating candidates and the task of testing these candidates for eodermdromicity, but in order to run this code in a timely manner we need some of the eodermdrome testing to leak into the candidate generation. For example, we could preprocess the word set removing words which contain double Ls (all, ball, call, ill, Bill, kill &amp;#8230;) since these can never appear in an eodermdrome. And we could similarly remove words which end ETE (delete, Pete, effete). As I hope you can see, it&amp;#8217;s easy to end up with finickity code and co-dependent functions.&lt;/p&gt;
&lt;p&gt;I chose a simple but effective strategy to reduce the search space to something manageable, based on word length. First, then, I loaded my word set into a Python dict collecting lists of words keyed by their length.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from collections import defaultdict
&amp;gt;&amp;gt;&amp;gt; words = defaultdict(list)
&amp;gt;&amp;gt;&amp;gt; for word in open(&amp;#x27;word-set.txt&amp;#x27;).read().split():
...     words[len(word)].append(word)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Given this dict, picking out single word eodermdromes is easy.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; list(filter(is_eodermdrome, words[11]))
[&amp;#x27;eodermdrome&amp;#x27;]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about eodermdromes composed of a 6 letter word followed by a 5 letter word? We can form the &lt;a href=&quot;http://docs.python.org/library/itertools.html#itertools.product&quot;&gt;cartesian product&lt;/a&gt; of the lists of 6 and 5 letter words and filter out the ones we want.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import product
&amp;gt;&amp;gt;&amp;gt; eod_6_5 = filter(is_eodermdrome, product(words[6], words[5]))
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
(&amp;#x27;earned&amp;#x27;, &amp;#x27;andre&amp;#x27;)
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
(&amp;#x27;yearly&amp;#x27;, &amp;#x27;relay&amp;#x27;)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about &lt;em&gt;all eodermdromes&lt;/em&gt; of length 11?&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import chain.from_iterable as seq
&amp;gt;&amp;gt;&amp;gt; word_lens = sum_to_n(11)
&amp;gt;&amp;gt;&amp;gt; candidates = seq(product(*[words[i] for i in s]) for s in word_lens)
&amp;gt;&amp;gt;&amp;gt; eods = filter(is_eodermdrome, candidates)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note here that I&amp;#8217;m using Python 3.0, and that &lt;a href=&quot;http://docs.python.org/py3k/library/functions.html#filter&quot;&gt;filter&lt;/a&gt; is therefore a lazy function. The interactive session shown above hasn&amp;#8217;t actually started taking anything from these lazily-evaluated streams.&lt;/p&gt;
&lt;p&gt;I certainly don&amp;#8217;t claim this is the quickest way to search for eodermdromes. In fact, this little program took several hours to complete. But a back-of-an-envelope calculation showed it &lt;em&gt;would&lt;/em&gt; complete in a few hours, and that was good enough.&lt;/p&gt;
&lt;p&gt;Note also that we haven&amp;#8217;t shown an implementation of &lt;code&gt;sum_to_n()&lt;/code&gt; yet, which takes us back to the problems posed at the start of this article.&lt;/p&gt;
&lt;h3 id=&quot;sum-to-n&quot;&gt;Sum to N&lt;/h3&gt;
&lt;p&gt;Finding the positive integer series which sum to a positive integer N is a job for &lt;a href=&quot;http://docs.python.org/library/itertools.html#itertools.combinations&quot;&gt;itertools.combinations&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from itertools import combinations, chain

def sum_to_n(n):
    &amp;#x27;Generate the series of +ve integer lists which sum to a +ve integer, n.&amp;#x27;
    from operator import sub
    b, mid, e = [0], list(range(1, n)), [n]
    splits = (d for i in range(n) for d in combinations(mid, i)) 
    return (list(map(sub, chain(s, e), chain(b, s))) for s in splits)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The idea here is straightforward: there&amp;#8217;s a 1-to-1 correspondence between the sums we want and ordered combinations drawn from the series 1, 2, &amp;#8230; n-1. For example, if n is 11 one such combination would be:&lt;/p&gt;
&lt;pre&gt;
(1, 5, 7, 10)
&lt;/pre&gt;

&lt;p&gt;we can extend this by pushing 0 in front and n at the end&lt;/p&gt;
&lt;pre&gt;
(0, 1, 5, 7, 10, 11)
&lt;/pre&gt;

&lt;p&gt;This extended tuple can now be seen as partial sums of a series which sums to 11. Taking differences gives the series&lt;/p&gt;
&lt;pre&gt;
(1-0, 5-1, 7-5, 10-7, 11-10)
&lt;/pre&gt;

&lt;p&gt;which is&lt;/p&gt;
&lt;pre&gt;
(1, 4, 2, 3, 1)
&lt;/pre&gt;

&lt;p&gt;which does indeed sum to 11&lt;/p&gt;
&lt;pre&gt;
1 + 4 + 2 + 3 + 1 = 11
&lt;/pre&gt;

&lt;p&gt;The Python code shown uses a clever idea to implement this staggered differencing, an idea I &lt;a href=&quot;http://newsimg.bbc.co.uk/media/images/45909000/jpg/_45909582_badartists.jpg&quot; title=&quot;Bristol&#x27;s famous artist and thief&quot;&gt;cleverly stole&lt;/a&gt; from one of &lt;a href=&quot;http://code.activestate.com/recipes/users/178123/&quot;&gt;Raymond Hettinger&amp;#8217;s brilliant Python recipes&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;partitioning-a-sequence&quot;&gt;Partitioning a Sequence&lt;/h3&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Python Cookbook: Recipe 576795&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from itertools import chain, combinations

def partition(iterable, chain=chain, map=map):
    s = iterable if hasattr(iterable, &amp;#x27;__getslice__&amp;#x27;) else tuple(iterable)
    n = len(s)
    first, middle, last = [0], range(1, n), [n]
    getslice = s.__getslice__
    return [map(getslice, chain(first, div), chain(div, last))
            for i in range(n) for div in combinations(middle, i)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This &lt;a href=&quot;http://code.activestate.com/recipes/576795&quot;&gt;recipe&lt;/a&gt; shows sum-to-n and partitioning to be very similar problems. In fact, we could easily implement &lt;code&gt;sum_to_n()&lt;/code&gt; on top of  &lt;code&gt;partition()&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def sum_to_n(n):
    return ([len(t) for t in p] for p in partition(range(n)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The posted recipe needs a minor overhaul to get it working with Python 3.0, &lt;a href=&quot;http://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods&quot;&gt;which does away&lt;/a&gt; with &lt;code&gt;__getslice__&lt;/code&gt;: getting a slice is simply what &lt;code&gt;__getitem__&lt;/code&gt; does when given a slice object. The 2to3 tool fails to convert the recipe, which must be recast as something like:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from itertools import chain, combinations

def sliceable(xs):
    &amp;#x27;&amp;#x27;&amp;#x27;Return a sliceable version of the iterable xs.&amp;#x27;&amp;#x27;&amp;#x27;
    try:
        xs[:0]
        return xs
    except TypeError:
        return tuple(xs)

def partition(iterable):
    s = sliceable(iterable)
    n = len(s)
    b, mid, e = [0], list(range(1, n)), [n]
    getslice = s.__getitem__
    splits = (d for i in range(n) for d in combinations(mid, i))
    return [[s[sl] for sl in map(slice, chain(b, d), chain(d, e))]
            for d in splits]

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;sum-to-n-again&quot;&gt;Sum to N, again&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a variant implementation of &lt;code&gt;sum_to_n()&lt;/code&gt;. The idea here is to fill N slots with a pattern of 0&amp;#8217;s and 1&amp;#8217;s. We then reduce this pattern to the lengths of runs of repeated elements, giving a series which sums to N. &lt;code&gt;Itertools.product(&#x27;01&#x27;, repeat=n)&lt;/code&gt; generates all possible binary patterns of length N, which turns out to be twice as many as we want since (e.g.) 00001111100 and 11110000011 represent the same sum, 4 + 5 + 2; hence the n-1 &lt;code&gt;repeat&lt;/code&gt; count and the call to &lt;code&gt;chain&lt;/code&gt; in the code below&lt;a id=&quot;fn1link&quot; href=&quot;https://wordaligned.org/articles/partitioning-with-python#fn1&quot;&gt;&lt;sup&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from itertools import groupby, chain, product

def ilen(it):
    return sum(1 for _ in it)

def sum_to_n(n):
    return ([ilen(gp) for _, gp in groupby(chain(&amp;#x27;1&amp;#x27;, O1))]
            for O1 in product(&amp;#x27;01&amp;#x27;, repeat=n-1))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Fun, but the version using &lt;a href=&quot;http://docs.python.org/library/itertools.html#itertools.combinations&quot;&gt;combinations&lt;/a&gt; is better!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a id=&quot;fn1&quot; href=&quot;https://wordaligned.org/articles/partitioning-with-python#fn1link&quot;&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/a&gt; My first thought was to use &lt;code&gt;itertools.islice&lt;/code&gt; to limit the stream to the first 2&lt;sup&gt;n-1&lt;/sup&gt; values, but I discovered &lt;code&gt;islice&lt;/code&gt; has a surprising &lt;a href=&quot;http://bugs.python.org/issue6305&quot; title=&quot;I&#x27;ve reported this as a bug&quot;&gt;limitation&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import islice, count
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31) - 1)
&amp;lt;itertools.islice object at 0x63a0c0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31))
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
ValueError: Stop argument for islice() must be a non-negative integer or None.

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;
&lt;p style=&quot;text-align:center&quot;&gt;&amp;sect;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;so reuse ours&lt;/p&gt;</description>
<dc:date>2009-06-17</dc:date>
<guid>https://wordaligned.org/articles/partitioning-with-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/partitioning-with-python</link>
<category>Puzzles</category>
</item>

<item>
<title>Oulipo and the Eodermdrome challenge</title>
<description>&lt;p style=&quot;margin:0;font-size:500%&quot;&gt;&lt;span style=&quot;color:#888&quot;&gt;S&lt;/span&gt;&lt;span style=&quot;color:#930&quot;&gt;H&lt;/span&gt;&lt;span style=&quot;color:#036&quot;&gt;O&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;E&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;S&lt;/span&gt; &lt;span style=&quot;color:#036&quot;&gt;O&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;N&lt;/span&gt; &lt;span style=&quot;color:#930&quot;&gt;H&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;E&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;N&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;S&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;margin:0;font-size:500%&quot;&gt;&lt;span style=&quot;color:#036&quot;&gt;S&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color:#930&quot;&gt;M&lt;/span&gt;&lt;span style=&quot;color:#036&quot;&gt;S&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;O&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;N&lt;/span&gt; &lt;span style=&quot;color:#930&quot;&gt;M&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;O&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;N&lt;/span&gt;&lt;span style=&quot;color:#036&quot;&gt;S&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;margin:0;font-size:500%&quot;&gt;&lt;span style=&quot;color:#555&quot;&gt;D&lt;/span&gt;&lt;span style=&quot;color:#930&quot;&gt;R&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color:#036&quot;&gt;B&lt;/span&gt; &lt;span style=&quot;color:#930&quot;&gt;R&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;E&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;D&lt;/span&gt; &lt;span style=&quot;color:#036&quot;&gt;B&lt;/span&gt;&lt;span style=&quot;color:#e50&quot;&gt;E&lt;/span&gt;&lt;span style=&quot;color:#888&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color:#555&quot;&gt;D&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;oulipo&quot;&gt;Oulipo&lt;/h3&gt;
&lt;p&gt;At the &lt;a href=&quot;http://www.dcs.warwick.ac.uk/bshm/meetings/Fiction.html&quot;&gt;Mathematics and Fiction&lt;/a&gt; workshop held last weekend in Oxford I particularly enjoyed &lt;a href=&quot;http://web.princeton.edu/sites/fit/faculty/bellos.html&quot;&gt;David Bellos&lt;/a&gt;&amp;#8217; wonderful talk about Oulipo, the world&amp;#8217;s longest running literary movement. &lt;a href=&quot;http://www.oulipo.net&quot;&gt;The Oulipo&lt;/a&gt; is a group of writers interested in exploring the application of mathematical structures, patterns and algorithms to writing.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/thomasguest/3597995774/&quot; title=&quot;Queneau sonnets by Thomas Guest, on Flickr&quot;&gt;&lt;img src=&quot;http://farm4.static.flickr.com/3342/3597995774_857cdd8566_o.jpg&quot; width=&quot;450&quot; height=&quot;325&quot; alt=&quot;Queneau sonnets&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As an example, poet and novelist &lt;a href=&quot;http://en.wikipedia.org/wiki/Raymond_Queneau&quot;&gt;Raymond Queneau&lt;/a&gt; unleashed the exponential power of combinatorics to write a &lt;a href=&quot;http://en.wikipedia.org/wiki/Sonnet&quot;&gt;small book&lt;/a&gt; of sonnets which he hadn&amp;#8217;t finished reading himself!&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;constraints&quot;&gt;Constraints&lt;/h3&gt;
&lt;div class=&quot;amazon&quot;&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/0099477548?tag=wordalig-20&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/books/damascus.jpg&quot; alt=&quot;Damascus cover&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;The &lt;a href=&quot;http://en.wikipedia.org/wiki/Sonnet&quot;&gt;sonnet&lt;/a&gt; is a highly constrained literary form: 14 lines, 10 syllables per line, and a well-defined rhyme pattern. More generally, the Oulipo discovered  such mathematical constraints can generate interesting results. Constraints can also provide inspiration &amp;#8212; tying things down helps give them shape. Consider two questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What are you doing?&lt;/li&gt;
&lt;li&gt;What are you doing? (Limit your answer to &lt;a href=&quot;http://twitter.com/thomasguest&quot;&gt;140 characters&lt;/a&gt;.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first sounds plain nosey; but the second has spawned a whole new form of publishing.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;http://www.fox.com/24&quot; title=&quot;24. Never seen it, but I get the idea!&quot;&gt;day-in-a-life&lt;/a&gt; format is another &lt;a href=&quot;http://en.wikipedia.org/wiki/Bloomsday&quot;&gt;famous&lt;/a&gt; literary constraint. Oulipo-inspired writer &lt;a href=&quot;http://richardbeard.info&quot;&gt;Richard Beard&lt;/a&gt; explains how he notched this constraint up a level, creating a novel in which the action is formally and tightly bound to a single day.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In &amp;#8220;Damascus,&amp;#8221; I only use nouns that appeared in The Times of Nov. 1 1993. How does this work? In one paragraph some children are racing to the sea and one of them wants to say &amp;#8212; &amp;#8220;Last to touch the water&amp;#8217;s a donkey.&amp;#8221; But there&amp;#8217;s no &amp;#8220;donkey&amp;#8221; in the paper, so they end up saying, &amp;#8220;Last to touch the water&amp;#8217;s a walrus.&amp;#8221; So you end up with some interesting and novel linguistic formulations. &amp;#8212; &lt;a href=&quot;http://richardbeard.info/html/the_japan_times_.html&quot;&gt;Richard Beard&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;the-eodermdrome-challenge&quot;&gt;The Eodermdrome challenge&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.oulipo.net/contraintes/docs/eodermdrome&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/eodermdrome.png&quot; width=&quot;200px&quot; height=&quot;200px&quot; style=&quot;float:right&quot; alt=&quot;eodermdrome&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The simplest Oulipian structure David Bellos presented was the &lt;a href=&quot;http://www.oulipo.net/contraintes/docs/eodermdrome&quot;&gt;eodermdrome&lt;/a&gt;. The word &amp;#8220;EODERMDROME&amp;#8221; is itself an eodermdrome &lt;a id=&quot;fn1link&quot; href=&quot;https://wordaligned.org/articles/oulipo-eodermdrome#fn1&quot;&gt;&lt;sup&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;: if you place the letters E, O, D, R, M at the vertices of a pentagon, as shown, when you trace the sequence E&amp;rarr;O&amp;rarr;D&amp;rarr;E&amp;rarr;R&amp;rarr;M&amp;rarr;D&amp;rarr;R&amp;rarr;O&amp;rarr;M&amp;rarr;E you end up where you started, covering each line in the resulting figure exactly once. Mathematically speaking, the sequence EODERMDROME forms an Eulerian circuit within the fully connected graph whose vertices are the set of its constituent characters. Eodermdromes make naturally pleasing sequences, perhaps suitable for domain names or memorable phone numbers.&lt;/p&gt;
&lt;p&gt;In his talk David Bellos offered three more eodermdromes. The second is credited to Jacques Roubaud. You&amp;#8217;ll notice that the elements in the third are words rather than characters: the pattern works at any scale, and a reader needn&amp;#8217;t be aware of it to appreciate its beauty.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;tears at rest&lt;/li&gt;
&lt;li&gt;&amp;eacute;toile, ortie&lt;/li&gt;
&lt;li&gt;figs, lizards, snakes, heat, light, figs, snakes, light, lizards, heat, figs&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Eodermdromes turn out to be surprisingly thin on the ground. I include three of my own discoveries &lt;a id=&quot;fn2link&quot; href=&quot;https://wordaligned.org/articles/oulipo-eodermdrome#fn2&quot;&gt;&lt;sup&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt; at the start of this article. Can you can find any better ones?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.withhugsandkisses.co.uk&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/shoes-on-hens.jpg&quot; alt=&quot;SHOES ON HENS&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a id=&quot;fn1&quot; href=&quot;https://wordaligned.org/articles/oulipo-eodermdrome#fn1link&quot;&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/a&gt; The word for such words is &amp;#8220;autological&amp;#8221;, as opposed to &amp;#8220;heterological&amp;#8221;. But is &lt;a href=&quot;http://en.wikipedia.org/wiki/Grelling-Nelson_paradox&quot; title=&quot;Yes but no but&quot;&gt;&amp;#8220;heterological&amp;#8221; itself heterological&lt;/a&gt;?&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn2&quot; href=&quot;https://wordaligned.org/articles/oulipo-eodermdrome#fn2link&quot;&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/a&gt; OK, so a computer did the hard work. It&amp;#8217;s a nice programming exercise.&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;&amp;sect;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;end code once&lt;/p&gt;</description>
<dc:date>2009-06-05</dc:date>
<guid>https://wordaligned.org/articles/oulipo-eodermdrome</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/oulipo-eodermdrome</link>
<category>Puzzles</category>
</item>

<item>
<title>Ordered sublists. A brute force approach</title>
<description>&lt;h3 id=&quot;younger-runners&quot;&gt;Younger runners&lt;/h3&gt;
&lt;p&gt;Recently &lt;a href=&quot;https://wordaligned.org/articles/a-race-within-a-race.html&quot;&gt;I posed a puzzle&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Starting with a list of runners ordered by their finishing time in a race, select a sublist of runners who are getting younger. &lt;strong&gt;What is the longest such sublist?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Below, I&amp;#8217;ve highlighted just such a sublist within the list of 8 runners who completed last year&amp;#8217;s &lt;a href=&quot;http://www.nycmarathon.org&quot;&gt;New York marathon&lt;/a&gt; in under two and a quarter hours. As you can see, MARILSON GOMES DO SANTOS, 31, is older and faster than RONO, 30, who is older and faster in turn than ROHATINSKY, 26.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;MARILSON GOMES DOS SANTOS, 31&lt;/strong&gt;, M, 2:08:43&lt;/li&gt;
&lt;li&gt;ABDERRAHIM GOUMRI, 32, M, 2:09:07&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DANIEL RONO, 30&lt;/strong&gt;, M, 2:11:22&lt;/li&gt;
&lt;li&gt;PAUL TERGAT, 39, M, 2:13:10&lt;/li&gt;
&lt;li&gt;ABDERRAHIME BOURAMDANE, 30, M, 2:13:33&lt;/li&gt;
&lt;li&gt;ABDI ABDIRAHMAN, 31, M, 2:14:17&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JOSH ROHATINSKY, 26&lt;/strong&gt;, M, 2:14:23&lt;/li&gt;
&lt;li&gt;JASON LEHMKUHLE, 31, M, 2:14:30&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a deceptively tricky problem. Even on such a small input list it&amp;#8217;s hard to be absolutely sure our solution is optimal. Certainly there are other ordered triples with decreasing ages, but might there be a quartet? And even if we&amp;#8217;re convinced Gomes, Rono, Rohatinsky &lt;strong&gt;do&lt;/strong&gt; form a longest ordered sublist, I think it&amp;#8217;s already clear that as more runners finish, there may be no longer be a longest ordered sublist which starts with these three.&lt;/p&gt;
&lt;h3 id=&quot;dumb-computers&quot;&gt;Dumb computers&lt;/h3&gt;
&lt;p&gt;Rather than invent a clever strategy to find an optimal solution, why not get a computer to exhaust the possibilities? If we generate all possible sublists then filter out the ones whose age fields decrease, then our answer will be the longest of these.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Exhaustive search&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from itertools import combinations as sublists
from functools import partial

def is_ordered(xs, comp):
    &amp;#x27;&amp;#x27;&amp;#x27;Return True if the sequence xs is ordered, False otherwise.

    &amp;gt;&amp;gt;&amp;gt; from operator import gt
    &amp;gt;&amp;gt;&amp;gt; is_ordered((3, 2, 1), gt)
    True
    &amp;#x27;&amp;#x27;&amp;#x27;
    return all(comp(xs[i], xs[i+1]) for i in range(len(xs)-1))

def longest_ordered_sublist(xs, comp):
    &amp;#x27;&amp;#x27;&amp;#x27;Find a longest sublist of &quot;xs&quot; which is ordered by &quot;comp&quot;

    (Note: there may be no unique solution, and this function makes
    no guarantees about which longest sublist is returned.)

    &amp;gt;&amp;gt;&amp;gt; from operator import lt
    &amp;gt;&amp;gt;&amp;gt; items = 2, 1, 5, 2, 2, 3, 1
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist(items, lt)
    (1, 2, 3)
    &amp;#x27;&amp;#x27;&amp;#x27;
    in_order = partial(is_ordered, comp=comp)
    xss = (xss for n in range(len(xs)) for xss in sublists(xs, n))
    return max(filter(in_order, xss), key=len)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The heavy lifting here is done by a recent addition to the &lt;code&gt;itertools&lt;/code&gt; module, &lt;a href=&quot;http://docs.python.org/library/itertools.html#itertools.combinations&quot;&gt;itertools.combinations&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;itertools.combinations(iterable, r)&lt;/p&gt;
&lt;p&gt;Return r length subsequences of elements from the input iterable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Generating all possible sublists is as easy (too easy!) as looping over &lt;code&gt;r&lt;/code&gt;. All that remains is to filter the ordered sublists, then use the &lt;code&gt;max&lt;/code&gt; builtin function keyed by length.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s apply this function to our top 8 finishers.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; results = (
... (&quot;Gomes&quot;, 31), (&quot;Goumri&quot;, 32), (&quot;Rono&quot;, 30),
... (&quot;Tergat&quot;, 39), (&quot;Bouramdane&quot;, 30), (&quot;Abdirahman&quot;, 31),
... (&quot;Rohatinsky&quot;, 26), (&quot;Lehmkuhle&quot;, 31))
&amp;gt;&amp;gt;&amp;gt; def older(runner_a, runner_b):
...     return runner_a[1] &amp;gt; runner_b[1]
&amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist(results, older)
((&amp;#x27;Gomes&amp;#x27;, 31), (&amp;#x27;Rono&amp;#x27;, 30), (&amp;#x27;Rohatinsky&amp;#x27;, 26))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So, the longest ordered sublist has length 3, and Gomes, Rono, Rohatinsky is such a sublist.&lt;/p&gt;
&lt;p&gt;Adapting &lt;code&gt;longest_ordered_sublist&lt;/code&gt; to return &lt;strong&gt;all&lt;/strong&gt; longest ordered sublists is easy enough:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replace &lt;code&gt;max(filter(in_order, xss), key=len)&lt;/code&gt; with &lt;code&gt;sorted(filter(in_order, xss), key=len)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;feed the sorted results through &lt;code&gt;itertools.groupby&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;and capture the final group. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It turns out there are no fewer than 7 longest subsequences ordered by decreasing age.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;All longest ordered subsequences&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;((&amp;#x27;Gomes&amp;#x27;, 31), (&amp;#x27;Rono&amp;#x27;, 30), (&amp;#x27;Rohatinsky&amp;#x27;, 26))
((&amp;#x27;Gomes&amp;#x27;, 31), (&amp;#x27;Bouramdane&amp;#x27;, 30), (&amp;#x27;Rohatinsky&amp;#x27;, 26))
((&amp;#x27;Goumri&amp;#x27;, 32), (&amp;#x27;Rono&amp;#x27;, 30), (&amp;#x27;Rohatinsky&amp;#x27;, 26))
((&amp;#x27;Goumri&amp;#x27;, 32), (&amp;#x27;Bouramdane&amp;#x27;, 30), (&amp;#x27;Rohatinsky&amp;#x27;, 26))
((&amp;#x27;Goumri&amp;#x27;, 32), (&amp;#x27;Abdirahman&amp;#x27;, 31), (&amp;#x27;Rohatinsky&amp;#x27;, 26))
((&amp;#x27;Tergat&amp;#x27;, 39), (&amp;#x27;Bouramdane&amp;#x27;, 30), (&amp;#x27;Rohatinsky&amp;#x27;, 26))
((&amp;#x27;Tergat&amp;#x27;, 39), (&amp;#x27;Abdirahman&amp;#x27;, 31), (&amp;#x27;Rohatinsky&amp;#x27;, 26))

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;dumber-programmers&quot;&gt;Dumber programmers&lt;/h3&gt;
&lt;p&gt;Did you spot the defects in &lt;code&gt;longest_ordered_sublist()&lt;/code&gt;? It gets the answer wrong for empty sequences and totally ordered sequences.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import operator
&amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist([], operator.lt)
Traceback (most recent call last):
....
ValueError: max() arg is an empty sequence
&amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist((1, 2, 3), operator.lt)
(1, 2)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Fixing the code is easy enough, but what should we do about the documentation, and indeed about testing these edge cases? Certainly edge cases &lt;strong&gt;should&lt;/strong&gt; be tested, and it&amp;#8217;s tempting to add a couple more examples to the function&amp;#8217;s docstring and let &lt;a href=&quot;http://docs.python.org/library/doctest.html&quot;&gt;doctest&lt;/a&gt; confirm correctness.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def longest_ordered_sublist(xs, comp):
    &amp;#x27;&amp;#x27;&amp;#x27;Find a longest sublist of &quot;xs&quot; which is ordered by &quot;comp&quot;

    (Note: there may be no unique solution, and this function makes
    no guarantees about which longest sublist is returned.)

    &amp;gt;&amp;gt;&amp;gt; from operator import lt
    &amp;gt;&amp;gt;&amp;gt; items = 2, 1, 5, 2, 2, 3, 1
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist(items, lt)
    (1, 2, 3)
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist((1, 2, 3), lt)
    (1, 2, 3)
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist((), lt)
    ()
    &amp;#x27;&amp;#x27;&amp;#x27;
    in_order = partial(is_ordered, comp=comp)
    xss = (xss for n in range(len(xs) + 1) for xss in sublists(xs, n))
    return max(filter(in_order, xss), key=len)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Tempting, yes. Good idea? Not really!&lt;/p&gt;
&lt;p&gt;As &lt;a href=&quot;http://nedbatchelder.com/blog/200811/things_i_dont_like_about_doctest.html&quot;&gt;Ned Batchelder puts it&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Docstrings, and the long sequence of code they encourage, may be good ways to explain what code does, but explaining and testing are two different tasks, and the code you write for each will be different. So why try to serve two masters at once?&lt;/p&gt;
&lt;p&gt;Either your expository text will be cluttered with uninformative edge cases, or your tests will merely skim the surface of what your code can do.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the case of the revised version of &lt;code&gt;longest_ordered_sublist()&lt;/code&gt;, the first example in the docstring explains clearly what the function does, but the second and third count as &lt;a href=&quot;http://docs.python.org/library/doctest.html#soapbox&quot;&gt;clutter&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;ignorant-machines&quot;&gt;Ignorant machines&lt;/h3&gt;
&lt;p&gt;Returning to our combinatorial algorithm, this kind of exhaustive search approach is often referred to as brute force. When you&amp;#8217;ve got a machine which can do billions of things every second without breaking a sweat, it&amp;#8217;s a great technique.&lt;/p&gt;
&lt;p&gt;In this case, though, brute force turns out to be machine ignorance. If a list has N items, then each item will be either in or out of any particular combination, giving a total of 2&lt;sup&gt;N&lt;/sup&gt; possible combinations. On my machine it took over 5 seconds to confirm the longest ordered subsequence of the &lt;a href=&quot;https://wordaligned.org/articles/a-race-within-a-race.html&quot;&gt;first 20 runners&lt;/a&gt; in the New York marathon was of length 7.&lt;/p&gt;
&lt;p&gt;5 seconds isn&amp;#8217;t so very long but every additional runner doubles up the time, and we can predict this particular algorithm would fail to process a result list of just 32 entries within the 2 and a bit hours it took Mar&amp;iacute;lson Gomes dos Santos to complete the course.&lt;/p&gt;
&lt;p&gt;We need to do better.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nycmarathon.org/2008_coverage.htm&quot;&gt;&lt;img src=&quot;http://www.nyrr.org/resources/photos/images/2008/marathon/men/pro_men_15.jpg&quot; alt=&quot;Marilson Gomes dos Santos&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We can do better! This problem has been studied and some particularly interesting solutions have been found. All talk here about races, ages, etc. only exists to disguise the real problem and encourage you to consider it afresh. If you want an answer now, search for &lt;a href=&quot;http://www.google.com/search?q=longest+ordered+subsequence&quot;&gt;&amp;#8220;longest ordered subsequence&amp;#8221;&lt;/a&gt; or &lt;a href=&quot;http://www.google.com/search?q=longest+increasing+subsequence&quot;&gt;&amp;#8220;longest increasing subsequence&amp;#8221;&lt;/a&gt;. If you&amp;#8217;d like to have a crack at the problem yourself, the 2008 New York marathon results can be found &lt;a href=&quot;http://www.nycmarathon.org/Results.htm&quot;&gt;online&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I get an answer of 1724 for the length of the longest sublist of these results formed of runners whose ages are non-increasing, and 60 for the longest sublist formed of runners whose ages are strictly decreasing.&lt;/p&gt;
&lt;p&gt;Alternatively, stick around &amp;#8212; I&amp;#8217;ll be writing up my own notes in the next couple of articles.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;python-30-notes&quot;&gt;Python 3.0 notes&lt;/h3&gt;
&lt;p&gt;As I mentioned at the start of the year, &lt;a href=&quot;https://wordaligned.org/articles/perl-6-python-3.html&quot;&gt;I intend to use Python 3.0 for all new code examples&lt;/a&gt; posted here on &lt;a href=&quot;https://wordaligned.org/&quot;&gt;Word Aligned&lt;/a&gt;. I&amp;#8217;ll also be making notes about what I discover about using this new version of Python, starting right here.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;my emacs python editing mode stopped working when I moved to Python 3.0. (I was using whatever came as standard with Carbon Emacs 22). The fix was to use &lt;a href=&quot;http://svn.python.org/view/python/tags/r30/Misc/python-mode.el?rev=67506&quot;&gt;Python-3.0/Misc/python-mode.el&lt;/a&gt; straight out of the Python 3.0 tarball. Happily this also works with Python 2.6 and earlier.&lt;/li&gt;
&lt;li&gt;the code presented runs out of time before running out of memory since, in Python 3.0, the &lt;code&gt;filter&lt;/code&gt; builtin function generates elements on demand. Use &lt;code&gt;future_builtins.filter&lt;/code&gt; or &lt;code&gt;itertools.ifilter&lt;/code&gt; if you want this behaviour with 2.6.&lt;/li&gt;
&lt;li&gt;while not strictly Python 3.0 (it appears in 2.6 as well) &lt;code&gt;itertools.combinations&lt;/code&gt; is worth mentioning again, as is another related member of the itertools module. Check out &lt;a href=&quot;http://code.activestate.com/recipes/576647/&quot;&gt;Raymond Hettinger&amp;#8217;s clever solution&lt;/a&gt; of the eight Queens puzzle, which uses &lt;code&gt;itertools.permutations&lt;/code&gt; to shuffle pieces around a chessboard. Unlike other itertools, &lt;code&gt;combinations&lt;/code&gt; and &lt;code&gt;permutations&lt;/code&gt; won&amp;#8217;t cope with infinite streams. &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Another way to exhaust your computer&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import combinations, count
&amp;gt;&amp;gt;&amp;gt; pairs = combinations(count(), 2) 

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2009-03-09</dc:date>
<guid>https://wordaligned.org/articles/ordered-sublists-a-brute-force-approach</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/ordered-sublists-a-brute-force-approach</link>
<category>Puzzles</category>
</item>

</channel>
</rss>
