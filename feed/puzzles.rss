<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>24 Puzzles</title>
<description>&lt;p&gt;On &lt;a href="http://blog.plover.com"&gt;The Universe of Discourse&lt;/a&gt; Mark Dominus discusses the classic &lt;a href="http://blog.plover.com/math/24-puzzle.html"&gt;24 Puzzle&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;You are given a sequence of four digits, say 1, 2, 3, 4, and your job is to combine them with ordinary arithmetic operations (+, -, &amp;times;, and &amp;divide;) in any order to make a target number, typically 24. For example, with 1, 2, 3, 4, you can go with &lt;code&gt;((1+2)+3)&amp;times;4=24&lt;/code&gt; or with &lt;code&gt;4&amp;times;((2&amp;times;3)&amp;times;1)=24&lt;/code&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Here&amp;#8217;s a solver for such puzzles. It uses &lt;code&gt;itertools&lt;/code&gt; to generate possible expressions, &lt;code&gt;fractions&lt;/code&gt; to get the arithmetic right, and &lt;code&gt;eval&lt;/code&gt; to evaluate expressions. It&amp;#8217;s limited to expressions formed from 4 numbers which means I don&amp;#8217;t have to programmatically calculate different ways of parenthesising: there are only 5.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;# http://blog.plover.com/math/24-puzzle.html
import re
import math

# Use fractions for exact calculations
from fractions import Fraction

# Solve for 4 numbers only!
N = 4

# So these are the only expression templates
# where X is a number and @ is an operation
templates = '''\
((X @ X) @ X) @ X
(X @ (X @ X)) @ X
X @ ((X @ X) @ X)
X @ (X @ (X @ X))
(X @ X) @ (X @ X)'''.splitlines()

import itertools as its

def defrac(s):
    return re.compile(r'Fraction\((\d+)\)').sub(r'\1', s)

def evaluate(nums, ops, template):
    fracs = ('Fraction(%s)' % n for n in nums)
    ops = iter(ops)
    expr = ''.join(next(fracs) if c == 'X' else
                   next(ops) if c == '@' else c
                   for c in template)
    try:
        return expr, eval(expr)
    except ZeroDivisionError:
        return expr, None

def solve(spec, ops):
    numbers = re.compile(r'\d+').findall(spec)
    assert len(numbers) == N + 1
    result = Fraction(numbers.pop())
    seqs = its.product(its.permutations(numbers),
                       its.product(ops, repeat=N-1),
                       templates)
    print(defrac(next((e for e, v in its.starmap(evaluate, seqs)
                       if v == result),
                      'Impossible')))

def main():
    solve('2,5,6,6 =&amp;gt; 17', '+-/*')
    solve('3,3,8,8 =&amp;gt; 24', '+-/*')

main()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a second attempt, which doesn&amp;#8217;t assume there will just be 4 numbers on the left hand side of the equation. Given a sequence of numbers and a set of operators, it repeatedly reduces the sequence length by picking pair of numbers and combining them using one of the operators, iterating over all possible ways of doing this. The first sequence of length 1 which equals the target value gives a solution and terminates the search.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;# http://blog.plover.com/math/24-puzzle.html
from fractions import Fraction
import itertools as its
import operator
import re

def pick2(xs):
    return ((p[:2], p[2:]) for p in its.permutations(xs))

def allow(op, l, r):
    return op != '/' or eval(r) != 0

def apply(op, l, r):
    return '(%s%s%s)'%(l, op, r)

def values(xs, ops):
    L = [xs]
    while L:
        xs = L.pop()
        if len(xs) == 1:
            yield xs.pop()
        else:
            L.extend([apply(op, *lr)] + list(tl)
                     for op, (lr, tl) in its.product(ops, pick2(xs))
                     if allow(op, *lr))

def solve(spec, ops):
    numbers = ['Fraction(%s)'%n for n in re.compile(r'\d+').findall(spec)]
    target = eval(numbers.pop())
    print(next((v for v in values(numbers, ops) if eval(v) == target), 'Impossible'))

def main():
    solve('2,5,6,6 =&amp;gt; 17', '+-/*')
    solve('3,3,8,8 =&amp;gt; 24', '+-/*')

main()

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2017-03-08</dc:date>
<guid>http://wordaligned.org/articles/24-puzzles</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/24-puzzles</link>
<category>Puzzles</category>
</item>

<item>
<title>Python Streams vs Unix Pipes</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocinfinite-series-and-python" name="toc0" id="toc0"&gt;Infinite series and Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocinfinite-series-in-other-languages" name="toc1" id="toc1"&gt;Infinite series in Other Languages&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocpartial-sums" name="toc2" id="toc2"&gt;Partial sums.&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocconsecutive-sums" name="toc3" id="toc3"&gt;Consecutive sums&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocbug-fixes" name="toc4" id="toc4"&gt;Bug Fixes&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocmerging-streams" name="toc5" id="toc5"&gt;Merging Streams&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocgenerating-primes" name="toc6" id="toc6"&gt;Generating Primes&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocpipe-connection" name="toc7" id="toc7"&gt;Pipe Connection&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocportability" name="toc8" id="toc8"&gt;Portability&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocstream-merge" name="toc9" id="toc9"&gt;Stream Merge&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocalternative-solutions" name="toc10" id="toc10"&gt;Alternative Solutions&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;I chanced upon an interesting puzzle:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Find the smallest number that can be expressed as the sum of 5, 17, 563, 641 consecutive prime numbers, and is itself a prime number.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;img src="http://wordaligned.org/images/primes.png" alt="Small primes graphic"/&gt;

&lt;p&gt;Here, the prime numbers are an infinite steam:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;2, 3, 5, 7, 11, 13 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;and sums of N consecutive primes are similarly infinite. For example, the sum of 2 consecutive primes would be the stream:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;2+3, 3+5, 5+7, 7+11, 11+13 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;which is:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;5, 8, 12, 18, 24 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;and the sum of 3 consecutive primes is:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;10 (=2+3+5), 15, 23, 31 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Had we been asked to find the smallest number which can be expressed as the sum of 3 consecutive primes and as the sum of 5 consecutive primes and is itself prime, the answer would be &lt;code&gt;83&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; 23 + 29 + 31
83
&amp;gt;&amp;gt;&amp;gt; 11 + 13 + 17 + 19 + 23
83

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc0" name="tocinfinite-series-and-python" id="tocinfinite-series-and-python"&gt;Infinite series and Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;My first thought was to tackle this puzzle using Python iterators and generators. Here&amp;#8217;s the outline of a strategy:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     starting with a stream of primes
 &lt;/li&gt;

 &lt;li&gt;
     tee the stream to create 4 additional copies
 &lt;/li&gt;

 &lt;li&gt;
     transform these copies into the consecutive sums of 5, 17, 563 and 641 primes
 &lt;/li&gt;

 &lt;li&gt;
     now merge these consecutive sums back with the original primes stream
 &lt;/li&gt;

 &lt;li&gt;
     group the elements of this merged stream by value
 &lt;/li&gt;

 &lt;li&gt;
     the first group which contains 5 elements must have occurred in every source, and is therefore a prime and representable as the consecutive sum of 5, 17, 563 and 641 primes
 &lt;/li&gt;

 &lt;li&gt;
     which solves the puzzle!
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that when we copy an infinite stream we cannot consume it first. We will have to be lazy or we&amp;#8217;ll get exhausted.
&lt;/p&gt;
&lt;p&gt;Courtesy of the Python Cookbook, I already had a couple of &lt;a href="http://www.onlamp.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=2"&gt;useful&lt;/a&gt; &lt;a href="http://code.activestate.com/recipes/491285-iterator-merge/"&gt;recipes&lt;/a&gt; to help implement this strategy:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def primes():
    '''Generate the sequence of prime numbers: 2, 3, 5 ... '''
    ....

def stream_merge(*ss):
    '''Merge a collection of sorted streams.
    
    Example: merge multiples of 2, 3, 5
    &amp;gt;&amp;gt;&amp;gt; from itertools import count, islice
    &amp;gt;&amp;gt;&amp;gt; def multiples(x): return (x * n for n in count(1))
    &amp;gt;&amp;gt;&amp;gt; s = stream_merge(multiples(2), multiples(3), multiples(5))
    &amp;gt;&amp;gt;&amp;gt; list(islice(s, 10))
    [2, 3, 4, 5, 6, 6, 8, 9, 10, 10]
    '''
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Both these functions merit a closer look for the cunning use they make of standard containers, but we&amp;#8217;ll defer this inspection until later. In passing, note that &lt;code&gt;stream_merge()&lt;/code&gt;&amp;#8217;s docstring suggests we might try using it as basis for &lt;code&gt;primes()&lt;/code&gt;:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;form the series of composite (non-prime) numbers by merging the streams formed by multiples of prime numbers; 
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;the primes remain when you remove these composites from the series of natural numbers.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This scheme is hardly original &amp;#8212; it&amp;#8217;s a variant of &lt;a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"&gt;Eratosthenes&amp;#8217; sieve&lt;/a&gt; &amp;#8212; but if you look carefully you&amp;#8217;ll notice the self-reference. Unfortunately recursive definitions of infinite series don&amp;#8217;t work well with Python&lt;a id="fn1link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;, hence &lt;code&gt;primes()&lt;/code&gt; requires a little more finesse. We&amp;#8217;ll take a look at it later.
&lt;/p&gt;
&lt;p&gt;Moving on, to solve the original puzzle we need a consecutive sum filter. This will transform a stream of numbers into a stream of consecutive sums of these numbers:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def consecutive_sum(s, n):
    '''Generate the series of sums of n consecutive elements of s
    
    Example: 0, 1, 2, 3, 4 ... =&amp;gt; 0+1, 1+2, 2+3, 3+4, ...
    &amp;gt;&amp;gt;&amp;gt; from itertools import count, islice
    &amp;gt;&amp;gt;&amp;gt; list(islice(consecutive_sum(count(), 2), 10))
    [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    '''
    lo, hi = itertools.tee(s)
    csum = sum(next(hi) for _ in range(n))
    while True:
        yield csum
        csum += next(hi) - next(lo)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here we can think of the summed elements as lying within a sliding window: each time we slide the window an element gets added to the top and an element gets removed from the bottom, and we adjust &lt;code&gt;csum&lt;/code&gt; accordingly.
&lt;/p&gt;
&lt;p&gt;So, now we have:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     the series of prime numbers, &lt;code&gt;primes()&lt;/code&gt;
 &lt;/li&gt;

 &lt;li&gt;
     a &lt;code&gt;stream_merge()&lt;/code&gt; connector
 &lt;/li&gt;

 &lt;li&gt;
     a &lt;code&gt;consecutive_sum()&lt;/code&gt; filter
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The remaining stream adaptors come from the standard &lt;a href="http://docs.python.org/lib/itertools-functions.html"&gt;itertools module&lt;/a&gt;. Note that the &lt;code&gt;stream_merge()&lt;/code&gt; works here since all the consecutive sum series are strictly increasing. Note also that the stream of prime numbers can be treated as &lt;code&gt;consecutive_sum(s=primes(), n=1)&lt;/code&gt;, handling the &amp;#8220;and is itself a prime number&amp;#8221; requirement.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; lens = 1, 5, 17, 563, 641
&amp;gt;&amp;gt;&amp;gt; N = len(lens)
&amp;gt;&amp;gt;&amp;gt; from itertools import tee, groupby
&amp;gt;&amp;gt;&amp;gt; ps = tee(primes(), N)
&amp;gt;&amp;gt;&amp;gt; csums = [consecutive_sum(p, n) for p, n in zip(ps, lens)]
&amp;gt;&amp;gt;&amp;gt; solns = (n for n, g in groupby(stream_merge(*csums)) 
             if len(list(g)) == N)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;solns&lt;/code&gt; is yet another stream, the result of merging the &lt;code&gt;N&lt;/code&gt; input consecutive sum streams then filtering out the numbers which appear &lt;code&gt;N&lt;/code&gt; times; that is, the numbers which can be expressed as sums of 1, 5, 17, 563 and 641 consecutive primes.
&lt;/p&gt;
&lt;p&gt;The first such number solves the original puzzle.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; next(solns)
7002221

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a picture of how these stream tools link up to solve this particular puzzle. The great thing is that we can reconnect these same tools to solve a wide range of puzzles, and indeed more practical &lt;a href="http://www.dabeaz.com/generators/"&gt;processing tasks&lt;/a&gt;. To use the common analogy, we direct data streams along pipes.
&lt;/p&gt;
&lt;img alt="Stream connections" src="http://wordaligned.org/images/pipeline.png"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc1" name="tocinfinite-series-in-other-languages" id="tocinfinite-series-in-other-languages"&gt;Infinite series in Other Languages&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Python is the language I find most convenient most of the time, which explains why I reached for it first. It&amp;#8217;s an increasingly popular language, which helps explain why I didn&amp;#8217;t need to write the tricky parts of my solution from scratch: they&amp;#8217;d already been done. Python is also a language which makes compromises. Having used Python to find a solution to the puzzle I wondered if there wasn&amp;#8217;t some other language better suited to this kind of problem.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://haskell.org"&gt;Haskell&lt;/a&gt; makes no compromises when it comes to functional programming. Its lazy evaluation and inductive recursion make it a perfect fit for this kind of puzzle &amp;#8212; but my  approach of teeing, filtering and merging made me consider the Unix Shell. Now, I use Bash every day and page through its manual at least once a week. Scripting appeals and I&amp;#8217;m comfortable at the command line. How hard could it be to solve this puzzle using Bash? After all, I already knew the answer!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc2" name="tocpartial-sums" id="tocpartial-sums"&gt;Partial sums.&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple shell function to generate partial sums. I&amp;#8217;ve used &lt;code&gt;awk&lt;/code&gt;, a little language I gave up on a long time ago in favour of more rounded scripting languages like Perl and then Python. Now I look at it again, it seems to fill a useful gap. Awk processes a file sequentially, applying pattern-action rules to each line, a processing template which I&amp;#8217;ve reinvented less cleanly many times. Despite my rediscovery of &lt;code&gt;awk&lt;/code&gt;, I&amp;#8217;ll be keeping its use strongly in check in what follows.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ psum() { awk '{ print s += $1 }'; }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Much like Perl, &lt;code&gt;awk&lt;/code&gt; guesses what you want to do. Here, it conjures the summation variable, &lt;code&gt;s&lt;/code&gt;, into existence, assigning it a default initial value of 0. (Good guess!) Since we&amp;#8217;re doing arithmetic &lt;code&gt;awk&lt;/code&gt; converts the first field of each input line into a number. We can test &lt;code&gt;psum&lt;/code&gt; by using &lt;code&gt;jot&lt;/code&gt; to generate the sequence 1, 2, 3, 4, 5 (this is on a Mac &amp;#8212; on a Linux platform use &lt;code&gt;seq&lt;/code&gt; instead of &lt;code&gt;jot&lt;/code&gt;).
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ jot 5 | psum
1
3
6
10
15

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc3" name="tocconsecutive-sums" id="tocconsecutive-sums"&gt;Consecutive sums&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You may be wondering why we&amp;#8217;ve bothered creating this partial sum filter since it&amp;#8217;s the sums of consecutive elements we&amp;#8217;re after, rather than the sum of the series so far. Well, notice that if &lt;code&gt;P[i]&lt;/code&gt; and &lt;code&gt;P[i+n]&lt;/code&gt; are two elements from the series of partial sums of S, then their difference, &lt;code&gt;P[i+n] - P[i]&lt;/code&gt;, is the sum of the &lt;code&gt;n&lt;/code&gt; consecutive elements from S.
&lt;/p&gt;
&lt;p&gt;So to form an n-element consecutive sum series we can tee the partial sums streams, advance one of these by n, then zip through them in parallel finding their differences. An example makes things clear:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ mkfifo pipe
$ jot 5 | psum | tee pipe | tail -n +2 | paste - pipe
3       1
6       3
10      6
15      10
        15

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;jot 5&lt;/code&gt; generates the sequence 1, 2, 3, 4, 5, which &lt;code&gt;psum&lt;/code&gt; progressively accumulates to 1, 3, 6, 10, 15. We then &lt;code&gt;tee&lt;/code&gt; this partial sum series through two pipes: the first, &lt;code&gt;pipe&lt;/code&gt;, is an explicitly created named pipe created by &lt;code&gt;mkfifo&lt;/code&gt;, the second is implicitly created by the pipeline operator, &lt;code&gt;|&lt;/code&gt;. The remainder of the command line delays one series by one (note that &lt;code&gt;tail&lt;/code&gt; numbers lines from &lt;code&gt;1&lt;/code&gt;, not &lt;code&gt;0&lt;/code&gt;, so &lt;code&gt;tail -n +1&lt;/code&gt; is the identity filter) then pastes the two series back together&lt;a id="fn2link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;By appending a single &lt;code&gt;awk&lt;/code&gt; action to the pipeline we get a consecutive sum series.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ jot 5 | psum | tee pipe | tail -n +2 | paste - pipe | awk '{print $1 - $2}'
2
3
4
5
15

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The output 2, 3, 4, 5 is the series of consecutive sums of length 1 taken from the original series 1, 2, 3, 4, 5. The trailing 15 and the 1 missed from the start are edge case problems, and easily corrected.
&lt;/p&gt;
&lt;p&gt;Accumulating an increasing series of numbers in order to find the differences between elements lying a given distance apart on this series isn&amp;#8217;t a very smart idea on a computer with a fixed word-size, but it&amp;#8217;s good to know (e.g.) that &lt;code&gt;awk&lt;/code&gt; doesn&amp;#8217;t stop counting at 32 bits.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ let "N=1&amp;lt;&amp;lt;32" &amp;amp;&amp;amp; echo $N | tee &amp;gt;(awk '{print $1 * $1}')
4294967296
18446744073709551616

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Exactly if and when awk stops counting, I&amp;#8217;m not sure. The documentation doesn&amp;#8217;t say and I haven&amp;#8217;t looked at the source code.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc4" name="tocbug-fixes" id="tocbug-fixes"&gt;Bug Fixes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s capture these tiny functions and name them. Here, then, are revised &lt;code&gt;psum()&lt;/code&gt; and &lt;code&gt;sdiff()&lt;/code&gt; filters. The edge case problems should now be fixed.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ psum()  { awk 'BEGIN { print 0 }{print s += $1 }'; }
$ delay() { let "n = $1 + 1" &amp;amp;&amp;amp; tail +$n; } 
$ sdiff() { mkfifo p.$1 &amp;amp;&amp;amp; tee p.$1 | delay $1 | paste - p.$1 | \
            awk 'NF == 2 {print $1 - $2 }'; }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A quick test:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ jot 5 | psum | sdiff 3
6
9
12

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The output is, as expected, the series of sums of consecutive triples taken from 1, 2, 3, 4, 5 (6=1+2+3, 9=2+3+4, 12=3+4+5).
&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s a pernicious bug, though. These functions can&amp;#8217;t handle infinite series so they are of limited use as pipeline tools. For example, if we stream in the series 0, 1, 2, &amp;#8230; (generated here as the partial sums of the series 1, 1, 1, &amp;#8230;) nothing gets output and we have to interrupt the process.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;# This command appears to hang
$ yes 1 | psum | sdiff 1
^C

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To work around this is, we can use Gnu &lt;code&gt;stdbuf&lt;/code&gt; to prohibit &lt;code&gt;tail&lt;/code&gt; and &lt;code&gt;paste&lt;/code&gt; from using output buffers.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ psum()  { awk 'BEGIN { print 0 }{print s += $1 }'; }
$ delay() { let "n = $1 + 1" &amp;amp;&amp;amp; stdbuf -o 0 tail +$n; } 
$ sdiff() { mkfifo p.$1 &amp;amp;&amp;amp; tee p.$1 | delay $1 | \
            stdbuf -o 0 paste - p.$1 | \
            awk 'NF == 2 {print $1 - $2 }'; }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now the data flows again:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;# Accumulate the stream 1 1 1 ...
# and print the difference between successive elements
$ yes 1 | psum | sdiff 1
1
1
1
1
^C

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc5" name="tocmerging-streams" id="tocmerging-streams"&gt;Merging Streams&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Unix shell merges streams rather more succinctly than Python. &lt;code&gt;Sort -m&lt;/code&gt; does the job directly. Note that a standard &lt;code&gt;sort&lt;/code&gt; cannot yield any output until all its inputs are exhausted, since the final input item might turn out to be the one which should appear first in the output. Merge sort, &lt;code&gt;sort -m&lt;/code&gt;, can and does produce output without delay&lt;a id="fn3link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn3"&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ yes | sort
^C
$ yes | sort -m
y
y
y
y
y
^C

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc6" name="tocgenerating-primes" id="tocgenerating-primes"&gt;Generating Primes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;No doubt it&amp;#8217;s possible to generate the infinite series of prime numbers using native Bash code, but I chose to reuse the &lt;a href="http://www.onlamp.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=2"&gt;Python Cookbook recipe&lt;/a&gt; for the job.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;primes&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#!/usr/bin/env python
import itertools

def primes():
    '''Generate the prime number series: 2, 3, 5 ... '''
    D = {}
    for n in itertools.count(2):
        p = D.pop(n, None)
        if p is None:
            yield n
            D[n * n] = n
        else:
            x = n + p
            while x in D:
                x += p
            D[x] = p

for p in primes():
    print(p)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This is a subtle little program which makes clever use of Python&amp;#8217;s native hashed array container, the dictionary. In this case dictionary values are the primes less than &lt;code&gt;n&lt;/code&gt; and the keys are composite multiples of these primes. The loop invariant, roughly speaking, is that the dictionary values are the primes less than &lt;code&gt;n&lt;/code&gt;, and the corresponding keys are the lowest multiples of these primes greater than or equal to &lt;code&gt;n&lt;/code&gt;. It&amp;#8217;s a lazy, recursion-free take of Eratosthenes&amp;#8217; sieve.
&lt;/p&gt;
&lt;p&gt;For the purposes of this article the important things about this program are:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     it generates an infinite series of numbers to standard output&lt;a id="fn4link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn4"&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/a&gt;, making it a good source for a shell pipeline
 &lt;/li&gt;

 &lt;li&gt;
     by making it executable and adding the usual shebang incantation, we can invoke this Python program seamlessly from the shell.
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc7" name="tocpipe-connection" id="tocpipe-connection"&gt;Pipe Connection&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recall the original puzzle:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Find the smallest number that can be expressed as the sum of 5, 17, 563, 641 consecutive prime numbers, and is itself a prime number.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;First, let&amp;#8217;s check the connections by solving a simpler problem which we can manually verify: to find prime numbers which are also the sum of 2 consecutive primes. As we noted before, this is the same as finding primes numbers which are the consecutive sums of 1 and 2 primes.
&lt;/p&gt;
&lt;p&gt;In one shell window we create a couple of named pipes, &lt;code&gt;c.1&lt;/code&gt; and &lt;code&gt;c.2&lt;/code&gt;, which we&amp;#8217;ll use to stream the consecutive sum series of 1 and 2 primes respectively. The results series comprises the duplicates when we merge these pipes.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Shell 1&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ mkfifo c.{1,2}
$ sort -mn c.{1,2} | uniq -d

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In another shell window, stream data into c.1 and c.2:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Shell 2&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ for i in 1 2; do (primes | psum | sdiff $i &amp;gt; c.$i) &amp;amp; done

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In the first window we see the single number &lt;code&gt;5&lt;/code&gt;, which is the first and only prime number equal to the sum of two consecutive primes.
&lt;/p&gt;
&lt;p&gt;Prime numbers equal to the sum of three consecutive primes are more interesting. In each shell window recall the previous commands and switch the 2s to 3s (a simple command history recall and edit, &lt;code&gt;^2^3^&lt;/code&gt;, does the trick). The merged output now looks like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ sort -mn c.1 c.3 | uniq -d
23
31
41
...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can check the first few values:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;23 = 5 + 7 + 11
31 = 7 + 11 + 13
41 = 11 + 13 + 17

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;At this point we&amp;#8217;re confident enough to give the actual puzzle a try. Start up the solutions stream.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ mkfifo c.{1,5,17,563,641}
$ sort -mn c.{1,5,17,563,641} | uniq -c | grep "5 "

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, we use a standard &lt;a href="http://wordaligned.org/articles/shell-script-sets"&gt;shell script set intersection&lt;/a&gt; recipe: &lt;code&gt;uniq -c&lt;/code&gt; groups and counts repeated elements, and the &lt;code&gt;grep&lt;/code&gt; pattern matches those numbers common to all five input streams.
&lt;/p&gt;
&lt;p&gt;Now we can kick off the processes which will feed into the consecutive sum streams, which &lt;code&gt;sort&lt;/code&gt; is waiting on.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ for i in 1 5 17 563 641; do (primes | psum | sdiff $i &amp;gt; c.$i) &amp;amp; done

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Sure enough, after about 15 seconds elapsed time&lt;a id="fn5link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn5"&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/a&gt;, out pops the result:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ sort -mn c.{1,5,17,563,641} | uniq -c | grep "5 "
    5 7002221

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;15 seconds seems an eternity for arithmetic on a modern computer (you could start up a word processor in less time!), and you might be inclined to blame the overhead of all those processes, files, large numbers, etc. In fact it took around 6 seconds for the Python program simply to generate prime numbers up to 7002221, and my pure Python solution ran in 9 seconds.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc8" name="tocportability" id="tocportability"&gt;Portability&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;One of the most convenient things about Python is its portability. I don&amp;#8217;t mean &amp;#8220;portable so long as you conform to the language standard&amp;#8221; or &amp;#8220;portable if you stick to a subset of the language&amp;#8221; &amp;#8212; I mean that a Python program works whatever platform I use without me having to worry about it.
&lt;/p&gt;
&lt;p&gt;Non-portability put me off the Unix shell when I first encountered it: there seemed too many details, too many platform differences &amp;#8212; which shell are you using? which extensions? which implementation of the core utilities, etc, etc? Readily available and well-written documentation didn&amp;#8217;t help much here: generally I want the shell to just do what I mean, which is why I switched so happily to Perl when I discovered it.
&lt;/p&gt;
&lt;p&gt;Since then this situation has, for me, improved in many ways. Non-Unix platforms are declining as are the different flavours of Unix. Bash seems to have become the standard shell of choice and Cygwin gets better all the time. GNU coreutils predominate. As a consequence I&amp;#8217;ve forgotten almost all the Perl I ever knew and am actively rediscovering the Unix shell.
&lt;/p&gt;
&lt;p&gt;Writing this article, though, I was reminded of the platform dependent behaviour which used to discourage me. On a Linux platform close to hand I had to use &lt;code&gt;seq&lt;/code&gt; instead of &lt;code&gt;jot&lt;/code&gt;, and &lt;code&gt;awk&lt;/code&gt; formatted large integers in a scientific form with a loss of precision.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Loss of precision&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ echo '10000000001 0' | awk '{print $1 - $2}'
1e+10

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;On OS X the same command outputs 10000000001. I couldn&amp;#8217;t tell you which implementation is more correct. The fix is to explicitly format these numbers as decimal integers, but the danger is that the shell silently swallows these discrepancies and you&amp;#8217;ve got a portability problem you don&amp;#8217;t even notice.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Precision recovered&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ echo '10000000001 0' | awk '{printf "%d\n", $1 - $2}'
10000000001

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc9" name="tocstream-merge" id="tocstream-merge"&gt;Stream Merge&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I mentioned &lt;code&gt;stream_merge()&lt;/code&gt; at the start of this article, a general purpose function written by Raymond Hettinger which I originally found in the Python Cookbook. As with the prime number generator, you might imagine the merge algorithm to be recursively defined:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;to merge a pair of streams, take items from the first which are less than the head of the second, then swap;
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;to merge N streams, merge the first stream with the merged (N-1) rest.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Again the Python solution does it differently, this time using a heap as a priority queue of items from the input streams. It&amp;#8217;s ingenious and efficient. Look how easy it is in Python to shunt functions and pairs in and out of queues.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from heapq import heapify, heappop, heapreplace

def stream_merge(*ss):
    '''Merge a collection of sorted streams.'''
    pqueue = []
    for i in map(iter, ss):
        try:
            pqueue.append((i.next(), i.next))
        except StopIteration:
            pass
    heapify(pqueue)
    while pqueue:
        val, it = pqueue[0]
        yield val
        try:
            heapreplace(pqueue, (it(), it))
        except StopIteration:
            heappop(pqueue)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A more sophisticated version of this code has made it into the Python standard library, where it goes by the name of &lt;a href="http://docs.python.org/dev/library/heapq.html#heapq.merge"&gt;heapq.merge&lt;/a&gt; (I wonder why it wasn&amp;#8217;t filed in &lt;a href="http://docs.python.org/lib/itertools-functions.html"&gt;itertools&lt;/a&gt;?)
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc10" name="tocalternative-solutions" id="tocalternative-solutions"&gt;Alternative Solutions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As usual Haskell wins the elegance award, so I&amp;#8217;ll quote in full a solution built without resorting to cookbookery which produces the (correct!) answer in 20 seconds.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;module Main where

import List

isPrime x = all (\i -&amp;gt; 0/=x`mod`i) $ takeWhile (\i -&amp;gt; i*i &amp;lt;= x) primes

primes = 2:filter (\x -&amp;gt; isPrime x) [3..]

cplist n = map (sum . take n) (tails primes)

meet (x:xs) (y:ys) | x &amp;lt; y = meet xs (y:ys)
                   | y &amp;lt; x = meet (x:xs) ys
                   | x == y =  x:meet xs ys

main = print $ head $ \
(primes `meet` cplist 5) `meet` (cplist 17 `meet` cplist 563) `meet` cplist 641

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn1link"&gt;[1]&lt;/a&gt; CPython, more precisely &amp;#8212; I don&amp;#8217;t think anything in the Python language itself prohibits tail recursion. Even using CPython, yet another &lt;a href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/496691"&gt;recipe&lt;/a&gt; from the online Python Cookbook explores the idea of an &lt;code&gt;@tail_recursion&lt;/code&gt; decorator.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn2link"&gt;[2]&lt;/a&gt; &lt;code&gt;Tail&lt;/code&gt; is more commonly used to yield a fixed number of lines from the end of the file: by prefixing the line count argument with a &lt;code&gt;+&lt;/code&gt; sign, it skips lines from the head of the file. The GNU version of &lt;code&gt;head&lt;/code&gt; can similarly be used with a &lt;code&gt;-&lt;/code&gt; prefix to skip lines at the tail of a file. The notation is {compact,powerful,subtle,implementation dependent}.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn3" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn3link"&gt;[3]&lt;/a&gt; &lt;code&gt;Sort -m&lt;/code&gt; is a sort which doesn&amp;#8217;t really sort &amp;#8212; its inputs should already be sorted &amp;#8212; rather like the &lt;code&gt;+n&lt;/code&gt; option turning &lt;code&gt;tail&lt;/code&gt; on its head.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn4" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn4link"&gt;[4]&lt;/a&gt; The series is infinite in theory only: at time &lt;code&gt;n&lt;/code&gt; the number of items in the &lt;code&gt;has_prime_factors&lt;/code&gt; dictionary equals the number of primes less than &lt;code&gt;n&lt;/code&gt;, and each key in this dictionary is larger than &lt;code&gt;n&lt;/code&gt;. So resource use increases steadily as &lt;code&gt;n&lt;/code&gt; increases.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn5" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn5link"&gt;[5]&lt;/a&gt; I used a MacBook laptop used to run these scripts. 
&lt;/p&gt;
&lt;pre&gt;
  Model Name:               MacBook
  Model Identifier:         MacBook1,1
  Processor Name:           Intel Core Duo
  Processor Speed:          2 GHz
  Number Of Processors:     1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;</description>
<dc:date>2016-07-28</dc:date>
<guid>http://wordaligned.org/articles/python-streams-vs-unix-pipes</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/python-streams-vs-unix-pipes</link>
<category>Puzzles</category>
</item>

<item>
<title>8 Queens Puzzle++</title>
<description>&lt;p&gt;&lt;a href="http://wordaligned.org/articles/8-queens-puzzle"&gt;Yesterday I wrote about&lt;/a&gt; a Python solution to the 8 Queens puzzle.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n = 8
sqs = range(n)

Qs = (Q for Q in itertools.permutations(sqs)
      if n == len({Q[i]+i for i in sqs})
           == len({Q[i]-i for i in sqs}))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It&amp;#8217;s possible to reproduce this strategy in C++:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     range(n) &amp;#8594; &lt;a href="http://en.cppreference.com/w/cpp/algorithm/iota"&gt;std::iota&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;
     itertools.permutations &amp;#8594; &lt;a href="http://wordaligned.org/articles/next-permutation"&gt;std::next_permutation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;
     set comprehension &amp;#8594; set insertion
 &lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist.github.com/wordaligned/c94649d6b37ec08a9bda16e53c43b888.js"&gt;&lt;/script&gt;

&lt;p&gt;The &lt;code&gt;std::next_permutation&lt;/code&gt; algorithm stands alone in the C++ standard library. Used here, it pairs well with the similarly uncommon &lt;code&gt;do ... while&lt;/code&gt; loop. The solution depends on the vector &lt;code&gt;sqs&lt;/code&gt; starting off in sorted order, and by the end of the loop the vector will have been returned to &lt;a href="https://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort"&gt;this state&lt;/a&gt;.
&lt;/p&gt;</description>
<dc:date>2016-04-05</dc:date>
<guid>http://wordaligned.org/articles/8-queens-puzzle-cpp</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/8-queens-puzzle-cpp</link>
<category>Puzzles</category>
</item>

<item>
<title>8 Queens Puzzle</title>
<description>&lt;p style="font-size:4em"&gt;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&lt;/p&gt;

&lt;p&gt;Here&amp;#8217;s one of my favourite &lt;a href="http://code.activestate.com/recipes/576647-eight-queens-six-lines"&gt;recipes, by Raymond Hettinger&lt;/a&gt;, lightly adapted for Python 3.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from itertools import permutations

n = width_of_chessboard = 8
sqs = range(n)

Qs = (Q for Q in permutations(sqs)
      if n == len({Q[i]+i for i in sqs})
           == len({Q[i]-i for i in sqs}))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We start by assigning &lt;code&gt;sqs&lt;/code&gt; to the range 0 through 7.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sqs = range(8)
&amp;gt;&amp;gt;&amp;gt; list(sqs)
[0, 1, 2, 3, 4, 5, 6, 7]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The range has 8 indices. If each index represents a column on a standard 8x8 chessboard and the value at that index represents a row on the same chessboard, then our range represents 8 positions on the board. Using the built-in &lt;a href="https://docs.python.org/3/library/functions.html#enumerate"&gt;enumerate&lt;/a&gt; function to generate these &lt;code&gt;(index, value)&lt;/code&gt; pairs we see that &lt;code&gt;sqs&lt;/code&gt; encodes the diagonal &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(7, 7)&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(enumerate(sqs))
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7)]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, permute the values &amp;#8212; the rows.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; rooks = permutations(sqs)
&amp;gt;&amp;gt;&amp;gt; next(rooks)
(0, 1, 2, 3, 4, 5, 6, 7)
&amp;gt;&amp;gt;&amp;gt; next(rooks)
(0, 1, 2, 3, 4, 5, 7, 6)
&amp;gt;&amp;gt;&amp;gt; next(rooks)
(0, 1, 2, 3, 4, 6, 5, 7)
&amp;gt;&amp;gt;&amp;gt; list(rooks)[34567]
(6, 7, 0, 1, 3, 4, 5, 2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://docs.python.org/3/library/itertools.html#itertools.permutations"&gt;Itertools.permutations&lt;/a&gt; generates values lazily. The snippet above shows the first two results, then skips forward 34568 places. &lt;code&gt;Permutations(sqs)&lt;/code&gt; generates all possible arrangements of 8 pieces on a chessboard such that each row has exactly one piece on it and so does each column. That is, it generates all possible ways of placing 8 &lt;a href="http://mathworld.wolfram.com/RooksProblem.html"&gt;rooks on a chessboard&lt;/a&gt; so that no pair attacks each other.
&lt;/p&gt;
&lt;p&gt;In the final program, we filter these rook positions to generate solutions to the more challenging &amp;#8212; and more interesting &amp;#8212; &lt;a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle"&gt;eight Queens puzzle&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Consider our starting point, the diagonal &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(7, 7)&lt;/code&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; diagonal = range(8)
&amp;gt;&amp;gt;&amp;gt; {r-c for c,r in enumerate(diagonal)}
{0}
&amp;gt;&amp;gt;&amp;gt; {r+c for c,r in enumerate(diagonal)}
{0, 2, 4, 6, 8, 10, 12, 14}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, a set comprehension collects the distinct values taken by the difference between the row and column along this diagonal, which in this case gives &lt;code&gt;{0}&lt;/code&gt;. That is, if we placed 8 bishops along this &amp;#x2197; diagonal they would all attack each other along this diagonal. The sum of the row and column takes 8 distinct values, however, meaning no pair attacks along a &amp;#x2196; diagonal.
&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3/reference/expressions.html#comparisons"&gt;Comparison operators chain in Python&lt;/a&gt;, so the expression:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n == len({Q[i]+i for i in sqs}) == len({Q[i]-i for i in sqs})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is &lt;code&gt;True&lt;/code&gt; if both sets have 8 elements, that is, if the squares in &lt;code&gt;Q&lt;/code&gt; are on distinct &amp;#x2196; and &amp;#x2197; diagonals; or, equivalently no pair of bishops placed on the squares in &lt;code&gt;Q&lt;/code&gt; would attack each other. Since we already know &lt;code&gt;Q&lt;/code&gt; positions 8 rooks so that no pair attacks each other, and a chess Queen combines the moves of a rook and a bishop, we can see that &lt;code&gt;Qs&lt;/code&gt; generates every possible way of placing 8 Queens on a chessboard so that no pair attacks each other: which is to say, we&amp;#8217;ve solved the &lt;a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle"&gt;8 Queens puzzle&lt;/a&gt;.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Qs = (Q for Q in permutations(sqs)
      if n == len({Q[i]+i for i in sqs})
           == len({Q[i]-i for i in sqs}))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is beautiful code and there&amp;#8217;s one final twist.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Qs&lt;/code&gt; is a &lt;a href="https://docs.python.org/3/reference/expressions.html#generator-expressions"&gt;generator expression&lt;/a&gt; primed to permute squares into neighbourly rooks filtered by amicable bishops yielding unthreatening Queens. Until asked, however, it does nothing.
&lt;/p&gt;
&lt;p style="font-size:4em"&gt;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&lt;/p&gt;</description>
<dc:date>2016-04-04</dc:date>
<guid>http://wordaligned.org/articles/8-queens-puzzle</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/8-queens-puzzle</link>
<category>Puzzles</category>
</item>

<item>
<title>Sausages, sausages, sausages - slice, slice, slice</title>
<description>&lt;p&gt;A friend asked for help reaching the next level of a puzzle game. The test which stalled her involves machine placement in a sausage factory.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; each sausage was branded with a letter for quality control purposes, thus:
   &lt;strong&gt;ypbtkizfgxptclcoirdsuhjwulqkoszrabfc&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;The string was then drawn through seven machines which rearranged the sausages in flavour enhancing ways.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine A: The Reversifier&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;Reverses the order of the sausages, so they get tastier as you go along.
&lt;/p&gt;
&lt;p&gt;&amp;#8230;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine G: Secondhalffirstifier&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;move the second half of the string to the beginning, as the earlier sausages are too spicy to eat early in the morning.
&lt;/p&gt;
&lt;p&gt;He attached these machines in a certain sequence, though one of them was out for repair so only six were used. He then fed a string of sausages through and was surprised to discover the string that came out at the other end said &lt;strong&gt;lickyourlips&lt;/strong&gt;. What order were the machines in?
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;It&amp;#8217;s nicely phrased, but what&amp;#8217;s really wanted is the sequence of simple transformations that takes input &amp;#8220;ypbtkizfgxptclcoirdsuhjwulqkoszrabfc&amp;#8221; and produces output &amp;#8220;lickyourlips&amp;#8221;.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s no doubt possible to work backwards and figure out a solution using no more than logic, pencil and paper. For example, only two of the machines change the length of the string, and &amp;#8212; looking at the before and after lengths &amp;#8212; these must both be used. It&amp;#8217;s rather easier to write a short program to find a solution.
&lt;/p&gt;
&lt;p&gt;First we must simulate the seven sausage machines, A-G, which perform the following sequence operations.
&lt;/p&gt;
&lt;ol type="A"&gt;
&lt;li&gt;reverse the order of a sequence&lt;/li&gt;
&lt;li&gt;remove every other element of a sequence&lt;/li&gt;
&lt;li&gt;remove every third element of a sequence&lt;/li&gt;
&lt;li&gt;pairwise reverse elements of a sequence&lt;/li&gt;
&lt;li&gt;move even numbered elements to the front of a sequence&lt;/li&gt;
&lt;li&gt;move the last element of a sequence to the front&lt;/li&gt;
&lt;li&gt;swap the front and back half of a sequence&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;None of these is difficult, especially in a high-level language which builds in support for sequence operations. What I found noteworthy is that a solution can be found without any &lt;a href="https://docs.python.org/3/reference/compound_stmts.html"&gt;loops or if statements&lt;/a&gt;. What&amp;#8217;s more, every operation can handled using nothing more than &lt;a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range"&gt;slice operations&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s my solution. The machines consist of slice operations, helped by a couple of conditional expressions and recursive calls. The solution can then be brute-forced: there are only 5040 ways of permuting 6 out of 7 machines.
&lt;/p&gt;
&lt;script src="https://gist.github.com/wordaligned/a04308eac7ee2aa37e01.js"&gt;&lt;/script&gt;

&lt;p&gt;I&amp;#8217;ve used &lt;code&gt;reduce&lt;/code&gt; to apply a chain of functions to a string of sausages &amp;#8212; an explicit loop might be clearer, but I want a loop-free solution. For this same reason I use recursion in the pairwise swapper and the element dropper. Generally in Python, recursion is a poor choice. In this case I know I&amp;#8217;m starting with a string of just 36 elements which cannot get any longer; there&amp;#8217;s no risk of exceeding the &lt;a href="https://docs.python.org/3/library/sys.html#sys.getrecursionlimit"&gt;system recursion limit&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;The sequence reversal &lt;code&gt;s[::-1]&lt;/code&gt; is idiomatic but alarming to the uninitiated. Slices have &lt;code&gt;[start:stop:stride]&lt;/code&gt; fields, any of which may be defaulted. Usually &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; default to the start and end of the sequence, but in this case the negative stride reverses them.
&lt;/p&gt;
&lt;p&gt;To rotate the last element of a sequence to the front, prefer:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return s[-1:] + s[:-1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return [s[-1]] + s[:-1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;because the latter raises an &lt;code&gt;IndexError&lt;/code&gt; for an empty sequence.
&lt;/p&gt;
&lt;p&gt;Slicing is a formidable tool for sequence manipulation, especially when combined with the option of using negative indices to count back from the end. Slices allow you to reverse, rotate and partition sequences, to pairwise swap elements, and to drop every nth element.
&lt;/p&gt;
&lt;p&gt;The miniature recipes presented here don&amp;#8217;t even use slice assignment, which gives me an excuse to reproduce this elegant prime sieve function, which does.
&lt;/p&gt;
&lt;script src="https://gist.github.com/wordaligned/09c17eaabb6cd4c6bcfb.js"&gt;&lt;/script&gt;</description>
<dc:date>2016-03-21</dc:date>
<guid>http://wordaligned.org/articles/sausages-slices</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/sausages-slices</link>
<category>Puzzles</category>
</item>

<item>
<title>Reverse, Esrever</title>
<description>&lt;p&gt;&lt;code&gt;&lt;a href="http://en.cppreference.com/w/cpp/algorithm/reverse"&gt;Reverse&lt;/a&gt;&lt;/code&gt; is a member of the C++ standard library, but its reverse, &lt;code&gt;esrever&lt;/code&gt;, isn&amp;#8217;t. Similarly &lt;code&gt;keep&lt;/code&gt; isn&amp;#8217;t but &lt;code&gt;&lt;a href="http://en.cppreference.com/w/cpp/io/basic_istream/peek"&gt;peek&lt;/a&gt;&lt;/code&gt; is.
&lt;/p&gt;
&lt;p&gt;Can anyone think of a C++ standard library member whose reverse &lt;strong&gt;is also a member&lt;/strong&gt;?
&lt;/p&gt;
&lt;p&gt;Answers in the comments below.
&lt;/p&gt;
&lt;p&gt;Go!
&lt;/p&gt;</description>
<dc:date>2013-09-27</dc:date>
<guid>http://wordaligned.org/articles/reverse-esrever</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/reverse-esrever</link>
<category>Puzzles</category>
</item>

<item>
<title>Clown, Flee, Jump</title>
<description>&lt;p&gt;The clown is running away from the circus. The contortionist wants nothing more to do with him. She&amp;#8217;s confessed everything to her husband, the strongman, who&amp;#8217;s after the clown&amp;#8217;s blood. The clown has no time to pack. Hurrying from the big top he snatches up his most treasured possessions and some refreshments:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     a makeup case
 &lt;/li&gt;

 &lt;li&gt;
     a box camera, with tripod attached
 &lt;/li&gt;

 &lt;li&gt;
     a cactus
 &lt;/li&gt;

 &lt;li&gt;
     a roasted goose
 &lt;/li&gt;

 &lt;li&gt;
     a magnum of champagne
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each item weighs exactly 3kg.
&lt;/p&gt;
&lt;p&gt;Soon he reaches the edge of a ravine. A rope bridge connected to the other side has a sign in front of it.
&lt;/p&gt;
&lt;pre style="align:center;width:400px;border: 2px solid red; background: white;font-size:200%;"&gt;WARNING
UNSTABLE STRUCTURE
SAFE TO A MAXIMUM OF 75KG&lt;/pre&gt;

&lt;p&gt;The bridge is 100m long. The clown weighs 70kg. The strongman, who&amp;#8217;s closing in, weighs considerably more. The clown must cross the bridge at once to effect his escape. &lt;strong&gt;How can he do so without abandoning any of his baggage&lt;/strong&gt;?
&lt;/p&gt;
&lt;p style="text-align:center;font-size:200%"&gt;?&lt;/p&gt;

&lt;p&gt;Elsewhere, it&amp;#8217;s school sports day. Conditions are perfect for the high jump &amp;#8212; warm, sunny, still &amp;#8212; and a talented young athlete has raised the bar to 1.85m, which happens to be his own height. On the first two attempts he fails. On the third attempt he succeeds.
&lt;/p&gt;
&lt;img alt="High Jump" src="http://wordaligned.org/images/high-jump.jpg"/&gt;

&lt;p&gt;&amp;#8220;Chapeau!&amp;#8221; says the French teacher.
&lt;/p&gt;
&lt;p&gt;&amp;#8220;Awesome!&amp;#8221; says the Chaplain.
&lt;/p&gt;
&lt;p&gt;&amp;#8220;Unbelievable!&amp;#8221; says the head of Mathematics.
&lt;/p&gt;
&lt;p&gt;&amp;#8220;Actually,&amp;#8221; the sports coach says, &amp;#8220;it&amp;#8217;s quite simple: a combination of talent, training, and technique. He cleared his own height &lt;strong&gt;but his centre of gravity didn&amp;#8217;t&lt;/strong&gt;.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;&amp;#8220;What nonsense!&amp;#8221; says the mathematician.
&lt;/p&gt;
&lt;p style="text-align:center;font-size:300%"&gt;??&lt;/p&gt;

&lt;img alt="Grimaldi" src="http://wordaligned.org/images/grimaldi.jpg"/&gt;

&lt;p&gt;The clown barely breaks stride. Juggling with mismatched objects is part of his act and quick as a flash case, camera, cactus, fowl and fizz are in the air. At no point does he have more than one object in either hand so his weight never exceeds 73kg. The bridge holds. The clown gets away.
&lt;/p&gt;
&lt;p&gt;&amp;#8220;Grrrr!&amp;#8221; says the strongman, shaking his fists.
&lt;/p&gt;
&lt;p style="text-align:center;font-size:400%"&gt;???&lt;/p&gt;</description>
<dc:date>2013-09-11</dc:date>
<guid>http://wordaligned.org/articles/clown-flee-jump</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/clown-flee-jump</link>
<category>Puzzles</category>
</item>

<item>
<title>Patience Sorted</title>
<description>&lt;p&gt;I gave a lightning talk today about patience sorting and its application to the longest increasing subsequence problem. It&amp;#8217;s a subject I&amp;#8217;ve &lt;a href="http://wordaligned.org/articles/patience-sort.html" title="Patience sort and the longest increasing subsequence"&gt;written about&lt;/a&gt; before. My computer has been put through several million simulations. I&amp;#8217;ve even coded up a &lt;a href="http://wordaligned.org/pages/psort"&gt;javascript demo&lt;/a&gt; which deals out virtual playing cards and sorts them at the click of a button.
&lt;/p&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
var zz = 0;

var xtop  = ["330px", "302px", "275px", "255px", "234px", "209px", "187px", "158px", "128px", "99px", "70px", "43px", "15px"];
var ytop  = ["26px", "30px", "28px", "29px", "31px", "28px", "27px", "28px", "28px", "30px", "26px", "30px", "29px"];
var xpile = ["10px", "13px", "12px", "115px", "14px", "220px", "220px", "319px", "15px", "216px", "118px", "118px", "321px"];
var ypile = ["205px", "233px", "266px", "206px", "295px", "206px", "236px", "209px", "325px", "267px", "235px", "263px", "234px"];
var result = ["#card7", "#card6", "#card3", "#card2"];

function reset_cards() {
    jQuery("img").stop();
    zz += 13;
    for (var j = 0; j != 13; ++j, --zz) {
        jQuery("#card" + j)
        .css({"z-index":zz, "margin-left":xtop[j], "margin-top":ytop[j], "border-width":0});
    }
    zz += 13;
}

function lis(j) {
    var it = jQuery(result[j]);
    if (it.length &gt; 0) {
        it.animate({borderWidth : "5px"}, "slow", 0, function(){lis(++j);});
    }
}

function psort(j) {
    var it = jQuery("#card"+j);
    if (it.length != 0) {
        it
        .animate({marginLeft : xpile[j], marginTop: ypile[j]}, "slow", 0, function(){psort(++j);})
        .css({"z-index" : ++zz});
    } else {
        lis(0);
    }
}

function animate() {
    reset_cards();
    psort(0);
}
&lt;/script&gt;

&lt;div class="cardtable" style="background-color: #093; width:440px; height:480px;"&gt;
&lt;img id="card0" style="border: 0 orange solid; position: absolute; margin-left: 330px; margin-top: 27px; z-index: 13;" src="http://wordaligned.org/images/cards/1s.png" alt="Ace of Spades"/&gt;
&lt;img id="card1" style="border: 0 orange solid; position: absolute; margin-left: 302px; margin-top: 27px; z-index: 12;" src="http://wordaligned.org/images/cards/10s.png" alt="10 of Spades"/&gt;
&lt;img id="card2" style="border: 0 orange solid; position: absolute; margin-left: 275px; margin-top: 27px; z-index: 11;" src="http://wordaligned.org/images/cards/6s.png" alt="6 of Spades"/&gt;
&lt;img id="card3" style="border: 0 orange solid; position: absolute; margin-left: 255px; margin-top: 26px; z-index: 10;" src="http://wordaligned.org/images/cards/7s.png" alt="7 of Spades"/&gt;
&lt;img id="card4" style="border: 0 orange solid; position: absolute; margin-left: 234px; margin-top: 28px; z-index: 9;" src="http://wordaligned.org/images/cards/5s.png" alt="5 of Spades"/&gt;
&lt;img id="card5" style="border: 0 orange solid; position: absolute; margin-left: 209px; margin-top: 26px; z-index: 8;" src="http://wordaligned.org/images/cards/13s.png" alt="King of Spades"/&gt;
&lt;img id="card6" style="border: 0 orange solid; position: absolute; margin-left: 187px; margin-top: 31px; z-index: 7;" src="http://wordaligned.org/images/cards/9s.png" alt="9 of Spades"/&gt;
&lt;img id="card7" style="border: 0 orange solid; position: absolute; margin-left: 158px; margin-top: 27px; z-index: 6;" src="http://wordaligned.org/images/cards/12s.png" alt="Queen of Spades"/&gt;
&lt;img id="card8" style="border: 0 orange solid; position: absolute; margin-left: 128px; margin-top: 29px; z-index: 5;" src="http://wordaligned.org/images/cards/2s.png" alt="2 of Spades"/&gt;
&lt;img id="card9" style="border: 0 orange solid; position: absolute; margin-left: 99px; margin-top: 29px; z-index: 4;" src="http://wordaligned.org/images/cards/8s.png" alt="8 of Spades"/&gt;
&lt;img id="card10" style="border: 0 orange solid; position: absolute; margin-left: 70px; margin-top: 26px; z-index: 3;" src="http://wordaligned.org/images/cards/4s.png" alt="4 of Spades"/&gt;
&lt;img id="card11" style="border: 0 orange solid; position: absolute; margin-left: 43px; margin-top: 27px; z-index: 2;" src="http://wordaligned.org/images/cards/3s.png" alt="3 of Spades"/&gt;
&lt;img id="card12" style="border: 0 orange solid; position: absolute; margin-left: 15px; margin-top: 28px; z-index: 1;" src="http://wordaligned.org/images/cards/11s.png" alt="Knave of Spades"/&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;button onclick="reset_cards();"&gt;Reset&lt;/button&gt;&lt;button onclick="animate();"&gt;Play&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Today I used real playing cards; a linen-finished standard deck. For any talk it&amp;#8217;s nice to have a prop.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/8558343442/" title="Rock &amp;amp; Pop Legends by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm9.staticflickr.com/8100/8558343442_0402f04e83.jpg" width="500" height="361" alt="Rock &amp;amp; Pop Legends"&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Now, I &lt;strong&gt;thought&lt;/strong&gt; I understood the patience sort algorithm but until yesterday I&amp;#8217;d never actually played it with real cards. I&amp;#8217;ve been surprised by how much this physical dimension has developed my understanding.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ll be testing my new cards on some other sorting algorithms; I have high hopes. It would be good to find a similarly simple prop for linked data structures so I can balance trees, flip lists and walk graphs.
&lt;/p&gt;</description>
<dc:date>2013-03-14</dc:date>
<guid>http://wordaligned.org/articles/patience-sorted</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/patience-sorted</link>
<category>Puzzles</category>
</item>

<item>
<title>Next permutation: When C++ gets it right</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocthe-next-number-problem" name="toc0" id="toc0"&gt;The Next Number Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocchoice-of-algorithm" name="toc1" id="toc1"&gt;Choice of Algorithm&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toclexicographical-ordering" name="toc2" id="toc2"&gt;Lexicographical Ordering&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocnext-permutation-in-action" name="toc3" id="toc3"&gt;Next permutation in action&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocsnail-sorts-revenge" name="toc4" id="toc4"&gt;Snail sort&amp;#8217;s revenge&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocthe-next-number-solved" name="toc5" id="toc5"&gt;The Next Number, Solved&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocimplementation" name="toc6" id="toc6"&gt;Implementation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocwhats-happening-here" name="toc7" id="toc7"&gt;What&amp;#8217;s happening here?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocbeautiful-c" name="toc8" id="toc8"&gt;Beautiful C++?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocpermutations-in-python" name="toc9" id="toc9"&gt;Permutations in Python&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc0" name="tocthe-next-number-problem" id="tocthe-next-number-problem"&gt;The Next Number Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose you have a fixed list of digits chosen from the range 1..9. What numbers can you make with them? You&amp;#8217;re allowed as many zeros as you want. Write the numbers in increasing order.
&lt;/p&gt;
&lt;p&gt;Exactly &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;this puzzle&lt;/a&gt; came up in the recent &lt;a href="http://code.google.com/codejam"&gt;Google Code Jam&lt;/a&gt; programming contest:
&lt;/p&gt;
&lt;blockquote&gt;You are writing out a list of numbers. Your list contains all numbers with exactly &lt;strong&gt;D&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt; digits in its decimal representation which are equal to i, for each i between 1 and 9, inclusive. You are writing them out in ascending order.&lt;/p&gt;&lt;p&gt;For example, you might be writing every number with two &amp;#8216;1&amp;#8217;s and one &amp;#8216;5&amp;#8217;. Your list would begin 115, 151, 511, 1015, 1051.&lt;/p&gt;&lt;p&gt;Given N, the last number you wrote, compute what the next number in the list will be.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The competition has closed now, but if you&amp;#8217;d like to give it a go sample input files can be found on the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;website&lt;/a&gt;, where you can also upload your results and have them checked.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a short section from a trial I ran on my computer. Input numbers are in the left-hand column: the corresponding output numbers are in the right-hand column.
&lt;/p&gt;
&lt;pre style="font-size:150%"&gt;
50110812884911623516 &amp;rarr; 50110812884911623561
82454322474161687049 &amp;rarr; 82454322474161687094
82040229261723155710 &amp;rarr; 82040229261723157015
43888989554234187388 &amp;rarr; 43888989554234187838
76080994872481480636 &amp;rarr; 76080994872481480663
31000989133449480678 &amp;rarr; 31000989133449480687
20347716554681051891 &amp;rarr; 20347716554681051918
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc1" name="tocchoice-of-algorithm" id="tocchoice-of-algorithm"&gt;Choice of Algorithm&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like many of the code jam challenges, you&amp;#8217;ll need to write a program which runs fast enough; but choosing the right algorithm is more important than choosing the right language. Typically a high-level interpreted language like Python allows me to code and test a solution far more quickly than using a low-level language like C or C++.
&lt;/p&gt;
&lt;p&gt;In this particular case, though, like most &lt;a href="http://www.go-hero.net/jam/09/problems/2/2"&gt;successful candidates&lt;/a&gt;, I used C++. &lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;Here&amp;#8217;s why&lt;/a&gt;.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;&lt;code&gt;Next_permutation&lt;/code&gt;&lt;/a&gt; transforms the range of elements &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically next greater permutation of the elements. [&amp;#8230;] If such a permutation exists, &lt;code&gt;next_permutation&lt;/code&gt; transforms &lt;code&gt;[first, last)&lt;/code&gt; into that permutation and returns true. Otherwise it transforms &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically smallest permutation and returns &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Although the next number problem appears to be about numbers and lexicographical ordering appears to be about words, &lt;code&gt;std::next_permutation&lt;/code&gt; is exactly what&amp;#8217;s needed here.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc2" name="toclexicographical-ordering" id="toclexicographical-ordering"&gt;Lexicographical Ordering&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/4099819327/" title="Lexicographical order by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2449/4099819327_4063635302.jpg" width="500" height="216" alt="Lexicographical order" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;A dictionary provides the canonical example of lexicographical ordering. Words are built from characters, which can be alphabetically ordered A, B, C, &amp;#8230; , so in the dictionary words which begin with &lt;strong&gt;A&lt;/strong&gt; appear before words which begin with &lt;strong&gt;B&lt;/strong&gt;, which themselves come in front of words beginning with &lt;strong&gt;C&lt;/strong&gt;, etc. If two words start with the same letter, pop that letter from the head of the word and compare their tails, which puts AARDVARK before ANIMAL, and &amp;#8212; applying this rule recursively &amp;#8212; after &lt;a href="http://www.aardman.com/" title="Bristol's finest"&gt;AARDMAN&lt;/a&gt;. Imagine there&amp;#8217;s an empty word marking position zero, before A, right at the front of the dictionary, and our recursive  definition is complete.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc3" name="tocnext-permutation-in-action" id="tocnext-permutation-in-action"&gt;Next permutation in action&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple program which shows &lt;code&gt;next_permutation()&lt;/code&gt; in action.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int main()
{
    char xs[] = "123";
    do
    {
        std::puts(xs);
    }
    while (std::next_permutation(xs, xs + sizeof(xs) - 1));
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This program outputs lexicographically ordered permutations of 1, 2 and 3. When the main function returns, the array &lt;code&gt;xs&lt;/code&gt; will have cycled round to hold the lexicographically smallest arrangement of its elements, which is &lt;code&gt;"123"&lt;/code&gt;. Note that we never convert the characters &lt;code&gt;'1'&lt;/code&gt;, &lt;code&gt;'2'&lt;/code&gt;, &lt;code&gt;'3'&lt;/code&gt; into the numbers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;. The values of both sets of data types appear in the same order, so all works as expected.
&lt;/p&gt;
&lt;pre&gt;
123
132
213
231
312
321
&lt;/pre&gt;

&lt;p&gt;If we tweak and rerun the same program with &lt;code&gt;xs&lt;/code&gt; initialised to &lt;code&gt;"AAADKRRV"&lt;/code&gt; we get rather more output.
&lt;/p&gt;
&lt;pre&gt;
AAADKRRV
AAADKRVR
AAADKVRR
...
AARDVARK
...
VRRKAADA
VRRKADAA
VRRKDAAA
&lt;/pre&gt;

&lt;p&gt;The sequence &lt;strong&gt;doesn&amp;#8217;t&lt;/strong&gt; start by repeating &lt;code&gt;"AAADKRRV"&lt;/code&gt; 6 times, once for every permutation of the 3 A&amp;#8217;s. Only strictly increasing permutations are included. And although the repeated calls to &lt;code&gt;next_permutation&lt;/code&gt; generate a series of permutations, the algorithm holds no state. Each function call works on its input range afresh.
&lt;/p&gt;
&lt;p&gt;This second run of the program yields 3360 lines of output, even though there are 8! = 40320 possible permutations of 8 characters. Each unique permutation corresponds to 3! &amp;times; 2! = 12 actual permutations of the 8 characters (because there are 3 A&amp;#8217;s and 2 R&amp;#8217;s), and 40320 &amp;divide; 12 is 3360.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc4" name="tocsnail-sorts-revenge" id="tocsnail-sorts-revenge"&gt;Snail sort&amp;#8217;s revenge&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/tim_norris/2789759648/"&gt;&lt;img src="http://farm4.static.flickr.com/3143/2789759648_ab4bfb5ea8.jpg" width="500px" height="333px" alt="...and in last place. By Tim Norris"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;As you can see, &lt;code&gt;next_permutation&lt;/code&gt; sorts an input range, one step at a time.  When &lt;code&gt;next_permutation&lt;/code&gt; eventually returns false, the range will be perfectly ordered. Hence we have &lt;code&gt;snail_sort()&lt;/code&gt;, hailed by the SGI STL &lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;documentation&lt;/a&gt; as the worst known deterministic sorting algorithm.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;class Iter&amp;gt; 
void snail_sort(Iter first, Iter last)
{
    while (next_permutation(first, last)) {}
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Very witty, and evidence that code can be both &lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html"&gt;elegant and inefficient&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;In two important edge cases, though, &lt;code&gt;snail_sort&lt;/code&gt; performs on a par with super-charged &lt;code&gt;quicksort&lt;/code&gt;!
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     I snail sorted an array filled with 100000000 zeros in 0.502 seconds. Running quicksort on the same array took 5.504 seconds. 
 &lt;/li&gt;

 &lt;li&gt;
     Starting with an array of the same size filled with the values 99999999, 99999998, 99999997, &amp;#8230; 1, 0 snail sort&amp;#8217;s 0.500 seconds trounced quicksort&amp;#8217;s 4.08 seconds.
 &lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc5" name="tocthe-next-number-solved" id="tocthe-next-number-solved"&gt;The Next Number, Solved&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s an outline solution to the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;next number problem&lt;/a&gt;. (I&amp;#8217;ve glossed over the exact input and output file formats for clarity.) It reads numbers from standard input and writes next numbers to standard output. &lt;code&gt;Next_permutation&lt;/code&gt; does the hard work, and there&amp;#8217;s a bit of fiddling when we have to increase the number of digits by adding a zero.&lt;a id="fn1link" href="http://wordaligned.org/articles/next-permutation#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

/*
 Given a string of digits, shift any leading '0's
 past the first non-zero digit and insert an extra zero.
 
 Examples:
  
 123 -&amp;gt; 1023
 008 -&amp;gt; 8000
 034 -&amp;gt; 3004
*/
void insert_a_zero(std::string &amp;amp; number)
{
    size_t nzeros = number.find_first_not_of('0');
    number = number.substr(nzeros);
    number.insert(1, nzeros + 1, '0');
}

/*
 Outline solution to the 2009 code jam Next Number problem.
 
 Given a string representing a decimal number, find the next
 number which can be formed from the same set of digits. Add
 another zero if necessary. Repeat for all such strings read
 from standard input.
*/
int main()
{
    std::string number;
    while (std::cin &amp;gt;&amp;gt; number)
    {
        if (!next_permutation(number.begin(), number.end()))
        {
            insert_a_zero(number);
        }
        std::cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; '\n';
    }
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc6" name="tocimplementation" id="tocimplementation"&gt;Implementation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having used the C++ standard library to solve the puzzle, let&amp;#8217;s take a look at how it works. Next permutation is a clever algorithm which shuffles a collection in place. My system implements it like this&lt;a id="fn2link" href="http://wordaligned.org/articles/next-permutation#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;
        
    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We start with a range delimited by a pair of bi-directional iterators, &lt;code&gt;[first, last)&lt;/code&gt;. If the range contains one item or fewer, there can be no next permutation, so leave the range as is and return &lt;code&gt;false&lt;/code&gt;. Otherwise, enter the &lt;code&gt;for&lt;/code&gt; loop with an iterator &lt;code&gt;i&lt;/code&gt; pointing at the final item in the range.
&lt;/p&gt;
&lt;p&gt;At each pass through the body of this for loop we decrement &lt;code&gt;i&lt;/code&gt; by one, stepping towards the first item in the range. We are looking for one of two conditions:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     the value pointed to by &lt;code&gt;i&lt;/code&gt; is smaller than the one it pointed to previously
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;i&lt;/code&gt; reaches into the first item in the range
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Put another way, we divide the range into a head and tail, where the tail is the longest possible decreasing tail of the range.
&lt;/p&gt;
&lt;p&gt;If this tail is the whole range (the second condition listed above) then the whole range is in reverse order, and we have the lexicographical maximum formed from its elements. Reversing the range returns it to its lexicographical minimum, and we can return &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;If this tail is not the whole range, then the final item in the head of the range, the item &lt;code&gt;i&lt;/code&gt; points to, this item is smaller than at least one of the items in the tail of the range, and we can certainly generate a greater permutation by moving the item towards the end of the range. To find the next permutation, we reverse iterate from the end of the range until we find an item &lt;code&gt;*j&lt;/code&gt; bigger than &lt;code&gt;*i&lt;/code&gt; &amp;#8212; that&amp;#8217;s what the while loop does. Swapping the items pointed to by &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; ensures the head of the range is bigger than it was, and the tail of the range remains in reverse order. Finally, we reverse the tail of the range, leaving us with a permutation exactly one beyond the input permutation, and we return &lt;code&gt;true&lt;/code&gt;. 
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc7" name="tocwhats-happening-here" id="tocwhats-happening-here"&gt;What&amp;#8217;s happening here?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s clear from this paper analysis that the algorithm is of linear complexity. Essentially, it walks up and down the tail of the list, comparing and swapping. But why does it work?
&lt;/p&gt;
&lt;p&gt;Let &lt;code&gt;xs&lt;/code&gt; be the range &lt;code&gt;(first, last)&lt;/code&gt;. As described above, divide this range into prefix and suffix subranges, &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, where &lt;code&gt;tail&lt;/code&gt; is the longest monotonically decreasing tail of the range.
&lt;/p&gt;
&lt;p&gt;If the &lt;code&gt;head&lt;/code&gt; of the range is empty, then the range &lt;code&gt;xs&lt;/code&gt; is clearly at its lexicographical maximum. 
&lt;/p&gt;
&lt;p&gt;Otherwise, &lt;code&gt;tail&lt;/code&gt; is a lexicographical maximum of the elements it contains, and &lt;code&gt;xs&lt;/code&gt; is therefore the largest permutation which starts with the subrange &lt;code&gt;head&lt;/code&gt;. What will the &lt;code&gt;head&lt;/code&gt; of the next permutation be? We have to swap the final item in &lt;code&gt;head&lt;/code&gt; with the smallest item of &lt;code&gt;tail&lt;/code&gt; which exceeds it: the definition of &lt;code&gt;tail&lt;/code&gt; guarantees at least one such item exists. Now we want to permute the new &lt;code&gt;tail&lt;/code&gt; to be at a its lexicographical minimum, which is a matter of sorting it from low to high.
&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;tail&lt;/code&gt; is in reverse order, finding the smallest item larger than &lt;code&gt;head[-1]&lt;/code&gt; is a matter of walking back from the end of the range to find the first such items; and once we&amp;#8217;ve swapped these items, &lt;code&gt;tail&lt;/code&gt; remains in reverse order, so a simple reversed will sort it.
&lt;/p&gt;
&lt;p&gt;As an example consider finding the next permutation of:
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8342666411
&lt;/pre&gt;

&lt;p&gt;The longest monotonically decreasing tail is &lt;code&gt;666411&lt;/code&gt;, and the corresponding head is &lt;code&gt;8342&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8342 666411
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;666411&lt;/code&gt; is, by definition, reverse-ordered, and cannot be increased by permuting its elements. To find the next permutation, we must increase the head; a matter of finding the smallest tail element larger than the head&amp;#8217;s final &lt;code&gt;2&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;2&lt;/span&gt; 666411
&lt;/pre&gt;

&lt;p&gt;Walking back from the end of tail, the first element greater than &lt;code&gt;2&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;2&lt;/span&gt;  666&lt;span style="color:#930"&gt;4&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Swap the &lt;code&gt;2&lt;/code&gt; and the &lt;code&gt;4&lt;/code&gt;
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;4&lt;/span&gt; 666&lt;span style="color:#930"&gt;2&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Since head has increased, we now have a greater permutation. To reduce to the next permutation, we reverse tail, putting it into increasing order.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8344 112666
&lt;/pre&gt;

&lt;p&gt;Join the head and tail back together. The permutation one greater than &lt;code&gt;8342666411&lt;/code&gt; is &lt;code&gt;8344112666&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc8" name="tocbeautiful-c" id="tocbeautiful-c"&gt;Beautiful C++?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/looping-forever-and-ever.html"&gt;&lt;img  src="http://wordaligned.org/images/mite.jpg" alt="for(;;) dust mite"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;C++ has its &lt;a href="http://yosefk.com/c++fqa/defective.html" title="If you are an expert in the intricacies of C++, please consider this knowledge a kind of martial art - something a real master never uses. Yossi Keinin"&gt;detractors&lt;/a&gt;, who characterise it as subtle, &lt;a href="http://twitter.com/dabeaz/status/5677453478" title="C++0x reminds me of blocks stacked by my toddler. Really wobbly and one block too many makes it topple. @dabeaz"&gt;complex&lt;/a&gt;, and &lt;a href="http://www2.research.att.com/~bs/bs_faq.html#really-say-that" title="C++ can blow your whole leg off. Bjarne Stroustrup"&gt;dangerous&lt;/a&gt;; but sometimes it excels. Look once more at the C++ implementation of this algorithm.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;
    
    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span /&gt;With its special cases, boolean literals, multiple returns (4, count them!), disembodied and infinite loops, this code fails to exhibit conventional beauty. Yet &lt;em&gt;it is&lt;/em&gt; beautiful. All the next permutation algorithm needs are iterators which can advance forwards or backwards, step by step. And that&amp;#8217;s all this implementation uses.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m as excited as anyone by the mathematical rigour of &lt;a href="http://www.informit.com/articles/article.aspx?p=1407357&amp;amp;seqNum=3" title="Great article by Andrei Alexandrescu, which questions a pure Haskell quicksort implementation"&gt;functional programming&lt;/a&gt;, but sometimes computer science is about algorithms with virtually no space overhead, algorithms which loop rather than recurse. Sometimes it&amp;#8217;s about shuffling, nudging and swapping &amp;#8212; operations which map directly to the machine&amp;#8217;s most primitive operations. In such cases, C++ gets it right.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc9" name="tocpermutations-in-python" id="tocpermutations-in-python"&gt;Permutations in Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For the code jam, though, as mentioned earlier, having a super-fast program rarely matters. More often, it&amp;#8217;s about developing a fast enough program super-quickly.
&lt;/p&gt;
&lt;p&gt;I find Python a far quicker language for developing code than C++. (Indeed, sometimes when it&amp;#8217;s obvious from the outset that a final program will need implementing in C++, I put together a working prototype using Python, which I then translate.) Could we solve the next number problem using code from the standard Python library?
&lt;/p&gt;
&lt;p&gt;At a first glance, &lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.permutations"&gt;itertools.permutations&lt;/a&gt; looks promising.
&lt;/p&gt;
&lt;blockquote&gt;&lt;h3&gt;&lt;tt&gt;itertools.permutations(&lt;em&gt;iterable&lt;/em&gt;, &lt;em&gt;r=None&lt;/em&gt;)&lt;/tt&gt;&lt;/h3&gt;&lt;p&gt;Return successive &lt;em&gt;r&lt;/em&gt; length permutations of elements in the &lt;em&gt;iterable&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;If &lt;em&gt;r&lt;/em&gt; is not specified or is &lt;tt&gt;None&lt;/tt&gt;, then &lt;em&gt;r&lt;/em&gt; defaults to the length
of the &lt;em&gt;iterable&lt;/em&gt; and all possible full-length permutations
are generated.&lt;/p&gt;&lt;p&gt;Permutations are emitted in lexicographic sort order.  So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the permutation tuples will be produced in sorted order.&lt;/p&gt;&lt;p&gt;Elements are treated as unique based on their position, not on their value.  So if the input elements are unique, there will be no repeat values in each permutation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;However, this algorithm doesn&amp;#8217;t care about the values of the items in the iterable, and the lexicographic sort order applies to the indices of these items. So although the ordering of the generated items is well-defined:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     we get repeats, and
 &lt;/li&gt;

 &lt;li&gt;
     it&amp;#8217;s not the ordering we want (in this case)
 &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; concat = ''.join
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations('AAA')))
['AAA', 'AAA', 'AAA', 'AAA', 'AAA', 'AAA']
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations('231')))
['231', '213', '321', '312', '123', '132']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It &lt;strong&gt;is&lt;/strong&gt; possible to code up &lt;code&gt;next_permutation&lt;/code&gt; using nothing more than the standard itertools, but it isn&amp;#8217;t advisable.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Snail permute&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import permutations, groupby

def next_permutation(xs):
    """Calculate the next permutation of the sequence xs.
    
    Returns a pair (yn, xs'), where yn is a boolean and xs' is the 
    next permutation. If yn is True, xs' will be the lexicographic 
    next permutation of xs, otherwise xs' is the lexicographic 
    smallest permutation of xs.
    """
    xs = tuple(xs)
    if not xs:
        return False, xs
    else:
        ps = [p for p, gp in groupby(sorted(permutations(xs)))]
        np = len(ps)
        ix = ps.index(xs) + 1
        if ix == len(ps):
            return False, ps[0]
        else:
            return True, ps[ix]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As it happens, a solution based on this exhaustive search would score points in the code jam since it copes with the small input set. For the large input set its factorial complexity rules it out, and we&amp;#8217;d need to implement the next permutation algorithm &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1"&gt;from scratch&lt;/a&gt;.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/next-permutation#fn1link"&gt;[1]&lt;/a&gt;: A more cunning &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1"&gt;solution&lt;/a&gt; avoids the special case by pushing the extra zero to head of the string before applying &lt;code&gt;next_permutation&lt;/code&gt;, then popping it if it hasn&amp;#8217;t been moved.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/next-permutation#fn2link"&gt;[2]&lt;/a&gt;: I&amp;#8217;ve tweaked the layout and parameter names for use on this site.
&lt;/p&gt;</description>
<dc:date>2009-11-19</dc:date>
<guid>http://wordaligned.org/articles/next-permutation</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/next-permutation</link>
<category>Puzzles</category>
</item>

<item>
<title>Favicon</title>
<description>&lt;p&gt;On the subject of &lt;a href="http://wordaligned.org/"&gt;this site&lt;/a&gt;, I wanted to mention the recent addition of a favicon &lt;img src="http://wordaligned.org/images/favicon.png" alt="Little chap favicon"/&gt;. Per pixel, it&amp;#8217;s cost me more effort than any other feature; but then it&amp;#8217;s accessed more than any other asset. It&amp;#8217;s meant to be a piece from a jigsaw puzzle. I got the idea when &lt;a href="http://wordaligned.org/articles/recursive-pictures.html"&gt;re-reading Life A User&amp;#8217;s Manual&lt;/a&gt;. I like &lt;a href="http://wordaligned.org/tag/puzzles/"&gt;puzzles&lt;/a&gt; and piecing things together.
&lt;/p&gt;
&lt;div class="amazon"&gt;&lt;a href="http://www.amazon.com/gp/product/0002719991?ie=UTF8&amp;amp;tag=wordalig-20"&gt;&lt;img src="http://wordaligned.org/images/books/life-a-users-manual.jpg" alt="Life A User's Manual"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Perec&amp;#8217;s great masterpiece is packed with interwoven stories and trickery, but at its heart is the epic battle between the millionaire, Bartlebooth, and the puzzle-maker Gaspard Winckler. Bartlebooth begins his campaign by learning how to paint, which takes him 10 years. For the next 20 years he travels the world, painting a water colour picture of a different port every couple of weeks. He sends the paintings back home to Paris. On receipt, Winckler glues each picture to a board which he then cuts, making a series of jigsaw puzzles for Bartlebooth to solve on his return. Once Bartlebooth completes each puzzle, an ingenious process is used to glue its pieces together and re-join the cut fibres of the paper; then the picture itself is lifted from the board, returned to the port it depicts, and washed clean in the sea; and finally the paper is returned in something close to its original state to Bartlebooth.
&lt;/p&gt;
&lt;p&gt;Thus, after 50 years of work, there will be nothing to show.
&lt;/p&gt;
&lt;img src="http://wordaligned.org/images/jigsaw-fr.png" alt="French jigsaw pieces"/&gt;

&lt;p&gt;In the book&amp;#8217;s preamble Perec describes familiar die-cut jigsaws, classifying the best known pieces of such puzzles as &amp;#8220;little chaps&amp;#8221;, &amp;#8220;double crosses&amp;#8221; and &amp;#8220;crossbars&amp;#8221;. Such diversions are eschewed by the true puzzler:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The art of jigsaw puzzling begins with wooden puzzles cut by hand, whose maker undertakes to ask himself all the questions the player will have to solve, and, instead of allowing chance to cover his tracks, aims to replace it with cunning, trickery and subterfuge. All the elements occurring in the image to be reassembled &amp;#8212; this armchair covered in gold brocade, that three-pointed black hat with its rather ruined black plume, or that silver-braided bright yellow livery &amp;#8212; serve by design as points of departure for trails that lead to false information.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;hr /&gt;

&lt;p&gt;My thanks to Tim Beard for scanning a couple of pages from his edition of &lt;a href="http://en.wikipedia.org/wiki/La_Vie_mode_d%27emploi" title="Life A User's Manual, Wikipedia"&gt;La Vie, Mode d&amp;#8217;Emploi&lt;/a&gt;. I wanted to know what the &amp;#8220;little chaps&amp;#8221; etc. were before they got translated into English. I realise my favicon &lt;img src="http://wordaligned.org/images/favicon.png" alt="Little chap favicon"/&gt; could be &lt;a href="http://typophile.com/node/60577" title="Astonishing exploded view of improved YouTube favicon"&gt;improved&lt;/a&gt; but I don&amp;#8217;t know how to go about it. Anyone?
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://typophile.com/node/60577" title="YouTube Favicon - improved"&gt;&lt;img src="http://wordaligned.org/images/youtube1.png" width="52px" height="26px" alt="YouTube Favicon - improved"/&gt;&lt;/a&gt;&lt;a href="http://typophile.com/node/60577" title="YouTube Favicon - improved"&gt;&lt;img src="http://wordaligned.org/images/youtube2.png" width="104px" height="52px" alt="YouTube Favicon - improved"/&gt;&lt;/a&gt;&lt;a href="http://typophile.com/node/60577" title="YouTube Favicon - improved"&gt;&lt;img src="http://wordaligned.org/images/youtube3.png" width="208px" height="104px" alt="YouTube Favicon - improved"/&gt;&lt;/a&gt;
&lt;/p&gt;</description>
<dc:date>2009-09-16</dc:date>
<guid>http://wordaligned.org/articles/favicon</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/favicon</link>
<category>Puzzles</category>
</item>

<item>
<title>Blackmail made easy using Python counters</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocthe-obsessive-blackmailer" name="toc0" id="toc0"&gt;The Obsessive Blackmailer&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocmodeling-the-problem" name="toc1" id="toc1"&gt;Modeling the Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocthe-evolution-of-multisets-in-python" name="toc2" id="toc2"&gt;The evolution of multisets in Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocwait-theres-more" name="toc3" id="toc3"&gt;Wait, there&amp;#8217;s more!&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocback-to-blackmail" name="toc4" id="toc4"&gt;Back to Blackmail&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocgeneric-code" name="toc5" id="toc5"&gt;Generic Code&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocend-of-message" name="toc6" id="toc6"&gt;End of Message&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc0" name="tocthe-obsessive-blackmailer" id="tocthe-obsessive-blackmailer"&gt;The Obsessive Blackmailer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;An obsessive blackmailer writes anonymous messages by by cut-and-pasting letters from newspapers. Being obsessive, the blackmailer only writes messages which can be composed entirely from a single newspaper.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3754867981/" title="word aligned by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2567/3754867981_a752d15f74_o.png" width="480" height="309" alt="word aligned" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Devise an algorithm which determines whether a given message can be written using a given newspaper.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc1" name="tocmodeling-the-problem" id="tocmodeling-the-problem"&gt;Modeling the Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This is a nice little problem but I&amp;#8217;m about to spoil it since I&amp;#8217;m using it here as a study in Python&amp;#8217;s evolution. So if you&amp;#8217;d like to try it yourself, look away now.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;We can represent both inputs to the algorithm as sequences of characters: a message string, length M, and a newspaper string, length N. We &lt;em&gt;could&lt;/em&gt; process the message string one character at a time, at each step scanning through the newspaper and noting the first occurrence of that character we haven&amp;#8217;t used before; but this is inefficient since we potentially read the whole paper M times.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s better to think of this problem in terms of multisets, sometimes known as bags. A multiset is a set which can have repeated elements. Our blackmailer can proceed if the multiset of letters used in the message is contained entirely within the multiset of letters used in the newspaper.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc2" name="tocthe-evolution-of-multisets-in-python" id="tocthe-evolution-of-multisets-in-python"&gt;The evolution of multisets in Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A dictionary provides a compact and efficient way to represent a multiset in Python: each dictionary key represents an item in the multiset, and the value associated with that key is the number of times the key appears in the multiset. Python dictionaries are implemented as hashed arrays, meaning that member insertion and access take constant time, on average.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s not hard to create such a multiset from a sequence but it&amp;#8217;s interesting to see how advances in the Python language have simplified the code. 
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python.org/doc/1.4/lib/node13.html#SECTION00316000000000000000"&gt;&lt;img src="http://python.org/doc/1.4/lib/img7.gif" height="181px" width="469px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The complete documentation for &lt;a href="http://python.org/doc/1.4/"&gt;Python 1.4&lt;/a&gt;, released in 1996, is still available on the Python website. In version 1.4 you could write:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_14(xs):
    multiset = {}
    for x in xs:
        if multiset.has_key(x):
            multiset[x] = multiset[x] + 1
        else:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code works unchanged in the current Python release, 2.6 (though note &lt;code&gt;dict.has_key()&lt;/code&gt; doesn&amp;#8217;t exist in Python 3.*). Alternatively, you might catch the &lt;code&gt;KeyError&lt;/code&gt; raised when trying to access the dict with an invalid key:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_14(xs):
    multiset = {}        
    for x in xs:
        try:
            multiset[x] = multiset[x] + 1
        except KeyError:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Python 1.5 introduces an exception-free dictionary access method, &lt;code&gt;dict.get()&lt;/code&gt;, which returns a user supplied default (defaulting to &lt;code&gt;None&lt;/code&gt;) for missing keys.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_15(xs):
    multiset = {}        
    for x in xs:
        multiset[x] = multiset.get(x, 0) + 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s certainly shorter, a little cleaner maybe, but perhaps it takes more effort for readers to see what exactly is going on.
&lt;/p&gt;
&lt;p&gt;At Python 2.2, &lt;code&gt;x in multiset&lt;/code&gt; improves on the equivalent &lt;code&gt;multiset.has_key(x)&lt;/code&gt; and we can use augmented arithmetic operators (&lt;code&gt;+=, -=, *=, /=, %=, **=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;amp;=, =, |=&lt;/code&gt;), allowing:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_22(xs):
    multiset = {}
    for x in xs:
        if x in multiset:
            multiset[x] += 1
        else:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I think I prefer the &lt;code&gt;dict.get()&lt;/code&gt; version, though.
&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;collections&lt;/code&gt; module makes its first appearance in Python 2.4 offering a &lt;code&gt;deque&lt;/code&gt; and a promise of more high performance container types to come. Python 2.5 makes good on this promise, adding &lt;code&gt;defaultdict&lt;/code&gt; to the module. A &lt;code&gt;defaultdict&lt;/code&gt; is a specialised dictionary which calls a client supplied factory function for missing keys. Setting this factory function to &lt;code&gt;int&lt;/code&gt; turns the &lt;code&gt;defaultdict&lt;/code&gt; into a multiset. No need for &lt;code&gt;dict.get()&lt;/code&gt; any more.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from collections import defaultdict

def multiset_25(xs):
    multiset = defaultdict(int)
    for x in xs:
        multiset[x] += 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc3" name="tocwait-theres-more" id="tocwait-theres-more"&gt;Wait, there&amp;#8217;s more!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The final improvement is available in Python 3.1 right now (or in Python 2.7, coming soon), courtesy once again of the collections module. &lt;a href="http://docs.python.org/dev/library/collections.html#collections.Counter"&gt;Collections.Counter&lt;/a&gt; is exactly what we&amp;#8217;ve been waiting for.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from collections import Counter

def multiset_31(xs):
    return Counter(xs)

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc4" name="tocback-to-blackmail" id="tocback-to-blackmail"&gt;Back to Blackmail&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So our blackmailer should first generate a multiset representation of the letters in the message. Then it&amp;#8217;s a matter of iterating through the newspaper and reducing the multiset each time a letter matches up. We keep a tally of the number of letters we still need to match, and stop when this tally is zero or when we get to the end of the newspaper. Here&amp;#8217;s a sketch of an implementation.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def blackmailable(message, newspaper):
    """Return True if newspaper can be used to write the blackmail 
    message, False otherwise.
    """
    m = len(message)
    if m == 0:
        return True
    counts = multiset(message)
    for ch in newspaper:
        if counts[ch] &amp;gt; 0:
            counts[ch] -= 1
            m -= 1
            if m == 0:
                return True
    return False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code assumes the multiset is represented as a &lt;code&gt;Counter&lt;/code&gt; or a &lt;code&gt;defaultdict&lt;/code&gt;, since it depends on &lt;code&gt;counts[ch]&lt;/code&gt; returning 0 for any character not in the message. If we&amp;#8217;d used a plain dict, we&amp;#8217;d need to employ &lt;code&gt;dict.get(ch, 0)&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m not entirely happy with the code shown. It&amp;#8217;s what I first came up with. Here&amp;#8217;s an alternative, which I also find a bit clunky. I&amp;#8217;d welcome any improvements. It&amp;#8217;s also worth noting that the algorithm locates the matching characters in the newspaper, so we might want to cache some indices for later use.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def blackmailable(message, newspaper):
    """Return True if newspaper can be used to write the blackmail 
    message, False otherwise.
    """
    counts = multiset(message)
    m = len(message)
    n = len(newspaper)
    i = 0
    while m != 0 and i != n:
        ch = newspaper[i]
        if counts[ch] &amp;gt; 0:
            counts[ch] -= 1
            m -= 1
        i += 1
    return m == 0

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can avoid the ugly code by persuading the obssessive blackmailer to generate and maintain multiset representations of the entire newspaper library. Then &lt;code&gt;blackmailable()&lt;/code&gt; can be implemented as multiset containment, something which the &lt;code&gt;Counter&lt;/code&gt; class handles nicely using the subtraction operator. Note here that multiset subtraction never results in any negative counts, even though a &lt;code&gt;Counter&lt;/code&gt; instance could itself have negative counts.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Counter
&amp;gt;&amp;gt;&amp;gt; missing_letters = Counter(message) - Counter(newspaper)
&amp;gt;&amp;gt;&amp;gt; blackmailable = len(missing_letters) == 0

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Alternatively:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; blackmailable = not missing_letters

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc5" name="tocgeneric-code" id="tocgeneric-code"&gt;Generic Code&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose the blackmailer prefers to compose a message from words, rather than letters? (For an example, see the threat to stay away from Grimpen Moor delivered to Sir Henry Baskerville discussed later in this article.) The code works as is &amp;#8212; just pass in message and newspaper as word sequences, rather than character sequences. Anything we can hash can be counted.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc6" name="tocend-of-message" id="tocend-of-message"&gt;End of Message&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In the age of the interweb anonymous cowardice is far easier and blackmailers don&amp;#8217;t need to resort to manual cut and paste techniques unless they&amp;#8217;re after a retro threatening effect.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Never_Mind_the_Bollocks,_Here's_the_Sex_Pistols"&gt;&lt;img src="http://wordaligned.org/images/never-mind-the-bollocks.jpg" alt="Never Mind the Bollocks"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;img style="float:right" alt="Sherlock Holmes" src="http://wordaligned.org/images/sherlock-holmes.png"/&gt;

&lt;p&gt;What&amp;#8217;s more, a detective can figure out plenty from these messages: so when Sir Henry Baskerville receives a threatening letter during his stay at the Northumberland Hotel, he shows it promptly to Sherlock Holmes:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Across the middle of it a single sentence had been formed by the expedient of pasting printed words upon it. It ran: &amp;#8220;As you value your life or your reason keep away from the moor.&amp;#8221; The word &amp;#8220;moor&amp;#8221; only was printed in ink.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;In a virtuso display of deductive reasoning, Holmes shows the author of the message was in a hurry, afraid of being interrupted, and working in a hotel room using nail-scissors. (He also deduces something else, which he does not reveal at the time.) Identifying the source of the words to be yesterday&amp;#8217;s Times leader is elementary.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The detection of types is one of the most elementary branches of knowledge to the special expert in crime, though I confess that once when I was very young I confused the Leeds Mercury with the Western Morning News. But a Times leader is entirely distinctive, and these words could have been taken from nothing else.
&lt;/p&gt;
&lt;p&gt;&amp;#8212; Sherlock Holmes, &lt;a href="http://www.gutenberg.org/dirs/etext02/bskrv11a.txt"&gt;The Hound of the Baskervilles&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Can anyone identify the newspaper I used to create the image at the start of this article?
&lt;/p&gt;
&lt;p&gt;&lt;hr /&gt;
   My thanks to jay for a &lt;a href="http://wordaligned.org/articles/python-counters#comment-13418772"&gt;correction&lt;/a&gt; to the original version of this article.
&lt;/p&gt;</description>
<dc:date>2009-07-27</dc:date>
<guid>http://wordaligned.org/articles/python-counters</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/python-counters</link>
<category>Puzzles</category>
</item>

<item>
<title>Partitioning with Python</title>
<description>&lt;h3&gt;Sums and Splits&lt;/h3&gt;
&lt;p&gt;On the subject of &lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;hunting for eodermdromes&lt;/a&gt;, here are a couple of semi-related partitioning problems.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     for a positive integer, N, find the positive integer sequences which sum to N
 &lt;/li&gt;

 &lt;li&gt;
     for a sequence, S, find the distinct partitions of that sequence
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As an example of the first, the 16 distinct integer sequences which sum to 5 are:
&lt;/p&gt;
&lt;pre&gt;
5
4 + 1
3 + 1 + 1
3 + 2
2 + 1 + 2
2 + 1 + 1 + 1
2 + 2 + 1
2 + 3
1 + 1 + 3
1 + 1 + 2 + 1
1 + 1 + 1 + 1 + 1
1 + 1 + 1 + 2
1 + 2 + 2
1 + 2 + 1 + 1
1 + 3 + 1
1 + 4
&lt;/pre&gt;

&lt;p&gt;and of the second, the 8 distinct ways of partitioning the sequence ABCD are:
&lt;/p&gt;
&lt;pre&gt;
ABCD
A BCD
AB CD
ABC D
A B CD
A BC D
AB C D
A B C D
&lt;/pre&gt;

&lt;p&gt;Note that I&amp;#8217;ve counted 2 + 1 + 2, 2 + 2 + 1, and 1 + 2 + 2 as distinct sums totalling 5. That happens to be the formulation of the problem which interested me.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Context&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;&lt;img src="http://wordaligned.org/images/eodermdrome.png" width="200px" height="200px" style="float:right" alt="eodermdrome"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Before discussing a solution to these problems, some context. Recall that an &lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;eodermdrome&lt;/a&gt; is a sequence which forms an Eulerian circuit through the fully connected graph whose vertices are the set of its elements. Put more simply: when you trace through the letters you get the figure shown, with no edge covered twice. Examples include:
&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;span style="color:#930"&gt;O&lt;/span&gt;&lt;span style="color:#036"&gt;D&lt;/span&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;R&lt;/span&gt;&lt;span style="color:#e50"&gt;M&lt;/span&gt;&lt;span style="color:#036"&gt;D&lt;/span&gt;&lt;span style="color:#555"&gt;R&lt;/span&gt;&lt;span style="color:#930"&gt;O&lt;/span&gt;&lt;span style="color:#e50"&gt;M&lt;/span&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;N&lt;/span&gt;&lt;span style="color:#036"&gt;H&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#555"&gt;N&lt;/span&gt;&lt;span style="color:#888"&gt;C&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt; &lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#888"&gt;C&lt;/span&gt;&lt;span style="color:#036"&gt;H&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#888"&gt;X&lt;/span&gt; &lt;span style="color:#e50"&gt;D&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#e50"&gt;D&lt;/span&gt; &lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#888"&gt;X&lt;/span&gt;&lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Eodermdromes turn out to be surprisingly rare. Writing a computer program to find them is a nice exercise in searching and text processing. Clearly, we should start with a collection of words. Then we can generate combinations of words from this collection and filter out the eodermdromes.
&lt;/p&gt;
&lt;pre&gt;
(filter eodermdrome? (combinations words))
&lt;/pre&gt;

&lt;p&gt;A large set of words (note: &amp;#8220;set&amp;#8221; not &amp;#8220;collection&amp;#8221;, we don&amp;#8217;t need duplicates) gives the best chance of success. I started with a file containing more than 35 thousand distinct words. This gives over a billion possible word pairs, and when we consider word triples and quartets the numbers get silly even for a modern computer.
&lt;/p&gt;
&lt;p&gt;As is so often the case in computing, we have a tension between opposing concerns. We&amp;#8217;d like code which separates the task of generating candidates and the task of testing these candidates for eodermdromicity, but in order to run this code in a timely manner we need some of the eodermdrome testing to leak into the candidate generation. For example, we could preprocess the word set removing words which contain double Ls (all, ball, call, ill, Bill, kill &amp;#8230;) since these can never appear in an eodermdrome. And we could similarly remove words which end ETE (delete, Pete, effete). As I hope you can see, it&amp;#8217;s easy to end up with finickity code and co-dependent functions.
&lt;/p&gt;
&lt;p&gt;I chose a simple but effective strategy to reduce the search space to something manageable, based on word length. First, then, I loaded my word set into a Python dict collecting lists of words keyed by their length.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import defaultdict
&amp;gt;&amp;gt;&amp;gt; words = defaultdict(list)
&amp;gt;&amp;gt;&amp;gt; for word in open('word-set.txt').read().split():
...     words[len(word)].append(word)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Given this dict, picking out single word eodermdromes is easy.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; list(filter(is_eodermdrome, words[11]))
['eodermdrome']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about eodermdromes composed of a 6 letter word followed by a 5 letter word? We can form the &lt;a href="http://docs.python.org/library/itertools.html#itertools.product"&gt;cartesian product&lt;/a&gt; of the lists of 6 and 5 letter words and filter out the ones we want.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import product
&amp;gt;&amp;gt;&amp;gt; eod_6_5 = filter(is_eodermdrome, product(words[6], words[5]))
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
('earned', 'andre')
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
('yearly', 'relay')

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about &lt;em&gt;all eodermdromes&lt;/em&gt; of length 11?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import chain.from_iterable as seq
&amp;gt;&amp;gt;&amp;gt; word_lens = sum_to_n(11)
&amp;gt;&amp;gt;&amp;gt; candidates = seq(product(*[words[i] for i in s]) for s in word_lens)
&amp;gt;&amp;gt;&amp;gt; eods = filter(is_eodermdrome, candidates)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note here that I&amp;#8217;m using Python 3.0, and that &lt;a href="http://docs.python.org/py3k/library/functions.html#filter"&gt;filter&lt;/a&gt; is therefore a lazy function. The interactive session shown above hasn&amp;#8217;t actually started taking anything from these lazily-evaluated streams.
&lt;/p&gt;
&lt;p&gt;I certainly don&amp;#8217;t claim this is the quickest way to search for eodermdromes. In fact, this little program took several hours to complete. But a back-of-an-envelope calculation showed it &lt;em&gt;would&lt;/em&gt; complete in a few hours, and that was good enough.
&lt;/p&gt;
&lt;p&gt;Note also that we haven&amp;#8217;t shown an implementation of &lt;code&gt;sum_to_n()&lt;/code&gt; yet, which takes us back to the problems posed at the start of this article.
&lt;/p&gt;

&lt;h3&gt;Sum to N&lt;/h3&gt;
&lt;p&gt;Finding the positive integer series which sum to a positive integer N is a job for &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;itertools.combinations&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import combinations, chain

def sum_to_n(n):
    'Generate the series of +ve integer lists which sum to a +ve integer, n.'
    from operator import sub
    b, mid, e = [0], list(range(1, n)), [n]
    splits = (d for i in range(n) for d in combinations(mid, i)) 
    return (list(map(sub, chain(s, e), chain(b, s))) for s in splits)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The idea here is straightforward: there&amp;#8217;s a 1-to-1 correspondence between the sums we want and ordered combinations drawn from the series 1, 2, &amp;#8230; n-1. For example, if n is 11 one such combination would be:
&lt;/p&gt;
&lt;pre&gt;
(1, 5, 7, 10)
&lt;/pre&gt;

&lt;p&gt;we can extend this by pushing 0 in front and n at the end
&lt;/p&gt;
&lt;pre&gt;
(0, 1, 5, 7, 10, 11)
&lt;/pre&gt;

&lt;p&gt;This extended tuple can now be seen as partial sums of a series which sums to 11. Taking differences gives the series
&lt;/p&gt;
&lt;pre&gt;
(1-0, 5-1, 7-5, 10-7, 11-10)
&lt;/pre&gt;

&lt;p&gt;which is
&lt;/p&gt;
&lt;pre&gt;
(1, 4, 2, 3, 1)
&lt;/pre&gt;

&lt;p&gt;which does indeed sum to 11
&lt;/p&gt;
&lt;pre&gt;
1 + 4 + 2 + 3 + 1 = 11
&lt;/pre&gt;

&lt;p&gt;The Python code shown uses a clever idea to implement this staggered differencing, an idea I &lt;a href="http://newsimg.bbc.co.uk/media/images/45909000/jpg/_45909582_badartists.jpg" title="Bristol's famous artist and thief"&gt;cleverly stole&lt;/a&gt; from one of &lt;a href="http://code.activestate.com/recipes/users/178123/"&gt;Raymond Hettinger&amp;#8217;s brilliant Python recipes&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;Partitioning a Sequence&lt;/h3&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Python Cookbook: Recipe 576795&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import chain, combinations

def partition(iterable, chain=chain, map=map):
    s = iterable if hasattr(iterable, '__getslice__') else tuple(iterable)
    n = len(s)
    first, middle, last = [0], range(1, n), [n]
    getslice = s.__getslice__
    return [map(getslice, chain(first, div), chain(div, last))
            for i in range(n) for div in combinations(middle, i)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This &lt;a href="http://code.activestate.com/recipes/576795"&gt;recipe&lt;/a&gt; shows sum-to-n and partitioning to be very similar problems. In fact, we could easily implement &lt;code&gt;sum_to_n()&lt;/code&gt; on top of  &lt;code&gt;partition()&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def sum_to_n(n):
    return ([len(t) for t in p] for p in partition(range(n)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The posted recipe needs a minor overhaul to get it working with Python 3.0, &lt;a href="http://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods"&gt;which does away&lt;/a&gt; with &lt;code&gt;__getslice__&lt;/code&gt;: getting a slice is simply what &lt;code&gt;__getitem__&lt;/code&gt; does when given a slice object. The 2to3 tool fails to convert the recipe, which must be recast as something like:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import chain, combinations

def sliceable(xs):
    '''Return a sliceable version of the iterable xs.'''
    try:
        xs[:0]
        return xs
    except TypeError:
        return tuple(xs)

def partition(iterable):
    s = sliceable(iterable)
    n = len(s)
    b, mid, e = [0], list(range(1, n)), [n]
    getslice = s.__getitem__
    splits = (d for i in range(n) for d in combinations(mid, i))
    return [[s[sl] for sl in map(slice, chain(b, d), chain(d, e))]
            for d in splits]

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Sum to N, again&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a variant implementation of &lt;code&gt;sum_to_n()&lt;/code&gt;. The idea here is to fill N slots with a pattern of 0&amp;#8217;s and 1&amp;#8217;s. We then reduce this pattern to the lengths of runs of repeated elements, giving a series which sums to N. &lt;code&gt;Itertools.product('01', repeat=n)&lt;/code&gt; generates all possible binary patterns of length N, which turns out to be twice as many as we want since (e.g.) 00001111100 and 11110000011 represent the same sum, 4 + 5 + 2; hence the n-1 &lt;code&gt;repeat&lt;/code&gt; count and the call to &lt;code&gt;chain&lt;/code&gt; in the code below&lt;a id="fn1link" href="http://wordaligned.org/articles/partitioning-with-python#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import groupby, chain, product

def ilen(it):
    return sum(1 for _ in it)

def sum_to_n(n):
    return ([ilen(gp) for _, gp in groupby(chain('1', O1))]
            for O1 in product('01', repeat=n-1))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Fun, but the version using &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;combinations&lt;/a&gt; is better!
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/partitioning-with-python#fn1link"&gt;[1]&lt;/a&gt; My first thought was to use &lt;code&gt;itertools.islice&lt;/code&gt; to limit the stream to the first 2&lt;sup&gt;n-1&lt;/sup&gt; values, but I discovered &lt;code&gt;islice&lt;/code&gt; has a surprising &lt;a href="http://bugs.python.org/issue6305" title="I've reported this as a bug"&gt;limitation&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import islice, count
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31) - 1)
&amp;lt;itertools.islice object at 0x63a0c0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31))
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
ValueError: Stop argument for islice() must be a non-negative integer or None.

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;
&lt;p style="text-align:center"&gt;so reuse ours&lt;/p&gt;</description>
<dc:date>2009-06-17</dc:date>
<guid>http://wordaligned.org/articles/partitioning-with-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/partitioning-with-python</link>
<category>Puzzles</category>
</item>

<item>
<title>Oulipo and the Eodermdrome challenge</title>
<description>&lt;p style="margin:0;font-size:500%"&gt;&lt;span style="color:#888"&gt;S&lt;/span&gt;&lt;span style="color:#930"&gt;H&lt;/span&gt;&lt;span style="color:#036"&gt;O&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#888"&gt;S&lt;/span&gt; &lt;span style="color:#036"&gt;O&lt;/span&gt;&lt;span style="color:#e50"&gt;N&lt;/span&gt; &lt;span style="color:#930"&gt;H&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#e50"&gt;N&lt;/span&gt;&lt;span style="color:#888"&gt;S&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:500%"&gt;&lt;span style="color:#036"&gt;S&lt;/span&gt;&lt;span style="color:#888"&gt;A&lt;/span&gt;&lt;span style="color:#930"&gt;M&lt;/span&gt;&lt;span style="color:#036"&gt;S&lt;/span&gt;&lt;span style="color:#555"&gt;O&lt;/span&gt;&lt;span style="color:#e50"&gt;N&lt;/span&gt; &lt;span style="color:#930"&gt;M&lt;/span&gt;&lt;span style="color:#555"&gt;O&lt;/span&gt;&lt;span style="color:#888"&gt;A&lt;/span&gt;&lt;span style="color:#e50"&gt;N&lt;/span&gt;&lt;span style="color:#036"&gt;S&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:500%"&gt;&lt;span style="color:#555"&gt;D&lt;/span&gt;&lt;span style="color:#930"&gt;R&lt;/span&gt;&lt;span style="color:#888"&gt;A&lt;/span&gt;&lt;span style="color:#036"&gt;B&lt;/span&gt; &lt;span style="color:#930"&gt;R&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;D&lt;/span&gt; &lt;span style="color:#036"&gt;B&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;span style="color:#888"&gt;A&lt;/span&gt;&lt;span style="color:#555"&gt;D&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;Oulipo&lt;/h3&gt;
&lt;p&gt;At the &lt;a href="http://www.dcs.warwick.ac.uk/bshm/meetings/Fiction.html"&gt;Mathematics and Fiction&lt;/a&gt; workshop held last weekend in Oxford I particularly enjoyed &lt;a href="http://web.princeton.edu/sites/fit/faculty/bellos.html"&gt;David Bellos&lt;/a&gt;&amp;#8217; wonderful talk about Oulipo, the world&amp;#8217;s longest running literary movement. &lt;a href="http://www.oulipo.net"&gt;The Oulipo&lt;/a&gt; is a group of writers interested in exploring the application of mathematical structures, patterns and algorithms to writing.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3597995774/" title="Queneau sonnets by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm4.static.flickr.com/3342/3597995774_857cdd8566_o.jpg" width="450" height="325" alt="Queneau sonnets" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;As an example, poet and novelist &lt;a href="http://en.wikipedia.org/wiki/Raymond_Queneau"&gt;Raymond Queneau&lt;/a&gt; unleashed the exponential power of combinatorics to write a &lt;a href="http://en.wikipedia.org/wiki/Sonnet"&gt;small book&lt;/a&gt; of sonnets which he hadn&amp;#8217;t finished reading himself!
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Constraints&lt;/h3&gt;
&lt;div class="amazon"&gt;&lt;a href="http://www.amazon.com/gp/product/0099477548?tag=wordalig-20"&gt;&lt;img src="http://wordaligned.org/images/books/damascus.jpg" alt="Damascus cover"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;The &lt;a href="http://en.wikipedia.org/wiki/Sonnet"&gt;sonnet&lt;/a&gt; is a highly constrained literary form: 14 lines, 10 syllables per line, and a well-defined rhyme pattern. More generally, the Oulipo discovered  such mathematical constraints can generate interesting results. Constraints can also provide inspiration &amp;#8212; tying things down helps give them shape. Consider two questions:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     What are you doing?
 &lt;/li&gt;

 &lt;li&gt;
     What are you doing? (Limit your answer to &lt;a href="http://twitter.com/thomasguest"&gt;140 characters&lt;/a&gt;.)
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first sounds plain nosey; but the second has spawned a whole new form of publishing.
&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://www.fox.com/24" title="24. Never seen it, but I get the idea!"&gt;day-in-a-life&lt;/a&gt; format is another &lt;a href="http://en.wikipedia.org/wiki/Bloomsday"&gt;famous&lt;/a&gt; literary constraint. Oulipo-inspired writer &lt;a href="http://richardbeard.info"&gt;Richard Beard&lt;/a&gt; explains how he notched this constraint up a level, creating a novel in which the action is formally and tightly bound to a single day.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In &amp;#8220;Damascus,&amp;#8221; I only use nouns that appeared in The Times of Nov. 1 1993. How does this work? In one paragraph some children are racing to the sea and one of them wants to say &amp;#8212; &amp;#8220;Last to touch the water&amp;#8217;s a donkey.&amp;#8221; But there&amp;#8217;s no &amp;#8220;donkey&amp;#8221; in the paper, so they end up saying, &amp;#8220;Last to touch the water&amp;#8217;s a walrus.&amp;#8221; So you end up with some interesting and novel linguistic formulations. &amp;#8212; &lt;a href="http://richardbeard.info/html/the_japan_times_.html"&gt;Richard Beard&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;The Eodermdrome challenge&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.oulipo.net/contraintes/docs/eodermdrome"&gt;&lt;img src="http://wordaligned.org/images/eodermdrome.png" width="200px" height="200px" style="float:right" alt="eodermdrome"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The simplest Oulipian structure David Bellos presented was the &lt;a href="http://www.oulipo.net/contraintes/docs/eodermdrome"&gt;eodermdrome&lt;/a&gt;. The word &amp;#8220;EODERMDROME&amp;#8221; is itself an eodermdrome &lt;a id="fn1link" href="http://wordaligned.org/articles/oulipo-eodermdrome#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;: if you place the letters E, O, D, R, M at the vertices of a pentagon, as shown, when you trace the sequence E&amp;rarr;O&amp;rarr;D&amp;rarr;E&amp;rarr;R&amp;rarr;M&amp;rarr;D&amp;rarr;R&amp;rarr;O&amp;rarr;M&amp;rarr;E you end up where you started, covering each line in the resulting figure exactly once. Mathematically speaking, the sequence EODERMDROME forms an Eulerian circuit within the fully connected graph whose vertices are the set of its constituent characters. Eodermdromes make naturally pleasing sequences, perhaps suitable for domain names or memorable phone numbers.
&lt;/p&gt;
&lt;p&gt;In his talk David Bellos offered three more eodermdromes. The second is credited to Jacques Roubaud. You&amp;#8217;ll notice that the elements in the third are words rather than characters: the pattern works at any scale, and a reader needn&amp;#8217;t be aware of it to appreciate its beauty.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     tears at rest
 &lt;/li&gt;

 &lt;li&gt;
     &amp;eacute;toile, ortie
 &lt;/li&gt;

 &lt;li&gt;
     figs, lizards, snakes, heat, light, figs, snakes, light, lizards, heat, figs
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Eodermdromes turn out to be surprisingly thin on the ground. I include three of my own discoveries &lt;a id="fn2link" href="http://wordaligned.org/articles/oulipo-eodermdrome#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt; at the start of this article. Can you can find any better ones?
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.withhugsandkisses.co.uk"&gt;&lt;img src="http://wordaligned.org/images/shoes-on-hens.jpg" alt="SHOES ON HENS"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/oulipo-eodermdrome#fn1link"&gt;[1]&lt;/a&gt; The word for such words is &amp;#8220;autological&amp;#8221;, as opposed to &amp;#8220;heterological&amp;#8221;. But is &lt;a href="http://en.wikipedia.org/wiki/Grelling-Nelson_paradox" title="Yes but no but"&gt;&amp;#8220;heterological&amp;#8221; itself heterological&lt;/a&gt;?
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/oulipo-eodermdrome#fn2link"&gt;[2]&lt;/a&gt; OK, so a computer did the hard work. It&amp;#8217;s a nice programming exercise.
&lt;/p&gt;
&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;
&lt;p style="text-align:center"&gt;end code once&lt;/p&gt;</description>
<dc:date>2009-06-05</dc:date>
<guid>http://wordaligned.org/articles/oulipo-eodermdrome</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/oulipo-eodermdrome</link>
<category>Puzzles</category>
</item>

<item>
<title>Ordered sublists. A brute force approach</title>
<description>&lt;h3&gt;Younger runners&lt;/h3&gt;
&lt;p&gt;Recently &lt;a href="http://wordaligned.org/articles/a-race-within-a-race.html"&gt;I posed a puzzle&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Starting with a list of runners ordered by their finishing time in a race, select a sublist of runners who are getting younger. &lt;strong&gt;What is the longest such sublist?&lt;/strong&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Below, I&amp;#8217;ve highlighted just such a sublist within the list of 8 runners who completed last year&amp;#8217;s &lt;a href="http://www.nycmarathon.org"&gt;New York marathon&lt;/a&gt; in under two and a quarter hours. As you can see, MARILSON GOMES DO SANTOS, 31, is older and faster than RONO, 30, who is older and faster in turn than ROHATINSKY, 26.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     &lt;strong&gt;MARILSON GOMES DOS SANTOS, 31&lt;/strong&gt;, M, 2:08:43
 &lt;/li&gt;

 &lt;li&gt;
     ABDERRAHIM GOUMRI, 32, M, 2:09:07
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;DANIEL RONO, 30&lt;/strong&gt;, M, 2:11:22
 &lt;/li&gt;

 &lt;li&gt;
     PAUL TERGAT, 39, M, 2:13:10
 &lt;/li&gt;

 &lt;li&gt;
     ABDERRAHIME BOURAMDANE, 30, M, 2:13:33
 &lt;/li&gt;

 &lt;li&gt;
     ABDI ABDIRAHMAN, 31, M, 2:14:17
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;JOSH ROHATINSKY, 26&lt;/strong&gt;, M, 2:14:23
 &lt;/li&gt;

 &lt;li&gt;
     JASON LEHMKUHLE, 31, M, 2:14:30
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a deceptively tricky problem. Even on such a small input list it&amp;#8217;s hard to be absolutely sure our solution is optimal. Certainly there are other ordered triples with decreasing ages, but might there be a quartet? And even if we&amp;#8217;re convinced Gomes, Rono, Rohatinsky &lt;strong&gt;do&lt;/strong&gt; form a longest ordered sublist, I think it&amp;#8217;s already clear that as more runners finish, there may be no longer be a longest ordered sublist which starts with these three.
&lt;/p&gt;

&lt;h3&gt;Dumb computers&lt;/h3&gt;
&lt;p&gt;Rather than invent a clever strategy to find an optimal solution, why not get a computer to exhaust the possibilities? If we generate all possible sublists then filter out the ones whose age fields decrease, then our answer will be the longest of these.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Exhaustive search&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import combinations as sublists
from functools import partial

def is_ordered(xs, comp):
    '''Return True if the sequence xs is ordered, False otherwise.
    
    &amp;gt;&amp;gt;&amp;gt; from operator import gt
    &amp;gt;&amp;gt;&amp;gt; is_ordered((3, 2, 1), gt)
    True
    '''
    return all(comp(xs[i], xs[i+1]) for i in range(len(xs)-1))

def longest_ordered_sublist(xs, comp):
    '''Find a longest sublist of "xs" which is ordered by "comp"
    
    (Note: there may be no unique solution, and this function makes
    no guarantees about which longest sublist is returned.)
    
    &amp;gt;&amp;gt;&amp;gt; from operator import lt
    &amp;gt;&amp;gt;&amp;gt; items = 2, 1, 5, 2, 2, 3, 1
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist(items, lt)
    (1, 2, 3)
    '''
    in_order = partial(is_ordered, comp=comp)
    xss = (xss for n in range(len(xs)) for xss in sublists(xs, n))
    return max(filter(in_order, xss), key=len)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The heavy lifting here is done by a recent addition to the &lt;code&gt;itertools&lt;/code&gt; module, &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;itertools.combinations&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;itertools.combinations(iterable, r)
&lt;/p&gt;
&lt;p&gt;Return r length subsequences of elements from the input iterable.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Generating all possible sublists is as easy (too easy!) as looping over &lt;code&gt;r&lt;/code&gt;. All that remains is to filter the ordered sublists, then use the &lt;code&gt;max&lt;/code&gt; builtin function keyed by length.
&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s apply this function to our top 8 finishers.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; results = (
... ("Gomes", 31), ("Goumri", 32), ("Rono", 30),
... ("Tergat", 39), ("Bouramdane", 30), ("Abdirahman", 31),
... ("Rohatinsky", 26), ("Lehmkuhle", 31))
&amp;gt;&amp;gt;&amp;gt; def older(runner_a, runner_b):
...     return runner_a[1] &amp;gt; runner_b[1]
&amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist(results, older)
(('Gomes', 31), ('Rono', 30), ('Rohatinsky', 26))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So, the longest ordered sublist has length 3, and Gomes, Rono, Rohatinsky is such a sublist.
&lt;/p&gt;
&lt;p&gt;Adapting &lt;code&gt;longest_ordered_sublist&lt;/code&gt; to return &lt;strong&gt;all&lt;/strong&gt; longest ordered sublists is easy enough:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     replace &lt;code&gt;max(filter(in_order, xss), key=len)&lt;/code&gt; with &lt;code&gt;sorted(filter(in_order, xss), key=len)&lt;/code&gt;
 &lt;/li&gt;

 &lt;li&gt;
     feed the sorted results through &lt;code&gt;itertools.groupby&lt;/code&gt; 
 &lt;/li&gt;

 &lt;li&gt;
     and capture the final group. 
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It turns out there are no fewer than 7 longest subsequences ordered by decreasing age.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;All longest ordered subsequences&lt;/div&gt;

&lt;pre class="prettyprint"&gt;(('Gomes', 31), ('Rono', 30), ('Rohatinsky', 26))
(('Gomes', 31), ('Bouramdane', 30), ('Rohatinsky', 26))
(('Goumri', 32), ('Rono', 30), ('Rohatinsky', 26))
(('Goumri', 32), ('Bouramdane', 30), ('Rohatinsky', 26))
(('Goumri', 32), ('Abdirahman', 31), ('Rohatinsky', 26))
(('Tergat', 39), ('Bouramdane', 30), ('Rohatinsky', 26))
(('Tergat', 39), ('Abdirahman', 31), ('Rohatinsky', 26))

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Dumber programmers&lt;/h3&gt;
&lt;p&gt;Did you spot the defects in &lt;code&gt;longest_ordered_sublist()&lt;/code&gt;? It gets the answer wrong for empty sequences and totally ordered sequences.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; import operator
&amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist([], operator.lt)
Traceback (most recent call last):
....
ValueError: max() arg is an empty sequence
&amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist((1, 2, 3), operator.lt)
(1, 2)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Fixing the code is easy enough, but what should we do about the documentation, and indeed about testing these edge cases? Certainly edge cases &lt;strong&gt;should&lt;/strong&gt; be tested, and it&amp;#8217;s tempting to add a couple more examples to the function&amp;#8217;s docstring and let &lt;a href="http://docs.python.org/library/doctest.html"&gt;doctest&lt;/a&gt; confirm correctness.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def longest_ordered_sublist(xs, comp):
    '''Find a longest sublist of "xs" which is ordered by "comp"
    
    (Note: there may be no unique solution, and this function makes
    no guarantees about which longest sublist is returned.)
    
    &amp;gt;&amp;gt;&amp;gt; from operator import lt
    &amp;gt;&amp;gt;&amp;gt; items = 2, 1, 5, 2, 2, 3, 1
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist(items, lt)
    (1, 2, 3)
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist((1, 2, 3), lt)
    (1, 2, 3)
    &amp;gt;&amp;gt;&amp;gt; longest_ordered_sublist((), lt)
    ()
    '''
    in_order = partial(is_ordered, comp=comp)
    xss = (xss for n in range(len(xs) + 1) for xss in sublists(xs, n))
    return max(filter(in_order, xss), key=len)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Tempting, yes. Good idea? Not really!
&lt;/p&gt;
&lt;p&gt;As &lt;a href="http://nedbatchelder.com/blog/200811/things_i_dont_like_about_doctest.html"&gt;Ned Batchelder puts it&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Docstrings, and the long sequence of code they encourage, may be good ways to explain what code does, but explaining and testing are two different tasks, and the code you write for each will be different. So why try to serve two masters at once?
&lt;/p&gt;
&lt;p&gt;Either your expository text will be cluttered with uninformative edge cases, or your tests will merely skim the surface of what your code can do.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;In the case of the revised version of &lt;code&gt;longest_ordered_sublist()&lt;/code&gt;, the first example in the docstring explains clearly what the function does, but the second and third count as &lt;a href="http://docs.python.org/library/doctest.html#soapbox"&gt;clutter&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;Ignorant machines&lt;/h3&gt;
&lt;p&gt;Returning to our combinatorial algorithm, this kind of exhaustive search approach is often referred to as brute force. When you&amp;#8217;ve got a machine which can do billions of things every second without breaking a sweat, it&amp;#8217;s a great technique.
&lt;/p&gt;
&lt;p&gt;In this case, though, brute force turns out to be machine ignorance. If a list has N items, then each item will be either in or out of any particular combination, giving a total of 2&lt;sup&gt;N&lt;/sup&gt; possible combinations. On my machine it took over 5 seconds to confirm the longest ordered subsequence of the &lt;a href="http://wordaligned.org/articles/a-race-within-a-race.html"&gt;first 20 runners&lt;/a&gt; in the New York marathon was of length 7.
&lt;/p&gt;
&lt;p&gt;5 seconds isn&amp;#8217;t so very long but every additional runner doubles up the time, and we can predict this particular algorithm would fail to process a result list of just 32 entries within the 2 and a bit hours it took Mar&amp;iacute;lson Gomes dos Santos to complete the course.
&lt;/p&gt;
&lt;p&gt;We need to do better.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.nycmarathon.org/2008_coverage.htm"&gt;&lt;img src="http://www.nyrr.org/resources/photos/images/2008/marathon/men/pro_men_15.jpg" alt="Marilson Gomes dos Santos"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;We can do better! This problem has been studied and some particularly interesting solutions have been found. All talk here about races, ages, etc. only exists to disguise the real problem and encourage you to consider it afresh. If you want an answer now, search for &lt;a href="http://www.google.com/search?q=longest+ordered+subsequence"&gt;&amp;#8220;longest ordered subsequence&amp;#8221;&lt;/a&gt; or &lt;a href="http://www.google.com/search?q=longest+increasing+subsequence"&gt;&amp;#8220;longest increasing subsequence&amp;#8221;&lt;/a&gt;. If you&amp;#8217;d like to have a crack at the problem yourself, the 2008 New York marathon results can be found &lt;a href="http://www.nycmarathon.org/Results.htm"&gt;online&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;I get an answer of 1724 for the length of the longest sublist of these results formed of runners whose ages are non-increasing, and 60 for the longest sublist formed of runners whose ages are strictly decreasing.
&lt;/p&gt;
&lt;p&gt;Alternatively, stick around &amp;#8212; I&amp;#8217;ll be writing up my own notes in the next couple of articles.
&lt;/p&gt;
&lt;hr /&gt;


&lt;h3&gt;Python 3.0 notes&lt;/h3&gt;
&lt;p&gt;As I mentioned at the start of the year, &lt;a href="http://wordaligned.org/articles/perl-6-python-3.html"&gt;I intend to use Python 3.0 for all new code examples&lt;/a&gt; posted here on &lt;a href="http://wordaligned.org/"&gt;Word Aligned&lt;/a&gt;. I&amp;#8217;ll also be making notes about what I discover about using this new version of Python, starting right here.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     my emacs python editing mode stopped working when I moved to Python 3.0. (I was using whatever came as standard with Carbon Emacs 22). The fix was to use &lt;a href="http://svn.python.org/view/python/tags/r30/Misc/python-mode.el?rev=67506"&gt;Python-3.0/Misc/python-mode.el&lt;/a&gt; straight out of the Python 3.0 tarball. Happily this also works with Python 2.6 and earlier.
 &lt;/li&gt;

 &lt;li&gt;
     the code presented runs out of time before running out of memory since, in Python 3.0, the &lt;code&gt;filter&lt;/code&gt; builtin function generates elements on demand. Use &lt;code&gt;future_builtins.filter&lt;/code&gt; or &lt;code&gt;itertools.ifilter&lt;/code&gt; if you want this behaviour with 2.6.
 &lt;/li&gt;

 &lt;li&gt;
     while not strictly Python 3.0 (it appears in 2.6 as well) &lt;code&gt;itertools.combinations&lt;/code&gt; is worth mentioning again, as is another related member of the itertools module. Check out &lt;a href="http://code.activestate.com/recipes/576647/"&gt;Raymond Hettinger&amp;#8217;s clever solution&lt;/a&gt; of the eight Queens puzzle, which uses &lt;code&gt;itertools.permutations&lt;/code&gt; to shuffle pieces around a chessboard. Unlike other itertools, &lt;code&gt;combinations&lt;/code&gt; and &lt;code&gt;permutations&lt;/code&gt; won&amp;#8217;t cope with infinite streams. 
 &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Another way to exhaust your computer&lt;/div&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import combinations, count
&amp;gt;&amp;gt;&amp;gt; pairs = combinations(count(), 2)

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2009-03-09</dc:date>
<guid>http://wordaligned.org/articles/ordered-sublists-a-brute-force-approach</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/ordered-sublists-a-brute-force-approach</link>
<category>Puzzles</category>
</item>

<item>
<title>A race within a race</title>
<description>&lt;p&gt;In 2003 the route of the Bristol half marathon took runners out of the city, following the Portway along the base of the Avon Gorge before turning 180&amp;deg; and taking them straight back again. So runners heading out along one side of the road got to watch the faster runners in front of them, heading back.
&lt;/p&gt;
&lt;p&gt;&lt;a style="align:top;" href="http://www.runnerslife.co.uk/Guest-Runners/Nick-Rose"&gt;&lt;img width="150" height="200" src="http://wordaligned.org/images/nick-rose-then.jpg" alt="Nick Rose then"/&gt;&lt;/a&gt;
   &lt;a style="align:top;" href="http://www.upandrunning.co.uk/shops/bristol.php"&gt;&lt;img width="150" height="200" src="http://wordaligned.org/images/nick-rose-now.jpg" alt="Nick Rose now"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The beauty of the Avon Gorge was probably lost on most competitors, myself included. What did impress me, though, was the sight of Nick Rose sprinting back along the Portway, his white hair swept back by his astonishing speed. Despite being 13 years older than me he completed the 13 mile race 13 minutes ahead of me. (I did beat &lt;a href="http://en.wikipedia.org/wiki/Steve_Cram"&gt;Steve Cram&lt;/a&gt; though!)
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;The &lt;a href="http://www.bristolhalfmarathon.com/about/race-history/"&gt;2003 Bristol half marathon&lt;/a&gt; featured a &lt;strong&gt;race within a race&lt;/strong&gt;, the &amp;#8220;Legends Challenge&amp;#8221;, which reunited veteran British athletes Nick Rose, Steve Cram, Tim Hutchings, Hugh Jones, Steve Jones and Mike McLeod to compete against each other for the first time since the 1984 Los Angeles Olympics. Nick Rose won this race within a race, aged 52, in 16&lt;sup&gt;th&lt;/sup&gt; place overall, with a time of just 1:11:08. This inspiring result set me wondering about another slice of the results: starting with a list of runners ordered by their finishing time in a race, select, in order, a sublist of runners who are getting younger. &lt;strong&gt;What is the longest such sublist?&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;Unfortunately I don&amp;#8217;t have access to the full results for the Bristol 2003 half marathon. Instead, here are the top 20 finishers in the 2008 &lt;a href="http://www.nycmarathon.org"&gt;New York marathon&lt;/a&gt;&lt;a id="fn1link" href="http://wordaligned.org/articles/a-race-within-a-race#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     MARILSON GOMES DOS SANTOS, 31, M, 2:08:43
 &lt;/li&gt;

 &lt;li&gt;
     ABDERRAHIM GOUMRI, 32, M, 2:09:07
 &lt;/li&gt;

 &lt;li&gt;
     DANIEL RONO, 30, M, 2:11:22
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;PAUL TERGAT, 39&lt;/strong&gt;, M, 2:13:10
 &lt;/li&gt;

 &lt;li&gt;
     ABDERRAHIME BOURAMDANE, 30, M, 2:13:33
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;ABDI ABDIRAHMAN, 31&lt;/strong&gt;, M, 2:14:17
 &lt;/li&gt;

 &lt;li&gt;
     JOSH ROHATINSKY, 26, M, 2:14:23
 &lt;/li&gt;

 &lt;li&gt;
     JASON LEHMKUHLE, 31, M, 2:14:30
 &lt;/li&gt;

 &lt;li&gt;
     HOSEA ROTICH, 29, M, 2:15:25
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;BOLOTA ASMEROM, 30&lt;/strong&gt;, M, 2:16:37
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;LUKE HUMPHREY, 27&lt;/strong&gt;, M, 2:18:38
 &lt;/li&gt;

 &lt;li&gt;
     HENDRICK RAMAALA, 36, M, 2:19:11
 &lt;/li&gt;

 &lt;li&gt;
     MOHAMMED AWOL, 30, M, 2:19:13
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;KASSAHUN KABISO, 25&lt;/strong&gt;, M, 2:19:54
 &lt;/li&gt;

 &lt;li&gt;
     JACOB FREY, 27, M, 2:20:17
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;GENNA TUFA, 24&lt;/strong&gt;, M, 2:20:23
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;KYLE SHACKLETON, 22&lt;/strong&gt;, M, 2:20:38
 &lt;/li&gt;

 &lt;li&gt;
     TEKLU TEFERA DENEKE, 29, M, 2:20:47
 &lt;/li&gt;

 &lt;li&gt;
     BOAZ CHEBOIYWO, 30, M, 2:21:40
 &lt;/li&gt;

 &lt;li&gt;
     DERESSE DENIBOBA, 26, M, 2:21:54
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As you can see Paul Tergat, 39, finished ahead of the younger runner Abdi Abdirahman, 31, who beat Bolota Asmerom, 30, etc., giving a sublist of 7 runners which fits our criteria. Certainly this isn&amp;#8217;t the only such sublist of this small sample, but is there a longer one?
&lt;/p&gt;
&lt;p&gt;After a few minutes we may convince ourselves we&amp;#8217;ve found an optimal solution. How would you approach this problem for the full results list, ending with YURIKO OKADA, 59, F, 9:59:58 in 38096&lt;sup&gt;th&lt;/sup&gt; place?
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.nyc-architecture.com/BRI/BR-010.htm" title="How many runners?"&gt;&lt;img width="300" src="http://www.nyc-architecture.com/BRI/Verrazano-Narrows_Bridge_New_York_City_Marathon_2.jpg" alt="How many runners?"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ll be discussing this problem in the next few posts, so please make sure you&amp;#8217;re &lt;a href="http://feeds.wordaligned.org/wordaligned"&gt;subscribed&lt;/a&gt; to read on. In the meanwhile, here&amp;#8217;s a picture of the Avon Gorge taken from the western pier of the Clifton Suspension bridge. You can see the Portway down at the bottom. Nick Rose is a past winner of the Bristol Half Marathon. In 1979 &lt;a href="http://www.nationmaster.com/encyclopedia/Half-marathon#World_record_progression_-_Men"&gt;he set a world record time&lt;/a&gt; for the distance of 1:02:36, and his &lt;a href="http://hem.bredband.net/athletics/atb-m59.htm"&gt;personal best of 1:01:03&lt;/a&gt; still stands as a British record. He lives in Bristol, now working at &lt;a href="http://www.upandrunning.co.uk/shops/bristol.php"&gt;&amp;#8220;Up and Running&amp;#8221;&lt;/a&gt; in Westbury Park, and he continues to participate in the sport.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3163729064/" title="Avon Gorge and Clifton Suspension Bridge by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm4.static.flickr.com/3120/3163729064_6f0feec1b8.jpg" width="500" height="154" alt="Avon Gorge and Clifton Suspension Bridge" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/a-race-within-a-race#fn1link"&gt;[1]&lt;/a&gt; I&amp;#8217;m using capital letters since these names are scraped directly from the &lt;a href="http://www.nycmarathon.org"&gt;New York Marathon website&lt;/a&gt;, which uses capital letters almost exclusively, except for non-ascii athletes such as CORN&amp;eacute; VAN OIRSCHOT.
&lt;/p&gt;</description>
<dc:date>2009-03-04</dc:date>
<guid>http://wordaligned.org/articles/a-race-within-a-race</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/a-race-within-a-race</link>
<category>Puzzles</category>
</item>

<item>
<title>What&#8217;s in the box?</title>
<description>&lt;p&gt;Last week I posted &lt;a href="http://wordaligned.org/articles/a-little-teaser.html"&gt;a little teaser&lt;/a&gt; which hid a series of clues in and around the page&amp;#8217;s HTML and the referenced graphic. Thanks to everyone who joined in. Some of you said you learned something in the process, which is good; and &lt;a href="http://netpbm.sourceforge.net/"&gt;I did too&lt;/a&gt;, which is better!
&lt;/p&gt;
&lt;p&gt;Filip Salomonsson completed the treasure hunt first. Extra credits go to Robin Stocker for his &lt;a href="http://www.flickr.com/photos/thomasguest/3106269463/"&gt;Swiss version&lt;/a&gt;, &lt;a href="http://chneukirchen.org/"&gt;Christian Neukirchen&lt;/a&gt; for a solution which requires no programming, and to Shiar who spotted the answer at once but nevertheless followed the clues to the end! 
&lt;/p&gt;
&lt;p&gt;A full solution appears below, &lt;a href="http://fliptitle.com"&gt;ROT-180&amp;deg;&lt;/a&gt; encoded.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/a-little-teaser.html"&gt;&lt;img src="http://wordaligned.org/images/top-row-flipped.png" alt="What's this? Answer below!"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;div style="text-align:right;"&gt;&lt;p&gt;&amp;#x02D9;&amp;#x01DD;&amp;#x0279;&amp;#x01DD;&amp;#x0265; p&amp;#x01DD;&amp;#x028C;&amp;#x0131;&amp;#x0279;&amp;#x0279;&amp;#x0250; &amp;#x01DD;&amp;#x028C;,no&amp;#x028E; &amp;#x028D;ou&amp;#x029E; &amp;#x01DD;&amp;#x026F; &amp;#x0287;&amp;#x01DD;l o&amp;#x0287; &amp;#x0183;&amp;#x0279;o&amp;#x02D9;p&amp;#x01DD;u&amp;#x0183;&amp;#x0131;l&amp;#x0250;p&amp;#x0279;o&amp;#x028D;@s&amp;#x028E;&amp;#x01DD;&amp;#x029E;&amp;#x0287;l&amp;#x0250;:o&amp;#x0287;l&amp;#x0131;&amp;#x0250;&amp;#x026F; &amp;#x01DD;s&amp;#x0250;&amp;#x01DD;ld &amp;#x02D9;(-&amp;#x061B; p&amp;#x01DD;u&amp;#x0183;&amp;#x0131;l&amp;#x0250; p&amp;#x0279;o&amp;#x028D; o&amp;#x0287; uo&amp;#x0131;&amp;#x0287;d&amp;#x0131;&amp;#x0279;&amp;#x0254;sqns &amp;#x0183;uol&amp;#x01DD;&amp;#x025F;&amp;#x0131;l &amp;#x01DD;&amp;#x01DD;&amp;#x0279;&amp;#x025F; &amp;#x0250; s&amp;#x0131; &amp;#x01DD;z&amp;#x0131;&amp;#x0279;d &amp;#x0279;no&amp;#x028E; &amp;#x00A1;&amp;#x01DD;uop ll&amp;#x01DD;&amp;#x028D; &amp;#x02D9;&lt;a href="http://www.flickr.com/photos/thomasguest/3104398656/"&gt;&amp;#x01DD;&amp;#x0279;&amp;#x01DD;&amp;#x0265;&lt;/a&gt; s&amp;#x0279;&amp;#x01DD;&amp;#x0287;&amp;#x0254;&amp;#x0250;&amp;#x0279;&amp;#x0250;&amp;#x0265;&amp;#x0254; &amp;#x025F;o s&amp;#x028D;o&amp;#x0279; &amp;#x01DD;&amp;#x01DD;&amp;#x0279;&amp;#x0265;&amp;#x0287; ll&amp;#x0250; &amp;#x01DD;&amp;#x01DD;s u&amp;#x0250;&amp;#x0254; no&amp;#x028E; &amp;#x02D9;&amp;#x028E;&amp;#x01DD;&amp;#x029E; &amp;#x0287;l&amp;#x0250; &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x028D;op &amp;#x0183;u&amp;#x0131;plo&amp;#x0265; &amp;#x01DD;l&amp;#x0131;&amp;#x0265;&amp;#x028D; p&amp;#x0279;&amp;#x0250;oq&amp;#x028E;&amp;#x01DD;&amp;#x029E; &amp;#x028E;&amp;#x0287;&amp;#x0279;&amp;#x01DD;&amp;#x028D;b &amp;#x0254;&amp;#x0250;&amp;#x026F; &amp;#x01DD;ldd&amp;#x0250; u&amp;#x0250; uo s&amp;#x0279;&amp;#x01DD;&amp;#x0287;&amp;#x0254;&amp;#x0250;&amp;#x0279;&amp;#x0250;&amp;#x0265;&amp;#x0254; &amp;#x025F;o &amp;#x028D;o&amp;#x0279; do&amp;#x0287; &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; &amp;#x01DD;d&amp;#x028E;&amp;#x0287; &amp;#8216;&amp;#x01DD;&amp;#x0183;&amp;#x0250;&amp;#x026F;&amp;#x0131; s&amp;#x0131;&amp;#x0265;&amp;#x0287; &amp;#x01DD;&amp;#x0287;&amp;#x0250;&amp;#x0279;&amp;#x01DD;u&amp;#x01DD;&amp;#x0183; o&amp;#x0287; :uo&amp;#x0131;&amp;#x0287;nlos&lt;/p&gt;&lt;p&gt;&amp;#x02D9;004 &amp;#x0254;- p&amp;#x0250;&amp;#x01DD;&amp;#x0265; | &amp;#x0183;ud&amp;#x02D9;&amp;#x028D;o&amp;#x0279;-do&amp;#x0287; &amp;#x0250;&amp;#x0265;dl&amp;#x0250;- &amp;#x026F;udo&amp;#x0287;&amp;#x0183;ud :&amp;#x0183;u&amp;#x0131;&amp;#x026F;&amp;#x026F;&amp;#x0250;&amp;#x0279;&amp;#x0183;o&amp;#x0279;d &amp;#x028E;u&amp;#x0250; &amp;#x0183;u&amp;#x0131;&amp;#x0279;&amp;#x0131;nb&amp;#x01DD;&amp;#x0279; &amp;#x0287;no&amp;#x0265;&amp;#x0287;&amp;#x0131;&amp;#x028D; &amp;#x0279;&amp;#x01DD;&amp;#x028D;su&amp;#x0250; &amp;#x01DD;&amp;#x0265;&amp;#x0287; s&amp;#x0287;&amp;#x01DD;&amp;#x0183; &amp;#x0265;&amp;#x0254;&amp;#x0131;&amp;#x0265;&amp;#x028D; &amp;#x026F;udo&amp;#x0287;&amp;#x0183;ud &amp;#x0287;&amp;#x0250; &amp;#x01DD;&amp;#x026F; p&amp;#x01DD;&amp;#x0287;u&amp;#x0131;od u&amp;#x01DD;&amp;#x0265;&amp;#x0254;&amp;#x0279;&amp;#x0131;&amp;#x029E;n&amp;#x01DD;u u&amp;#x0250;&amp;#x0131;&amp;#x0287;s&amp;#x0131;&amp;#x0279;&amp;#x0265;&amp;#x0254; &amp;#x02D9;s&amp;#x01DD;nl&amp;#x0250;&amp;#x028C; &amp;#x0250;&amp;#x0265;dl&amp;#x0250; &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0287;&amp;#x01DD;&amp;#x0183; o&amp;#x0287; &amp;#x0287;d&amp;#x0131;&amp;#x0279;&amp;#x0254;s &amp;#x01DD;ld&amp;#x026F;&amp;#x0131;s &amp;#x0250; &amp;#x01DD;&amp;#x0287;&amp;#x0131;&amp;#x0279;&amp;#x028D; o&amp;#x0287; &amp;#x028E;&amp;#x0279;&amp;#x0250;&amp;#x0279;q&amp;#x0131;l &amp;#x0183;u&amp;#x0131;&amp;#x0183;&amp;#x0250;&amp;#x026F;&amp;#x0131; uo&amp;#x0265;&amp;#x0287;&amp;#x028E;d &amp;#x01DD;&amp;#x0265;&amp;#x0287; p&amp;#x01DD;sn &amp;#x0131;&lt;/p&gt;&lt;p&gt;&amp;#x02D9;&amp;#x01DD;nl&amp;#x0254; &amp;#x0287;x&amp;#x01DD;u &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0287;no ll&amp;#x01DD;ds &amp;#x0183;ud s&amp;#x0131;&amp;#x0265;&amp;#x0287; &amp;#x025F;o &amp;#x028D;o&amp;#x0279; do&amp;#x0287; &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; s&amp;#x01DD;nl&amp;#x0250;&amp;#x028C; &amp;#x0250;&amp;#x0265;dl&amp;#x0250; &amp;#x01DD;&amp;#x0265;&amp;#x0287; :s&amp;#x028E;&amp;#x0250;s &amp;#x0265;&amp;#x0254;&amp;#x0131;&amp;#x0265;&amp;#x028D; &amp;#8216;&amp;#x0287;u&amp;#x01DD;&amp;#x026F;&amp;#x026F;o&amp;#x0254; &amp;#x01DD;&amp;#x0265;&amp;#x0287; p&amp;#x0250;&amp;#x01DD;&amp;#x0279; o&amp;#x0287; &amp;#x0183;ud&amp;#x02D9;&amp;#x028D;o&amp;#x0279;-do&amp;#x0287; &amp;#x01DD;soq&amp;#x0279;&amp;#x01DD;&amp;#x028C;- &amp;#x028E;&amp;#x025F;&amp;#x0131;&amp;#x0287;u&amp;#x01DD;p&amp;#x0131; &amp;#x029E;&amp;#x0254;&amp;#x0131;&amp;#x0183;&amp;#x0250;&amp;#x026F;&amp;#x01DD;&amp;#x0183;&amp;#x0250;&amp;#x026F;&amp;#x0131; p&amp;#x01DD;sn &amp;#x0131; &amp;#x02D9;&amp;#x028E;ll&amp;#x0250;&amp;#x0254;ol &amp;#x0183;ud &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x01DD;&amp;#x028C;&amp;#x0250;s&lt;/p&gt;&lt;p&gt;&amp;#x02D9;&amp;#x0183;ud &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x025F;o &amp;#x029E;un&amp;#x0265;&amp;#x0254; &amp;#x0287;x&amp;#x0287;z &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; &amp;#x0287;u&amp;#x01DD;&amp;#x026F;&amp;#x026F;o&amp;#x0254; &amp;#x01DD;&amp;#x0265;&amp;#x0287; p&amp;#x0250;&amp;#x01DD;&amp;#x0279; &amp;#8216;&amp;#x01DD;nl&amp;#x0254; &amp;#x0287;x&amp;#x01DD;u &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0279;o&amp;#x025F; :&amp;#x01DD;&amp;#x01DD;s ll,no&amp;#x028E; &amp;#x02D9;&amp;#x01DD;sno&amp;#x026F; &amp;#x0279;no&amp;#x028E; &amp;#x0183;u&amp;#x0131;sn &amp;#x0279;&amp;#x0250;q&amp;#x01DD;p&amp;#x0131;s &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0287;&amp;#x0254;&amp;#x01DD;l&amp;#x01DD;s&lt;/p&gt;&lt;p&gt;&amp;#x02D9;&amp;#x0279;&amp;#x0250;q&amp;#x01DD;p&amp;#x0131;s &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; &amp;#x0287;x&amp;#x01DD;&amp;#x0287; &amp;#x01DD;&amp;#x0287;&amp;#x0131;&amp;#x0265;&amp;#x028D; uo &amp;#x01DD;&amp;#x0287;&amp;#x0131;&amp;#x0265;&amp;#x028D; &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x0287;&amp;#x0265;&amp;#x0183;&amp;#x0131;l&amp;#x0265;&amp;#x0183;&amp;#x0131;&amp;#x0265; &amp;#8216;&amp;#x01DD;nl&amp;#x0254; &amp;#x0287;x&amp;#x01DD;u &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x01DD;&amp;#x01DD;s o&amp;#x0287; :sp&amp;#x0250;&amp;#x01DD;&amp;#x0279; l&amp;#x026F;&amp;#x0287;&amp;#x0265; &amp;#x01DD;&amp;#x0265;&amp;#x0287; u&amp;#x0131; &amp;#x0287;u&amp;#x01DD;&amp;#x026F;&amp;#x026F;o&amp;#x0254; &amp;#x0250; &amp;#x02D9;xo&amp;#x025F;&amp;#x01DD;&amp;#x0279;&amp;#x0131;&amp;#x025F; uo n+l&amp;#x0279;&amp;#x0287;&amp;#x0254; (&amp;#x02D9;&amp;#x0183;&amp;#x02D9;&amp;#x01DD;) &amp;#x0183;u&amp;#x0131;sn l&amp;#x026F;&amp;#x0287;&amp;#x0265; &amp;#x01DD;&amp;#x0265;&amp;#x0287; &amp;#x028D;&amp;#x01DD;&amp;#x0131;&amp;#x028C;&lt;/p&gt;&lt;/div&gt;

&lt;span id="continue-reading"/&gt;

&lt;p&gt;Some found the teaser too easy. Others asked if I&amp;#8217;d be posting a follow up.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3122529935/" title="What's in the box?"&gt;&lt;img src="http://farm4.static.flickr.com/3264/3122529935_dfe6550cf6_o.png" width="294" height="450" alt="What's in the box?" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Sorry. Maybe.
&lt;/p&gt;</description>
<dc:date>2008-12-20</dc:date>
<guid>http://wordaligned.org/articles/whats-in-the-box</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/whats-in-the-box</link>
<category>Puzzles</category>
</item>

<item>
<title>A Little Teaser. Keen Eyes? You&#8217;ll See!</title>
<description>&lt;p&gt;This curious document turned up in the lost+found. Can anyone help me &lt;a href="http://www.imagemagick.org/www/identify.html" title="First hint!"&gt;identify&lt;/a&gt; it?
&lt;/p&gt;
&lt;img src="http://wordaligned.org/images/top-row.png" alt="What's this?"/&gt;

&lt;p&gt;(View &lt;a href="http://wordaligned.org/articles/a-little-teaser.html"&gt;this page&amp;#8217;s&lt;/a&gt; source for a clue.)
&lt;/p&gt;
&lt;!-- To see the next clue, highlight the white on white text in the sidebar --&gt;</description>
<dc:date>2008-12-12</dc:date>
<guid>http://wordaligned.org/articles/a-little-teaser</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/a-little-teaser</link>
<category>Puzzles</category>
</item>

<item>
<title>Sums and sums of squares in C++</title>
<description>&lt;h3&gt;C++ question&lt;/h3&gt;
&lt;p&gt;Suppose you have a collection, &lt;code&gt;xs&lt;/code&gt;, of floating point values.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef std::vector&amp;lt;double&amp;gt; doubles;
doubles xs;
.... code which fills xs

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How would you sum the elements of &lt;code&gt;xs&lt;/code&gt;? 
&lt;/p&gt;
&lt;p&gt;Now how would you calculate the sum of squares of these elements?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;It&amp;#8217;s not a trick question but there is more than one plausible answer &amp;#8212; a fact I was reminded of when I read a recent &lt;a href="http://www.johndcook.com/blog/2008/10/20/comparing-two-ways-to-fit-a-line-to-data/"&gt;article by John D. Cook&lt;/a&gt; which demonstrates how to recast a curve fitting equation to avoid loss of precision. An obvious and idiomatic approach is to loop through the values of &lt;code&gt;xs&lt;/code&gt; accumulating the required sums&lt;a id="fn1link" href="http://wordaligned.org/articles/sums-and-sums-of-squares#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double sum_xs = 0.0;
double sum_squares_xs = 0.0;

for (doubles::const_iterator xi = xs.begin(); xi != xs.end(); ++xi)
{
    double const x = *xi;
    sum_xs += x;
    sum_squares_xs += x * x;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Functional programmers might sniff at this double purpose loop which repeatedly rewrites the values of &lt;code&gt;sum_xs&lt;/code&gt; and &lt;code&gt;sum_squares_xs&lt;/code&gt; to achieve the desired result. Surely this code ought to be expressed as an application of that well-known higher order function, &lt;a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)"&gt;reduce&lt;/a&gt;? 
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s hard for an imperative programmer accept this complaint: the code, as it stands, is simple, idiomatic and efficient. However &amp;#8230; consider the same problem in Python.
&lt;/p&gt;

&lt;h3&gt;Reduce in Python&lt;/h3&gt;
&lt;p&gt;Python is far from being a pure functional programming language. As it happens, &lt;a href="http://docs.python.org/library/functions.html#reduce"&gt;reduce()&lt;/a&gt; is being demoted from a builtin to a library function in the next major release of the language. Here&amp;#8217;s the deprecation warning Python 2.6 spits out:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ python -3 -c "print reduce(lambda x, y: x + y, range(10))"
-c:1: DeprecationWarning: reduce() not supported in 3.x; use functools.reduce()
45

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I&amp;#8217;ve no real quibble about this decision: the truth is, reduce can move aside because Python already &lt;a href="http://wordaligned.org/articles/paralipsis.html"&gt;builds in specialisations&lt;/a&gt; of the most common reductions. In this case &lt;code&gt;sum&lt;/code&gt; answers our first question. Combine &lt;code&gt;sum&lt;/code&gt; with a generator expression and we&amp;#8217;ve answered the second one nicely too.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;sum_xs = sum(xs)
sum_squares_xs = sum(x * x for x in xs)

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Reduce in C++&lt;/h3&gt;
&lt;p&gt;&lt;span /&gt;Idiomatic C++ varies across both time and team. The C++ standard library does include &lt;code&gt;reduce&lt;/code&gt;, and it deserves to be better known. You can find it in &lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt; under the name of &lt;a href="http://www.sgi.com/tech/stl/accumulate.html"&gt;std::accumulate()&lt;/a&gt;. Accumulate accepts as arguments an iterator range, an initial value, and optionally a binary function. From the SGI STL &lt;a href="http://www.sgi.com/tech/stl/accumulate.html"&gt;documentation&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3&gt;Prototype&lt;/h3&gt;
&lt;p&gt;&lt;tt&gt;Accumulate&lt;/tt&gt; is an overloaded name; there are actually two &lt;tt&gt;accumulate&lt;/tt&gt;functions.&lt;/p&gt;
&lt;pre&gt;
template &amp;lt;class InputIterator, class T&amp;gt;
T accumulate(InputIterator first, InputIterator last, T init);

template &amp;lt;class InputIterator, class T, class BinaryFunction&amp;gt;
T accumulate(InputIterator first, InputIterator last, T init,
             BinaryFunction binary_op);
&lt;/pre&gt;
&lt;h3&gt;Description&lt;/h3&gt;
&lt;p&gt;&lt;tt&gt;Accumulate&lt;/tt&gt; is a generalization of summation: it computes the sum
(or some other binary operation) of &lt;tt&gt;init&lt;/tt&gt; and all of the elements
in the range &lt;tt&gt;[first, last)&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The function object &lt;tt&gt;binary_op&lt;/tt&gt; is not required to be either commutative or associative: the order of all of &lt;tt&gt;accumulate&lt;/tt&gt;&amp;#8217;s operations is specified.  The result is first initialized to &lt;tt&gt;init&lt;/tt&gt;.  Then, for each
iterator &lt;tt&gt;i&lt;/tt&gt; in &lt;tt&gt;[first, last)&lt;/tt&gt;, in order from beginning to end,
it is updated by &lt;tt&gt;result = result + *i&lt;/tt&gt; (in the first version) or &lt;tt&gt;result = binary_op(result, *i)&lt;/tt&gt; (in the second version).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thus, in its simpler form, &lt;code&gt;std::accumulate&lt;/code&gt; returns the sum of elements in the input range. Like Python, we can sum numbers; unlike Python we can also sum (i.e. concatenate) &lt;code&gt;strings&lt;/code&gt; or &lt;code&gt;valarrays&lt;/code&gt;&lt;a id="fn2link" href="http://wordaligned.org/articles/sums-and-sums-of-squares#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt; &amp;#8212; or indeed any other type we choose, provided we implement a suitable overload of &lt;code&gt;operator+()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;So, to sum the elements of &lt;code&gt;xs&lt;/code&gt;, we write:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double sum_xs = accumulate(xs.begin(), xs.end(), 0.0);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Include &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; and we can find their product too:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double product_xs 
    = accumulate(xs.begin(), xs.end(), 1.0, std::multiplies&amp;lt;double&amp;gt;());

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To sum the squares of elements of &lt;code&gt;xs&lt;/code&gt; we might supply a custom binary function.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double accum_sq(double sum_so_far, double x)
{
    return sum_so_far + x * x;
}

.... double sum_squares_xs 
         = accumulate(xs.begin(), xs.end(), 0.0, accum_sq);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Or have we got the arguments to &lt;code&gt;accum_sq()&lt;/code&gt; the wrong way round? This is the kind of code which risks giving &lt;code&gt;reduce()&lt;/code&gt; a bad name. Maybe we could avoid confusion by creating an intermediate container to hold the squared values?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;doubles xxs;

transform(xs.begin(), xs.end(), xs.begin(),
          back_inserter(xxs), std::multiplies&amp;lt;double&amp;gt;());
double sum_squares_xs = accumulate(xxs.begin(), xxs.end(), 0.0);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the first three arguments to &lt;code&gt;std::transform()&lt;/code&gt; cause &lt;code&gt;xs&lt;/code&gt; to be zipped with itself and &lt;code&gt;std::multiplies&lt;/code&gt; ensures &lt;code&gt;xxs&lt;/code&gt; gets filled with squares of elements of &lt;code&gt;xs&lt;/code&gt;. Feed the resulting range into &lt;code&gt;accumulate&lt;/code&gt; and we&amp;#8217;re done. It&amp;#8217;s cute that C++ lets you do this but a programmer may well fret about the extra storage and wonder where the original simple loop went!
&lt;/p&gt;

&lt;h3&gt;Std::inner_product&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Std::accumulate()&lt;/code&gt; &lt;strong&gt;is&lt;/strong&gt; reduce but sadly C++ doesn&amp;#8217;t do functional programming well enough to really exploit its power. Nonetheless, the algorithm deserves to be better known. As it happens there&amp;#8217;s &lt;a href="http://www.sgi.com/tech/stl/inner_product.html"&gt;an even less well known member&lt;/a&gt; of the standard library which can solve our sum of squares puzzle.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Std::inner_product&lt;/code&gt; is yet another reduction. It zips up two iterator ranges multiplying together elements from the resulting pairs and summing these multiples to produce a final result. You can use it to find the scalar product of two vectors, or to calculate a weighted sum or, indeed, if we feed the range &lt;code&gt;xs.begin()&lt;/code&gt;, &lt;code&gt;xs.end()&lt;/code&gt; to it twice, to sum the squares of elements of &lt;code&gt;xs&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;double sum_squares_xs 
    = inner_product(xs.begin(), xs.end(), xs.begin(), 0.0);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This form is undeniably compact. If you know about &lt;code&gt;std::inner_product&lt;/code&gt; it&amp;#8217;s easy to understand. I&amp;#8217;ll &lt;a href="http://ccgi.hashpling.plus.com/blog/new-things-are-always-better/" title="Chris Bailey explores a typical C++ conundrum"&gt;leave you to decide if it&amp;#8217;s better&lt;/a&gt; than a hand-written loop.
&lt;/p&gt;

&lt;h3&gt;Example program&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple program designed to demonstrate the use of accumulate and inner_product.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;// Examples of std::accumulate and std::inner_product
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;valarray&amp;gt;
#include &amp;lt;vector&amp;gt;

typedef std::valarray&amp;lt;double&amp;gt; xyz;

// Xyz output operator
std::ostream &amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp; os, xyz const &amp;amp; pt)
{
    os &amp;lt;&amp;lt; '(';
    char const * sep = "";
    for (size_t i = 0; i != pt.size(); sep = ", ", ++i)
    {
        os &amp;lt;&amp;lt; sep &amp;lt;&amp;lt; pt[i];
    }
    os &amp;lt;&amp;lt; ')';
    return os;
}

// Bitwise or function, for use in reductions
unsigned bit_or(unsigned u, unsigned v)
{
    return u | v;
}

// Create and return a triangle
std::vector&amp;lt;xyz&amp;gt; create_triangle()
{
    std::vector&amp;lt;xyz&amp;gt; pts;
    double const p[9] = {1.,1.,0.,1.,0.,1.,0.,1.,1.};
    pts.push_back(xyz(p + 0, 3));
    pts.push_back(xyz(p + 3, 3));
    pts.push_back(xyz(p + 6, 3));
    return pts;
}

// Set up some test arrays, accumulate them and print the results to stdout.
int main()
{
    int const a[3] = { 1, 2, 3 };
    int const b[3] = { 3, 2, 1 };
    std::string const s[3] = { "http://", "wordaligned", ".org" };
    bool const t[3] = { false, true, false };
    std::vector&amp;lt;xyz&amp;gt; tri = create_triangle();
    unsigned m[3] = { 1&amp;lt;&amp;lt;1, 1&amp;lt;&amp;lt;3, 1&amp;lt;&amp;lt;5 };
    
    std::cout
        &amp;lt;&amp;lt; "sum(a) "
        &amp;lt;&amp;lt; std::accumulate(a, a + 3, 0)
        &amp;lt;&amp;lt; "\nprod(a) "
        &amp;lt;&amp;lt; std::accumulate(a, a + 3, 1, std::multiplies&amp;lt;int&amp;gt;())
        &amp;lt;&amp;lt; "\nsum_sqs(a) "
        &amp;lt;&amp;lt; std::inner_product(a, a + 3, a, 0)
        &amp;lt;&amp;lt; "\ndot(a, b) "
        &amp;lt;&amp;lt; std::inner_product(a, a + 3, b, 0)
        &amp;lt;&amp;lt; "\nconcat(s) "
        &amp;lt;&amp;lt; std::accumulate(s, s + 3, std::string(""))
        &amp;lt;&amp;lt; "\nany(t) " &amp;lt;&amp;lt; std::boolalpha
        &amp;lt;&amp;lt; std::accumulate(t, t + 3, false, std::logical_or&amp;lt;bool&amp;gt;())
        &amp;lt;&amp;lt; "\ncentroid(tri) "
        &amp;lt;&amp;lt; std::accumulate(tri.begin(), tri.end(), xyz(0., 3)) / 3.
        &amp;lt;&amp;lt; "\nbitor(m) " &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; "0x"
        &amp;lt;&amp;lt; std::accumulate(m, m + 3, 0, bit_or)
        &amp;lt;&amp;lt; '\n';
    
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This program outputs:
&lt;/p&gt;
&lt;pre&gt;
sum(a) 6
prod(a) 6
sum_sqs(a) 14
dot(a, b) 10
concat(s) http://wordaligned.org
any(t) true
centroid(tri) (0.666667, 0.666667, 0.666667)
bitor(m) 0x2a
&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/sums-and-sums-of-squares#fn1link"&gt;[1]&lt;/a&gt; In the case of &lt;a href="http://www.johndcook.com/blog/2008/10/20/comparing-two-ways-to-fit-a-line-to-data/"&gt;John D. Cook&amp;#8217;s article&lt;/a&gt;, which draws attention to the nuts and bolts of a calculation, the explicit loop is an ideal formulation.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/sums-and-sums-of-squares#fn2link"&gt;[2]&lt;/a&gt; &amp;#x2621; A note of caution! Although you can add &lt;code&gt;std::string&lt;/code&gt;s together, using &lt;code&gt;std::accumulate&lt;/code&gt; to concatenate a large number of strings may class as &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;premature pessimization&lt;/a&gt; since each addition is likely to involve dynamic memory allocation. I must also point out that &lt;code&gt;std::valarray&lt;/code&gt; has an uncertain footing in the C++ Standard Library. In his excellent C++ standard library reference book &lt;a href="http://www.josuttis.com/libbook/"&gt;Nicolai Josuttis&lt;/a&gt; sticks the boot in:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The valarray classes were not designed very well. In fact, nobody tried to determine whether the final specification worked. This happened because nobody felt &amp;#8220;responsible&amp;#8221; for these classes. The person who introduced valarrays to the C++ standard library left the committee a long time before the standard was finished.
&lt;/p&gt;
&lt;/blockquote&gt;</description>
<dc:date>2008-10-30</dc:date>
<guid>http://wordaligned.org/articles/sums-and-sums-of-squares</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/sums-and-sums-of-squares</link>
<category>Puzzles</category>
</item>

<item>
<title>Stop the clock, squash the bug</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocsoftware-bugs" name="toc0" id="toc0"&gt;Software Bugs&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocleaks-and-races" name="toc1" id="toc1"&gt;Leaks and Races&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc75-correct-vs-50-correct" name="toc2" id="toc2"&gt;75% correct vs 50% correct&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocprobabilistic-algorithms" name="toc3" id="toc3"&gt;Probabilistic algorithms&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocfixing-isfprime" name="toc4" id="toc4"&gt;Fixing is_fprime&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocdefensive-programming" name="toc5" id="toc5"&gt;Defensive programming&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocdefect-halflife" name="toc6" id="toc6"&gt;Defect halflife&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tochow-did-that-code-ever-work" name="toc7" id="toc7"&gt;How did that code ever work?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocconclusions" name="toc8" id="toc8"&gt;Conclusions&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocsource-code" name="toc9" id="toc9"&gt;Source code&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;Which clock is the best?
&lt;/p&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/images/stopped-clock.gif" alt="Stopped clock"/&gt;
   &lt;img src="http://wordaligned.org/images/slow-clock.gif" alt="Slow clock"/&gt;
   &lt;img src="http://wordaligned.org/images/fast-clock.gif" alt="Fast clock"/&gt;
&lt;/p&gt;
&lt;p&gt;We can easily rule the one which has stopped &amp;#8230; 
&lt;/p&gt;
&lt;p&gt;Or can we? In &amp;#8220;The Rectory Umbrella&amp;#8221; Lewis Carroll &lt;a href="http://www.gavagai.de/themen/HHPT02.htm"&gt;argues otherwise&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Which is better, a clock that is right only once a year, or a clock that is right twice every day?
&lt;/p&gt;
&lt;p&gt;&amp;#8220;The latter,&amp;#8221; you reply, &amp;#8220;unquestionably.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;Very good, now attend.
   I have two clocks: one doesn&amp;#8217;t go at all, and the other loses a minute a day: which would you prefer? &amp;#8220;The losing one,&amp;#8221; you answer, &amp;#8220;without a doubt.&amp;#8221; Now observe: the one which loses a minute a day has to lose twelve hours, or seven hundred and twenty minutes before it is right again, consequently it is only right once in two years, whereas the other is evidently right as often as the time it points to comes round, which happens twice a day. 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;span id="continue-reading"/&gt;

&lt;p&gt;It&amp;#8217;s an amusing diversion, but not really that puzzling: &lt;em&gt;of course&lt;/em&gt; the clock which loses time is of more practical use, even if, somewhat paradoxically, the less time it loses the less often it tells the right time. A clock which loses just a second a day only tells the right time every 118 years or so.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc0" name="tocsoftware-bugs" id="tocsoftware-bugs"&gt;Software Bugs&lt;/a&gt;&lt;/h3&gt;
&lt;img style="float:right;" src="http://wordaligned.org/images/buttons/spider.jpg" alt="Bug"/&gt;

&lt;p&gt;I mention these defective clocks because I&amp;#8217;m thinking about bugs in software and how we go about finding and fixing them. 
&lt;/p&gt;
&lt;p&gt;Code which is obviously wrong is easier to spot than code which is almost right, and spotting bugs is the precursor to fixing them. This implies &amp;#8212; building on Carroll&amp;#8217;s terminology &amp;#8212; that we&amp;#8217;re unlikely to ship many stopped clocks but if we&amp;#8217;re not careful we may end up delivering a few which lose time. And, in general, code which is obviously wrong is easier to fix than code which is almost right. A badly-broken function clearly needs a rethink; whereas one which &lt;em&gt;almost&lt;/em&gt; works may simply get tweaked until it &lt;em&gt;appears&lt;/em&gt; to work, often resulting in a more subtle bug.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc1" name="tocleaks-and-races" id="tocleaks-and-races"&gt;Leaks and Races&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;C and C++ provide a good example of what I&amp;#8217;m talking about. Consider a program which misuses memory. An attempt to allocate workspace of 4294967295 bytes fails instantly&lt;a id="fn1link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;; a slow memory leak, like a slow running clock, may cause no perceptible damage for an extended period.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://valgrind.org"&gt;Decent tools&lt;/a&gt; detect memory leaks. Race conditions in multi-threaded code are harder to track and may prove elusive during system testing. More than once I&amp;#8217;ve left a program running under a debugger, being fed random inputs, in the hope some rare and apparently random condition will trigger a break in execution. Give me truly broken code any day!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc2" name="toc75-correct-vs-50-correct" id="toc75-correct-vs-50-correct"&gt;75% correct vs 50% correct&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here are two implementations of a C function to find an integer midway between a pair of ordered, positive integer values, truncating downwards. Before reading on, ask yourself which is better.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;int midpoint1(int low, int high)
{
    return low/2 + high/2;
}

int midpoint2(int low, int high)
{
    return (low + high)/2;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Midpoint1&lt;/code&gt; is a &amp;#8220;stopped clock&amp;#8221;, returning 3 instead of 4 as the mid-point of 3 and 5, for example. It gets the wrong answer 25% of the time &amp;#8212; fatally wrong were it to be used at the heart of, say, a binary search. I think we&amp;#8217;d quickly detect the problem.
&lt;/p&gt;
&lt;p&gt;An obvious fix would be the one shown in &lt;code&gt;midpoint2&lt;/code&gt; which does indeed return 4 as the mid-point of 3 and 5. 
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Midpoint2&lt;/code&gt; turns out to be a losing clock, though. If the sum &lt;code&gt;low + high&lt;/code&gt; overflows then the result is undefined. On my implementation I get a negative value &amp;#8212; a dangerous thing to use as an array index. This is a notorious and very real defect, nicely documented in a &lt;a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html"&gt;note by Joshua Bloch&lt;/a&gt; subtitled &amp;#8220;Nearly all Binary Searches and Mergesorts are broken&amp;#8221;. 
&lt;/p&gt;
&lt;p&gt;Bloch offers more than one fix so I&amp;#8217;ll just note here that:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     this defect simply doesn&amp;#8217;t exist in a high-level language like Python or Haskell, where integers are bounded only by machine resources
 &lt;/li&gt;

 &lt;li&gt;
     I think Bloch is unfair to suggest Jon Bentley&amp;#8217;s analysis in chapter 4 of Programming Pearls is wrong. The pseudo-code in this chapter is written in a C-like language somewhere between C and Python, and in fact one of Bentley&amp;#8217;s exercises is to examine what effect word size has on this analysis.
 &lt;/li&gt;

 &lt;li&gt;
     in a sense, &lt;code&gt;midpoint2&lt;/code&gt; is more broken than &lt;code&gt;midpoint1&lt;/code&gt;: over the range of possible low and high inputs, the sum overflows and triggers the defect 50% of the time.
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc3" name="tocprobabilistic-algorithms" id="tocprobabilistic-algorithms"&gt;Probabilistic algorithms&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Computers are supposed to be predictable and we typically aim for correct programs. There&amp;#8217;s no reason why we shouldn&amp;#8217;t consider aiming for programs which are good enough, though, and indeed many programs which are good enough to be useful are also flawed. Google adverts, for example, analyse the contents of web pages and serve up related links. The algorithm used is secret, clever and quick, but often results in &lt;a href="http://wordaligned.org/articles/mistargeted-ads.html"&gt;semantic blunders&lt;/a&gt; and, on occasion, &lt;a href="http://www.bofh.org.uk/articles/2008/04/15/ads-are-gone"&gt;offensive mistakes&lt;/a&gt;. Few could deny how useful to Google this program has been, though.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a more interesting example of an algorithm which, like a losing clock, is nearly right.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def is_fprime(n):
    """Use Fermat's little theorem to guess if n is prime.
    """
    from random import randrange
    tries = 3
    xs = (randrange(1, n) for _ in range(tries))
    return all((x ** n) % n == x for x in xs)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We won&amp;#8217;t go into the &lt;a href="http://mathworld.wolfram.com/FermatsLittleTheorem.html"&gt;mathematics&lt;/a&gt; here. A quick play with this function looks promising.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; all(is_fprime(n) for n in [2, 3, 5, 7, 11, 13, 17, 19])
True
&amp;gt;&amp;gt;&amp;gt; any(is_fprime(n) for n in [4, 6, 8, 9, 10, 12, 14, 15])
False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In fact, if we give it a real work-out on some large numbers, it does well. I used it to guess which of the numbers between 100000 and 102000 were prime, comparing the answer with the correct result (the code is at the end of this article). It had a better than 99% success rate (in clock terms, it lost around 8 minutes a day) and increasing &lt;code&gt;tries&lt;/code&gt; will boost its performance.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc4" name="tocfixing-isfprime" id="tocfixing-isfprime"&gt;Fixing is_fprime&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The better &lt;code&gt;is_fprime&lt;/code&gt; performs, the less likely we are to spot that it&amp;#8217;s wrong. What&amp;#8217;s worse, though, is that &lt;em&gt;it cannot be fixed&lt;/em&gt; by simple tweaking. However high we set &lt;code&gt;tries&lt;/code&gt; we won&amp;#8217;t have a correct function. We could even take the random probing out of the function and shove every single value of &lt;code&gt;x&lt;/code&gt; in the range 1 to n into the predicate:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def exhaustive_is_fprime(n):
    return all((x ** n) % n == x for x in range(1, n))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Exhaustive_is_fprime&lt;/code&gt; is expensive to run and will (very) occasionally return &lt;code&gt;True&lt;/code&gt; for a composite number&lt;a id="fn2link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;. If you want to know more, &lt;a href="http://www.google.com/search?q=carmichael+numbers"&gt;search for Carmichael numbers&lt;/a&gt;. 
&lt;/p&gt;
&lt;p&gt;The point I&amp;#8217;m making is that code which is almost right can be dangerous. We are tempted to fix it by adjusting the existing implementation, even if, as in this case, a complete overhaul is required. By contrast, we all know what needs doing with code which is plainly wrong.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc5" name="tocdefensive-programming" id="tocdefensive-programming"&gt;Defensive programming&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We&amp;#8217;ve all seen nervous functions which go beyond their stated interface in an attempt to protect themselves from careless users.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;/**
 * Return the maximum value found in the input array.
 * Pre-condition: the input array must not be empty.
 */
int nervy_maximum_value(int const * items, size_t count)
{
    int M = -INT_MAX;
    
    if (items == NULL || count == 0)
    {
        return M;
    }
    for ( ; count-- != 0; ++items)
    {
        if (*items &amp;gt; M)
        {
            M = *items;
        }
    }
    return M;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;What&amp;#8217;s really wanted is both simpler and easier for clients to code against.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;int maximum_value(int const * items, size_t count)
{
    int const * const end = items + count;
    int M = *items++;
    
    for ( ; items != end; ++items)
    {
        if (*items &amp;gt; M)
        {
            M = *items;
        }
    }
    return M;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Did you spot the subtle bug in &lt;code&gt;nervy_maximum_value&lt;/code&gt;? It uses &lt;code&gt;-INT_MAX&lt;/code&gt; instead of &lt;code&gt;INT_MIN&lt;/code&gt; which will cause trouble if clients code against this undocumented behaviour; if &lt;code&gt;nervy_maximum_value&lt;/code&gt; is subsequently fixed, this client code back-fires.
&lt;/p&gt;
&lt;p&gt;Note that I&amp;#8217;m not against the use of assertions to check pre-conditions, and a simple &lt;code&gt;assert(items != NULL &amp;amp;&amp;amp; count != 0)&lt;/code&gt; works well in &lt;code&gt;maximum_value&lt;/code&gt;; it&amp;#8217;s writing code which swallows these failed pre-conditions I consider wrong.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc6" name="tocdefect-halflife" id="tocdefect-halflife"&gt;Defect halflife&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The occurrence of defects in complex software systems can be modelled in the same way as radioactive decay. I haven&amp;#8217;t studied this theory and my physics is rusty&lt;a id="fn3link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn3"&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;, but the basic idea is that the population of bugs in some software is rather like a population of radioactive particles. Any given bug fires (any given particle decays) at random, so we can&amp;#8217;t predict when this event will happen, but it is equally likely to fire at any particular time. This gives each defect an average lifetime: a small lifetime for howling defects, such as dereferencing NULL pointers, and a longer one for more subtle problems, such as accumulated rounding errors. Assuming we fix a bug once it occurs, the population of defects decays exponentially, and we get the classic tailing-off curve.
&lt;/p&gt;
&lt;img src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Exponential+Defect+Decay
&amp;amp;chs=500x200
&amp;amp;chxt=x,y
&amp;amp;chxl=0:||Time|1:||Bugs
&amp;amp;chd=t:95.0,70.3,52.1,38.6,28.6,21.1,15.7,11.6,8.61,6.38
&amp;amp;chco=ff0000
&amp;amp;chm=B,dddddd,0,0,0
&amp;amp;chls=3,1,0" alt="Classic exponential decay curve"/&gt;

&lt;p&gt;&lt;span /&gt;Anyone who has ever tried to release a software product knows how it feels to slide down the slope of this curve. We system test, find bugs, fix them, repeat. At the start it can be exhilarating as bugs with short half-lives fall out and get squashed, but the end game is demoralising as defects get reported which then cannot be reproduced, and we find ourselves clawing out progress. When we eventually draw the line and ship the product we do so suspecting the worst problems are yet to be found. To put it more succinctly&lt;a id="fn4link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn4"&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Ship happens!
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;A combination of techniques can help us escape this depressing picture. The most obvious one would be to avoid it: rather than aim for &amp;#8220;big-bang&amp;#8221; releases every few years, we can move towards continual and incremental delivery. A modular, decoupled architecture helps. So does insistence on unit testing. Rather than shake the system and sweep up the bugs which fall off we should develop a suite of automated tests which actively seek the various paths through the code, and exercise edge cases. Within the code-base, as already mentioned, &lt;span /&gt;defensive programming can cause defects to become entrenched. Instead, we should adopt a more confident style, where code fails hard and fast.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc7" name="tochow-did-that-code-ever-work" id="tochow-did-that-code-ever-work"&gt;How did that code ever work?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Have you ever fixed a defect and wondered how the code ever even appeared to work before your fix? It&amp;#8217;s an important question and one which requires investigation. Perhaps the bug you&amp;#8217;ve fixed is compensated for by defensive programming elsewhere. Or perhaps there are vast routes through the code which have yet to be exercised.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc8" name="tocconclusions" id="tocconclusions"&gt;Conclusions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/images/stopped-clock.gif" alt="Stopped clock"/&gt;
   &lt;img src="http://wordaligned.org/images/slow-clock.gif" alt="Slow clock"/&gt;
   &lt;img src="http://wordaligned.org/images/fast-clock.gif" alt="Fast clock"/&gt;
&lt;/p&gt;
&lt;p&gt;None of these clocks is much good. The first has stopped, the second loses a second every minute, the third gains a second every minute. At least it&amp;#8217;s easy to see the problem with the first: we won&amp;#8217;t be tempted to patch it.
&lt;/p&gt;
&lt;p&gt;We should never expect our code to work first time and we should be suspicious if it appears to do so. Defensive programming seems to mean different things to different people. If I&amp;#8217;ve misused the term here, I&amp;#8217;m sorry. Our best defence is to assume code is broken until we&amp;#8217;ve tested it, to assume it will break in future if our tests are not automated, and to fail hard and fast when we detect errors.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc9" name="tocsource-code" id="tocsource-code"&gt;Source code&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import math
from itertools import islice, count
from random import randrange

def primes(lo, hi):
    '''Return the list of primes in the range [lo, hi).
    
    &amp;gt;&amp;gt;&amp;gt; primes(0, 19)
    [2, 3, 5, 7, 11, 13, 17]
    &amp;gt;&amp;gt;&amp;gt; primes(5, 10)
    [5, 7]
    '''
    sqrt_hi = int(math.sqrt(hi))
    sieve = range(hi)
    zeros = [0] * hi
    sieve[1] = 0
    for i in islice(count(2), sqrt_hi):
        if sieve[i] != 0:
            remove = slice(i * i, hi, i)
            sieve[remove] = zeros[remove]
    return [p for p in sieve[lo:] if p != 0]

def is_fprime(n, tries=3):
    '''Use Fermat little theorem to guess if n is prime.
    '''
    xs = (randrange(1, n) for _ in range(tries))
    return all((x ** n) % n == x for x in xs)

def fprimes(lo, hi, tries=10):
    '''Alternative implementation of primes.
    '''
    return filter(is_fprime, range(lo, hi))

if __name__ == '__main__':
    import doctest
    doctest.testmod()
    lo, hi = 100000, 102000
    primes_set = set(primes(lo, hi))
    fprimes_set = set(fprimes(lo, hi))
    print "Range [%r, %r)" % (lo, hi)
    print "Actual number of primes", len(primes_set)
    print "Number of fprimes", len(fprimes_set)
    print "Primes missed", primes_set - fprimes_set
    print "False fprimes", fprimes_set - primes_set

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Running this program produced output:
&lt;/p&gt;
&lt;pre&gt;
Range [100000, 102000)
Actual number of primes 174
Number of fprimes 175
Primes missed set([])
False fprimes set([101101])
&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn1link"&gt;[1]&lt;/a&gt; In the first version of this article I wrote that an attempt to allocate 4294967295 bytes would cause the program to crash, which isn&amp;#8217;t quite right. &lt;code&gt;Malloc&lt;/code&gt; returns NULL in the event of failure; standard C++ operator new behaviour is to throw a &lt;code&gt;bad_alloc&lt;/code&gt; exception. My thanks to R Samuel Klatchko for the &lt;a href="http://www.haloscan.com/comments/wordaligned/stop_the_clock_squash_the_bug/#16928"&gt;correction&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn2link"&gt;[2]&lt;/a&gt;
   &lt;a href="http://mitpress.mit.edu/sicp"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt; discusses Carmichael numbers in a &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#call_footnote_Temp_80"&gt;footnote&lt;/a&gt;
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Numbers that fool the Fermat test are called &lt;em&gt;Carmichael numbers&lt;/em&gt;, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a &amp;#8220;correct&amp;#8221; algorithm. Considering an algorithm to be inadequate for the first reason but not for the second illustrates the difference between mathematics and engineering.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;a id="fn3" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn3link"&gt;[3]&lt;/a&gt;
   Being lazy and online I thought I&amp;#8217;d search for a nice radioactive decay graphic rather than draw my own. I found a real gem on the &lt;a href="http://www.colorado.edu/physics/2000/isotopes/radioactive_decay3.html"&gt;University of Colarado site&lt;/a&gt;, where Kyla and Bob discuss radioactive decay.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;img src="http://www.colorado.edu/physics/2000/images/kyla-set/kyla3.jpg" alt="Kyla" style="float:left;"/&gt;&lt;/p&gt;&lt;p&gt;Hmmm&amp;#8230;so a lot of decays happen really fast when there are lots of atoms, and then things slow down when there aren&amp;#8217;t so many. The halflife is always the same, but the &lt;i&gt;half&lt;/i&gt; gets smaller and smaller.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://www.colorado.edu/physics/2000/images/bob-set/bob2.jpg" alt="Bob" style="float:left;"/&gt;&lt;/p&gt;&lt;p&gt;That&amp;#8217;s exactly right.  Here&amp;#8217;s another applet that illustrates radioactive decay in action.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="http://www.colorado.edu/physics/2000/isotopes/radioactive_decay3.html"&gt;Visit the site&lt;/a&gt; to play with the applet Bob mentions. You&amp;#8217;ll find more Kyla and Bob pictures there too.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn4" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn4link"&gt;[4]&lt;/a&gt;
   I&amp;#8217;m unable to provide a definitive attribution for the &amp;#8220;Ship happens!&amp;#8221; quotation. I first heard it from &lt;a href="http://erdani.org"&gt;Andrei Alexandrescu&lt;/a&gt; at an &lt;a href="http://accu.org/index.php/conferences"&gt;ACCU conference&lt;/a&gt;, who in turn thinks he got it from Erich Gamma. I haven&amp;#8217;t managed to contact Erich Gamma. Matthew B. Doar &lt;a href="http://www.haloscan.com/comments/wordaligned/stop_the_clock_squash_the_bug/#17002"&gt;reports&lt;/a&gt; using the term back in 2002, and it appears as a &lt;a href="http://www.oreilly.com/catalog/practicalde/toc.html"&gt;section heading&lt;/a&gt; in his book &lt;a href="http://www.oreilly.com/catalog/practicalde"&gt;&amp;#8220;Practical Development Environments&amp;#8221;&lt;/a&gt;.
&lt;/p&gt;</description>
<dc:date>2008-04-16</dc:date>
<guid>http://wordaligned.org/articles/stop-the-clock-squash-the-bug</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/stop-the-clock-squash-the-bug</link>
<category>Puzzles</category>
</item>

<item>
<title>Drawing Chessboards</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocthe-python-imaging-library" name="toc0" id="toc0"&gt;The Python Imaging Library&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocimagemagick" name="toc1" id="toc1"&gt;ImageMagick&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocgoogle-chart-api" name="toc2" id="toc2"&gt;Google Chart API&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocascii-text" name="toc3" id="toc3"&gt;ASCII Text&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocunicode-block-elements" name="toc4" id="toc4"&gt;Unicode Block Elements&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocand-more" name="toc5" id="toc5"&gt;And more&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocwhy" name="toc6" id="toc6"&gt;Why?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocteaser" name="toc7" id="toc7"&gt;Teaser&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#tocthanks" name="toc8" id="toc8"&gt;Thanks&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;I wanted a picture of a chessboard. Rather than boot up some drawing software and cut and paste black and white squares I decided to write a program to create the picture.
&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;d like to know &lt;strong&gt;why&lt;/strong&gt; anyone would ever create work for themselves in this way, skip to the end of this article, where you&amp;#8217;ll find justification and a more challenging &lt;a href="http://wordaligned.org/articles/drawing-chessboards.html#why"&gt;follow-on problem&lt;/a&gt;. Otherwise, please read on from top to bottom in the usual way.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc0" name="tocthe-python-imaging-library" id="tocthe-python-imaging-library"&gt;The Python Imaging Library&lt;/a&gt;&lt;/h3&gt;
&lt;img style="border-style:double;" src="http://wordaligned.org/images/chessboard-pil.png" alt="Chessboard created by PIL"/&gt;

&lt;p&gt;Fredrik Lundh&amp;#8217;s &lt;a href="http://effbot.org/imagingbook/pil-index.htm"&gt;Python Imaging Library&lt;/a&gt; (commonly known as &lt;a href="http://effbot.org/imagingbook/pil-index.htm"&gt;PIL&lt;/a&gt;) must surely rank as one of the most popular Python libraries which doesn&amp;#8217;t come as standard&lt;sup&gt;&lt;a id="fn1link" href="http://wordaligned.org/articles/drawing-chessboards.html#fn1"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. It&amp;#8217;s a fabulous tool which I&amp;#8217;ve used to create the graphic above (though note that the double border around this graphic and subsequent ones is applied by a CSS style property). Here&amp;#8217;s how.
   &lt;span id="continue-reading"/&gt;
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;PIL chessboard&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def draw_chessboard(n=8, pixel_width=200):
    "Draw an n x n chessboard using PIL."
    import Image, ImageDraw
    from itertools import cycle
    def sq_start(i):
        "Return the x/y start coord of the square at column/row i."
        return i * pixel_width / n
    
    def square(i, j):
        "Return the square corners, suitable for use in PIL drawings" 
        return map(sq_start, [i, j, i + 1, j + 1])
    
    image = Image.new("L", (pixel_width, pixel_width))
    draw_square = ImageDraw.Draw(image).rectangle
    squares = (square(i, j)
               for i_start, j in zip(cycle((0, 1)), range(n))
               for i in range(i_start, n, 2))
    for sq in squares:
        draw_square(sq, fill='white')
    image.save("chessboard-pil.png")

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     We don&amp;#8217;t draw any black squares, instead relying on the default image background being black.
 &lt;/li&gt;

 &lt;li&gt;
     The &amp;#8220;L&amp;#8221; image type (Luminance?) specifies a greyscale image.
 &lt;/li&gt;

 &lt;li&gt;
     PIL adopts the usual raster graphics convention, of the origin being in the top-left corner.
 &lt;/li&gt;

 &lt;li&gt;
     As we progress &lt;strong&gt;down&lt;/strong&gt; the board row by row, the first white square alternates between being the first and second square of each row. &lt;code&gt;Itertools.cycle((0, 1))&lt;/code&gt; achieves this nicely. 
 &lt;/li&gt;

 &lt;li&gt;
     A regular 8 x 8 chessboard will, then, have a black square at the bottom left, which is the usual convention. For odd values of n the bottom-left square would be white.
 &lt;/li&gt;

 &lt;li&gt;
     There may be rounding problems with this code if the supplied pixel width isn&amp;#8217;t an integral multiple of &lt;code&gt;n&lt;/code&gt;. It&amp;#8217;s probably better to guarantee the image size, rather than round down the board size.
 &lt;/li&gt;

 &lt;li&gt;
     It would be better to parametrise the output file name, or even return the created image to clients. For now, we&amp;#8217;ll just save to a fixed-name PNG.
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc1" name="tocimagemagick" id="tocimagemagick"&gt;ImageMagick&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;PIL is a general purpose image processing library and it takes a little head-scratching and maths before we can even create something as simple as a chessboard. &lt;a href="http://www.imagemagick.org/script/index.php"&gt;ImageMagick&lt;/a&gt; provides tools to perform a similar job from the command-line, making the chessboard a one-liner.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;ImageMagick chessboard&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ N=8
$ PIXEL_WIDTH=200
$ convert -size $((N*15))x$((N*15)) pattern:checkerboard \
  -monochrome -resize $PIXEL_WIDTH chessboard-magick.png

&lt;/pre&gt;

&lt;/div&gt;

&lt;img style="border-style:double;float:right;margin-left:4px;" src="http://wordaligned.org/images/chessboard-magick.png" alt="Chessboard created by ImageMagick"/&gt;

&lt;p&gt;Here, the checkerboard pattern is an ImageMagick built-in which, inspecting its output, happens to generate 15x15 squares (hence the 15&amp;#8217;s in the script above). The &lt;code&gt;-monochrome&lt;/code&gt; filter renders the pattern in black and white, rather than its native light- on dark-grey. The &lt;code&gt;-size&lt;/code&gt; and &lt;code&gt;-resize&lt;/code&gt; parameters should need no further explanation. The ((double parentheses)) perform Bash shell arithmetic.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.imagemagick.org/script/index.php"&gt;ImageMagick&lt;/a&gt; masquerades as a shell tool but really it&amp;#8217;s a powerful and fully featured programmer&amp;#8217;s imaging tool &amp;#8212; a bit like a command-line version of &lt;a href="http://www.gimp.org"&gt;Gimp&lt;/a&gt;&lt;a id="fn2link" href="http://wordaligned.org/articles/drawing-chessboards#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;. Although well documented, my gut reaction is that it pushes the command-line interface too far. For more advanced image mangling, you&amp;#8217;ll probably need a program to generate the one-liner needed to drive &lt;code&gt;convert&lt;/code&gt;. Despite this reservation, it does the simple things simply, and it can do complex things too. Recommended!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc2" name="tocgoogle-chart-api" id="tocgoogle-chart-api"&gt;Google Chart API&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For a bit of fun, we can persuade Google to render the chessboard for us &amp;#8212; in this case as a scatter plot using a square black markers&lt;a id="fn3link" href="http://wordaligned.org/articles/drawing-chessboards#fn3"&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;. We flip the PIL processing around, drawing black squares on the (default) white background, and using the usual plotting convention which places the origin at the bottom left.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Google chart chessboard&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def chessboard_url(n=8, pixel_width=200):
    "Returns the URL of a chessboard graphic."
    def sq_midpt(i):
        "Return the x/y midpt of a square in column/row i."
        # For text encoding, the graphic's logical width is 100
        return (0.5 + i) * 100. / n
    
    xys = [(sq_midpt(i), sq_midpt(j))
           for i_start, j in zip(cycle((0, 1)), range(n))
           for i in range(i_start, n, 2)]
    fields = dict(width=pixel_width, sqside=pixel_width/n,
                  xs=",".join("%.02f" % x for x, _ in xys),
                  ys=",".join("%.02f" % y for _, y in xys))
    return (
        "http://chart.apis.google.com/chart?"
        "cht=s&amp;amp;"                        # Draw a scatter graph
        "chd=t:%(xs)s|%(ys)s&amp;amp;"          # using text encoding and
        "chm=s,000000,1,2.0,%(sqside)r&amp;amp;"# square black markers
        "chs=%(width)rx%(width)r"       # at this size.
        ) % fields

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that we plot our chart on a logical 100 x 100 rectangle, the coordinate space mandated by the encoding we&amp;#8217;ve chosen, then resize it to the physical dimensions supplied by the client.
&lt;/p&gt;
&lt;p&gt;This function actually returns the URL of a PNG which the &lt;a href="http://code.google.com/apis/chart/"&gt;Google chart API&lt;/a&gt; serves up. Paste this URL into your browser address bar to see the graphic, or curl it to a local file.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://chart.apis.google.com/chart?cht=s&amp;amp;chd=t:6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75|6.25,6.25,6.25,6.25,18.75,18.75,18.75,18.75,31.25,31.25,31.25,31.25,43.75,43.75,43.75,43.75,56.25,56.25,56.25,56.25,68.75,68.75,68.75,68.75,81.25,81.25,81.25,81.25,93.75,93.75,93.75,93.75&amp;amp;chm=s,000000,1,2.0,25.0&amp;amp;chs=200x200"&gt;http://chart.apis.google.com/chart?cht=s&amp;amp;chd=t:6.25,31.25&amp;#8230;&amp;amp;chs=200x200&lt;/a&gt;
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ url=`python chessboard_url.py`
$ curl $url &amp;gt; chessboard.png

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We could embed the image into HTML using the IMG element, which is how I&amp;#8217;ve embedded the image which you should see below.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from cgi import escape
&amp;gt;&amp;gt;&amp;gt; img = '&amp;lt;img src="%s" alt="chessboard graphic"/&amp;gt;'
&amp;gt;&amp;gt;&amp;gt; img % escape(chessboard_url())

&lt;/pre&gt;

&lt;/div&gt;

&lt;img src="http://chart.apis.google.com/chart?cht=s&amp;amp;chd=t:6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75,6.25,31.25,56.25,81.25,18.75,43.75,68.75,93.75|6.25,6.25,6.25,6.25,18.75,18.75,18.75,18.75,31.25,31.25,31.25,31.25,43.75,43.75,43.75,43.75,56.25,56.25,56.25,56.25,68.75,68.75,68.75,68.75,81.25,81.25,81.25,81.25,93.75,93.75,93.75,93.75&amp;amp;chm=s,000000,1,2.0,25.0&amp;amp;chs=200x200" alt="Chessboard chart" style="float:right;border-style:double;margin-left:4px;"/&gt;

&lt;p&gt;As you can see, we have plenty of options, but unfortunately the image itself isn&amp;#8217;t suitable. You can&amp;#8217;t get rid of the axes &amp;#8212; or at least, I haven&amp;#8217;t found a way to &amp;#8212; and the rendered chart has some padding to the top and the right. And worse, we&amp;#8217;re pretty much at the end of the line for this hack: if we wanted to do something more interesting, such as place pieces on the board, we&amp;#8217;re out of luck. 
&lt;/p&gt;
&lt;p&gt;Of course this isn&amp;#8217;t a flaw in the &lt;a href="http://code.google.com/apis/chart/"&gt;Google Chart API&lt;/a&gt;: we&amp;#8217;ve actually asked it to draw a scatter plot of the centres of black squares on a chessboard, using square black markers, a job it&amp;#8217;s done well enough. Some examples showing the proper use of Google charts can be found in an &lt;a href="http://wordaligned.org/articles/the-maximum-subsequence-problem.html"&gt;article I wrote about maximum sum subsequences&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc3" name="tocascii-text" id="tocascii-text"&gt;ASCII Text&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The chart URL might be considered a text encoding of the image; the actual graphic is returned by a server. There are other, more direct, textual representations.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;ASCII art chessboard&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def outer_join(sep, ss):
    """Like string.join, but encloses the result with outer separators.
    
    Example:
    &amp;gt;&amp;gt;&amp;gt; outer_join('|', ['1', '2', '3'])
    '|1|2|3|'
    """
    return "%s%s%s" % (sep, sep.join(ss), sep)
    
def ascii_chessboard(n=8):
    """Draws an ASCII art chessboard.
    
    Returns a string representation of an n x n board.
    """
    from itertools import islice, cycle
    divider = outer_join("+", "-" * n) + "\n"
    row0 = outer_join("|", islice(cycle(" B"), n)) + "\n"
    row1 = outer_join("|", islice(cycle("B "), n)) + "\n"
    return outer_join(divider, islice(cycle([row0, row1]), n))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I suspect this code was easier for me to write than it is for you to read! It treats the chessboard as a sequence of alternating rows of alternating squares, which are then joined together for output.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; print ascii_chessboard(8)
+-+-+-+-+-+-+-+-+
| |B| |B| |B| |B|
+-+-+-+-+-+-+-+-+
|B| |B| |B| |B| |
+-+-+-+-+-+-+-+-+
| |B| |B| |B| |B|
+-+-+-+-+-+-+-+-+
|B| |B| |B| |B| |
+-+-+-+-+-+-+-+-+
| |B| |B| |B| |B|
+-+-+-+-+-+-+-+-+
|B| |B| |B| |B| |
+-+-+-+-+-+-+-+-+
| |B| |B| |B| |B|
+-+-+-+-+-+-+-+-+
|B| |B| |B| |B| |
+-+-+-+-+-+-+-+-+

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Not pretty, but such graphics may be useful in source code, which is typically viewed in a plain-text editor, and where ASCII art provides a way of embedding pictures right where they&amp;#8217;re needed. 
&lt;/p&gt;
&lt;p&gt;On which point: if you&amp;#8217;re working through &amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221; you may like to know the book is &lt;a href="http://www.neilvandyke.org/sicp-texi/"&gt;available in Texinfo format&lt;/a&gt;, with the pictures all rendered in ASCII art. So you can split your editor window and run the code on one side, while browsing the book on the other. Here&amp;#8217;s one of the figures:
&lt;/p&gt;
&lt;pre&gt;
*Figure 4.6:* The `or' combination of two queries is produced by
operating on the stream of frames in parallel and merging the
results.
    
            +---------------------------+
            |          (or A B)         |
            |    +---+                  |
 input      | +-&amp;gt;| A |------------+     |  output
 stream of  | |  +---+            V     |  stream of
 frames     | |    ^          +-------+ |  frames
 -------------*    |          | merge +---------------&amp;gt;
            | |    |          +-------+ |
            | |    |              ^     |
            | |    |   +---+      |     |
            | +-------&amp;gt;| B +------+     |
            |      |   +---+            |
            |      |     ^              |
            |      |     |              |
            |      +--*--+              |
            +---------|-----------------+
                      |
                  data base
&lt;/pre&gt;

&lt;p&gt;Even though I own a copy of the book and the &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;full text is available on-line&lt;/a&gt;, this primitive info version has become my preferred format when actually running the code examples and exercises.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc4" name="tocunicode-block-elements" id="tocunicode-block-elements"&gt;Unicode Block Elements&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Most programming languages may be &lt;a href="http://wordaligned.org/articles/a-yen-for-more-symbols.html"&gt;stuck in ASCII&lt;/a&gt;, but we needn&amp;#8217;t restict ourselves in this way. I found some block elements in the &lt;a href="http://www.unicode.org/charts/symbols.html"&gt;Geometrical Symbols&lt;/a&gt; section of the Unicode code charts (&lt;a href="http://www.unicode.org/charts/PDF/U2580.pdf"&gt;Unicode Block Elements (PDF)&lt;/a&gt;). Here&amp;#8217;s a pre-rendered block of text composed of the light and dark shade block characters, U+2591 LIGHT SHADE and U+2593 DARK SHADE.
&lt;/p&gt;
&lt;pre&gt;
&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;
&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;
&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;
&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;
&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;
&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;
&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;
&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;&amp;#x2593;&amp;#x2591;
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc5" name="tocand-more" id="tocand-more"&gt;And more&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I can think of plenty of other ways to draw a chessboard. My favourite &lt;a href="http://wordaligned.org/articles/drawing-software-design.htmls"&gt;drawing&lt;/a&gt; environments are the &lt;a href="http://blogoscoped.com/archive/2008-02-11-n78.html"&gt;pencil and paper&lt;/a&gt;, and the pen and whiteboard; combine the former with a scanner and the latter with a digital camera and you&amp;#8217;ve got an easy route to an electronic version of your design.
&lt;/p&gt;
&lt;p&gt;For an HTML document I suspect &lt;a href="http://www.w3.org/Graphics/SVG/"&gt;SVG&lt;/a&gt; would be a good choice, but I don&amp;#8217;t know enough about SVG to state this with confidence. I bet you could go a long way with &lt;a href="http://www.w3.org/Style/CSS/"&gt;CSS&lt;/a&gt; too. &lt;a href="http://en.wikipedia.org/wiki/Chessboard"&gt;Wikipedia&amp;#8217;s chess board&lt;/a&gt; is a table built on top of two small images, a light and a dark square, which I guess saves on bandwidth.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc6" name="tocwhy" id="tocwhy"&gt;Why?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Why ever bother programming when all we want is a simple graphic?
&lt;/p&gt;
&lt;p&gt;Well, for one thing, there&amp;#8217;s not &lt;strong&gt;that&lt;/strong&gt; much programming. The actual work of pushing pixels around is done by &lt;a href="http://code.google.com/apis/chart/"&gt;Google&lt;/a&gt;, or &lt;a href="http://effbot.org/imagingbook/pil-index.htm"&gt;PIL&lt;/a&gt;, or &lt;a href="http://www.imagemagick.org/script/index.php"&gt;ImageMagick&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Once we&amp;#8217;ve got a program written, it should be easy to adapt it. We&amp;#8217;ve already put in hooks to specify the number of squares and the image dimensions. It&amp;#8217;s equally easy to, for example, write out a JPEG rather than a PNG, or use different colours.
&lt;/p&gt;
&lt;p&gt;A programmatic solution is dynamic. Google&amp;#8217;s chart API generates pictures on the fly, based on data points, ranges etc. which clients choose as and when. It&amp;#8217;s rather  like lazy-evaluation: pre-rendering all possibilities isn&amp;#8217;t just expensive, it&amp;#8217;s out of the question.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc7" name="tocteaser" id="tocteaser"&gt;Teaser&lt;/a&gt;&lt;/h3&gt;
&lt;img src="http://tbn0.google.com/images?q=tbn:AmRSkxMo-1W5iM:http://web.usna.navy.mil/~wdj/images_chess/chess011.gif" alt="Lurid chessboard" style="float:right;margin-left:4px;"/&gt;

&lt;p&gt;That&amp;#8217;s quite enough pixels and characters for now, so this article will have to appear in two parts. If I&amp;#8217;ve still not convinced you of the merits of creating images programmatically, please consider the following puzzle.
&lt;/p&gt;
&lt;p&gt;&lt;span /&gt;How would you draw a position reached in a game of chess, showing both the board and the pieces?
&lt;/p&gt;
&lt;p&gt;And if I &lt;strong&gt;have&lt;/strong&gt; convinced you, this exercise makes for a good workout.
&lt;/p&gt;
&lt;p&gt;Some Q&amp;amp;A&amp;#8217;s.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     &lt;strong&gt;Q&lt;/strong&gt;: What position, exactly?
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;A&lt;/strong&gt;: Any!
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;Q&lt;/strong&gt;: How will the position be described?
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;A&lt;/strong&gt;: Your choice &amp;#8212; it&amp;#8217;s an interesting part of the puzzle.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A great starting point would be to solve the puzzle using an ASCII art representation.
&lt;/p&gt;
&lt;p&gt;You can find my solution in &lt;a href="http://wordaligned.org/articles/drawing-chess-positions.html"&gt;this follow-up article&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/drawing-chessboards#toc8" name="tocthanks" id="tocthanks"&gt;Thanks&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Thanks to &lt;a href="http://gedmin.as"&gt;Marius Gedminas&lt;/a&gt; and Johannes Hoff for their help bug-fixing this article.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/drawing-chessboards#fn1link"&gt;[1]&lt;/a&gt;
   I&amp;#8217;m confused about where exactly PIL belongs; the official homepage seems to be on the PythonWare website (&lt;a href="http://www.pythonware.com/library/pil/handbook/"&gt;http://www.pythonware.com/library/pil/handbook/&lt;/a&gt;), but I usually head for the Effbot site, &lt;a href="http://effbot.org/imagingbook/"&gt;http://effbot.org/imagingbook/&lt;/a&gt;. I think the sites mirror the same information, so it boils down to whether you prefer a blue or green theme, and how off-putting you find all the ads-by-google.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/drawing-chessboards#fn2link"&gt;[2]&lt;/a&gt;
   Actually, you can use &lt;a href="http://www.gimp.org/tutorials/Basic_Batch/"&gt;Gimp from the command-line&lt;/a&gt;, and it comes with some tools for creating and editing batch files, and indeed for creating a personal suite of image processing scripts. I&amp;#8217;ve never used &lt;a href="http://www.gimp.org"&gt;Gimp&lt;/a&gt; in this way, so I can&amp;#8217;t say much more about this.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn3" href="http://wordaligned.org/articles/drawing-chessboards#fn3link"&gt;[3]&lt;/a&gt;
   In theory you could use the Google Chart API to render any image in a pointillist manner: just plot enough pixels in the right places.
&lt;/p&gt;</description>
<dc:date>2008-03-18</dc:date>
<guid>http://wordaligned.org/articles/drawing-chessboards</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/drawing-chessboards</link>
<category>Puzzles</category>
</item>

</channel>
</rss>
