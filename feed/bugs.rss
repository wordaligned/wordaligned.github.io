<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Your computer might be at risk</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tochard-drive-failure" name="toc0" id="toc0"&gt;Hard drive failure&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocrecovery-strategy" name="toc1" id="toc1"&gt;Recovery strategy&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocfree-file-recovery-software" name="toc2" id="toc2"&gt;&amp;#8220;Free&amp;#8221; file recovery software&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocrestoring-the-machine" name="toc3" id="toc3"&gt;Restoring the machine&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocnetgear-wireless-pci-card" name="toc4" id="toc4"&gt;Netgear Wireless PCI card&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocflash-install-problems" name="toc5" id="toc5"&gt;Flash install problems&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocthe-antivirus-racket" name="toc6" id="toc6"&gt;The antivirus racket&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocyou-idiot" name="toc7" id="toc7"&gt;You idiot!&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocalternatives" name="toc8" id="toc8"&gt;Alternatives&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocthe-future-of-operating-systems" name="toc9" id="toc9"&gt;The future of operating systems&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#tocback-in-the-present" name="toc10" id="toc10"&gt;Back in the present&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;I dislike all three major OS &amp;#8212; Windows, Mac, Linux.
&lt;/p&gt;
&lt;p&gt;&amp;#8212; &lt;a href="http://www.stifflog.com/2006/10/16/stiff-asks-great-programmers-answer/"&gt;Peter Norvig, Stifflog interview&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Although I write software for a living and write about writing software in my spare time, I don&amp;#8217;t like computers much. I&amp;#8217;m not afraid of them. I&amp;#8217;m not completely incompetent at operating them. They just don&amp;#8217;t behave the way I&amp;#8217;d like. Here&amp;#8217;s an example.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc0" name="tochard-drive-failure" id="tochard-drive-failure"&gt;Hard drive failure&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The family computer wouldn&amp;#8217;t boot. Instead it came up with white text on a blue screen listing register contents in hex. A hardware check confirmed my fears: &lt;a href="http://www.google.com/search?q=error+code+7"&gt;Error Code 7&lt;/a&gt;, hard drive failure.
&lt;/p&gt;
&lt;p&gt;This was irritating but not so very surprising: it&amp;#8217;s an aging computer which had been running Windows XP progressively more and more slowly, and which was almost exclusively used by the kids for playing games on. On more than one occasion it had frozen and needed a hard reboot. What&amp;#8217;s more saddening but also not so very surprising is that our domestic backup policy isn&amp;#8217;t as good as it should be. There were some files on the dead drive we wanted to recover.
&lt;/p&gt;
&lt;p&gt;And even though Gail and I each have our own laptops, it soon became apparent how important a part of family life the defunct desktop was. Our children enjoy playing computer games. They like to watch &lt;a href="http://www.bbc.co.uk/merlin/"&gt;Merlin on iPlayer&lt;/a&gt;. We needed their machine back.
&lt;/p&gt;
&lt;p&gt;Fortunately I had a laptop and internet access. After hunting through shelves and drawers I reckoned I could get my hands on most of the original install media. It didn&amp;#8217;t take long to come up with a recovery strategy.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc1" name="tocrecovery-strategy" id="tocrecovery-strategy"&gt;Recovery strategy&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.getdigital.de/products/Any_Key"&gt;&lt;img style="float:right;" src="http://www.getdigital.de/images/produkte/t2/t2_anykey.jpg" alt="Any Key"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The plan was:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     disconnect the dead drive
 &lt;/li&gt;

 &lt;li&gt;
     connect a new drive
 &lt;/li&gt;

 &lt;li&gt;
     install Windows on the new drive
 &lt;/li&gt;

 &lt;li&gt;
     reconnect the dead drive
 &lt;/li&gt;

 &lt;li&gt;
     boot Windows from the new drive
 &lt;/li&gt;

 &lt;li&gt;
     try and recover files from the dead drive
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This article is &lt;strong&gt;not&lt;/strong&gt; meant to be a tutorial on recovering from hard drive failures &amp;#8212; if that&amp;#8217;s what you&amp;#8217;re after, the sanest source of information I found was this &lt;a href="http://forums.techarena.in/windows-xp-support/730578.htm#post2775674"&gt;forum post by Patrick Keenan&lt;/a&gt; &amp;#8212; but I do want to stress here that when you get to stage 5 you should &lt;strong&gt;not&lt;/strong&gt; allow windows to run a disk check on the dead drive, which is what it defaults to doing. 
&lt;/p&gt;
&lt;p&gt;Be ready to skip the check by pressing the Any Key!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc2" name="tocfree-file-recovery-software" id="tocfree-file-recovery-software"&gt;&amp;#8220;Free&amp;#8221; file recovery software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first few stages of this plan were tedious but straightforward. I nursed the machine through the Windows XP installation onto a new drive. Since the desktop was designed to accommodate a second hard drive, slotting in the dead drive alongside the new one was idiot-proof. One minor wrinkle: the system didn&amp;#8217;t automatically register the new drive. I had to press F12 to interrupt the boot sequence, enter the BIOS and explicitly enable the drive. By now, I felt quite comfortable with the BIOS screens: this stuff works!
&lt;/p&gt;
&lt;p&gt;On reboot I skipped the default disk check, as mentioned. My hope was that the physical memory on the dead drive could still be read and that some lower level file reader utility could patch together enough of the file-system for me to recover what I needed. By the way, at this point the PC had no network access. Evidently Windows XP hadn&amp;#8217;t installed a driver for the wireless PCI card. Fortunately the USB ports were functional, so I could download software on the laptop and transfer it to the desktop.
&lt;/p&gt;
&lt;p&gt;I wasn&amp;#8217;t prepared to pay for any file recovery software (yet). The value of the lost files wasn&amp;#8217;t that high, especially if I couldn&amp;#8217;t get them back. Surely I could &lt;a href="http://www.google.com/search?q=free+hard+drive+recovery+software"&gt;find some freeware&lt;/a&gt;? I took a couple of wrong turnings here and ended up feeling rather gullible. The top few search hits led me to software I could download and demo for free, which claimed they could do the job, but which I&amp;#8217;d have to pay to use.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.diskinternals.com/products/ntfs-reader/"&gt;DiskInternals NTFS Reader&lt;/a&gt; turned out to be what I was looking for. I&amp;#8217;m sure there are others. Happily I&amp;#8217;d soon managed to locate and recover the files we wanted, and could disconnect the faulty drive. Phew!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc3" name="tocrestoring-the-machine" id="tocrestoring-the-machine"&gt;Restoring the machine&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Restoring the files was one thing. Next I needed to restore the machine itself to full functionality. The screen resolution wasn&amp;#8217;t right. Screen repaints were jaggy. It couldn&amp;#8217;t access the internet. There was no sound (apart from an annoying system beep). Etc. etc. 
&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s going on here? I&amp;#8217;m running a licensed copy of the world&amp;#8217;s most popular operating system on hardware purchased from the world&amp;#8217;s best known PC dealer, not some bleeding edge Linux distribution. Surely it should just work!
&lt;/p&gt;
&lt;p&gt;Hobbyists may delight in tinkering and fixing computers. Not me. I&amp;#8217;m not  clueless, though, and I did realise that what I needed to do was keep downloading and installing drivers until everything behaved. It would have been nice if the system had been a little more self aware, though. Why couldn&amp;#8217;t it tell me why it wasn&amp;#8217;t working? Why couldn&amp;#8217;t it at least provide a hardware manifest in some standard format?
&lt;/p&gt;
&lt;p&gt;I won&amp;#8217;t bore you with the details of what followed. You don&amp;#8217;t need me to tell you about the repeated reboots, broken download links, quirky installers; like me, you&amp;#8217;ll be immune to the screenfuls of THREATENING LEGAL MUMBO JUMBO YOU HAVE TO AGREE TO. But I do want to highlight a couple of egregious examples of what I&amp;#8217;m talking about.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc4" name="tocnetgear-wireless-pci-card" id="tocnetgear-wireless-pci-card"&gt;Netgear Wireless PCI card&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I had the original install media for the wireless PCI card, and this got the machine connected to the internet. I didn&amp;#8217;t just have to reboot to complete the installation, though, I also needed to physically remove the card and reseat it halfway through the process. Good job the PC chassis was already open. As if all this wasn&amp;#8217;t bad enough, I also had to bypass a grim warning from Windows XP about destabilizing my system. Lovely!
&lt;/p&gt;
&lt;img src="http://wordaligned.org/images/install-netgear-warning.png" alt="Netgear WG311 install warnings"/&gt;

&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/2807550653/" title="alex-rant by Thomas Guest, on Flickr"&gt;&lt;img style="float:right;" src="http://farm4.static.flickr.com/3112/2807550653_43ac2d3d2f_m.jpg" width="202" height="240" alt="alex-rant" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Then I discovered wireless internet access only worked for system administrators, a level of privilege no one should really need to run at. &lt;a href="http://www.velocityreviews.com/forums/t4522-no-limited-account-connectivity-netgear-wg311twg624t.html"&gt;Googling the problem&lt;/a&gt; suggested I was not alone. So I downloaded the latest drivers, uninstalled the original version, reinstalled the new (power off, remove the old card, power on, install software, power off, insert card, power on, finish installing the software) only to find the driver problems still had not been fixed!
&lt;/p&gt;
&lt;p&gt;To work around the problem I had to follow the install procedure for a third time, in this case &lt;strong&gt;not&lt;/strong&gt; clicking through the recommended path, but rather allowing the Windows network connection manager to run the wireless service. Even then I had to stop the Netgear software from auto-starting.
&lt;/p&gt;
&lt;p&gt;Grrrr!!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc5" name="tocflash-install-problems" id="tocflash-install-problems"&gt;Flash install problems&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The kids like playing Adobe Flash games so I installed the Flash browser plugin. Well, I tried. Apparently I&amp;#8217;d run out of disk space.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bugs.adobe.com/jira/browse/FP-907"&gt;&lt;img src="http://wordaligned.org/images/install-flash-bug.png" alt="Install Flash bug"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;An alarming message, considering H:\WINDOWS\system32 was a directory on my brand new, unpartitioned and almost empty 500 GB hard drive! A little more googling revealed that &lt;a href="http://bugs.adobe.com/jira/browse/FP-907"&gt;the Flash installer actually required the presence of a C: drive&lt;/a&gt;. After mounting a USB flash drive and fiddling about with the control panel to remap drive labels, I managed to get Flash plugged in.
&lt;/p&gt;
&lt;p&gt;Unfunnily enough, I recently faced a similar but less tractable issue at work, trying to get the Flash plugin working on a Red Hat Linux box. Why should running Flash require me to upgrade libc!?
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc6" name="tocthe-antivirus-racket" id="tocthe-antivirus-racket"&gt;The antivirus racket&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Checklist:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Hardware happy? &amp;#x2713;
 &lt;/li&gt;

 &lt;li&gt;
     Software happy? &amp;#x2713;
 &lt;/li&gt;

 &lt;li&gt;
     Computer happy? &amp;#x2718;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Despite the clean install of properly licensed software on a new hard drive, &lt;strong&gt;Your computer might be at risk&lt;/strong&gt;. Clicking the balloon to fix the problem directs me to the Microsoft antivirus partners page, where plenty of companies will be happy to help &amp;#8212; at a price, that is.
&lt;/p&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/images/antivirus-balloon.png" alt="Antivirus Balloon"/&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3027199004/" title="antivirus-partners by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm4.static.flickr.com/3283/3027199004_581f3bf8d6_m.jpg" width="240" height="158" alt="antivirus-partners" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This, I think, is the final straw. I&amp;#8217;m no longer willing to play along with this racket. The antivirus software &lt;strong&gt;is itself a virus&lt;/strong&gt;, a virus carried by my reconstructed computer from the moment I installed Windows; and clicking the threatening balloon will only make things worse. In the computer&amp;#8217;s former life, I installed some free antivirus software which turned out to be &lt;span /&gt;free as in free beer, not free as in without cost. It soaked up resources, hammered the hard drive mercilessly, and was forever interrupting me, cajoling and wheedling me to upgrade to the professional edition.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc7" name="tocyou-idiot" id="tocyou-idiot"&gt;You idiot!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As a software professional I should know better. I should know better than run Windows. I should know about security. I should know about backups. I had a lucky escape, and I&amp;#8217;ll admit, I was lazy, but the truth is this kind of thing happens to computer users &amp;#8212; both professional and amateur &amp;#8212; all the time, and many have been burned far worse than me. I think the model of standalone computers with their own hard drives running their own operating system is all wrong, and bolting on an external hard-drive and some backup software doesn&amp;#8217;t make it all right.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc8" name="tocalternatives" id="tocalternatives"&gt;Alternatives&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Right now, I&amp;#8217;m not inspired to go out and buy another computer plus the additional hardware and software required to make the house a secure and safe place for computing. It&amp;#8217;s a home, not a server farm!
&lt;/p&gt;
&lt;p&gt;Yes, if we went the Apple route and purchased hardware and software in beautiful (but expensive!) self-contained packages the driver problems ought to disappear and &lt;a href="http://www.apple.com/macosx/features/timemachine.html"&gt;time machine&lt;/a&gt; would allow me to chase backwards and recover anything and everything. I&amp;#8217;ll admit I&amp;#8217;m tempted, but I have my concerns about vendor lock-in: if being tied to a software application is bad, being tied to a platform is worse. And yes, if we went the Ubuntu route I don&amp;#8217;t think we&amp;#8217;d be troubled by the antivirus protection racket but I suspect I&amp;#8217;d still end up grubbing round for drivers, possibly with even less success, and I&amp;#8217;m sure it wouldn&amp;#8217;t be such a good games platform.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://norvig.com" title="Peter Norvig's homepage"&gt;&lt;img style="float:right;" alt="Picture of Peter Norvig" src="http://pn.smugmug.com/photos/343788298_VRnZs-S.jpg"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;In an &lt;a href="http://www.stifflog.com/2006/10/16/stiff-asks-great-programmers-answer/"&gt;interview on stifflog&lt;/a&gt; a number of well known programmers answer questions about their favourite tools (operating systems, languages, editors etc.) I sympathise with Peter Norvig&amp;#8217;s rather negative answer.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8220;I dislike all three major OS &amp;#8212; Windows, Mac, Linux. I like Python and Lisp. Emacs.&amp;#8221;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Personally, I prefer the model of computing as a service, a service you connect to from a variety of devices in a variety of locations. I don&amp;#8217;t really care where exactly my data is &amp;#8212; I just want (secure) access to it, wherever, whenever. I don&amp;#8217;t want a house full of wires and hard drives. Backup should be transparent to me as a user, and it should be straightforward for service providers to implement: bytes are easy to replicate and transmit, to distribute, and there are economies of scale. (For what it&amp;#8217;s worth, my personal backup strategy, based around &lt;a href="http://diveintomark.org/archives/2008/11/03/the-pursuit-of-happiness"&gt;travelling light&lt;/a&gt;, internet access, version control, cron and rysnc, does what it can to emulate this model, but it certainly isn&amp;#8217;t for everyone.)
&lt;/p&gt;
&lt;p&gt;I don&amp;#8217;t think this a Utopian view and I certainly don&amp;#8217;t claim it&amp;#8217;s original: computing has been gradually moving in this direction for some time now. Perhaps, though, we should refuse to accept the dystopia we&amp;#8217;re currently living with.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc9" name="tocthe-future-of-operating-systems" id="tocthe-future-of-operating-systems"&gt;The future of operating systems&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You&amp;#8217;ll have to look hard for an honest and open insider&amp;#8217;s assessment of the state of Mac and Windows, but the Unix community have always been quick to acknowledge design limitations. In an &lt;a href="http://interviews.slashdot.org/article.pl?sid=04/10/18/1153211&amp;amp;tid=189&amp;amp;tid=156&amp;amp;tid=130&amp;amp;tid=11"&gt;interview on Slashdot, Rob Pike explains&lt;/a&gt; how weak the Unix design has become in the networked world we live in.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The major things we saw wrong with Unix [&amp;#8230;] back around 1985, all stemmed from the appearance of a network. As a stand-alone system, Unix was pretty good. But when you networked Unix machines together, you got a network of stand-alone systems instead of a seamless, integrated networked system. Instead of one big file system, one user community, one secure setup uniting your network of machines, you had a hodgepodge of workarounds to Unix&amp;#8217;s fundamental design decision that each machine is self-sufficient.
&lt;/p&gt;
&lt;p&gt;We really are using a 1970s era operating system well past its sell-by date. We get a lot done, and we have fun, but let&amp;#8217;s face it, the fundamental design of Unix is older than many of the readers of Slashdot, while lots of different, great ideas about computing and networks have been developed in the last 30 years. Using Unix is the computing equivalent of listening only to music by David Cassidy. 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Earlier in the same interview, Rob Pike clears up a misconception. Although he co-authored a book on about Unix, he cannot take credit for its creation.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Ken Thompson and Dennis Ritchie created Unix and deserve all the credit, and more.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Which leads us from Slashdot to Google, the computing equivalent of listening to, say, the &lt;a href="http://www.whitestripes.com"&gt;White Stripes&lt;/a&gt;. On the &lt;a href="http://moderator.appspot.com/#15/e=c9&amp;amp;t=2d&amp;amp;q=8e64&amp;amp;v=4"&gt;Ask a Google engineer&lt;/a&gt; forum, Jeff B from Woodstock GA asks a leading question.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I believe the future of operating systems is a &amp;#8220;Cloud OS.&amp;#8221; Do you agree?
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Ken_Thompson"&gt;Ken Thompson&lt;/a&gt; from Mountain View CA responds.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;yes
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/your-computer-might-be-at-risk#toc10" name="tocback-in-the-present" id="tocback-in-the-present"&gt;Back in the present&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.gifford.co.uk/~coredump/oldsad.htm"&gt;&lt;img style="float:right;" src="http://www.gifford.co.uk/~coredump/zx81_1.jpg" alt="Old sad ZX81"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Ironically, the remade computer is actually tolerable to use at present. It boots in seconds, has decent peripherals, and (at last!) carries no &lt;a href="http://en.wikipedia.org/wiki/Crapware"&gt;craplets&lt;/a&gt;. Having spent a few hours getting to know it, from BIOS, through driver, to control panel, I&amp;#8217;m on better terms with it than ever before. Maybe it&amp;#8217;s not such an &lt;a href="http://www.gifford.co.uk/~coredump/oldsad.htm"&gt;old sad thing&lt;/a&gt; after all.
&lt;/p&gt;</description>
<dc:date>2008-11-17</dc:date>
<guid>http://wordaligned.org/articles/your-computer-might-be-at-risk</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/your-computer-might-be-at-risk</link>
<category>Bugs</category>
</item>

<item>
<title>Stop the clock, squash the bug</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocsoftware-bugs" name="toc0" id="toc0"&gt;Software Bugs&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocleaks-and-races" name="toc1" id="toc1"&gt;Leaks and Races&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc75-correct-vs-50-correct" name="toc2" id="toc2"&gt;75% correct vs 50% correct&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocprobabilistic-algorithms" name="toc3" id="toc3"&gt;Probabilistic algorithms&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocfixing-isfprime" name="toc4" id="toc4"&gt;Fixing is_fprime&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocdefensive-programming" name="toc5" id="toc5"&gt;Defensive programming&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocdefect-halflife" name="toc6" id="toc6"&gt;Defect halflife&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tochow-did-that-code-ever-work" name="toc7" id="toc7"&gt;How did that code ever work?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocconclusions" name="toc8" id="toc8"&gt;Conclusions&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#tocsource-code" name="toc9" id="toc9"&gt;Source code&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;Which clock is the best?
&lt;/p&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/images/stopped-clock.gif" alt="Stopped clock"/&gt;
   &lt;img src="http://wordaligned.org/images/slow-clock.gif" alt="Slow clock"/&gt;
   &lt;img src="http://wordaligned.org/images/fast-clock.gif" alt="Fast clock"/&gt;
&lt;/p&gt;
&lt;p&gt;We can easily rule the one which has stopped &amp;#8230; 
&lt;/p&gt;
&lt;p&gt;Or can we? In &amp;#8220;The Rectory Umbrella&amp;#8221; Lewis Carroll &lt;a href="http://www.gavagai.de/themen/HHPT02.htm"&gt;argues otherwise&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Which is better, a clock that is right only once a year, or a clock that is right twice every day?
&lt;/p&gt;
&lt;p&gt;&amp;#8220;The latter,&amp;#8221; you reply, &amp;#8220;unquestionably.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;Very good, now attend.
   I have two clocks: one doesn&amp;#8217;t go at all, and the other loses a minute a day: which would you prefer? &amp;#8220;The losing one,&amp;#8221; you answer, &amp;#8220;without a doubt.&amp;#8221; Now observe: the one which loses a minute a day has to lose twelve hours, or seven hundred and twenty minutes before it is right again, consequently it is only right once in two years, whereas the other is evidently right as often as the time it points to comes round, which happens twice a day. 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;span id="continue-reading"/&gt;

&lt;p&gt;It&amp;#8217;s an amusing diversion, but not really that puzzling: &lt;em&gt;of course&lt;/em&gt; the clock which loses time is of more practical use, even if, somewhat paradoxically, the less time it loses the less often it tells the right time. A clock which loses just a second a day only tells the right time every 118 years or so.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc0" name="tocsoftware-bugs" id="tocsoftware-bugs"&gt;Software Bugs&lt;/a&gt;&lt;/h3&gt;
&lt;img style="float:right;" src="http://wordaligned.org/images/buttons/spider.jpg" alt="Bug"/&gt;

&lt;p&gt;I mention these defective clocks because I&amp;#8217;m thinking about bugs in software and how we go about finding and fixing them. 
&lt;/p&gt;
&lt;p&gt;Code which is obviously wrong is easier to spot than code which is almost right, and spotting bugs is the precursor to fixing them. This implies &amp;#8212; building on Carroll&amp;#8217;s terminology &amp;#8212; that we&amp;#8217;re unlikely to ship many stopped clocks but if we&amp;#8217;re not careful we may end up delivering a few which lose time. And, in general, code which is obviously wrong is easier to fix than code which is almost right. A badly-broken function clearly needs a rethink; whereas one which &lt;em&gt;almost&lt;/em&gt; works may simply get tweaked until it &lt;em&gt;appears&lt;/em&gt; to work, often resulting in a more subtle bug.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc1" name="tocleaks-and-races" id="tocleaks-and-races"&gt;Leaks and Races&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;C and C++ provide a good example of what I&amp;#8217;m talking about. Consider a program which misuses memory. An attempt to allocate workspace of 4294967295 bytes fails instantly&lt;a id="fn1link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;; a slow memory leak, like a slow running clock, may cause no perceptible damage for an extended period.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://valgrind.org"&gt;Decent tools&lt;/a&gt; detect memory leaks. Race conditions in multi-threaded code are harder to track and may prove elusive during system testing. More than once I&amp;#8217;ve left a program running under a debugger, being fed random inputs, in the hope some rare and apparently random condition will trigger a break in execution. Give me truly broken code any day!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc2" name="toc75-correct-vs-50-correct" id="toc75-correct-vs-50-correct"&gt;75% correct vs 50% correct&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here are two implementations of a C function to find an integer midway between a pair of ordered, positive integer values, truncating downwards. Before reading on, ask yourself which is better.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;int midpoint1(int low, int high)
{
    return low/2 + high/2;
}

int midpoint2(int low, int high)
{
    return (low + high)/2;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Midpoint1&lt;/code&gt; is a &amp;#8220;stopped clock&amp;#8221;, returning 3 instead of 4 as the mid-point of 3 and 5, for example. It gets the wrong answer 25% of the time &amp;#8212; fatally wrong were it to be used at the heart of, say, a binary search. I think we&amp;#8217;d quickly detect the problem.
&lt;/p&gt;
&lt;p&gt;An obvious fix would be the one shown in &lt;code&gt;midpoint2&lt;/code&gt; which does indeed return 4 as the mid-point of 3 and 5. 
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Midpoint2&lt;/code&gt; turns out to be a losing clock, though. If the sum &lt;code&gt;low + high&lt;/code&gt; overflows then the result is undefined. On my implementation I get a negative value &amp;#8212; a dangerous thing to use as an array index. This is a notorious and very real defect, nicely documented in a &lt;a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html"&gt;note by Joshua Bloch&lt;/a&gt; subtitled &amp;#8220;Nearly all Binary Searches and Mergesorts are broken&amp;#8221;. 
&lt;/p&gt;
&lt;p&gt;Bloch offers more than one fix so I&amp;#8217;ll just note here that:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     this defect simply doesn&amp;#8217;t exist in a high-level language like Python or Haskell, where integers are bounded only by machine resources
 &lt;/li&gt;

 &lt;li&gt;
     I think Bloch is unfair to suggest Jon Bentley&amp;#8217;s analysis in chapter 4 of Programming Pearls is wrong. The pseudo-code in this chapter is written in a C-like language somewhere between C and Python, and in fact one of Bentley&amp;#8217;s exercises is to examine what effect word size has on this analysis.
 &lt;/li&gt;

 &lt;li&gt;
     in a sense, &lt;code&gt;midpoint2&lt;/code&gt; is more broken than &lt;code&gt;midpoint1&lt;/code&gt;: over the range of possible low and high inputs, the sum overflows and triggers the defect 50% of the time.
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc3" name="tocprobabilistic-algorithms" id="tocprobabilistic-algorithms"&gt;Probabilistic algorithms&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Computers are supposed to be predictable and we typically aim for correct programs. There&amp;#8217;s no reason why we shouldn&amp;#8217;t consider aiming for programs which are good enough, though, and indeed many programs which are good enough to be useful are also flawed. Google adverts, for example, analyse the contents of web pages and serve up related links. The algorithm used is secret, clever and quick, but often results in &lt;a href="http://wordaligned.org/articles/mistargeted-ads.html"&gt;semantic blunders&lt;/a&gt; and, on occasion, &lt;a href="http://www.bofh.org.uk/articles/2008/04/15/ads-are-gone"&gt;offensive mistakes&lt;/a&gt;. Few could deny how useful to Google this program has been, though.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a more interesting example of an algorithm which, like a losing clock, is nearly right.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def is_fprime(n):
    """Use Fermat's little theorem to guess if n is prime.
    """
    from random import randrange
    tries = 3
    xs = (randrange(1, n) for _ in range(tries))
    return all((x ** n) % n == x for x in xs)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We won&amp;#8217;t go into the &lt;a href="http://mathworld.wolfram.com/FermatsLittleTheorem.html"&gt;mathematics&lt;/a&gt; here. A quick play with this function looks promising.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; all(is_fprime(n) for n in [2, 3, 5, 7, 11, 13, 17, 19])
True
&amp;gt;&amp;gt;&amp;gt; any(is_fprime(n) for n in [4, 6, 8, 9, 10, 12, 14, 15])
False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In fact, if we give it a real work-out on some large numbers, it does well. I used it to guess which of the numbers between 100000 and 102000 were prime, comparing the answer with the correct result (the code is at the end of this article). It had a better than 99% success rate (in clock terms, it lost around 8 minutes a day) and increasing &lt;code&gt;tries&lt;/code&gt; will boost its performance.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc4" name="tocfixing-isfprime" id="tocfixing-isfprime"&gt;Fixing is_fprime&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The better &lt;code&gt;is_fprime&lt;/code&gt; performs, the less likely we are to spot that it&amp;#8217;s wrong. What&amp;#8217;s worse, though, is that &lt;em&gt;it cannot be fixed&lt;/em&gt; by simple tweaking. However high we set &lt;code&gt;tries&lt;/code&gt; we won&amp;#8217;t have a correct function. We could even take the random probing out of the function and shove every single value of &lt;code&gt;x&lt;/code&gt; in the range 1 to n into the predicate:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def exhaustive_is_fprime(n):
    return all((x ** n) % n == x for x in range(1, n))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Exhaustive_is_fprime&lt;/code&gt; is expensive to run and will (very) occasionally return &lt;code&gt;True&lt;/code&gt; for a composite number&lt;a id="fn2link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;. If you want to know more, &lt;a href="http://www.google.com/search?q=carmichael+numbers"&gt;search for Carmichael numbers&lt;/a&gt;. 
&lt;/p&gt;
&lt;p&gt;The point I&amp;#8217;m making is that code which is almost right can be dangerous. We are tempted to fix it by adjusting the existing implementation, even if, as in this case, a complete overhaul is required. By contrast, we all know what needs doing with code which is plainly wrong.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc5" name="tocdefensive-programming" id="tocdefensive-programming"&gt;Defensive programming&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We&amp;#8217;ve all seen nervous functions which go beyond their stated interface in an attempt to protect themselves from careless users.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;/**
 * Return the maximum value found in the input array.
 * Pre-condition: the input array must not be empty.
 */
int nervy_maximum_value(int const * items, size_t count)
{
    int M = -INT_MAX;
    
    if (items == NULL || count == 0)
    {
        return M;
    }
    for ( ; count-- != 0; ++items)
    {
        if (*items &amp;gt; M)
        {
            M = *items;
        }
    }
    return M;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;What&amp;#8217;s really wanted is both simpler and easier for clients to code against.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;int maximum_value(int const * items, size_t count)
{
    int const * const end = items + count;
    int M = *items++;
    
    for ( ; items != end; ++items)
    {
        if (*items &amp;gt; M)
        {
            M = *items;
        }
    }
    return M;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Did you spot the subtle bug in &lt;code&gt;nervy_maximum_value&lt;/code&gt;? It uses &lt;code&gt;-INT_MAX&lt;/code&gt; instead of &lt;code&gt;INT_MIN&lt;/code&gt; which will cause trouble if clients code against this undocumented behaviour; if &lt;code&gt;nervy_maximum_value&lt;/code&gt; is subsequently fixed, this client code back-fires.
&lt;/p&gt;
&lt;p&gt;Note that I&amp;#8217;m not against the use of assertions to check pre-conditions, and a simple &lt;code&gt;assert(items != NULL &amp;amp;&amp;amp; count != 0)&lt;/code&gt; works well in &lt;code&gt;maximum_value&lt;/code&gt;; it&amp;#8217;s writing code which swallows these failed pre-conditions I consider wrong.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc6" name="tocdefect-halflife" id="tocdefect-halflife"&gt;Defect halflife&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The occurrence of defects in complex software systems can be modelled in the same way as radioactive decay. I haven&amp;#8217;t studied this theory and my physics is rusty&lt;a id="fn3link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn3"&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;, but the basic idea is that the population of bugs in some software is rather like a population of radioactive particles. Any given bug fires (any given particle decays) at random, so we can&amp;#8217;t predict when this event will happen, but it is equally likely to fire at any particular time. This gives each defect an average lifetime: a small lifetime for howling defects, such as dereferencing NULL pointers, and a longer one for more subtle problems, such as accumulated rounding errors. Assuming we fix a bug once it occurs, the population of defects decays exponentially, and we get the classic tailing-off curve.
&lt;/p&gt;
&lt;img src="http://chart.apis.google.com/chart?
cht=lc
&amp;amp;chtt=Exponential+Defect+Decay
&amp;amp;chs=500x200
&amp;amp;chxt=x,y
&amp;amp;chxl=0:||Time|1:||Bugs
&amp;amp;chd=t:95.0,70.3,52.1,38.6,28.6,21.1,15.7,11.6,8.61,6.38
&amp;amp;chco=ff0000
&amp;amp;chm=B,dddddd,0,0,0
&amp;amp;chls=3,1,0" alt="Classic exponential decay curve"/&gt;

&lt;p&gt;&lt;span /&gt;Anyone who has ever tried to release a software product knows how it feels to slide down the slope of this curve. We system test, find bugs, fix them, repeat. At the start it can be exhilarating as bugs with short half-lives fall out and get squashed, but the end game is demoralising as defects get reported which then cannot be reproduced, and we find ourselves clawing out progress. When we eventually draw the line and ship the product we do so suspecting the worst problems are yet to be found. To put it more succinctly&lt;a id="fn4link" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn4"&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Ship happens!
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;A combination of techniques can help us escape this depressing picture. The most obvious one would be to avoid it: rather than aim for &amp;#8220;big-bang&amp;#8221; releases every few years, we can move towards continual and incremental delivery. A modular, decoupled architecture helps. So does insistence on unit testing. Rather than shake the system and sweep up the bugs which fall off we should develop a suite of automated tests which actively seek the various paths through the code, and exercise edge cases. Within the code-base, as already mentioned, &lt;span /&gt;defensive programming can cause defects to become entrenched. Instead, we should adopt a more confident style, where code fails hard and fast.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc7" name="tochow-did-that-code-ever-work" id="tochow-did-that-code-ever-work"&gt;How did that code ever work?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Have you ever fixed a defect and wondered how the code ever even appeared to work before your fix? It&amp;#8217;s an important question and one which requires investigation. Perhaps the bug you&amp;#8217;ve fixed is compensated for by defensive programming elsewhere. Or perhaps there are vast routes through the code which have yet to be exercised.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc8" name="tocconclusions" id="tocconclusions"&gt;Conclusions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/images/stopped-clock.gif" alt="Stopped clock"/&gt;
   &lt;img src="http://wordaligned.org/images/slow-clock.gif" alt="Slow clock"/&gt;
   &lt;img src="http://wordaligned.org/images/fast-clock.gif" alt="Fast clock"/&gt;
&lt;/p&gt;
&lt;p&gt;None of these clocks is much good. The first has stopped, the second loses a second every minute, the third gains a second every minute. At least it&amp;#8217;s easy to see the problem with the first: we won&amp;#8217;t be tempted to patch it.
&lt;/p&gt;
&lt;p&gt;We should never expect our code to work first time and we should be suspicious if it appears to do so. Defensive programming seems to mean different things to different people. If I&amp;#8217;ve misused the term here, I&amp;#8217;m sorry. Our best defence is to assume code is broken until we&amp;#8217;ve tested it, to assume it will break in future if our tests are not automated, and to fail hard and fast when we detect errors.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#toc9" name="tocsource-code" id="tocsource-code"&gt;Source code&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import math
from itertools import islice, count
from random import randrange

def primes(lo, hi):
    '''Return the list of primes in the range [lo, hi).
    
    &amp;gt;&amp;gt;&amp;gt; primes(0, 19)
    [2, 3, 5, 7, 11, 13, 17]
    &amp;gt;&amp;gt;&amp;gt; primes(5, 10)
    [5, 7]
    '''
    sqrt_hi = int(math.sqrt(hi))
    sieve = range(hi)
    zeros = [0] * hi
    sieve[1] = 0
    for i in islice(count(2), sqrt_hi):
        if sieve[i] != 0:
            remove = slice(i * i, hi, i)
            sieve[remove] = zeros[remove]
    return [p for p in sieve[lo:] if p != 0]

def is_fprime(n, tries=3):
    '''Use Fermat little theorem to guess if n is prime.
    '''
    xs = (randrange(1, n) for _ in range(tries))
    return all((x ** n) % n == x for x in xs)

def fprimes(lo, hi, tries=10):
    '''Alternative implementation of primes.
    '''
    return filter(is_fprime, range(lo, hi))

if __name__ == '__main__':
    import doctest
    doctest.testmod()
    lo, hi = 100000, 102000
    primes_set = set(primes(lo, hi))
    fprimes_set = set(fprimes(lo, hi))
    print "Range [%r, %r)" % (lo, hi)
    print "Actual number of primes", len(primes_set)
    print "Number of fprimes", len(fprimes_set)
    print "Primes missed", primes_set - fprimes_set
    print "False fprimes", fprimes_set - primes_set

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Running this program produced output:
&lt;/p&gt;
&lt;pre&gt;
Range [100000, 102000)
Actual number of primes 174
Number of fprimes 175
Primes missed set([])
False fprimes set([101101])
&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn1link"&gt;[1]&lt;/a&gt; In the first version of this article I wrote that an attempt to allocate 4294967295 bytes would cause the program to crash, which isn&amp;#8217;t quite right. &lt;code&gt;Malloc&lt;/code&gt; returns NULL in the event of failure; standard C++ operator new behaviour is to throw a &lt;code&gt;bad_alloc&lt;/code&gt; exception. My thanks to R Samuel Klatchko for the &lt;a href="http://www.haloscan.com/comments/wordaligned/stop_the_clock_squash_the_bug/#16928"&gt;correction&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn2link"&gt;[2]&lt;/a&gt;
   &lt;a href="http://mitpress.mit.edu/sicp"&gt;&amp;#8220;Structure and Interpretation of Computer Programs&amp;#8221;&lt;/a&gt; discusses Carmichael numbers in a &lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#call_footnote_Temp_80"&gt;footnote&lt;/a&gt;
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Numbers that fool the Fermat test are called &lt;em&gt;Carmichael numbers&lt;/em&gt;, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a &amp;#8220;correct&amp;#8221; algorithm. Considering an algorithm to be inadequate for the first reason but not for the second illustrates the difference between mathematics and engineering.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;a id="fn3" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn3link"&gt;[3]&lt;/a&gt;
   Being lazy and online I thought I&amp;#8217;d search for a nice radioactive decay graphic rather than draw my own. I found a real gem on the &lt;a href="http://www.colorado.edu/physics/2000/isotopes/radioactive_decay3.html"&gt;University of Colarado site&lt;/a&gt;, where Kyla and Bob discuss radioactive decay.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;img src="http://www.colorado.edu/physics/2000/images/kyla-set/kyla3.jpg" alt="Kyla" style="float:left;"/&gt;&lt;/p&gt;&lt;p&gt;Hmmm&amp;#8230;so a lot of decays happen really fast when there are lots of atoms, and then things slow down when there aren&amp;#8217;t so many. The halflife is always the same, but the &lt;i&gt;half&lt;/i&gt; gets smaller and smaller.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://www.colorado.edu/physics/2000/images/bob-set/bob2.jpg" alt="Bob" style="float:left;"/&gt;&lt;/p&gt;&lt;p&gt;That&amp;#8217;s exactly right.  Here&amp;#8217;s another applet that illustrates radioactive decay in action.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="http://www.colorado.edu/physics/2000/isotopes/radioactive_decay3.html"&gt;Visit the site&lt;/a&gt; to play with the applet Bob mentions. You&amp;#8217;ll find more Kyla and Bob pictures there too.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn4" href="http://wordaligned.org/articles/stop-the-clock-squash-the-bug#fn4link"&gt;[4]&lt;/a&gt;
   I&amp;#8217;m unable to provide a definitive attribution for the &amp;#8220;Ship happens!&amp;#8221; quotation. I first heard it from &lt;a href="http://erdani.org"&gt;Andrei Alexandrescu&lt;/a&gt; at an &lt;a href="http://accu.org/index.php/conferences"&gt;ACCU conference&lt;/a&gt;, who in turn thinks he got it from Erich Gamma. I haven&amp;#8217;t managed to contact Erich Gamma. Matthew B. Doar &lt;a href="http://www.haloscan.com/comments/wordaligned/stop_the_clock_squash_the_bug/#17002"&gt;reports&lt;/a&gt; using the term back in 2002, and it appears as a &lt;a href="http://www.oreilly.com/catalog/practicalde/toc.html"&gt;section heading&lt;/a&gt; in his book &lt;a href="http://www.oreilly.com/catalog/practicalde"&gt;&amp;#8220;Practical Development Environments&amp;#8221;&lt;/a&gt;.
&lt;/p&gt;</description>
<dc:date>2008-04-16</dc:date>
<guid>http://wordaligned.org/articles/stop-the-clock-squash-the-bug</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/stop-the-clock-squash-the-bug</link>
<category>Bugs</category>
</item>

</channel>
</rss>
