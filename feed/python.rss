<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Unleash the test army</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocare-the-tests-adequate" name="toc0" id="toc0"&gt;Are the tests adequate?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocproperty-based-testing" name="toc1" id="toc1"&gt;Property based testing&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tochypothesis" name="toc2" id="toc2"&gt;Hypothesis&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocfirst-impressions" name="toc3" id="toc3"&gt;First impressions&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocmy-first-test" name="toc4" id="toc4"&gt;My first test&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocmy-second-test" name="toc5" id="toc5"&gt;My second test&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toccomplete-test-suite" name="toc6" id="toc6"&gt;Complete test suite&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocquality-of-failure" name="toc7" id="toc7"&gt;Quality of failure&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#tocconclusions" name="toc8" id="toc8"&gt;Conclusions&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc0" name="tocare-the-tests-adequate" id="tocare-the-tests-adequate"&gt;Are the tests adequate?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Recently I described a solution to &lt;a href="http://wordaligned.org/articles/slicing-a-list-evenly-with-python"&gt;the problem of dividing a list into evenly sized chunks&lt;/a&gt;. It&amp;#8217;s a simple enough problem with just two inputs: the list (or other sliceable container) &lt;code&gt;xs&lt;/code&gt; and the number of chunks &lt;code&gt;n&lt;/code&gt;. Nonetheless, there are traps to avoid and special cases to consider &amp;#8212; what if &lt;code&gt;n&lt;/code&gt; is larger than the list, for example? Must the chunks comprise contiguous elements from the original list?
&lt;/p&gt;
&lt;p&gt;The tests I came up with are straightforward and uninspiring. They were developed within the context of my own assumptions about the solution and the special cases I could imagine. They were written after the implementation &amp;#8212; which is to say, development wasn&amp;#8217;t driven by tests. They are whitebox tests, designed to cover the various paths through the code based on my insider knowledge.
&lt;/p&gt;
&lt;p&gt;Are these tests adequate? Certainly they don&amp;#8217;t accurately represent the data which will hit the algorithm in practice. Can we be sure we haven&amp;#8217;t missed anything? Would the tests still cover all paths if the implementation changed?
&lt;/p&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc1" name="tocproperty-based-testing" id="tocproperty-based-testing"&gt;Property based testing&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;David R MacIver described another, complementary, approach at &lt;a href="https://accu.org/index.php/conferences/accu_conference_2016/accu2016_sessions#The_Plural_of_Anecdote_is_not_Test_Suite"&gt;a talk I attended at ACCU 2016&lt;/a&gt;. In the talk abstract he characterises the (class of) tests I&amp;#8217;d written as &lt;strong&gt;anecdotal&lt;/strong&gt; &amp;#8212; &amp;#8220;let me tell you about this time I called a function &amp;#8230; and then it returned this .. and then it raised an exception &amp;#8230; etc. etc.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;How about if the test suite instead describes the &lt;strong&gt;properties&lt;/strong&gt; required of the system under test, and then conjures up inputs designed to see if these properties hold under stress? So, rather than our test suite being a limited set of input/output pairs, it becomes an executable specification validated by a robot army.
&lt;/p&gt;
&lt;p&gt;&lt;a data-flickr-embed="true"  href="https://www.flickr.com/photos/avatarr8/3819520612" title="China&amp;#x27;s Robot Army"&gt;&lt;img src="https://c1.staticflickr.com/3/2431/3819520612_4b32f2b423.jpg" width="500" height="334" alt="China&amp;#x27;s Robot Army"&gt;&lt;/a&gt;&lt;script async src="http://wordaligned.org//embedr.flickr.com/assets/client-code.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc2" name="tochypothesis" id="tochypothesis"&gt;Hypothesis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This approach sounds compelling but I had my doubts. I also had my doubts about the adequacy of both my code and tests. A perfect opportunity, then, to try out &lt;a href="https://hypothesis.readthedocs.io/en/latest/"&gt;Hypothesis&lt;/a&gt;, an open source property-based testing library developed by David MacIver.
&lt;/p&gt;
&lt;p&gt;I used the Python version of the library, which is the primary implementation. The rest of this article describes my experience of using &lt;a href="https://hypothesis.readthedocs.io/en/latest/"&gt;hypothesis&lt;/a&gt; for the first time: I&amp;#8217;m not claiming expertise.
&lt;/p&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc3" name="tocfirst-impressions" id="tocfirst-impressions"&gt;First impressions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Excellent!
&lt;/p&gt;
&lt;p&gt;Installation was the usual &lt;code&gt;pip&lt;/code&gt; invocation. The &lt;a href="https://hypothesis.readthedocs.io/en/latest/"&gt;documentation&lt;/a&gt; is written with care. It&amp;#8217;s evident the library is mature, supported and actively developed. It&amp;#8217;s licensed under the &lt;a href="https://www.mozilla.org/en-US/MPL/2.0/"&gt;Mozilla Public License&lt;/a&gt;.
&lt;/p&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc4" name="tocmy-first-test" id="tocmy-first-test"&gt;My first test&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Recall that the code I wanted to test reads:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def chunk(xs, n):
    '''Split the list, xs, into n evenly sized chunks'''
    L = len(xs)
    assert 0 &amp;lt; n &amp;lt;= L
    s, r = divmod(L, n)
    t = s + 1
    return ([xs[p:p+t] for p in range(0, r*t, t)] +
            [xs[p:p+s] for p in range(r*t, L, s)])

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I also proposed a second &lt;code&gt;itertools&lt;/code&gt; based version:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import accumulate, chain, repeat, tee

def chunk(xs, n):
    '''Split the list, xs, into n evenly sized chunks'''
    assert n &amp;gt; 0
    L = len(xs)
    s, r = divmod(L, n)
    widths = chain(repeat(s+1, r), repeat(s, n-r))
    offsets = accumulate(chain((0,), widths))
    b, e = tee(offsets)
    next(e)
    return [xs[s] for s in map(slice, b, e)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The first thing you notice when thinking about a property based test is that the specification &amp;#8212; the function&amp;#8217;s docstring &amp;#8212; doesn&amp;#8217;t describe the exact form of the output. In fact, as a comment on the article pointed out, my own interpretation of the specification is not the only one, and allowing the chunks to be formed from non-contiguous items permits a particularly elegant solution.
&lt;/p&gt;
&lt;p&gt;Also, if the list doesn&amp;#8217;t divide exactly into &lt;code&gt;n&lt;/code&gt; chunks, what should the result be? Well, although I&amp;#8217;d have been happy with any evenly-chunked solution, my conventional unit tests &lt;strong&gt;assumed&lt;/strong&gt; an implementation which placed the larger chunks first.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def test_chunk():
    assert chunk('', 1) == ['']
    assert chunk('ab', 2) == ['a', 'b']
    assert chunk('abc', 2) == ['ab', 'c']
    
    xs = list(range(8))
    assert chunk(xs, 2) == [[0, 1, 2, 3], [4, 5, 6, 7]]
    assert chunk(xs, 3) == [[0, 1, 2], [3, 4, 5], [6, 7]]
    assert chunk(xs, 5) == [[0, 1], [2, 3], [4, 5], [6], [7]]
    
    rs = range(1000000)
    assert chunk(rs, 2) == [range(500000), range(500000, 1000000)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Notice, by the way, that although the docstring only mentions lists, I can&amp;#8217;t resist demonstrating the algorithm also behaves for strings and ranges &amp;#8212; for any sliceable sequence, in fact.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s what I started with when I tried specifying the &amp;#8220;evenly sized&amp;#8221; property using hypothesis.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def test_evenly_chunked(xs, n):
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert set(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This first test case defines &amp;#8220;evenly sized&amp;#8221;, stating that the result comprises &lt;code&gt;n&lt;/code&gt; chunks, that the set of the lengths of these chunks is either 1 (all chunks the same size) or 2, and the maximum chunk length is equal to or one more than the minumum chunk length.
&lt;/p&gt;
&lt;p&gt;This doesn&amp;#8217;t fully specify the function. We also need assertions which confirm that recombining the chunks produces the original sequence.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def test_combining_chunks(xs_n):
    pass # We'll come back to this!

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We&amp;#8217;ll come back to this later!
&lt;/p&gt;
&lt;p&gt;Now, &lt;code&gt;test_evenly_chunked()&lt;/code&gt; looks quite like a conventional test function. It just needs some input values. Rather than poke the function with some hand-chosen values, we can let hypothesis have a go.
&lt;/p&gt;
&lt;p&gt;Based on a read of the &lt;a href="https://hypothesis.readthedocs.io/en/latest/quickstart.html"&gt;Quick start guide&lt;/a&gt; I tried this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import hypothesis as ht
import hypothesis.strategies as st

@ht.given(xs=st.lists(), n=st.integers())
def test_evenly_chunked(xs, n):
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert len(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As you can see, the test function pre-conditions are encapsulated in a &lt;code&gt;hypothesis.given&lt;/code&gt; decorator, which specifies the use of &lt;code&gt;hypothesis.strategies.lists()&lt;/code&gt; and &lt;code&gt;hypothesis.strategies.integers()&lt;/code&gt; to generate test values for &lt;code&gt;xs&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; respectively.
&lt;/p&gt;
&lt;p&gt;The result was a lengthy but helpful failure, which printed out the documentation of the &lt;code&gt;lists()&lt;/code&gt; strategy and the usage error:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;hypothesis.errors.InvalidArgument: Cannot create non-empty lists without an element type

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;OK then. The function doesn&amp;#8217;t really care about the element type. Integers will do.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@ht.given(xs=st.lists(st.integers()), n=st.integers())
def test_evenly_chunked(xs, n):
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This gave me an error, along with a minimal test case which produces it.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;xs = [], n = 0

def chunk(xs, n):
        '''Split the list, xs, into n evenly sized chunks'''
        L = len(xs)
&amp;gt;       assert 0 &amp;lt; n &amp;lt;= L
E       AssertionError

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Our function, &lt;code&gt;chunk()&lt;/code&gt; requires the value &lt;code&gt;n&lt;/code&gt; to be in the closed range &lt;code&gt;(0, len(xs)]&lt;/code&gt;. Looking more closely at the failure, we can see that the function under test, &lt;code&gt;chunk()&lt;/code&gt;, isn&amp;#8217;t great, since we won&amp;#8217;t be able to split an empty list into &lt;strong&gt;any&lt;/strong&gt; number of chunks since, in this case, &lt;code&gt;L&lt;/code&gt; is zero and no value of &lt;code&gt;n&lt;/code&gt; satisfies &lt;code&gt;0 &amp;lt; n &amp;lt;= L&lt;/code&gt;. 
&lt;/p&gt;
&lt;p&gt;At this point I had to makes some choices:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     should my tests confirm &lt;code&gt;chunk()&lt;/code&gt; was checking pre-conditions (by catching the &lt;code&gt;AssertionError&lt;/code&gt;)?
 &lt;/li&gt;

 &lt;li&gt;
     should my function handle the case when &lt;code&gt;n &amp;gt; L&lt;/code&gt;? It&amp;#8217;s not the intended use of the function, but it can be handled.
 &lt;/li&gt;

 &lt;li&gt;
     what about when &lt;code&gt;n == 0&lt;/code&gt;? Splitting a non-empty list into &lt;code&gt;0&lt;/code&gt; chunks is impossible, but I guess an empty list can be split into &lt;code&gt;0&lt;/code&gt; chunks.
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc5" name="tocmy-second-test" id="tocmy-second-test"&gt;My second test&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I made some decisions.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     I decided not to test the pre-condition assertions. Instead, I&amp;#8217;d modify the test strategy to pass in valid inputs.
 &lt;/li&gt;

 &lt;li&gt;
     I decided I&amp;#8217;d go with the &lt;code&gt;itertools&lt;/code&gt; chunk function which naturally handles &lt;code&gt;n &amp;gt; L&lt;/code&gt;.
 &lt;/li&gt;

 &lt;li&gt;
     I decided my function needn&amp;#8217;t handle &lt;code&gt;n == 0&lt;/code&gt;, even when &lt;code&gt;xs == []&lt;/code&gt;.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here&amp;#8217;s the modified test code
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@ht.given(xs=st.lists(st.integers()),
          n=st.integers(min_value=1))
def test_evenly_chunked(xs, n):
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert len(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;When I tried running the tests again, they appeared to hang until I interrupted them.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt; py.test
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.0.7, py-1.4.33, pluggy-0.4.0
....
plugins: hypothesis-3.8.3
collected 1 items

test_chunk.py   C-c C-c

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
to show a full traceback on KeyboardInterrupt use --fulltrace

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now, I had a suspicion that &lt;code&gt;chunk()&lt;/code&gt; couldn&amp;#8217;t really handle &lt;strong&gt;any&lt;/strong&gt; input integers &amp;#8212; it was designed for a value of &lt;code&gt;n&lt;/code&gt; equal to &lt;code&gt;multiprocessing.cpu_count()&lt;/code&gt; &amp;#8212; but I wanted to see what would happen with no upper limits. Here was my answer. Running and interrupting again with &lt;code&gt;--fulltrace&lt;/code&gt; set, I got several pages of output ending with the test inputs:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;xs = [50], n = 67108865

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Evidently my code was taking a while to create a list comprising a single list &lt;code&gt;[50]&lt;/code&gt; and over 67 million empty lists &lt;code&gt;[], [], [], ...&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Once again, I had a decision to make. Perhaps unsurprisingly, it&amp;#8217;s a decision I&amp;#8217;d already faced. I could make &lt;code&gt;chunk()&lt;/code&gt; a generator function, yielding the chunks one at a time &amp;#8212; a trivial and natural change to the &lt;code&gt;itertools&lt;/code&gt; based implementation &amp;#8212; or I could constrain the tests to more suitable values of &lt;code&gt;n&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;In this case I decided to stick with what I had: my function would accept a list and return a list (of lists). In an attempt to get some passing tests, I set a maximum value on &lt;code&gt;n&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@ht.given(xs=st.lists(st.integers()),
          n=st.integers(min_value=1, max_value=100))
def test_evenly_chunked(xs, n):
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;At last, I had a passing test.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;py.test 
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.0.7, py-1.4.33, pluggy-0.4.0
rootdir: /work/sliced-python, inifile:
plugins: hypothesis-3.8.3
collected 1 items

test_chunk.py .

========================== 1 passed in 0.23 seconds ===========================

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Building on this success, I wanted to confirm the function also handled other sliceable types &amp;#8212; strings and bytes specifically. Hypothesis provides a &lt;code&gt;one_of&lt;/code&gt; strategy for combining other strategies.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@ht.given(xs=st.one_of(st.text(),
                       st.binary(),
                       st.lists(st.integers())),
          n=st.integers(min_value=1, max_value=100))
def test_evenly_chunked(xs, n):
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert len(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Again, the test passes.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;py.test
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.0.7, py-1.4.33, pluggy-0.4.0
rootdir: /work/sliced-python, inifile:
plugins: hypothesis-3.8.3
collected 1 items

test_chunk.py .

========================== 1 passed in 0.30 seconds ===========================

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This output is rather inscrutable. Generally, passing tests shouldn&amp;#8217;t draw attention to themselves, but what inputs had my test strategies generated? Were they sufficient?
&lt;/p&gt;
&lt;p&gt;A commandline switch provides a little more detail.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;py.test --hypothesis-show-statistics

....

test_chunk.py::test_evenly_chunked:

- 200 passing examples, 0 failing examples, 0 invalid examples
  - Typical runtimes: &amp;lt; 1ms
  - Stopped because settings.max_examples=200

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s also possible to peek at examples produced by the test strategy.
&lt;/p&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; s=st.one_of(st.text(), st.binary(), st.lists(st.integers()))
&amp;gt;&amp;gt;&amp;gt; s.example()
b''
&amp;gt;&amp;gt;&amp;gt; s.example()
b'\xc2\xfd6['
&amp;gt;&amp;gt;&amp;gt; s.example()
':\n&amp;uacute;&amp;amp;\U000ea7e8'
&amp;gt;&amp;gt;&amp;gt; s.example()
b'\xe7z'
&amp;gt;&amp;gt;&amp;gt; s.example()
''
&amp;gt;&amp;gt;&amp;gt; s.example()
[184, 36, -205, 1486638017]
&lt;/pre&gt;


&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc6" name="toccomplete-test-suite" id="toccomplete-test-suite"&gt;Complete test suite&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here&amp;#8217;s my final test suite. Rather than hard code a maximum value for &lt;code&gt;n&lt;/code&gt;, I used a &lt;a href="https://hypothesis.readthedocs.io/en/latest/data.html#composite-strategies"&gt;composite strategy&lt;/a&gt; which adapts &lt;code&gt;n&lt;/code&gt; to the size of &lt;code&gt;xs&lt;/code&gt;. I&amp;#8217;ve also added a test which confirms the result does comprise chunks of the input sequence.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import functools

import hypothesis as ht
import hypothesis.strategies as st

@st.composite
def items_and_chunk_count(draw):
    xs = draw(st.one_of(st.text(),
                        st.binary(),
                        st.lists(st.integers())))
    n = draw(st.integers(min_value=1,
                         max_value=max(1, len(xs))))
    return xs, n

@ht.given(xs_n=items_and_chunk_count())
def test_evenly_chunked(xs_n):
    '''Verify there are n evenly sized chunks'''
    xs, n = xs_n
    chunks = chunk(xs, n)
    assert len(chunks) == n
    chunk_lens = {len(c) for c in chunks}
    assert len(chunk_lens) in {1, 2}
    assert max(chunk_lens) - min(chunk_lens) in {0, 1}

@ht.given(xs_n=items_and_chunk_count())
def test_combining_chunks(xs_n):
    '''Verify recombining the chunks reproduces the original sequence.'''
    xs, n = xs_n
    chunks = chunk(xs, n)
    assert functools.reduce(lambda x, y: x+y, chunks) == xs

&lt;/pre&gt;

&lt;/div&gt;


&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc7" name="tocquality-of-failure" id="tocquality-of-failure"&gt;Quality of failure&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the comments to my original article Mike Edey put forward an elegant solution to the original problem of evenly subdividing a sequence into an exact number of chunks:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def chunk(xs, n):
    return [xs[index::n] for index in range(n)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This is a delightful piece piece of code, and an approach I simply hadn&amp;#8217;t considered. If the input list &lt;code&gt;xs&lt;/code&gt; represents a number of tasks to be distributed amongst &lt;code&gt;n&lt;/code&gt; workers, this does the job evenly. In my actual motivating example, though, however, the input sequence was a document which caused a problem, and what I wanted to do was split that document up into a number of sections and see which of these exhibited the same problem: that is, I needed the chunks to be contiguous blocks of text from the original document. This is the property which &lt;code&gt;test_combining_chunks()&lt;/code&gt; checks.
&lt;/p&gt;
&lt;p&gt;Running Mike Edey&amp;#8217;s implementation through the test suite, we get:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;py.test
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.0.7, py-1.4.33, pluggy-0.4.0
rootdir: /work/sliced-python, inifile:
plugins: hypothesis-3.8.3
collected 2 items

test_chunk.py .F

================================== FAILURES ===================================
____________________________ test_combining_chunks ____________________________

@ht.given(xs_n=items_and_chunk_count())
&amp;gt;   def test_combining_chunks(xs_n):

test_chunk.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
d:\venvs\slackbot\lib\site-packages\hypothesis\core.py:634: in wrapped_test
    state.run()
d:\venvs\slackbot\lib\site-packages\hypothesis\core.py:531: in run
    print_example=True, is_final=True
d:\venvs\slackbot\lib\site-packages\hypothesis\executors.py:58: in default_new_style_executor
    return function(data)
d:\venvs\slackbot\lib\site-packages\hypothesis\core.py:113: in run
    return test(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

xs_n = ('001', 2)

@ht.given(xs_n=items_and_chunk_count())
    def test_combining_chunks(xs_n):
        '''Verify recombining the chunks reproduces the original sequence.'''
        xs, n = xs_n
        chunks = chunk(xs, n)
&amp;gt;       assert functools.reduce(lambda x, y: x+y, chunks) == xs
E       AssertionError: assert '010' == '001'
E         - 010
E         + 001

test_chunk.py:33: AssertionError
--------------------------------- Hypothesis ----------------------------------
Falsifying example: test_combining_chunks(xs_n=('001', 2))
===================== 1 failed, 1 passed in 0.52 seconds ======================

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Hypothesis has discovered a minimal failing example: the string &lt;code&gt;001&lt;/code&gt; splits into &lt;code&gt;2&lt;/code&gt; chunks as &lt;code&gt;01&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;.
&lt;/p&gt;

&lt;h2&gt;&lt;a href="http://wordaligned.org/articles/unleash-the-test-army#toc8" name="tocconclusions" id="tocconclusions"&gt;Conclusions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Hypothesis worked well for this particular example.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     it forced me to pin down the function specification
 &lt;/li&gt;

 &lt;li&gt;
     I had to consider the special cases: would the function behave in the face of logically permissable inputs, and not just the ones I had in mind when I wrote it
 &lt;/li&gt;

 &lt;li&gt;
     it increased my confidence the function was correct
 &lt;/li&gt;

 &lt;li&gt;
     and particularly appealing, in this case &amp;#8212; the tests were not tied to a detail of the implementation, and would continue to work if, for example, the larger chunks were to appear at the end of the results.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More generally, I found the hypothesis library solid. It&amp;#8217;s well designed and documented, as well as being a fine example of how to use Python decorators.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;d say property based testing complements example based testing. Example based unit tests show you how a function is used, for instance; with hypothesis, this useful demonstration happens behind the scenes (though note that your hypothesis tests &lt;strong&gt;can&lt;/strong&gt; include explicit &lt;a href="https://hypothesis.readthedocs.io/en/latest/details.html#providing-explicit-examples"&gt;@examples&lt;/a&gt;). Example based unit tests are typically one or two orders of magnitude quicker to execute. It&amp;#8217;s not a problem if a couple of tests take half a second to run, but what if you have a couple of thousand tests?
&lt;/p&gt;
&lt;p&gt;In my case the built-in strategies were good enough to generate inputs to my function. I can imagine that&amp;#8217;s not the case for functions higher up a software stack. Test setup functions can be hard work and I suspect test setup strategies would be harder.
&lt;/p&gt;
&lt;p&gt;In closing, I&amp;#8217;d like to quote from the section of the &lt;a href="https://hypothesis.readthedocs.io/en/latest/manifesto.html"&gt;Hypothesis documentation&lt;/a&gt; which describes its purpose.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Software is, as they say, eating the world. Software is also &lt;a href="https://www.youtube.com/watch?v=csyL9EC0S0c"&gt;terrible&lt;/a&gt;. It&amp;#8217;s buggy, insecure and generally poorly thought out. This combination is clearly a recipe for disaster.
&lt;/p&gt;
&lt;p&gt;And the state of software testing is even worse. Although it&amp;#8217;s fairly uncontroversial at this point that you should be testing your code, can you really say with a straight face that most projects you&amp;#8217;ve worked on are adequately tested?
&lt;/p&gt;
&lt;p&gt;A lot of the problem here is that it&amp;#8217;s too hard to write good tests. Your tests encode exactly the same assumptions and fallacies that you had when you wrote the code, so they miss exactly the same bugs that you missed when you wrote the code.
&lt;/p&gt;
&lt;p&gt;&amp;#8212; &lt;a href="https://hypothesis.readthedocs.io/en/latest/manifesto.html"&gt;The Purpose of Hypothesis&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;</description>
<dc:date>2017-05-29</dc:date>
<guid>http://wordaligned.org/articles/unleash-the-test-army</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/unleash-the-test-army</link>
<category>Python</category>
</item>

<item>
<title>Lazy sequences working hard</title>
<description>&lt;p&gt;I gave a talk &lt;a href="http://www.pydiff.wales/events/2017-05-16.html"&gt;@PyDiff&lt;/a&gt; this evening in the computer science department at Cardiff University.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;h2&gt;Lazy Sequences working hard&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;Python has no problem handling large and even infinite streams of data. Just write lazy programs &amp;#8212; code which defers data access until the last minute. This talk examines Python&amp;#8217;s language and library support for such delaying tactics. There will be live coding, and we&amp;#8217;ll draw parallels with similar features in other languages, in particular the Unix shell.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Being unsure where to pitch it, I started off easy and kept going until I&amp;#8217;d lost everybody &amp;#8212; including myself.
&lt;/p&gt;
&lt;p&gt;The room was well set up with a good quality projector and whiteboard, along with a desk to sit down when I wanted to write and run code and plenty of space to move around in otherwise. I did feel a bit like a jack-in-the-box by the end.
&lt;/p&gt;
&lt;p&gt;&lt;a data-flickr-embed="true"  href="https://www.flickr.com/photos/thomasguest/34663534326/in/dateposted-friend/" title="Me @PyDiff"&gt;&lt;img src="https://c1.staticflickr.com/5/4164/34663534326_4bf8851eeb.jpg" width="500" height="375" alt="Me @PyDiff"&gt;&lt;/a&gt;&lt;script async src="http://wordaligned.org//embedr.flickr.com/assets/client-code.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;d based the talk on a Jupyter notebook which I replayed with the ingenious &lt;a href="https://github.com/damianavila/RISE"&gt;RISE reveal.js extension&lt;/a&gt; written by Damian Avila. This worked well, since I got the pretty graphics along with the interactive coding. A static version of the slides is &lt;a href="http://nbviewer.jupyter.org/url/wordaligned.org/docs/lazy-sequences.ipynb"&gt;available here&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Thanks to everyone who came. Sorry I had to rush off after. If anyone would &lt;a href="http://swanseasdc.co.uk/"&gt;like to talk at Swansea&lt;/a&gt;, please let me know: you&amp;#8217;d be most welcome.
&lt;/p&gt;</description>
<dc:date>2017-05-16</dc:date>
<guid>http://wordaligned.org/articles/lazy-sequences-working-hard</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/lazy-sequences-working-hard</link>
<category>Python</category>
</item>

<item>
<title>Slicing a list evenly with Python</title>
<description>&lt;img src="http://wordaligned.org/images/sliced-python.jpg" alt="Sliced Python"/&gt;

&lt;p&gt;Here&amp;#8217;s a problem I came up against recently.
&lt;/p&gt;
&lt;p&gt;The task was to chop a list into exactly &lt;code&gt;n&lt;/code&gt; evenly slized chunks. To give a little more context, let&amp;#8217;s suppose we want to divide a list of jobs equally between &lt;code&gt;n&lt;/code&gt; workers, where &lt;code&gt;n&lt;/code&gt; might be the number of CPU cores available.
&lt;/p&gt;
&lt;p&gt;We can build the result by repeatedly slicing the input:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def chunk(xs, n):
    '''Split the list, xs, into n chunks'''
    L = len(xs)
    assert 0 &amp;lt; n &amp;lt;= L
    s = L//n
    return [xs[p:p+s] for p in range(0, L, s)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This looks promising
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; chunk('abcdefghi', 3)
['abc', 'def', 'ghi']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;but if the size of the list is not an exact multiple of &lt;code&gt;n&lt;/code&gt;, the result won&amp;#8217;t contain &lt;strong&gt;exactly&lt;/strong&gt; &lt;code&gt;n&lt;/code&gt; chunks.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; chunk('abcde', 3)
['a', 'b', 'c', 'd', 'e']
&amp;gt;&amp;gt;&amp;gt; chunk('abcdefgh', 3)
['ab', 'cd', 'ef', 'gh']
&amp;gt;&amp;gt;&amp;gt; chunk('abcdefghij', 3)
['abc', 'def', 'ghi', 'j']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(By the way, I&amp;#8217;m using strings rather than lists in the examples. The code works equally well for both types, and strings make it slightly easier to see what&amp;#8217;s going on.)
&lt;/p&gt;
&lt;p&gt;One way to fix the problem is to group the final chunks together.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def chunk(xs, n):
    '''Split the list, xs, into n chunks'''
    L = len(xs)
    assert 0 &amp;lt; n &amp;lt;= L
    s, r = divmod(L, n)
    chunks = [xs[p:p+s] for p in range(0, L, s)]
    chunks[n-1:] = [xs[-r-s:]]
    return chunks

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now we have exactly &lt;code&gt;n&lt;/code&gt; chunks, but they may not be evenly sized, since the last chunk gets padded with any surplus.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; chunk('abcde', 3)
['a', 'b', 'cde']
&amp;gt;&amp;gt;&amp;gt; chunk('abcdefgh', 3)
['ab', 'cd', 'efgh']
&amp;gt;&amp;gt;&amp;gt; chunk('abcdefghij', 3)
['abc', 'def', 'ghij']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;What does &amp;#8220;evenly sized&amp;#8221; actually mean? Loosely speaking, we want the resulting chunks as closely sized as possible.
&lt;/p&gt;
&lt;p&gt;More precisely, if the result of dividing the length of the list &lt;code&gt;L&lt;/code&gt; by the number of chunks &lt;code&gt;n&lt;/code&gt; gives a size &lt;code&gt;s&lt;/code&gt; with remainder &lt;code&gt;r&lt;/code&gt;, then the function should return &lt;code&gt;r&lt;/code&gt; chunks of size &lt;code&gt;s+1&lt;/code&gt; and &lt;code&gt;n-r&lt;/code&gt; chunks of size &lt;code&gt;s&lt;/code&gt;. There are &lt;a href="https://en.wikipedia.org/wiki/Combination"&gt;choose(n, r)&lt;/a&gt; ways of doing this. Here&amp;#8217;s a solution which puts the longer chunks to the front of the results.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def chunk(xs, n):
    '''Split the list, xs, into n evenly sized chunks'''
    L = len(xs)
    assert 0 &amp;lt; n &amp;lt;= L
    s, r = divmod(L, n)
    t = s + 1
    return ([xs[p:p+t] for p in range(0, r*t, t)] +
            [xs[p:p+s] for p in range(r*t, L, s)])

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a second implementation, this time using &lt;code&gt;itertools&lt;/code&gt;. Chaining &lt;code&gt;r&lt;/code&gt; copies of &lt;code&gt;s+1&lt;/code&gt; and &lt;code&gt;n-r&lt;/code&gt; copies of &lt;code&gt;s&lt;/code&gt; gives us the &lt;code&gt;n&lt;/code&gt; chunk widths. Accumulating the widths gives us the list offsets for slicing &amp;#8212; though note we need to prepend an initial &lt;code&gt;0&lt;/code&gt;. Now we can form a &lt;a href="http://wordaligned.org/articles/zippy-triples-served-with-python"&gt;(this, next) pair of iterators&lt;/a&gt; over the offsets, and the result is the accumulation of repeated &lt;code&gt;(begin, end)&lt;/code&gt; slices taken from the original list.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import accumulate, chain, repeat, tee

def chunk(xs, n):
    assert n &amp;gt; 0
    L = len(xs)
    s, r = divmod(L, n)
    widths = chain(repeat(s+1, r), repeat(s, n-r))
    offsets = accumulate(chain((0,), widths))
    b, e = tee(offsets)
    next(e)
    return [xs[s] for s in map(slice, b, e)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This version does something sensible in the case when the number of slices, &lt;code&gt;n&lt;/code&gt;, exceeds the length of the list.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; chunk('ab', 5)
['a', 'b', '', '', '']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Finally, some tests.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def test_chunk():
    assert chunk('', 1) == ['']
    assert chunk('ab', 2) == ['a', 'b']
    assert chunk('abc', 2) == ['ab', 'c']
    
    xs = list(range(8))
    assert chunk(xs, 2) == [[0, 1, 2, 3], [4, 5, 6, 7]]
    assert chunk(xs, 3) == [[0, 1, 2], [3, 4, 5], [6, 7]]
    assert chunk(xs, 5) == [[0, 1], [2, 3], [4, 5], [6], [7]]
    
    rs = range(1000000)
    assert chunk(rs, 2) == [range(500000), range(500000, 1000000)]

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2017-05-14</dc:date>
<guid>http://wordaligned.org/articles/slicing-a-list-evenly-with-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/slicing-a-list-evenly-with-python</link>
<category>Python</category>
</item>

<item>
<title>From bytes to strings in Python and back again</title>
<description>&lt;p&gt;Low level languages like C have little opinion about what goes in a string, which is simply a null-terminated sequence of bytes. Those bytes could be ASCII or UTF-8 encoded text, or they could be raw data &amp;#8212; object code, for example. It&amp;#8217;s quite possible and legal to have a C string with mixed content.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char const * mixed =
    "EURO SIGN "          // ASCII
    "UTF-8 \xE2\x82\xAC " // UTF-8 encoded EURO SIGN
    "Latin-9 \xA4";       // Latin-9 encoded EURO SIGN
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This might seem indisciplined and risky but it can be useful. Environment variables are notionally text but actually C strings, for example, meaning they can hold whatever data you want. Similarly filenames and command line parameters are only loosely text.
&lt;/p&gt;
&lt;p&gt;A higher level language like Python makes a strict distinction between bytes and strings. Bytes objects contain raw data &amp;#8212; a sequence of octets &amp;#8212; whereas strings are Unicode sequences. Conversion between the two types is explicit: you encode a string to get bytes, specifying an encoding (which defaults to UTF-8); and you decode bytes to get a string. Clients of these functions should be aware that such conversions may fail, and should consider how failures are handled.
&lt;/p&gt;
&lt;p&gt;Simply put, a string in Python is a valid Unicode sequence. Real world text data may not be. Programmers need to take charge of reconciling any discrepancies.
&lt;/p&gt;
&lt;p&gt;We faced such problems recently &lt;a href="https://clinithink.com"&gt;at work&lt;/a&gt;. We&amp;#8217;re in the business of extracting meaning from clinical narratives &amp;#8212; text data stored on medical records systems in hospitals, for example. These documents may well have passed through a variety of systems. They may be unclear about their text encoding. They may not be encoded as they claim. So what? They can and do contain abbreviations, mispellings, jargon and colloquialisms. Refining the signal from such noise is our core business: if we can correctly interpret positional and temporal aspects of a sentence such as:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Previous fracture of left neck of femur
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;then we can surely deal with text which claims to be UTF-8 encoded but isn&amp;#8217;t really.
&lt;/p&gt;
&lt;p&gt;Our application stack is server-based: a REST API to a Python application handles document ingest; lower down, a C++ engine does the actual document processing. The problem we faced was supporting a modern API capable of handling real world data.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s both undesirable and unnecessary to require clients to clean their text before submitting it. We want to make the ingest direct and idiomatic. Also, we shouldn&amp;#8217;t penalise clients whose data &lt;strong&gt;is&lt;/strong&gt; clean. Thus document upload is an HTTP POST request, and the document content is a JSON string &amp;#8212; rather than, say, base64 encoded binary data. Our server, however, will be permissive about the contents of this string.
&lt;/p&gt;
&lt;p&gt;So far so good. &lt;a href="http://www.catb.org/jargon/html/P/Postels-Prescription.html" title="Postel's prescription"&gt;Postel&amp;#8217;s prescription&lt;/a&gt; advises:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Be liberal in what you accept, and conservative in what you send.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;This would suggest accepting messy text data but presenting it in a cleaned up form. In our case, we &lt;strong&gt;do&lt;/strong&gt; normalise the input data &amp;#8212; a process which includes detecting and standardising date/time information, expanding abbreviations, fixing typos and so on &amp;#8212; but this normalised form links back to a faithful copy of the original data. What gets presented to the user is their own text annotated with our findings. That is, we subscribe to a &lt;a href="https://en.wikipedia.org/wiki/Garbage_in,_garbage_out"&gt;more primitive prescription&lt;/a&gt; than Postel&amp;#8217;s:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Garbage in, garbage out
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;with the caveat that the garbage shouldn&amp;#8217;t be damaged in transit.
&lt;/p&gt;
&lt;p&gt;Happily, there is a simple way to pass dodgy strings through Python. It&amp;#8217;s used in the standard library to handle text data which isn&amp;#8217;t guaranteed to be clean &amp;#8212; those environment variables, command line parameters, and filenames for example.
&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;surrogateescape&lt;/code&gt; error handler smuggles non-decodable bytes into the (Unicode) Python string in such a way that the original bytes can be recovered on encode, as described in &lt;a href="https://www.python.org/dev/peps/pep-0383/" title="PEP 383 -- Non-decodable Bytes in System Character Interfaces"&gt;PEP 383&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;On POSIX systems, Python currently applies the locale&amp;#8217;s encoding to convert the byte data to Unicode, failing for characters that cannot be decoded. With &lt;a href="https://www.python.org/dev/peps/pep-0383/" title="PEP 383 -- Non-decodable Bytes in System Character Interfaces"&gt;this PEP&lt;/a&gt;, non-decodable bytes &amp;gt;= 128 will be represented as lone surrogate codes U+DC80..U+DCFF.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;This workaround is possible because Unicode surrogates are intended for use in pairs. Quoting the Unicode specification, they &lt;a href="http://www.unicode.org/versions/Unicode9.0.0/ch03.pdf#G2630"&gt;&amp;#8220;have no interpretation on their own&amp;#8221;&lt;/a&gt;. The lone trailing surrogate code &amp;#8212; the half-a-pair &amp;#8212; can only be the result of a &lt;code&gt;surrogateescape&lt;/code&gt; error handler being invoked, and the original bytes can be recovered by using the same error handler on encode.
&lt;/p&gt;
&lt;p&gt;In conclusion, text data is handled differently in C++ and Python, posing a problem for layered applications. The &lt;code&gt;surrogateescape&lt;/code&gt; error handler provides a standard and robust way of closing the gap.
&lt;/p&gt;

&lt;h2&gt;Unicode Surrogate Pairs&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.unicode.org/versions/Unicode9.0.0/ch03.pdf#G2630"&gt;&lt;img src="http://wordaligned.org/images/unicode-surrogates.png" alt="Surrogates"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h2&gt;Code Listing&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; mixed = b"EURO SIGN \xE2\x82\xAC \xA4"
&amp;gt;&amp;gt;&amp;gt; mixed
b'EURO SIGN \xe2\x82\xac \xa4'
&amp;gt;&amp;gt;&amp;gt; mixed.decode()
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xa4 in position 14:
  invalid start byte
&amp;gt;&amp;gt;&amp;gt; help(mixed.decode)
Help on built-in function decode:

decode(encoding='utf-8', errors='strict') method of builtins.bytes instance
    Decode the bytes using the codec registered for encoding.

encoding
      The encoding with which to decode the bytes.
    errors
      The error handling scheme to use for the handling of decoding errors.
      The default is 'strict' meaning that decoding errors raise a
      UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
      as well as any other name registered with codecs.register_error that
      can handle UnicodeDecodeErrors.

&amp;gt;&amp;gt;&amp;gt; mixed.decode(errors='surrogateescape')
'EURO SIGN &amp;euro; \udca4'
&amp;gt;&amp;gt;&amp;gt; s = mixed.decode(errors='surrogateescape')
&amp;gt;&amp;gt;&amp;gt; s.encode()
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
UnicodeEncodeError: 'utf-8' codec can't encode character '\udca4' in position 12:
  surrogates not allowed
&amp;gt;&amp;gt;&amp;gt; s.encode(errors='surrogateescape')
b'EURO SIGN \xe2\x82\xac \xa4'
&lt;/code&gt;&lt;/pre&gt;</description>
<dc:date>2017-03-24</dc:date>
<guid>http://wordaligned.org/articles/from-bytes-to-strings-in-python-and-back-again</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/from-bytes-to-strings-in-python-and-back-again</link>
<category>Python</category>
</item>

<item>
<title>24 Puzzles</title>
<description>&lt;p&gt;On &lt;a href="http://blog.plover.com"&gt;The Universe of Discourse&lt;/a&gt; Mark Dominus discusses the classic &lt;a href="http://blog.plover.com/math/24-puzzle.html"&gt;24 Puzzle&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;You are given a sequence of four digits, say 1, 2, 3, 4, and your job is to combine them with ordinary arithmetic operations (+, -, &amp;times;, and &amp;divide;) in any order to make a target number, typically 24. For example, with 1, 2, 3, 4, you can go with &lt;code&gt;((1+2)+3)&amp;times;4=24&lt;/code&gt; or with &lt;code&gt;4&amp;times;((2&amp;times;3)&amp;times;1)=24&lt;/code&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Here&amp;#8217;s a solver for such puzzles. It uses &lt;code&gt;itertools&lt;/code&gt; to generate possible expressions, &lt;code&gt;fractions&lt;/code&gt; to get the arithmetic right, and &lt;code&gt;eval&lt;/code&gt; to evaluate expressions. It&amp;#8217;s limited to expressions formed from 4 numbers which means I don&amp;#8217;t have to programmatically calculate different ways of parenthesising: there are only 5.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;# http://blog.plover.com/math/24-puzzle.html
import re
import math

# Use fractions for exact calculations
from fractions import Fraction

# Solve for 4 numbers only!
N = 4

# So these are the only expression templates
# where X is a number and @ is an operation
templates = '''\
((X @ X) @ X) @ X
(X @ (X @ X)) @ X
X @ ((X @ X) @ X)
X @ (X @ (X @ X))
(X @ X) @ (X @ X)'''.splitlines()

import itertools as its

def defrac(s):
    return re.compile(r'Fraction\((\d+)\)').sub(r'\1', s)

def evaluate(nums, ops, template):
    fracs = ('Fraction(%s)' % n for n in nums)
    ops = iter(ops)
    expr = ''.join(next(fracs) if c == 'X' else
                   next(ops) if c == '@' else c
                   for c in template)
    try:
        return expr, eval(expr)
    except ZeroDivisionError:
        return expr, None

def solve(spec, ops):
    numbers = re.compile(r'\d+').findall(spec)
    assert len(numbers) == N + 1
    result = Fraction(numbers.pop())
    seqs = its.product(its.permutations(numbers),
                       its.product(ops, repeat=N-1),
                       templates)
    print(defrac(next((e for e, v in its.starmap(evaluate, seqs)
                       if v == result),
                      'Impossible')))

def main():
    solve('2,5,6,6 =&amp;gt; 17', '+-/*')
    solve('3,3,8,8 =&amp;gt; 24', '+-/*')

main()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a second attempt, which doesn&amp;#8217;t assume there will just be 4 numbers on the left hand side of the equation. Given a sequence of numbers and a set of operators, it repeatedly reduces the sequence length by picking pair of numbers and combining them using one of the operators, iterating over all possible ways of doing this. The first sequence of length 1 which equals the target value gives a solution and terminates the search.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;# http://blog.plover.com/math/24-puzzle.html
from fractions import Fraction
import itertools as its
import operator
import re

def pick2(xs):
    return ((p[:2], p[2:]) for p in its.permutations(xs))

def allow(op, l, r):
    return op != '/' or eval(r) != 0

def apply(op, l, r):
    return '(%s%s%s)'%(l, op, r)

def values(xs, ops):
    L = [xs]
    while L:
        xs = L.pop()
        if len(xs) == 1:
            yield xs.pop()
        else:
            L.extend([apply(op, *lr)] + list(tl)
                     for op, (lr, tl) in its.product(ops, pick2(xs))
                     if allow(op, *lr))

def solve(spec, ops):
    numbers = ['Fraction(%s)'%n for n in re.compile(r'\d+').findall(spec)]
    target = eval(numbers.pop())
    print(next((v for v in values(numbers, ops) if eval(v) == target), 'Impossible'))

def main():
    solve('2,5,6,6 =&amp;gt; 17', '+-/*')
    solve('3,3,8,8 =&amp;gt; 24', '+-/*')

main()

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2017-03-08</dc:date>
<guid>http://wordaligned.org/articles/24-puzzles</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/24-puzzles</link>
<category>Python</category>
</item>

<item>
<title>Negative Sequence Indices in Python</title>
<description>&lt;p&gt;Supply a negative index when accessing a sequence and Python counts back from the end. So, for example, &lt;code&gt;my_list[-2]&lt;/code&gt; is the penultimate element of &lt;code&gt;my_list&lt;/code&gt;, which is much better than &lt;code&gt;my_list[len(my_list)-2]&lt;/code&gt; or even &lt;code&gt;*(++my_list.rbegin())&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;That final example uses one of C++&amp;#8217;s reverse iterators. It gets the penultimate element of a collection by advancing an iterator from the reversed beginning of that collection. If you&amp;#8217;re addicted to negative indices you &lt;strong&gt;can&lt;/strong&gt; use them with C++ arrays, sort of.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Negative array indices in C++&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    char const * domain = "wordaligned.org";
    char const * end = domain + strlen(domain);
    std::cout &amp;lt;&amp;lt; end[-3] &amp;lt;&amp;lt; end[-2] &amp;lt;&amp;lt; end[-1] &amp;lt;&amp;lt; '\n';
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Compiling and running this program outputs the string &amp;#8220;org&amp;#8221;.
&lt;/p&gt;
&lt;p&gt;Going back to Python, the valid indices into a sequence of length &lt;code&gt;L&lt;/code&gt; are &lt;code&gt;-L&lt;/code&gt;, &lt;code&gt;-L+1&lt;/code&gt;, &amp;#8230; , &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &amp;#8230; &lt;code&gt;L-1&lt;/code&gt;. Whenever you write code to calculate an index used for accessing a sequence, and especially if you&amp;#8217;re catching any resulting &lt;code&gt;IndexError&lt;/code&gt;s, it&amp;#8217;s worth checking if the result of the calculation can be negative, and if &amp;#8212; in this case &amp;#8212; you really do want the from-the-back indexing behaviour.
&lt;/p&gt;
&lt;div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;0&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;1&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;2&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;3&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;4&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;5&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;6&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;7&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;8&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;9&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;10&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;11&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;12&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;13&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;hellip;&lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;W&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;O&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;R&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;D&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;A&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;L&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;I&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;G&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;N&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;E&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;D&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;hellip;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-14&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-13&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-12&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-11&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-10&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-9&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-8&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-7&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-6&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-5&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-4&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-3&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-2&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;-1&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;div style="line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;"&gt;&amp;nbsp;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The power of negative indices increases with slicing. Take a slice of a sequence by supplying begin and end indices.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; domain = 'wordaligned.org'
&amp;gt;&amp;gt;&amp;gt; domain[4:9]
'align'
&amp;gt;&amp;gt;&amp;gt; domain[4:-4]
'aligned'
&amp;gt;&amp;gt;&amp;gt; digits = list(range(10))
&amp;gt;&amp;gt;&amp;gt; digits
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&amp;gt;&amp;gt;&amp;gt; digits[3:4]
[3]
&amp;gt;&amp;gt;&amp;gt; digits[1:-1]
[1, 2, 3, 4, 5, 6, 7, 8]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Omitting an index defaults it to the end of the sequence. Omit both indices and both ends of the sequence are defaulted, giving a sliced copy.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; domain[-3:]
'org'
&amp;gt;&amp;gt;&amp;gt; domain[:4]
'word'
&amp;gt;&amp;gt;&amp;gt; digits[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I prefer the &lt;code&gt;list(digits)&lt;/code&gt; form for copying &lt;code&gt;digits&lt;/code&gt; but you should certainly be familiar with the &lt;code&gt;digits[:]&lt;/code&gt; version.
&lt;/p&gt;
&lt;p&gt;You can supply any indices as slice limits, even ones which wouldn&amp;#8217;t be valid for item access. Imagine laying your sequence out on an indexed chopping board, slicing it at the specified points, then taking whatever lies between these points.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; digits[-1000000]
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&amp;gt;&amp;gt;&amp;gt; digits[1000000]
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&amp;gt;&amp;gt;&amp;gt; digits[-1000000:1000000]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Sequence slicing also takes a step parameter.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; digits[::2]
[0, 2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; digits[1::2]
[1, 3, 5, 7, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This parameter too can be negative. The sign of the step affects which limiting values the &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; slice parameters default to. It&amp;#8217;s subtle behaviour, but you soon get used to it.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; digits[0:10:-2]
[]
&amp;gt;&amp;gt;&amp;gt; digits[::-2]
[9, 7, 5, 3, 1]
&amp;gt;&amp;gt;&amp;gt; digits[-2::-2]
[8, 6, 4, 2, 0]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How do you reverse a string? Slice it back to front!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; domain[::-1]
'gro.dengiladrow'

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To recap: the default slice limits are the start and end of the sequence, &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;-1&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; if the step is negative. The default step is &lt;code&gt;1&lt;/code&gt; whichever way round the limits are. When slicing, &lt;code&gt;s[i:j:k]&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; may take any integer value, and &lt;code&gt;k&lt;/code&gt; can take any integer value &lt;strong&gt;except&lt;/strong&gt; &lt;code&gt;0&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;The zero value creates another interesting edge case. Here&amp;#8217;s a function to return the last &lt;code&gt;n&lt;/code&gt; items of a sequence.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; def tail(xs, n)
...     return xs[-n:]
...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It fails when &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; tail(digits, 3)
[7, 8, 9]
&amp;gt;&amp;gt;&amp;gt; tail(digits, 2)
[8, 9]
&amp;gt;&amp;gt;&amp;gt; tail(digits, 1)
[9]
&amp;gt;&amp;gt;&amp;gt; tail(digits, 0)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;By the way, we&amp;#8217;ve already seen slicing working well with lists and strings. It also works nicely with range objects.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; r = range(10)
&amp;gt;&amp;gt;&amp;gt; r[::2]
range(0, 10, 2)
&amp;gt;&amp;gt;&amp;gt; r[1::2]
range(1, 10, 2)

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2016-08-01</dc:date>
<guid>http://wordaligned.org/articles/negative-sequence-indices-in-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/negative-sequence-indices-in-python</link>
<category>Python</category>
</item>

<item>
<title>Python Streams vs Unix Pipes</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocinfinite-series-and-python" name="toc0" id="toc0"&gt;Infinite series and Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocinfinite-series-in-other-languages" name="toc1" id="toc1"&gt;Infinite series in Other Languages&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocpartial-sums" name="toc2" id="toc2"&gt;Partial sums.&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocconsecutive-sums" name="toc3" id="toc3"&gt;Consecutive sums&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocbug-fixes" name="toc4" id="toc4"&gt;Bug Fixes&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocmerging-streams" name="toc5" id="toc5"&gt;Merging Streams&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocgenerating-primes" name="toc6" id="toc6"&gt;Generating Primes&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocpipe-connection" name="toc7" id="toc7"&gt;Pipe Connection&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocportability" name="toc8" id="toc8"&gt;Portability&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocstream-merge" name="toc9" id="toc9"&gt;Stream Merge&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#tocalternative-solutions" name="toc10" id="toc10"&gt;Alternative Solutions&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;I chanced upon an interesting puzzle:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Find the smallest number that can be expressed as the sum of 5, 17, 563, 641 consecutive prime numbers, and is itself a prime number.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;img src="http://wordaligned.org/images/primes.png" alt="Small primes graphic"/&gt;

&lt;p&gt;Here, the prime numbers are an infinite steam:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;2, 3, 5, 7, 11, 13 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;and sums of N consecutive primes are similarly infinite. For example, the sum of 2 consecutive primes would be the stream:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;2+3, 3+5, 5+7, 7+11, 11+13 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;which is:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;5, 8, 12, 18, 24 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;and the sum of 3 consecutive primes is:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;10 (=2+3+5), 15, 23, 31 ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Had we been asked to find the smallest number which can be expressed as the sum of 3 consecutive primes and as the sum of 5 consecutive primes and is itself prime, the answer would be &lt;code&gt;83&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; 23 + 29 + 31
83
&amp;gt;&amp;gt;&amp;gt; 11 + 13 + 17 + 19 + 23
83

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc0" name="tocinfinite-series-and-python" id="tocinfinite-series-and-python"&gt;Infinite series and Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;My first thought was to tackle this puzzle using Python iterators and generators. Here&amp;#8217;s the outline of a strategy:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     starting with a stream of primes
 &lt;/li&gt;

 &lt;li&gt;
     tee the stream to create 4 additional copies
 &lt;/li&gt;

 &lt;li&gt;
     transform these copies into the consecutive sums of 5, 17, 563 and 641 primes
 &lt;/li&gt;

 &lt;li&gt;
     now merge these consecutive sums back with the original primes stream
 &lt;/li&gt;

 &lt;li&gt;
     group the elements of this merged stream by value
 &lt;/li&gt;

 &lt;li&gt;
     the first group which contains 5 elements must have occurred in every source, and is therefore a prime and representable as the consecutive sum of 5, 17, 563 and 641 primes
 &lt;/li&gt;

 &lt;li&gt;
     which solves the puzzle!
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that when we copy an infinite stream we cannot consume it first. We will have to be lazy or we&amp;#8217;ll get exhausted.
&lt;/p&gt;
&lt;p&gt;Courtesy of the Python Cookbook, I already had a couple of &lt;a href="http://www.onlamp.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=2"&gt;useful&lt;/a&gt; &lt;a href="http://code.activestate.com/recipes/491285-iterator-merge/"&gt;recipes&lt;/a&gt; to help implement this strategy:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def primes():
    '''Generate the sequence of prime numbers: 2, 3, 5 ... '''
    ....

def stream_merge(*ss):
    '''Merge a collection of sorted streams.
    
    Example: merge multiples of 2, 3, 5
    &amp;gt;&amp;gt;&amp;gt; from itertools import count, islice
    &amp;gt;&amp;gt;&amp;gt; def multiples(x): return (x * n for n in count(1))
    &amp;gt;&amp;gt;&amp;gt; s = stream_merge(multiples(2), multiples(3), multiples(5))
    &amp;gt;&amp;gt;&amp;gt; list(islice(s, 10))
    [2, 3, 4, 5, 6, 6, 8, 9, 10, 10]
    '''
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Both these functions merit a closer look for the cunning use they make of standard containers, but we&amp;#8217;ll defer this inspection until later. In passing, note that &lt;code&gt;stream_merge()&lt;/code&gt;&amp;#8217;s docstring suggests we might try using it as basis for &lt;code&gt;primes()&lt;/code&gt;:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;form the series of composite (non-prime) numbers by merging the streams formed by multiples of prime numbers; 
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;the primes remain when you remove these composites from the series of natural numbers.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This scheme is hardly original &amp;#8212; it&amp;#8217;s a variant of &lt;a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"&gt;Eratosthenes&amp;#8217; sieve&lt;/a&gt; &amp;#8212; but if you look carefully you&amp;#8217;ll notice the self-reference. Unfortunately recursive definitions of infinite series don&amp;#8217;t work well with Python&lt;a id="fn1link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;, hence &lt;code&gt;primes()&lt;/code&gt; requires a little more finesse. We&amp;#8217;ll take a look at it later.
&lt;/p&gt;
&lt;p&gt;Moving on, to solve the original puzzle we need a consecutive sum filter. This will transform a stream of numbers into a stream of consecutive sums of these numbers:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def consecutive_sum(s, n):
    '''Generate the series of sums of n consecutive elements of s
    
    Example: 0, 1, 2, 3, 4 ... =&amp;gt; 0+1, 1+2, 2+3, 3+4, ...
    &amp;gt;&amp;gt;&amp;gt; from itertools import count, islice
    &amp;gt;&amp;gt;&amp;gt; list(islice(consecutive_sum(count(), 2), 10))
    [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    '''
    lo, hi = itertools.tee(s)
    csum = sum(next(hi) for _ in range(n))
    while True:
        yield csum
        csum += next(hi) - next(lo)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here we can think of the summed elements as lying within a sliding window: each time we slide the window an element gets added to the top and an element gets removed from the bottom, and we adjust &lt;code&gt;csum&lt;/code&gt; accordingly.
&lt;/p&gt;
&lt;p&gt;So, now we have:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     the series of prime numbers, &lt;code&gt;primes()&lt;/code&gt;
 &lt;/li&gt;

 &lt;li&gt;
     a &lt;code&gt;stream_merge()&lt;/code&gt; connector
 &lt;/li&gt;

 &lt;li&gt;
     a &lt;code&gt;consecutive_sum()&lt;/code&gt; filter
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The remaining stream adaptors come from the standard &lt;a href="http://docs.python.org/lib/itertools-functions.html"&gt;itertools module&lt;/a&gt;. Note that the &lt;code&gt;stream_merge()&lt;/code&gt; works here since all the consecutive sum series are strictly increasing. Note also that the stream of prime numbers can be treated as &lt;code&gt;consecutive_sum(s=primes(), n=1)&lt;/code&gt;, handling the &amp;#8220;and is itself a prime number&amp;#8221; requirement.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; lens = 1, 5, 17, 563, 641
&amp;gt;&amp;gt;&amp;gt; N = len(lens)
&amp;gt;&amp;gt;&amp;gt; from itertools import tee, groupby
&amp;gt;&amp;gt;&amp;gt; ps = tee(primes(), N)
&amp;gt;&amp;gt;&amp;gt; csums = [consecutive_sum(p, n) for p, n in zip(ps, lens)]
&amp;gt;&amp;gt;&amp;gt; solns = (n for n, g in groupby(stream_merge(*csums)) 
             if len(list(g)) == N)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;solns&lt;/code&gt; is yet another stream, the result of merging the &lt;code&gt;N&lt;/code&gt; input consecutive sum streams then filtering out the numbers which appear &lt;code&gt;N&lt;/code&gt; times; that is, the numbers which can be expressed as sums of 1, 5, 17, 563 and 641 consecutive primes.
&lt;/p&gt;
&lt;p&gt;The first such number solves the original puzzle.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; next(solns)
7002221

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a picture of how these stream tools link up to solve this particular puzzle. The great thing is that we can reconnect these same tools to solve a wide range of puzzles, and indeed more practical &lt;a href="http://www.dabeaz.com/generators/"&gt;processing tasks&lt;/a&gt;. To use the common analogy, we direct data streams along pipes.
&lt;/p&gt;
&lt;img alt="Stream connections" src="http://wordaligned.org/images/pipeline.png"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc1" name="tocinfinite-series-in-other-languages" id="tocinfinite-series-in-other-languages"&gt;Infinite series in Other Languages&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Python is the language I find most convenient most of the time, which explains why I reached for it first. It&amp;#8217;s an increasingly popular language, which helps explain why I didn&amp;#8217;t need to write the tricky parts of my solution from scratch: they&amp;#8217;d already been done. Python is also a language which makes compromises. Having used Python to find a solution to the puzzle I wondered if there wasn&amp;#8217;t some other language better suited to this kind of problem.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://haskell.org"&gt;Haskell&lt;/a&gt; makes no compromises when it comes to functional programming. Its lazy evaluation and inductive recursion make it a perfect fit for this kind of puzzle &amp;#8212; but my  approach of teeing, filtering and merging made me consider the Unix Shell. Now, I use Bash every day and page through its manual at least once a week. Scripting appeals and I&amp;#8217;m comfortable at the command line. How hard could it be to solve this puzzle using Bash? After all, I already knew the answer!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc2" name="tocpartial-sums" id="tocpartial-sums"&gt;Partial sums.&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple shell function to generate partial sums. I&amp;#8217;ve used &lt;code&gt;awk&lt;/code&gt;, a little language I gave up on a long time ago in favour of more rounded scripting languages like Perl and then Python. Now I look at it again, it seems to fill a useful gap. Awk processes a file sequentially, applying pattern-action rules to each line, a processing template which I&amp;#8217;ve reinvented less cleanly many times. Despite my rediscovery of &lt;code&gt;awk&lt;/code&gt;, I&amp;#8217;ll be keeping its use strongly in check in what follows.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ psum() { awk '{ print s += $1 }'; }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Much like Perl, &lt;code&gt;awk&lt;/code&gt; guesses what you want to do. Here, it conjures the summation variable, &lt;code&gt;s&lt;/code&gt;, into existence, assigning it a default initial value of 0. (Good guess!) Since we&amp;#8217;re doing arithmetic &lt;code&gt;awk&lt;/code&gt; converts the first field of each input line into a number. We can test &lt;code&gt;psum&lt;/code&gt; by using &lt;code&gt;jot&lt;/code&gt; to generate the sequence 1, 2, 3, 4, 5 (this is on a Mac &amp;#8212; on a Linux platform use &lt;code&gt;seq&lt;/code&gt; instead of &lt;code&gt;jot&lt;/code&gt;).
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ jot 5 | psum
1
3
6
10
15

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc3" name="tocconsecutive-sums" id="tocconsecutive-sums"&gt;Consecutive sums&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You may be wondering why we&amp;#8217;ve bothered creating this partial sum filter since it&amp;#8217;s the sums of consecutive elements we&amp;#8217;re after, rather than the sum of the series so far. Well, notice that if &lt;code&gt;P[i]&lt;/code&gt; and &lt;code&gt;P[i+n]&lt;/code&gt; are two elements from the series of partial sums of S, then their difference, &lt;code&gt;P[i+n] - P[i]&lt;/code&gt;, is the sum of the &lt;code&gt;n&lt;/code&gt; consecutive elements from S.
&lt;/p&gt;
&lt;p&gt;So to form an n-element consecutive sum series we can tee the partial sums streams, advance one of these by n, then zip through them in parallel finding their differences. An example makes things clear:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ mkfifo pipe
$ jot 5 | psum | tee pipe | tail -n +2 | paste - pipe
3       1
6       3
10      6
15      10
        15

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;jot 5&lt;/code&gt; generates the sequence 1, 2, 3, 4, 5, which &lt;code&gt;psum&lt;/code&gt; progressively accumulates to 1, 3, 6, 10, 15. We then &lt;code&gt;tee&lt;/code&gt; this partial sum series through two pipes: the first, &lt;code&gt;pipe&lt;/code&gt;, is an explicitly created named pipe created by &lt;code&gt;mkfifo&lt;/code&gt;, the second is implicitly created by the pipeline operator, &lt;code&gt;|&lt;/code&gt;. The remainder of the command line delays one series by one (note that &lt;code&gt;tail&lt;/code&gt; numbers lines from &lt;code&gt;1&lt;/code&gt;, not &lt;code&gt;0&lt;/code&gt;, so &lt;code&gt;tail -n +1&lt;/code&gt; is the identity filter) then pastes the two series back together&lt;a id="fn2link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;By appending a single &lt;code&gt;awk&lt;/code&gt; action to the pipeline we get a consecutive sum series.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ jot 5 | psum | tee pipe | tail -n +2 | paste - pipe | awk '{print $1 - $2}'
2
3
4
5
15

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The output 2, 3, 4, 5 is the series of consecutive sums of length 1 taken from the original series 1, 2, 3, 4, 5. The trailing 15 and the 1 missed from the start are edge case problems, and easily corrected.
&lt;/p&gt;
&lt;p&gt;Accumulating an increasing series of numbers in order to find the differences between elements lying a given distance apart on this series isn&amp;#8217;t a very smart idea on a computer with a fixed word-size, but it&amp;#8217;s good to know (e.g.) that &lt;code&gt;awk&lt;/code&gt; doesn&amp;#8217;t stop counting at 32 bits.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ let "N=1&amp;lt;&amp;lt;32" &amp;amp;&amp;amp; echo $N | tee &amp;gt;(awk '{print $1 * $1}')
4294967296
18446744073709551616

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Exactly if and when awk stops counting, I&amp;#8217;m not sure. The documentation doesn&amp;#8217;t say and I haven&amp;#8217;t looked at the source code.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc4" name="tocbug-fixes" id="tocbug-fixes"&gt;Bug Fixes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s capture these tiny functions and name them. Here, then, are revised &lt;code&gt;psum()&lt;/code&gt; and &lt;code&gt;sdiff()&lt;/code&gt; filters. The edge case problems should now be fixed.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ psum()  { awk 'BEGIN { print 0 }{print s += $1 }'; }
$ delay() { let "n = $1 + 1" &amp;amp;&amp;amp; tail +$n; } 
$ sdiff() { mkfifo p.$1 &amp;amp;&amp;amp; tee p.$1 | delay $1 | paste - p.$1 | \
            awk 'NF == 2 {print $1 - $2 }'; }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A quick test:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ jot 5 | psum | sdiff 3
6
9
12

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The output is, as expected, the series of sums of consecutive triples taken from 1, 2, 3, 4, 5 (6=1+2+3, 9=2+3+4, 12=3+4+5).
&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s a pernicious bug, though. These functions can&amp;#8217;t handle infinite series so they are of limited use as pipeline tools. For example, if we stream in the series 0, 1, 2, &amp;#8230; (generated here as the partial sums of the series 1, 1, 1, &amp;#8230;) nothing gets output and we have to interrupt the process.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;# This command appears to hang
$ yes 1 | psum | sdiff 1
^C

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To work around this is, we can use Gnu &lt;code&gt;stdbuf&lt;/code&gt; to prohibit &lt;code&gt;tail&lt;/code&gt; and &lt;code&gt;paste&lt;/code&gt; from using output buffers.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ psum()  { awk 'BEGIN { print 0 }{print s += $1 }'; }
$ delay() { let "n = $1 + 1" &amp;amp;&amp;amp; stdbuf -o 0 tail +$n; } 
$ sdiff() { mkfifo p.$1 &amp;amp;&amp;amp; tee p.$1 | delay $1 | \
            stdbuf -o 0 paste - p.$1 | \
            awk 'NF == 2 {print $1 - $2 }'; }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now the data flows again:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;# Accumulate the stream 1 1 1 ...
# and print the difference between successive elements
$ yes 1 | psum | sdiff 1
1
1
1
1
^C

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc5" name="tocmerging-streams" id="tocmerging-streams"&gt;Merging Streams&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Unix shell merges streams rather more succinctly than Python. &lt;code&gt;Sort -m&lt;/code&gt; does the job directly. Note that a standard &lt;code&gt;sort&lt;/code&gt; cannot yield any output until all its inputs are exhausted, since the final input item might turn out to be the one which should appear first in the output. Merge sort, &lt;code&gt;sort -m&lt;/code&gt;, can and does produce output without delay&lt;a id="fn3link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn3"&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ yes | sort
^C
$ yes | sort -m
y
y
y
y
y
^C

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc6" name="tocgenerating-primes" id="tocgenerating-primes"&gt;Generating Primes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;No doubt it&amp;#8217;s possible to generate the infinite series of prime numbers using native Bash code, but I chose to reuse the &lt;a href="http://www.onlamp.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=2"&gt;Python Cookbook recipe&lt;/a&gt; for the job.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;primes&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#!/usr/bin/env python
import itertools

def primes():
    '''Generate the prime number series: 2, 3, 5 ... '''
    D = {}
    for n in itertools.count(2):
        p = D.pop(n, None)
        if p is None:
            yield n
            D[n * n] = n
        else:
            x = n + p
            while x in D:
                x += p
            D[x] = p

for p in primes():
    print(p)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This is a subtle little program which makes clever use of Python&amp;#8217;s native hashed array container, the dictionary. In this case dictionary values are the primes less than &lt;code&gt;n&lt;/code&gt; and the keys are composite multiples of these primes. The loop invariant, roughly speaking, is that the dictionary values are the primes less than &lt;code&gt;n&lt;/code&gt;, and the corresponding keys are the lowest multiples of these primes greater than or equal to &lt;code&gt;n&lt;/code&gt;. It&amp;#8217;s a lazy, recursion-free take of Eratosthenes&amp;#8217; sieve.
&lt;/p&gt;
&lt;p&gt;For the purposes of this article the important things about this program are:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     it generates an infinite series of numbers to standard output&lt;a id="fn4link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn4"&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/a&gt;, making it a good source for a shell pipeline
 &lt;/li&gt;

 &lt;li&gt;
     by making it executable and adding the usual shebang incantation, we can invoke this Python program seamlessly from the shell.
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc7" name="tocpipe-connection" id="tocpipe-connection"&gt;Pipe Connection&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recall the original puzzle:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Find the smallest number that can be expressed as the sum of 5, 17, 563, 641 consecutive prime numbers, and is itself a prime number.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;First, let&amp;#8217;s check the connections by solving a simpler problem which we can manually verify: to find prime numbers which are also the sum of 2 consecutive primes. As we noted before, this is the same as finding primes numbers which are the consecutive sums of 1 and 2 primes.
&lt;/p&gt;
&lt;p&gt;In one shell window we create a couple of named pipes, &lt;code&gt;c.1&lt;/code&gt; and &lt;code&gt;c.2&lt;/code&gt;, which we&amp;#8217;ll use to stream the consecutive sum series of 1 and 2 primes respectively. The results series comprises the duplicates when we merge these pipes.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Shell 1&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ mkfifo c.{1,2}
$ sort -mn c.{1,2} | uniq -d

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In another shell window, stream data into c.1 and c.2:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Shell 2&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ for i in 1 2; do (primes | psum | sdiff $i &amp;gt; c.$i) &amp;amp; done

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In the first window we see the single number &lt;code&gt;5&lt;/code&gt;, which is the first and only prime number equal to the sum of two consecutive primes.
&lt;/p&gt;
&lt;p&gt;Prime numbers equal to the sum of three consecutive primes are more interesting. In each shell window recall the previous commands and switch the 2s to 3s (a simple command history recall and edit, &lt;code&gt;^2^3^&lt;/code&gt;, does the trick). The merged output now looks like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ sort -mn c.1 c.3 | uniq -d
23
31
41
...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can check the first few values:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;23 = 5 + 7 + 11
31 = 7 + 11 + 13
41 = 11 + 13 + 17

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;At this point we&amp;#8217;re confident enough to give the actual puzzle a try. Start up the solutions stream.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ mkfifo c.{1,5,17,563,641}
$ sort -mn c.{1,5,17,563,641} | uniq -c | grep "5 "

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, we use a standard &lt;a href="http://wordaligned.org/articles/shell-script-sets"&gt;shell script set intersection&lt;/a&gt; recipe: &lt;code&gt;uniq -c&lt;/code&gt; groups and counts repeated elements, and the &lt;code&gt;grep&lt;/code&gt; pattern matches those numbers common to all five input streams.
&lt;/p&gt;
&lt;p&gt;Now we can kick off the processes which will feed into the consecutive sum streams, which &lt;code&gt;sort&lt;/code&gt; is waiting on.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ for i in 1 5 17 563 641; do (primes | psum | sdiff $i &amp;gt; c.$i) &amp;amp; done

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Sure enough, after about 15 seconds elapsed time&lt;a id="fn5link" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn5"&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/a&gt;, out pops the result:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ sort -mn c.{1,5,17,563,641} | uniq -c | grep "5 "
    5 7002221

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;15 seconds seems an eternity for arithmetic on a modern computer (you could start up a word processor in less time!), and you might be inclined to blame the overhead of all those processes, files, large numbers, etc. In fact it took around 6 seconds for the Python program simply to generate prime numbers up to 7002221, and my pure Python solution ran in 9 seconds.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc8" name="tocportability" id="tocportability"&gt;Portability&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;One of the most convenient things about Python is its portability. I don&amp;#8217;t mean &amp;#8220;portable so long as you conform to the language standard&amp;#8221; or &amp;#8220;portable if you stick to a subset of the language&amp;#8221; &amp;#8212; I mean that a Python program works whatever platform I use without me having to worry about it.
&lt;/p&gt;
&lt;p&gt;Non-portability put me off the Unix shell when I first encountered it: there seemed too many details, too many platform differences &amp;#8212; which shell are you using? which extensions? which implementation of the core utilities, etc, etc? Readily available and well-written documentation didn&amp;#8217;t help much here: generally I want the shell to just do what I mean, which is why I switched so happily to Perl when I discovered it.
&lt;/p&gt;
&lt;p&gt;Since then this situation has, for me, improved in many ways. Non-Unix platforms are declining as are the different flavours of Unix. Bash seems to have become the standard shell of choice and Cygwin gets better all the time. GNU coreutils predominate. As a consequence I&amp;#8217;ve forgotten almost all the Perl I ever knew and am actively rediscovering the Unix shell.
&lt;/p&gt;
&lt;p&gt;Writing this article, though, I was reminded of the platform dependent behaviour which used to discourage me. On a Linux platform close to hand I had to use &lt;code&gt;seq&lt;/code&gt; instead of &lt;code&gt;jot&lt;/code&gt;, and &lt;code&gt;awk&lt;/code&gt; formatted large integers in a scientific form with a loss of precision.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Loss of precision&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ echo '10000000001 0' | awk '{print $1 - $2}'
1e+10

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;On OS X the same command outputs 10000000001. I couldn&amp;#8217;t tell you which implementation is more correct. The fix is to explicitly format these numbers as decimal integers, but the danger is that the shell silently swallows these discrepancies and you&amp;#8217;ve got a portability problem you don&amp;#8217;t even notice.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Precision recovered&lt;/div&gt;

&lt;pre class="prettyprint"&gt;$ echo '10000000001 0' | awk '{printf "%d\n", $1 - $2}'
10000000001

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc9" name="tocstream-merge" id="tocstream-merge"&gt;Stream Merge&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I mentioned &lt;code&gt;stream_merge()&lt;/code&gt; at the start of this article, a general purpose function written by Raymond Hettinger which I originally found in the Python Cookbook. As with the prime number generator, you might imagine the merge algorithm to be recursively defined:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;p&gt;to merge a pair of streams, take items from the first which are less than the head of the second, then swap;
&lt;/p&gt;

 &lt;/li&gt;

 &lt;li&gt;&lt;p&gt;to merge N streams, merge the first stream with the merged (N-1) rest.
&lt;/p&gt;

 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Again the Python solution does it differently, this time using a heap as a priority queue of items from the input streams. It&amp;#8217;s ingenious and efficient. Look how easy it is in Python to shunt functions and pairs in and out of queues.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from heapq import heapify, heappop, heapreplace

def stream_merge(*ss):
    '''Merge a collection of sorted streams.'''
    pqueue = []
    for i in map(iter, ss):
        try:
            pqueue.append((i.next(), i.next))
        except StopIteration:
            pass
    heapify(pqueue)
    while pqueue:
        val, it = pqueue[0]
        yield val
        try:
            heapreplace(pqueue, (it(), it))
        except StopIteration:
            heappop(pqueue)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A more sophisticated version of this code has made it into the Python standard library, where it goes by the name of &lt;a href="http://docs.python.org/dev/library/heapq.html#heapq.merge"&gt;heapq.merge&lt;/a&gt; (I wonder why it wasn&amp;#8217;t filed in &lt;a href="http://docs.python.org/lib/itertools-functions.html"&gt;itertools&lt;/a&gt;?)
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#toc10" name="tocalternative-solutions" id="tocalternative-solutions"&gt;Alternative Solutions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As usual Haskell wins the elegance award, so I&amp;#8217;ll quote in full a solution built without resorting to cookbookery which produces the (correct!) answer in 20 seconds.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;module Main where

import List

isPrime x = all (\i -&amp;gt; 0/=x`mod`i) $ takeWhile (\i -&amp;gt; i*i &amp;lt;= x) primes

primes = 2:filter (\x -&amp;gt; isPrime x) [3..]

cplist n = map (sum . take n) (tails primes)

meet (x:xs) (y:ys) | x &amp;lt; y = meet xs (y:ys)
                   | y &amp;lt; x = meet (x:xs) ys
                   | x == y =  x:meet xs ys

main = print $ head $ \
(primes `meet` cplist 5) `meet` (cplist 17 `meet` cplist 563) `meet` cplist 641

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn1link"&gt;[1]&lt;/a&gt; CPython, more precisely &amp;#8212; I don&amp;#8217;t think anything in the Python language itself prohibits tail recursion. Even using CPython, yet another &lt;a href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/496691"&gt;recipe&lt;/a&gt; from the online Python Cookbook explores the idea of an &lt;code&gt;@tail_recursion&lt;/code&gt; decorator.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn2link"&gt;[2]&lt;/a&gt; &lt;code&gt;Tail&lt;/code&gt; is more commonly used to yield a fixed number of lines from the end of the file: by prefixing the line count argument with a &lt;code&gt;+&lt;/code&gt; sign, it skips lines from the head of the file. The GNU version of &lt;code&gt;head&lt;/code&gt; can similarly be used with a &lt;code&gt;-&lt;/code&gt; prefix to skip lines at the tail of a file. The notation is {compact,powerful,subtle,implementation dependent}.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn3" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn3link"&gt;[3]&lt;/a&gt; &lt;code&gt;Sort -m&lt;/code&gt; is a sort which doesn&amp;#8217;t really sort &amp;#8212; its inputs should already be sorted &amp;#8212; rather like the &lt;code&gt;+n&lt;/code&gt; option turning &lt;code&gt;tail&lt;/code&gt; on its head.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn4" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn4link"&gt;[4]&lt;/a&gt; The series is infinite in theory only: at time &lt;code&gt;n&lt;/code&gt; the number of items in the &lt;code&gt;has_prime_factors&lt;/code&gt; dictionary equals the number of primes less than &lt;code&gt;n&lt;/code&gt;, and each key in this dictionary is larger than &lt;code&gt;n&lt;/code&gt;. So resource use increases steadily as &lt;code&gt;n&lt;/code&gt; increases.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn5" href="http://wordaligned.org/articles/python-streams-vs-unix-pipes#fn5link"&gt;[5]&lt;/a&gt; I used a MacBook laptop used to run these scripts. 
&lt;/p&gt;
&lt;pre&gt;
  Model Name:               MacBook
  Model Identifier:         MacBook1,1
  Processor Name:           Intel Core Duo
  Processor Speed:          2 GHz
  Number Of Processors:     1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;</description>
<dc:date>2016-07-28</dc:date>
<guid>http://wordaligned.org/articles/python-streams-vs-unix-pipes</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/python-streams-vs-unix-pipes</link>
<category>Python</category>
</item>

<item>
<title>8 Queens Puzzle</title>
<description>&lt;p style="font-size:4em"&gt;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&amp;#9819;&lt;/p&gt;

&lt;p&gt;Here&amp;#8217;s one of my favourite &lt;a href="http://code.activestate.com/recipes/576647-eight-queens-six-lines"&gt;recipes, by Raymond Hettinger&lt;/a&gt;, lightly adapted for Python 3.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from itertools import permutations

n = width_of_chessboard = 8
sqs = range(n)

Qs = (Q for Q in permutations(sqs)
      if n == len({Q[i]+i for i in sqs})
           == len({Q[i]-i for i in sqs}))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We start by assigning &lt;code&gt;sqs&lt;/code&gt; to the range 0 through 7.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sqs = range(8)
&amp;gt;&amp;gt;&amp;gt; list(sqs)
[0, 1, 2, 3, 4, 5, 6, 7]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The range has 8 indices. If each index represents a column on a standard 8x8 chessboard and the value at that index represents a row on the same chessboard, then our range represents 8 positions on the board. Using the built-in &lt;a href="https://docs.python.org/3/library/functions.html#enumerate"&gt;enumerate&lt;/a&gt; function to generate these &lt;code&gt;(index, value)&lt;/code&gt; pairs we see that &lt;code&gt;sqs&lt;/code&gt; encodes the diagonal &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(7, 7)&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(enumerate(sqs))
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7)]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, permute the values &amp;#8212; the rows.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; rooks = permutations(sqs)
&amp;gt;&amp;gt;&amp;gt; next(rooks)
(0, 1, 2, 3, 4, 5, 6, 7)
&amp;gt;&amp;gt;&amp;gt; next(rooks)
(0, 1, 2, 3, 4, 5, 7, 6)
&amp;gt;&amp;gt;&amp;gt; next(rooks)
(0, 1, 2, 3, 4, 6, 5, 7)
&amp;gt;&amp;gt;&amp;gt; list(rooks)[34567]
(6, 7, 0, 1, 3, 4, 5, 2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="https://docs.python.org/3/library/itertools.html#itertools.permutations"&gt;Itertools.permutations&lt;/a&gt; generates values lazily. The snippet above shows the first two results, then skips forward 34568 places. &lt;code&gt;Permutations(sqs)&lt;/code&gt; generates all possible arrangements of 8 pieces on a chessboard such that each row has exactly one piece on it and so does each column. That is, it generates all possible ways of placing 8 &lt;a href="http://mathworld.wolfram.com/RooksProblem.html"&gt;rooks on a chessboard&lt;/a&gt; so that no pair attacks each other.
&lt;/p&gt;
&lt;p&gt;In the final program, we filter these rook positions to generate solutions to the more challenging &amp;#8212; and more interesting &amp;#8212; &lt;a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle"&gt;eight Queens puzzle&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Consider our starting point, the diagonal &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(7, 7)&lt;/code&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; diagonal = range(8)
&amp;gt;&amp;gt;&amp;gt; {r-c for c,r in enumerate(diagonal)}
{0}
&amp;gt;&amp;gt;&amp;gt; {r+c for c,r in enumerate(diagonal)}
{0, 2, 4, 6, 8, 10, 12, 14}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, a set comprehension collects the distinct values taken by the difference between the row and column along this diagonal, which in this case gives &lt;code&gt;{0}&lt;/code&gt;. That is, if we placed 8 bishops along this &amp;#x2197; diagonal they would all attack each other along this diagonal. The sum of the row and column takes 8 distinct values, however, meaning no pair attacks along a &amp;#x2196; diagonal.
&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3/reference/expressions.html#comparisons"&gt;Comparison operators chain in Python&lt;/a&gt;, so the expression:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n == len({Q[i]+i for i in sqs}) == len({Q[i]-i for i in sqs})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is &lt;code&gt;True&lt;/code&gt; if both sets have 8 elements, that is, if the squares in &lt;code&gt;Q&lt;/code&gt; are on distinct &amp;#x2196; and &amp;#x2197; diagonals; or, equivalently no pair of bishops placed on the squares in &lt;code&gt;Q&lt;/code&gt; would attack each other. Since we already know &lt;code&gt;Q&lt;/code&gt; positions 8 rooks so that no pair attacks each other, and a chess Queen combines the moves of a rook and a bishop, we can see that &lt;code&gt;Qs&lt;/code&gt; generates every possible way of placing 8 Queens on a chessboard so that no pair attacks each other: which is to say, we&amp;#8217;ve solved the &lt;a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle"&gt;8 Queens puzzle&lt;/a&gt;.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Qs = (Q for Q in permutations(sqs)
      if n == len({Q[i]+i for i in sqs})
           == len({Q[i]-i for i in sqs}))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is beautiful code and there&amp;#8217;s one final twist.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Qs&lt;/code&gt; is a &lt;a href="https://docs.python.org/3/reference/expressions.html#generator-expressions"&gt;generator expression&lt;/a&gt; primed to permute squares into neighbourly rooks filtered by amicable bishops yielding unthreatening Queens. Until asked, however, it does nothing.
&lt;/p&gt;
&lt;p style="font-size:4em"&gt;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&amp;#9813;&lt;/p&gt;</description>
<dc:date>2016-04-04</dc:date>
<guid>http://wordaligned.org/articles/8-queens-puzzle</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/8-queens-puzzle</link>
<category>Python</category>
</item>

<item>
<title>Easy as Py</title>
<description>&lt;h2&gt;What makes Python Simple?&lt;/h2&gt;
&lt;p&gt;I consider Python a simple language. Here&amp;#8217;s why.
&lt;/p&gt;

&lt;h2&gt;Easy to Read&lt;/h2&gt;
&lt;p&gt;I can read and understand Python code (unless it&amp;#8217;s &lt;a href="https://benkurtovic.com/2014/06/01/obfuscating-hello-world.html"&gt;wilfully perverse&lt;/a&gt;). Syntactic whitespace and the associated removal of punctuation results in a regular, open layout. The combination of built in containers, extensive standard libraries and high level constructs allow for clear, compact code: code which fits in your head.
&lt;/p&gt;

&lt;h2&gt;Easy to Write&lt;/h2&gt;
&lt;p&gt;I can write Python code which is free of syntax errors and which does what I want. Of course it helps that I&amp;#8217;ve been actively using the language for 15 years, but I&amp;#8217;ve been using C++ for longer and still make mistakes with it: ask me to declare a pointer to a member function, for example, or to knock up a variadic template function, and I&amp;#8217;ll need a moment or two.
&lt;/p&gt;

&lt;h2&gt;Transparent&lt;/h2&gt;
&lt;p&gt;I also consider C a simple language. C offers a transparent abstraction of a register machine, with a stack, a heap, and addressable memory. If you can imagine the operation of such a machine, you can figure out C. Python is less transparent but reveals its workings if pressed. Dicts form a part of the language seen by users, and under the hood they provide the dynamic context which supports a running program. The &lt;a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop"&gt;read-eval-print loop&lt;/a&gt; makes it easy to poke and reshape your program. You can &lt;a href="https://docs.python.org/3/library/dis.html"&gt;disassemble code&lt;/a&gt; to see what the virtual machine sees.
&lt;/p&gt;

&lt;h2&gt;Consistent improvement&lt;/h2&gt;
&lt;p&gt;The language has got better since I first started using it. It has also got bigger, and this growth would, at first, seem at odds with simplicity. However, consider &amp;#8212; as an example &amp;#8212; the point when list comprehensions were introduced. Language support for building a list from an iterable results in compact declarative code. Simple code. What&amp;#8217;s more, the square brackets which now delimit list comprehensions are the same square brackets that were previously used to delimit lists. The syntax may have been new but it didn&amp;#8217;t surprise. Now consider the introduction of set and dict comprehensions, which follow logically and naturally from list comprehensions, almost as if they were discovered rather than invented.
&lt;/p&gt;
&lt;p&gt;There are many other examples where additions to the language have unified and simplified.
&lt;/p&gt;

&lt;h2&gt;Vision&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m not a Python insider and cannot comment on the exact balance of benevolence and dictatorship which goes into the &lt;a href="https://www.python.org/dev/peps/"&gt;language enhancement process&lt;/a&gt;. I would say Python doesn&amp;#8217;t suffer from being designed by a committee. It sticks to its strengths and its direction, to its vision.
&lt;/p&gt;</description>
<dc:date>2016-03-23</dc:date>
<guid>http://wordaligned.org/articles/easy-as-py</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/easy-as-py</link>
<category>Python</category>
</item>

<item>
<title>Sausages, sausages, sausages - slice, slice, slice</title>
<description>&lt;p&gt;A friend asked for help reaching the next level of a puzzle game. The test which stalled her involves machine placement in a sausage factory.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8230; each sausage was branded with a letter for quality control purposes, thus:
   &lt;strong&gt;ypbtkizfgxptclcoirdsuhjwulqkoszrabfc&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;The string was then drawn through seven machines which rearranged the sausages in flavour enhancing ways.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine A: The Reversifier&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;Reverses the order of the sausages, so they get tastier as you go along.
&lt;/p&gt;
&lt;p&gt;&amp;#8230;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine G: Secondhalffirstifier&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;move the second half of the string to the beginning, as the earlier sausages are too spicy to eat early in the morning.
&lt;/p&gt;
&lt;p&gt;He attached these machines in a certain sequence, though one of them was out for repair so only six were used. He then fed a string of sausages through and was surprised to discover the string that came out at the other end said &lt;strong&gt;lickyourlips&lt;/strong&gt;. What order were the machines in?
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;It&amp;#8217;s nicely phrased, but what&amp;#8217;s really wanted is the sequence of simple transformations that takes input &amp;#8220;ypbtkizfgxptclcoirdsuhjwulqkoszrabfc&amp;#8221; and produces output &amp;#8220;lickyourlips&amp;#8221;.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s no doubt possible to work backwards and figure out a solution using no more than logic, pencil and paper. For example, only two of the machines change the length of the string, and &amp;#8212; looking at the before and after lengths &amp;#8212; these must both be used. It&amp;#8217;s rather easier to write a short program to find a solution.
&lt;/p&gt;
&lt;p&gt;First we must simulate the seven sausage machines, A-G, which perform the following sequence operations.
&lt;/p&gt;
&lt;ol type="A"&gt;
&lt;li&gt;reverse the order of a sequence&lt;/li&gt;
&lt;li&gt;remove every other element of a sequence&lt;/li&gt;
&lt;li&gt;remove every third element of a sequence&lt;/li&gt;
&lt;li&gt;pairwise reverse elements of a sequence&lt;/li&gt;
&lt;li&gt;move even numbered elements to the front of a sequence&lt;/li&gt;
&lt;li&gt;move the last element of a sequence to the front&lt;/li&gt;
&lt;li&gt;swap the front and back half of a sequence&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;None of these is difficult, especially in a high-level language which builds in support for sequence operations. What I found noteworthy is that a solution can be found without any &lt;a href="https://docs.python.org/3/reference/compound_stmts.html"&gt;loops or if statements&lt;/a&gt;. What&amp;#8217;s more, every operation can handled using nothing more than &lt;a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range"&gt;slice operations&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s my solution. The machines consist of slice operations, helped by a couple of conditional expressions and recursive calls. The solution can then be brute-forced: there are only 5040 ways of permuting 6 out of 7 machines.
&lt;/p&gt;
&lt;script src="https://gist.github.com/wordaligned/a04308eac7ee2aa37e01.js"&gt;&lt;/script&gt;

&lt;p&gt;I&amp;#8217;ve used &lt;code&gt;reduce&lt;/code&gt; to apply a chain of functions to a string of sausages &amp;#8212; an explicit loop might be clearer, but I want a loop-free solution. For this same reason I use recursion in the pairwise swapper and the element dropper. Generally in Python, recursion is a poor choice. In this case I know I&amp;#8217;m starting with a string of just 36 elements which cannot get any longer; there&amp;#8217;s no risk of exceeding the &lt;a href="https://docs.python.org/3/library/sys.html#sys.getrecursionlimit"&gt;system recursion limit&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;The sequence reversal &lt;code&gt;s[::-1]&lt;/code&gt; is idiomatic but alarming to the uninitiated. Slices have &lt;code&gt;[start:stop:stride]&lt;/code&gt; fields, any of which may be defaulted. Usually &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; default to the start and end of the sequence, but in this case the negative stride reverses them.
&lt;/p&gt;
&lt;p&gt;To rotate the last element of a sequence to the front, prefer:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return s[-1:] + s[:-1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return [s[-1]] + s[:-1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;because the latter raises an &lt;code&gt;IndexError&lt;/code&gt; for an empty sequence.
&lt;/p&gt;
&lt;p&gt;Slicing is a formidable tool for sequence manipulation, especially when combined with the option of using negative indices to count back from the end. Slices allow you to reverse, rotate and partition sequences, to pairwise swap elements, and to drop every nth element.
&lt;/p&gt;
&lt;p&gt;The miniature recipes presented here don&amp;#8217;t even use slice assignment, which gives me an excuse to reproduce this elegant prime sieve function, which does.
&lt;/p&gt;
&lt;script src="https://gist.github.com/wordaligned/09c17eaabb6cd4c6bcfb.js"&gt;&lt;/script&gt;</description>
<dc:date>2016-03-21</dc:date>
<guid>http://wordaligned.org/articles/sausages-slices</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/sausages-slices</link>
<category>Python</category>
</item>

<item>
<title>Sledgehammers vs Nut Crackers</title>
<description>&lt;h2&gt;Awk&lt;/h2&gt;
&lt;p&gt;I get awk and can read awk programs but find the language of little use. Its focus is narrow and its syntax can be surprising. Python matches it at home and smashes it away. Nonetheless, a number of the &lt;a href="./advent-of-code"&gt;advent of code&lt;/a&gt; puzzles fit the awk processing model &amp;#8212; line based instructions, the interpretation of which builds state contributing to the final result &amp;#8212; and I enjoyed writing awk solutions. There&amp;#8217;s satisfaction in using a tool which is up to the job, no more and no less: in using a nutcracker, rather than a sledgehammer, to crack a nut.
&lt;/p&gt;

&lt;h2&gt;Puzzle&lt;/h2&gt;
&lt;p&gt;For example, the puzzle set on &lt;a href="http://adventofcode.com/day/6"&gt;day 6&lt;/a&gt; consists of a list of instructions for switching and toggling a 1000 x 1000 grid of lights. The instructions read:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;turn on 296,50 through 729,664
turn on 212,957 through 490,987
toggle 171,31 through 688,88
turn off 991,989 through 994,998
....
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and the question is, after following these instructions, &lt;strong&gt;how many lights are lit&lt;/strong&gt;?
&lt;/p&gt;
&lt;p&gt;Each instruction is a single line; the actions &amp;#8212; turn on, turn off, toggle &amp;#8212; can be matched by patterns; and to follow these actions requires no more than an array and arithmetic: &lt;code&gt;awk&lt;/code&gt; fits nicely.
&lt;/p&gt;

&lt;h2&gt;Code&lt;/h2&gt;
&lt;script src="https://gist.github.com/wordaligned/ceb8671aad6a3416e094.js" type="text/javascript"&gt;&lt;/script&gt;


&lt;h2&gt;Comments&lt;/h2&gt;
&lt;p&gt;Here, the &lt;code&gt;BEGIN&lt;/code&gt; action sets the field separator &lt;code&gt;FS&lt;/code&gt; to the regular expression &lt;code&gt;[ ,]&lt;/code&gt; which picks out the textual and numeric fields from each instruction. Awk is highly dynamic: use a variable as a number and it becomes a number, in this case the coordinates of a lighting grid; and similarly, the fields &amp;#8220;on&amp;#8221;, &amp;#8220;off&amp;#8221; and &amp;#8220;toggle&amp;#8221; are matched and treated as strings.
&lt;/p&gt;
&lt;p&gt;The grid of lights appears to be represented as a two dimensional array, accessed &lt;code&gt;lights[x,y]&lt;/code&gt; rather than &lt;code&gt;lights[x][y]&lt;/code&gt;. In fact, the array &amp;#8212; like all arrays in awk &amp;#8212; is an associative container, which maps from strings &amp;#8212; not numbers &amp;#8212; to values.  The key &lt;code&gt;x,y&lt;/code&gt; becomes a string which joins the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; with a separator defaulted to &lt;code&gt;"\034"&lt;/code&gt;.
&lt;/p&gt;

&lt;h2&gt;Niggles&lt;/h2&gt;
&lt;p&gt;The escape character at the end of line 5 is needed to continue the long line. I&amp;#8217;d prefer to use parentheses to wrap the expression over more than one line, &lt;a href="http://pep8.org/#indentation"&gt;as I would in Python&lt;/a&gt;, but this trick doesn&amp;#8217;t seem to work. I was somewhat surprised there was no built in &lt;code&gt;sum()&lt;/code&gt; function to count up the number of lights turned on by the &lt;code&gt;END&lt;/code&gt;. It would have been cute to pass &lt;code&gt;on()&lt;/code&gt;, &lt;code&gt;off()&lt;/code&gt; and &lt;code&gt;toggle()&lt;/code&gt; as functions into &lt;code&gt;switch()&lt;/code&gt;, separating traversal from action, but I couldn&amp;#8217;t find a way to do this in awk.
&lt;/p&gt;
&lt;p&gt;My awk script solved the puzzle in 45 seconds. A Python solution took 17 seconds. I didn&amp;#8217;t try optimising either.
&lt;/p&gt;
&lt;script src="https://gist.github.com/wordaligned/007c5cb30a3f7490e3ff.js" type="text/javascript"&gt;&lt;/script&gt;


&lt;h2&gt;Don&amp;#8217;t use a sledgehammer to crack a nut!&lt;/h2&gt;
&lt;p&gt;This advice, commonly given to programmers, demands explanation. If it&amp;#8217;s intended to imply a sledgehammer is more likely to pulverise the nut than open it, then fine, that&amp;#8217;s true &amp;#8212; but the analogy fails in this case: a solution written in Python would have been equally correct.
&lt;/p&gt;
&lt;p&gt;Alternatively, if we mean you shouldn&amp;#8217;t use a powerful language when a less powerful one would do, then the question becomes: &lt;strong&gt;why not&lt;/strong&gt;? Python is a general purpose programming language. It can crack nuts, peel bananas, serve web pages and so much more. If you know Python why bother with Awk?
&lt;/p&gt;
&lt;p&gt;At the outset of this post I admitted I don&amp;#8217;t generally bother with awk. Sometimes, though, I encounter the language and need to read and possibly adapt an existing script. So that&amp;#8217;s one reason to bother. Another reason is that it&amp;#8217;s elegant and compact. Studying its operation and motivation may help us compose and factor our own programs &amp;#8212; programs far more substantial than the scripts presented here, and in which there will surely be places for mini-languages of our own.
&lt;/p&gt;</description>
<dc:date>2016-02-23</dc:date>
<guid>http://wordaligned.org/articles/sledgehammers-vs-nut-crackers</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/sledgehammers-vs-nut-crackers</link>
<category>Python</category>
</item>

<item>
<title>Why zip when you can map?</title>
<description>&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Zipper"&gt;&lt;img src="http://wordaligned.org/images/zip.jpg" title="Why zip?" alt="Why zip?"/&gt;&lt;/a&gt;
   &lt;a href="http://www.strava.com/activities/158661061"&gt;&lt;img src="http://wordaligned.org/images/dundry-thunder.jpg" alt="when you can map?" title="when you can map!"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;You&amp;#8217;ve got a couple of parallel lists you&amp;#8217;d like to combine and output, a line for each pair. Here&amp;#8217;s one way to do it: use &lt;code&gt;zip&lt;/code&gt; to do the combining.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; times = [42.12, 42.28, 42.34, 42.40, 42.45]
&amp;gt;&amp;gt;&amp;gt; names = ['Hickman', 'Guest', 'Burns', 'Williams']
&amp;gt;&amp;gt;&amp;gt; fmt = '{:20} {:.2f}'.format
&amp;gt;&amp;gt;&amp;gt; print('\n'.join(fmt(n, t) for n, t in zip(names, times)))
Hickman              42.12
Guest                42.28
Burns                42.34
Williams             42.40

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Slightly more succinctly:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; print('\n'.join(fmt(*nt) for nt in zip(names, times)))
...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If you look at the generator expression passed into &lt;code&gt;str.join&lt;/code&gt;, you can see we&amp;#8217;re just mapping &lt;code&gt;fmt&lt;/code&gt; to the zipped &lt;code&gt;names&lt;/code&gt; and &lt;code&gt;times&lt;/code&gt; lists.
&lt;/p&gt;
&lt;p&gt;Well, sort of.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; print('\n'.join(map(fmt, zip(names, times))))
Traceback (most recent call last):
...
IndexError: tuple index out of range

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To fix this, we &lt;strong&gt;could&lt;/strong&gt; use &lt;code&gt;itertools.starmap&lt;/code&gt; which effectively unpacks the zipped pairs.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import starmap
&amp;gt;&amp;gt;&amp;gt; print('\n'.join(starmap(fmt, zip(names, times))))
Hickman              42.12
Guest                42.28
Burns                42.34
Williams             42.40

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This latest version looks clean enough but there&amp;#8217;s something odd about zipping two lists together only to unpack the resulting 2-tuples for consumption by the format function.
&lt;/p&gt;
&lt;p&gt;Don&amp;#8217;t forget, &lt;code&gt;map&lt;/code&gt; happily accepts more than one sequence! There&amp;#8217;s no need to &lt;code&gt;zip&lt;/code&gt; after all.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Don&amp;#8217;t zip, map!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; print('\n'.join(map(fmt, names, times)))
...

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2014-12-16</dc:date>
<guid>http://wordaligned.org/articles/why-zip-when-you-can-map</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/why-zip-when-you-can-map</link>
<category>Python</category>
</item>

<item>
<title>Find the average of a collection of tuples or dicts using Python</title>
<description>&lt;p&gt;You&amp;#8217;ve been running some tests, each of which returns a 3-tuple of numerical results &amp;#8212; &lt;code&gt;(real, user, sys)&lt;/code&gt; times, maybe &amp;#8212; and you&amp;#8217;d like to combine these into a single 3-tuple, the average result.
&lt;/p&gt;
&lt;p&gt;Easy!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def average(times):
    N = float(len(times))
    return (sum(t[0] for t in times)/N,
            sum(t[1] for t in times)/N,
            sum(t[2] for t in times)/N)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If you want a more generic solution, one which works when the tuples might have any number of elements, you could do this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def average(xs):
    N = float(len(xs))
    R = len(xs[0])
    return tuple(sum(x[i] for x in xs)/N for i in range(R))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;or this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def average(xs):
    N = float(len(xs))
    return tuple(sum(col)/N for col in zip(*xs))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The second generic variant uses &lt;a href="https://docs.python.org/3/library/functions.html#zip"&gt;zip&lt;/a&gt; to transpose its inputs. 
&lt;/p&gt;
&lt;p&gt;Now suppose we have keyed collections of results which we want to average:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; times = [{'real': 34.4, 'user': 26.2, 'sys': 7.3},
             {'real': 28.7, 'user': 21.5, 'sys': 6.4},
             {'real': 29.3, 'user': 22.0, 'sys': 6.9}]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If, as in the example above, each result has the same set of keys, the average result could be calculated like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; N = float(len(times))
&amp;gt;&amp;gt;&amp;gt; { k : sum(t[k] for t in times)/N for k in times[0] }
{'real': 30.8, 'sys': 6.9, 'user': 23.2}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;What if the inputs don&amp;#8217;t have the same keys? Consider the contents of four fridges.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; fridges = [
    { 'egg': 5, 'milk': 1.700, 'sausage': 6 },
    { 'beer': 6, 'milk': 0.568, 'egg': 1 },
    { 'egg': 3, 'sausage': 4, 'milk': 0.125, 'lettuce': 1 },
    { 'carrot': 4 }]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A &lt;a href="https://docs.python.org/3/library/collections.html#collections.Counter"&gt;Counter&lt;/a&gt; can collect and calculate the average fridge contents. 
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Counter
&amp;gt;&amp;gt;&amp;gt; total = sum(map(Counter, fridges), Counter())
&amp;gt;&amp;gt;&amp;gt; N = float(len(fridges))
&amp;gt;&amp;gt;&amp;gt; { k: v/N for k, v in total.items() }
{'sausage': 2.5, 'lettuce': 0.25, 'beer': 1.5, 'carrot': 1.0, 
 'egg': 2.25, 'milk': 0.59825}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that although &lt;code&gt;Counter&lt;/code&gt;s were primarily designed to work with positive integers to represent counts, there&amp;#8217;s nothing stopping us from using floating point numbers (amount of milk in our example) in the values field.
&lt;/p&gt;</description>
<dc:date>2014-12-03</dc:date>
<guid>http://wordaligned.org/articles/python-averages</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/python-averages</link>
<category>Python</category>
</item>

<item>
<title>Group When</title>
<description>&lt;p&gt;Phil Nash&amp;#8217;s recent tweet intrigued me.
&lt;/p&gt;
&lt;div&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;Functional people: I often (in F#) need to process a seq into a smaller list or seq &amp;ndash; where items from the input are grouped in some way&amp;hellip;&lt;/p&gt;&amp;mdash; Phil Nash (@phil_nash) &lt;a href="https://twitter.com/phil_nash/statuses/489167611641724928"&gt;July 15, 2014&lt;/a&gt;&lt;/blockquote&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;&amp;hellip; the need to group may not be known until after the first item in the group.&amp;#10;I struggle to find a nicely functional way to do this. Ideas?&lt;/p&gt;&amp;mdash; Phil Nash (@phil_nash) &lt;a href="https://twitter.com/phil_nash/statuses/489167962931482626"&gt;July 15, 2014&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="http://wordaligned.org//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/div&gt;

&lt;p&gt;He later clarified what he was after &amp;#8212; and had now found &amp;#8212; linking to a &lt;a href="http://fssnip.net/6A"&gt;solution&lt;/a&gt; posted a couple of years ago by &lt;a href="http://tomasp.net"&gt;Tomas Petricek&lt;/a&gt;. The function &lt;code&gt;groupWhen&lt;/code&gt; splits a sequence into groups, starting a new group whenever the predicate returns true.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt; module Seq =
   /// Iterates over elements of the input sequence and groups adjacent elements.
   /// A new group is started when the specified predicate holds about the element
   /// of the sequence (and at the beginning of the iteration).
   ///
   /// For example: 
   ///    Seq.groupWhen isOdd [3;3;2;4;1;2] = seq [[3]; [3; 2; 4]; [1; 2]]
   let groupWhen f (input:seq&amp;lt;_&amp;gt;) = seq {
     use en = input.GetEnumerator()
     let running = ref true
     
     // Generate a group starting with the current element. Stops generating
     // when it founds element such that 'f en.Current' is 'true'
     let rec group() = 
       [ yield en.Current
         if en.MoveNext() then
           if not (f en.Current) then yield! group() 
         else running := false ]
     
     if en.MoveNext() then
       // While there are still elements, start a new group
       while running.Value do
         yield group() |&amp;gt; Seq.ofList }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a nice Haskell version coded up by &lt;a href="https://twitter.com/sdarlington"&gt;@sdarlington&lt;/a&gt;.
&lt;/p&gt;
&lt;script src="https://gist.github.com/sdarlington/be76048bff124694769d.js"&gt;&lt;/script&gt;

&lt;p&gt;Maybe &lt;a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile"&gt;takewhile&lt;/a&gt; and &lt;a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile"&gt;dropwhile&lt;/a&gt; could power a Python solution, but my first choice would be &lt;a href="https://docs.python.org/3/library/itertools.html#itertools.groupby"&gt;itertools.groupby&lt;/a&gt;. &lt;code&gt;Groupby&lt;/code&gt; chops a sequence into subsequences, where the elements of each subsequence have the same key value. A suitable key function, in this case, must change its return value every time the sequence yields an element for which the predicate holds. It could toggle between a pair of values, for example. Or it could just count the number of times the predicate holds.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;class count_p:
    ''' Return a value which increments every time the predicate holds.
    '''
    def __init__(self, pred):
        self._n = 0
        self._pred = pred
    
    def __call__(self, v):
        self._n += self._pred(v)
        return self._n

def group_when(pred, xs):
    return (gp for _, gp in groupby(xs, count_p(pred)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;group_when&lt;/code&gt; accepts an iterable and returns an iterable sequence of iterable groups. Clients choose how to consume the results.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; def odd(v): return v % 2
&amp;gt;&amp;gt;&amp;gt; xs = group_when(odd, [3, 3, 2, 4, 1, 2])
&amp;gt;&amp;gt;&amp;gt; print([list(g) for g in xs])
[[3], [3, 2, 4], [1, 2]]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that &lt;code&gt;count_p&lt;/code&gt; does something very like &lt;a href="acc"&gt;itertools.accumulate&lt;/a&gt;. Here&amp;#8217;s another version of &lt;code&gt;group_when&lt;/code&gt; which takes advantage of this.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def group_when(pred, xs):
    xs, ys = tee(xs)
    accu = accumulate(map(pred, ys))
    return (gp for _, gp in groupby(xs, lambda _: next(accu)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;After a short break, here&amp;#8217;s a third version of &lt;code&gt;group_when&lt;/code&gt;. This is the first time I&amp;#8217;ve found a use for &lt;code&gt;takewhile&lt;/code&gt; and &lt;code&gt;dropwhile&lt;/code&gt;. Beware: as the teed streams &lt;code&gt;xs&lt;/code&gt; and &lt;code&gt;ys&lt;/code&gt; diverge, the amount of backing storage required will grow &amp;#8230; only for the stored values to then be dropped!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import *
 
def group_when(p, xs):
    def notp(x): return not p(x)
    xs = iter(xs)
    while True:
        x = next(xs)
        xs, ys = tee(xs)
        yield chain([x], takewhile(notp, xs))
        xs = dropwhile(notp, ys)
 
def odd(x):
    return x % 2
 
[list(g) for g in group_when(odd, [3, 3, 2, 4, 1, 2])] # [[3], [3, 2, 4], [1, 2]]

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2014-07-16</dc:date>
<guid>http://wordaligned.org/articles/group-when</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/group-when</link>
<category>Python</category>
</item>

<item>
<title>You wait all day for a bus&#8230;</title>
<description>&lt;p&gt;&lt;a href="http://docs.python.org/3/library/functions.html#any"&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; and &lt;a href="http://docs.python.org/3/library/functions.html#all"&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt;  didn&amp;#8217;t appear in Python until version 2.5, released in 2006, when the language was already well into its teens.
&lt;/p&gt;
&lt;p&gt;Why the delay in offering such fundamental functions? An oversight? Or simply that they&amp;#8217;re so easy to implement they weren&amp;#8217;t thought necessary. Either way, they&amp;#8217;re here now.
&lt;/p&gt;
&lt;p&gt;The functions are closely related and complementary. We can define &lt;code&gt;any&lt;/code&gt; in terms of &lt;code&gt;all&lt;/code&gt; and vice-versa.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def any_(xs):
    return not all(map(operator.not_, xs))

def all_(xs):
    return not any(map(operator.not_, xs))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;C++ reached its 30s before introducing &lt;a href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"&gt;its own versions&lt;/a&gt; of these logical algorithms, &lt;code&gt;any_of&lt;/code&gt; and &lt;code&gt;all_of&lt;/code&gt;, but made up for lost time by finding room for a third, &lt;code&gt;none_of&lt;/code&gt;, which is not &lt;code&gt;any_of&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;class Iter, class Pred&amp;gt;
bool none_of_(Iter b, Iter e, Pred p)
{
    return std::find_if(b, e, p) == e;
}

template &amp;lt;class Iter, class Pred&amp;gt;
bool any_of_(Iter b, Iter e, Pred p)
{
    return !none_of_(b, e, p);
}

template &amp;lt;class Iter, class Pred&amp;gt;
bool all_of_(Iter b, Iter e, Pred p)
{
    return !any_of_(b, e, std::not1(p));
}

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2013-10-02</dc:date>
<guid>http://wordaligned.org/articles/all-any-none</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/all-any-none</link>
<category>Python</category>
</item>

<item>
<title>Python&#8217;s lesser known loop control</title>
<description>&lt;p&gt;I&amp;#8217;ll break out of a loop if I have to but generally prefer to recast code so no &lt;code&gt;break&lt;/code&gt; is needed. It&amp;#8217;s not about avoiding the keyword; but rather that the loop control expression should tell readers when and why the loop exits.
&lt;/p&gt;
&lt;p&gt;In C and C++ such recasting is rarely a problem. Python separates statements and expressions which makes things more difficult. You can&amp;#8217;t assign to a variable in a loop control expression, for example. Consider a function which processes a file one chunk at a time, until the file is exhausted.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;while True:
    data = fp.read(4096)
    if not data:
        break
    ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The control expression, &lt;code&gt;while True&lt;/code&gt;, suggests an infinite loop, which isn&amp;#8217;t what actually happens, but readers must poke around in the loop body to find the actual termination condition.
&lt;/p&gt;
&lt;p&gt;As already mentioned, an assignment statement isn&amp;#8217;t an expression, so we can&amp;#8217;t write this:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Syntax error!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;while data = fp.read(4096):
    ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;You could implement a file reader &lt;a href="http://docs.python.org/3/howto/functional.html#generators"&gt;generator function&lt;/a&gt; which yields chunks of data, allowing clients to write:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;for data in chunked_file_reader(fp):
    ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This at least localises the problem to &lt;code&gt;chunked_file_reader()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Another solution is to use the two argument flavour of &lt;a href="http://docs.python.org/3.3/library/functions.html#iter"&gt;iter&lt;/a&gt;, &lt;code&gt;iter(object, sentinel)&lt;/code&gt;. Here, &lt;code&gt;object&lt;/code&gt; is a callable and &lt;code&gt;sentinel&lt;/code&gt; is a terminal value. &lt;code&gt;Object&lt;/code&gt; is called with no arguments: use &lt;code&gt;&lt;a href="http://docs.python.org/3/library/functools.html#functools.partial"&gt;functools.partial&lt;/a&gt;&lt;/code&gt; to set the chunk size passed to &lt;code&gt;file.read&lt;/code&gt;; and stop when this function returns the empty string.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import functools

chunked_file_reader = functools.partial(fp.read, 4096)

for data in iter(chunked_file_reader, ''):
    ...

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2013-01-14</dc:date>
<guid>http://wordaligned.org/articles/pythons-lesser-known-loop-control</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/pythons-lesser-known-loop-control</link>
<category>Python</category>
</item>

<item>
<title>Set.insert or set.add?</title>
<description>&lt;h2&gt;Get set, go!&lt;/h2&gt;
&lt;p&gt;Suppose you have an element &lt;code&gt;e&lt;/code&gt; to put in a set &lt;code&gt;S&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Should you:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;S.add(e)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;or:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;S.insert(e)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;?
&lt;/p&gt;
&lt;p&gt;It depends on which language you&amp;#8217;re using. I use C++ and Python and I usually get it wrong.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; S.insert(e)
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
AttributeError: 'set' object has no attribute 'insert'

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Try again!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;error: 'class std::set&amp;lt;int, std::less&amp;lt;int&amp;gt;, std::allocator&amp;lt;int&amp;gt; &amp;gt;' 
has no member named 'add'

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Maybe my &lt;a href="http://wordaligned.org/articles/accidental-emacs.html" title="Emacs of course!"&gt;IDE&lt;/a&gt; should auto-complete the correct member function but it doesn&amp;#8217;t, or at least I haven&amp;#8217;t configured it to, so instead I&amp;#8217;ve worked out how to remember.
&lt;/p&gt;
&lt;p&gt;Now, neither C++ nor Python pins down how a set should be implemented &amp;#8212; read the language standard and reference manual respectively and all you&amp;#8217;ll get is an interface and some hints. Read between the lines of these references, though, or study &lt;a href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01064_source.html" title="G++ stl_tree.h, on which std::sets and std::multisets are based"&gt;the&lt;/a&gt; &lt;a href="http://svn.python.org/view/python/trunk/Objects/setobject.c?view=markup" title="setobject.c, from CPython"&gt;implementations&lt;/a&gt;, and you&amp;#8217;ll soon realise a Python set is an unordered container designed for fast membership, union, intersection, and differencing operations &amp;#8212; much like the mathematical sets I learned about at school &amp;#8212; whereas a C++ set is an ordered container, featuring logarithmic access times and persistent iterators. 
&lt;/p&gt;
&lt;p&gt;Think: C++ set &amp;asymp; binary tree; Python set &amp;asymp; hashed array.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s apparent which method is correct for which language now. To put something into a binary tree you must recurse down the tree and find where to &lt;strong&gt;insert&lt;/strong&gt; it. Hence &lt;code&gt;std::set::insert()&lt;/code&gt; is correct C++. To put something into a hashed array you hash it and &lt;strong&gt;add&lt;/strong&gt; it right there. Hence &lt;code&gt;set.add()&lt;/code&gt; is proper Python.
&lt;/p&gt;

&lt;h2&gt;How long is a string?&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m suggesting programmers should know at least some of what goes on in their standard language library implementations. Appreciating an API isn&amp;#8217;t always enough. You &lt;strong&gt;insert&lt;/strong&gt; into trees and &lt;strong&gt;add&lt;/strong&gt; to hashes: so if your set is a tree, call &lt;code&gt;S.insert()&lt;/code&gt;, and if it&amp;#8217;s a hash, &lt;code&gt;S.add()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Such logical arguments don&amp;#8217;t always deliver.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Suppose now that &lt;code&gt;S&lt;/code&gt; is a string and you&amp;#8217;re after its length. Should you use &lt;code&gt;S.length()&lt;/code&gt; or &lt;code&gt;S.size()&lt;/code&gt;?
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Neither or both.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/the-g-uk/3867089043/" title="string [how long?] by the|G|, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2538/3867089043_2f2b3f5fa6.jpg" width="485" height="149" alt="string [how long?]" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;In Python a string is a standard sequence and as for all other sequences &lt;code&gt;len(S)&lt;/code&gt; does the trick. In C++ a string is a standard container and as for all other containers &lt;code&gt;S.size()&lt;/code&gt; returns the number of elements; &lt;strong&gt;but&lt;/strong&gt;, being &lt;code&gt;std::string&lt;/code&gt;, &lt;code&gt;S.length()&lt;/code&gt; does too.
&lt;/p&gt;
&lt;p&gt;Oh, and the next revision of C++ features an &lt;code&gt;unordered_set&lt;/code&gt; (available now as &lt;code&gt;std::tr1::unordered_set&lt;/code&gt;) which is a hashed container. I think &lt;code&gt;unordered_set&lt;/code&gt; is a poor name for something which models a set better than &lt;code&gt;std::set&lt;/code&gt; does but that&amp;#8217;s the price it pays for coming late to the party. And you don&amp;#8217;t &lt;code&gt;std::unordered_set::add&lt;/code&gt; elements to it, you &lt;code&gt;std::unordered_set::insert&lt;/code&gt; them.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;My thanks to &lt;a href="http://www.flickr.com/photos/the-g-uk"&gt;the|G|&amp;trade;&lt;/a&gt; for permission to use his &lt;a href="http://www.flickr.com/photos/the-g-uk/3867089043" title="string [how long?] on Flickr"&gt;string&lt;/a&gt;.
&lt;/p&gt;</description>
<dc:date>2010-11-17</dc:date>
<guid>http://wordaligned.org/articles/setinsert-or-setadd</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/setinsert-or-setadd</link>
<category>Python</category>
</item>

<item>
<title>Hiding iterator boilerplate behind a Boost facade</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocfilling-in-missing-methods-python" name="toc0" id="toc0"&gt;Filling in missing methods. Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocfilling-in-missing-methods-c" name="toc1" id="toc1"&gt;Filling in missing methods. C++&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocenter-boost-iterators" name="toc2" id="toc2"&gt;Enter Boost iterators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocusing-boostiteratorfacade" name="toc3" id="toc3"&gt;Using boost::iterator_facade&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toctemplates-and-traits" name="toc4" id="toc4"&gt;Templates and Traits&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocconstructors-destructors-and-operators" name="toc5" id="toc5"&gt;Constructors, destructors and operators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocwrinkles" name="toc6" id="toc6"&gt;Wrinkles&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocless-code-more-software" name="toc7" id="toc7"&gt;Less code, more software&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocperformance" name="toc8" id="toc8"&gt;Performance&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;&lt;a href="http://www.flickr.com/photos/davehamster/2336911145/" title="SS Great Britain by Dave Hamster, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2379/2336911145_5275811ec0_m.jpg" width="240" height="160" alt="SS Great Britain"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc0" name="tocfilling-in-missing-methods-python" id="tocfilling-in-missing-methods-python"&gt;Filling in missing methods. Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s another wholesome &lt;a href="http://code.activestate.com/recipes/576685" title="Total ordering class decorator, by Raymond Hettinger"&gt;recipe&lt;/a&gt; served up by Raymond Hettinger.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Total ordering class decorator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def total_ordering(cls):
    'Class decorator that fills-in missing ordering methods'    
    convert = {
        '__lt__': [('__gt__', lambda self, other: other &amp;lt; self),
                   ('__le__', lambda self, other: not other &amp;lt; self),
                   ('__ge__', lambda self, other: not self &amp;lt; other)],
        '__le__': [('__ge__', lambda self, other: other &amp;lt;= self),
                   ('__lt__', lambda self, other: not other &amp;lt;= self),
                   ('__gt__', lambda self, other: not self &amp;lt;= other)],
        '__gt__': [('__lt__', lambda self, other: other &amp;gt; self),
                   ('__ge__', lambda self, other: not other &amp;gt; self),
                   ('__le__', lambda self, other: not self &amp;gt; other)],
        '__ge__': [('__le__', lambda self, other: other &amp;gt;= self),
                   ('__gt__', lambda self, other: not other &amp;gt;= self),
                   ('__lt__', lambda self, other: not self &amp;gt;= other)]
    }
    roots = set(dir(cls)) &amp;amp; set(convert)
    assert roots, 'must define at least one ordering operation: &amp;lt; &amp;gt; &amp;lt;= &amp;gt;='
    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__
    for opname, opfunc in convert[root]:
        if opname not in roots:
            opfunc.__name__ = opname
            opfunc.__doc__ = getattr(int, opname).__doc__
            setattr(cls, opname, opfunc)
    return cls

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If you have a class, &lt;code&gt;X&lt;/code&gt;, which implements one or more of the ordering operators, &lt;code&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; then &lt;code&gt;total_ordering(X)&lt;/code&gt; adapts and returns the class with the missing operators filled-in. Alternatively, use standard decorator syntax to adapt a class. If we apply &lt;code&gt;@total_ordering&lt;/code&gt; to a &lt;code&gt;Point&lt;/code&gt; class
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@total_ordering
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __lt__(self, other):
        return (self.x, self.y) &amp;lt; (other.x, other.y)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;then we can compare points however we like
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; p = Point(1,2)
&amp;gt;&amp;gt;&amp;gt; q = Point(1,3)
&amp;gt;&amp;gt;&amp;gt; p &amp;lt; q, p &amp;gt; q, p &amp;gt;= q, p &amp;lt;= q
(True, False, False, True)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a nice touch: the freshly-baked methods even have documentation!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; help(Point)
Help on class Point in module __main__:

class Point
 |  Methods defined here:
 |  
 |  __ge__(self, other)
 |      x.__ge__(y) &amp;lt;==&amp;gt; x&amp;gt;=y
 |  
 |  __gt__(self, other)
 |      x.__gt__(y) &amp;lt;==&amp;gt; x&amp;gt;y
 |  
 |  __init__(self, x, y)
 |  
 |  __le__(self, other)
 |      x.__le__(y) &amp;lt;==&amp;gt; x&amp;lt;=y
 |  
 |  __lt__(self, other)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Writing class decorators may not be the first thing a new Python programmer attempts, but once you&amp;#8217;ve discovered the relationship between Python&amp;#8217;s special method names and the more familiar operator symbols, I think this recipe is remarkably straightforward.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;convert = {
    '__lt__': [('__gt__', lambda self, other: other &amp;lt; self),
               ('__le__', lambda self, other: not other &amp;lt; self),
               ('__ge__', lambda self, other: not self &amp;lt; other)],
    '__le__': [('__ge__', lambda self, other: other &amp;lt;= self),
               ('__lt__', lambda self, other: not other &amp;lt;= self),
               ('__gt__', lambda self, other: not self &amp;lt;= other)],
    '__gt__': [('__lt__', lambda self, other: other &amp;gt; self),
               ('__ge__', lambda self, other: not other &amp;gt; self),
               ('__le__', lambda self, other: not self &amp;gt; other)],
    '__ge__': [('__le__', lambda self, other: other &amp;gt;= self),
               ('__gt__', lambda self, other: not other &amp;gt;= self),
               ('__lt__', lambda self, other: not self &amp;gt;= other)]
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Before moving on to something more challenging, look again at one of the recipe&amp;#8217;s key ingredients, the &lt;code&gt;convert&lt;/code&gt; dict, which helps create the missing ordering functions from existing ones. As you can see, there&amp;#8217;s much repetition here, and plenty of opportunities for cut-and-paste errors.
&lt;/p&gt;
&lt;p&gt;This block of code is an example of what programmers term &lt;a href="http://en.wikipedia.org/wiki/Boilerplate_(text)#Boilerplate_code"&gt;boilerplate&lt;/a&gt;. By using the total ordering decorator, we can avoid boilerplating our own code.&lt;a id="fn1link" href="http://wordaligned.org/articles/boost-iterator-facade#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc1" name="tocfilling-in-missing-methods-c" id="tocfilling-in-missing-methods-c"&gt;Filling in missing methods. C++&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Python is dynamic and self-aware, happy to expose its internals for this kind of tinkering.  It takes real wizardry to achieve similar results with a &lt;a href="http://sites.google.com/site/steveyegge2/tour-de-babel" title="C++ is the dumbest language on earth ... doesn't know about itself. It is not introspective"&gt;less flexible language, such as C++&lt;/a&gt; &amp;#8212; but it can be done.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;In a &lt;a href="http://wordaligned.org/articles/binary-search-revisited.html"&gt;previous article&lt;/a&gt; we developed a random access file iterator in C++. At its heart, this iterator simply repositioned itself using file-seeks and dereferenced itself using file-reads. There wasn&amp;#8217;t much to it.
&lt;/p&gt;
&lt;p&gt;Unfortunately we had to fill-out the iterator with the various members required to make it comply with the standard random access iterator requirements (which was the whole point, since we wanted something we could use with standard binary search algorithms).
&lt;/p&gt;
&lt;p&gt;We had to expose standard typedefs:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef std::random_access_iterator_tag iterator_category;
typedef item value_type;
typedef std::streamoff difference_type;
typedef item * pointer;
typedef item &amp;amp; reference;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Worse, we had to implement a full set of comparison, iteration, step and access functions. Please, page down past the following code block! I only include it here so you can see how long it goes on for.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Iterator boilerplate&lt;/div&gt;

&lt;pre class="prettyprint"&gt;public: // Comparison
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }
    
    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }
    
    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }
    
public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }
    
    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }
    
    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }
    
    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }
    
public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }
    
    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }
    
    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }
    
    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }
    
public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return pos - other.pos;
    }
    
public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }

value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How tiresome! Most of these member functions are directly and unsurprisingly implemented in a standard way. It would be nice if we could write (and test!) what we actually needed to and have a decorator fill in the rest.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/chr1sp/3997724676/" title="Library - Ephesus by Chris. P, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2554/3997724676_bf73106637.jpg" width="500" height="334" alt="Library - Ephesus"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc2" name="tocenter-boost-iterators" id="tocenter-boost-iterators"&gt;Enter Boost iterators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Actually, we can! I&amp;#8217;m grateful to proggitor dzorz for &lt;a href="http://www.reddit.com/r/programming/comments/c8fsk/binary_search_revisited/c0quxr0"&gt;telling me how&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;A nicer solution would use boost::iterator_facade and just implement dereference, equal, increment, decrement, advance and distance_to.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Like many programmers I have mixed feelings about C++ &amp;#8212; when it&amp;#8217;s good it&amp;#8217;s very very good, but when it&amp;#8217;s bad it&amp;#8217;s horrid &amp;#8212; and these feelings are only amplified by the &lt;a href="http://www.boost.org" title="Boost library home page"&gt;Boost&lt;/a&gt; library. Boost is superb, so long as you stick to the good parts.
&lt;/p&gt;
&lt;p&gt;So which parts are good? It depends. On you, who you work with, and the platforms you&amp;#8217;re working on.
&lt;/p&gt;
&lt;p&gt;In my previous article I used an ingenious iterator adaptor from the &lt;a href="http://www.boost.org/doc/libs/release/libs/spirit/index.html"&gt;Boost.Spirit&lt;/a&gt; parser library to disastrous effect. If only I&amp;#8217;d looked a little more carefully I&amp;#8217;d have discovered something more useful in a more obvious place. &lt;a href="http://www.boost.org/doc/libs/release/libs/iterator/"&gt;Boost.Iterator&lt;/a&gt; could have helped.
&lt;/p&gt;
&lt;p&gt;As dzorz points out, &lt;code&gt;boost::iterator_facade&lt;/code&gt; can work with any C++ iterable. Implement whatever subset of 
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     dereference
 &lt;/li&gt;

 &lt;li&gt;
     equal
 &lt;/li&gt;

 &lt;li&gt;
     increment 
 &lt;/li&gt;

 &lt;li&gt;
     decrement
 &lt;/li&gt;

 &lt;li&gt;
     advance
 &lt;/li&gt;

 &lt;li&gt;
     distance_to
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;is appropriate and &lt;code&gt;iterator_facade&lt;/code&gt; will fill in the boilerplate required to standardise your iterator.
&lt;/p&gt;
&lt;p&gt;In our case, we&amp;#8217;ll need the full set. That&amp;#8217;s because we&amp;#8217;re after a random access iterator. Other iterators need rather less. Here&amp;#8217;s a &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#iterator-facade-requirements"&gt;table&lt;/a&gt; showing the relationship between core operations and iterator concepts.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#iterator-facade-requirements"&gt;&lt;img src="http://wordaligned.org/images/iterator-facade.png" alt="iterator_facade Core Operations"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc3" name="tocusing-boostiteratorfacade" id="tocusing-boostiteratorfacade"&gt;Using boost::iterator_facade&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href="http://www.boost.org/doc/libs/release/libs/iterator/"&gt;Boost.Iterator&lt;/a&gt; documentation is well-written but daunting. Read it from top-to bottom and you&amp;#8217;ll get:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     rationale and theory
 &lt;/li&gt;

 &lt;li&gt;
     plans for standardisation (which don&amp;#8217;t seem correct &lt;a id="fn2link" href="http://wordaligned.org/articles/boost-iterator-facade#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;)
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;usage notes&lt;/strong&gt;
 &lt;/li&gt;

 &lt;li&gt;
     some subtle points on the implementation and its predecessor
 &lt;/li&gt;

 &lt;li&gt;
     a namecheck for the curiously recurring template pattern
 &lt;/li&gt;

 &lt;li&gt;
     a fat reference section detailing the boilerplate which this library allows you to forget
 &lt;/li&gt;

 &lt;li&gt;
     a &lt;strong&gt;tutorial&lt;/strong&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&amp;#8217;re tempted to skip to the end of the page, you&amp;#8217;ll see this code block.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;boost/type_traits/is_convertible.hpp&amp;gt;
#include &amp;lt;boost/utility/enable_if.hpp&amp;gt;
  
  ....
  
private:
  struct enabler {};
  
public:
  template &amp;lt;class OtherValue&amp;gt;
  node_iter(
      node_iter&amp;lt;OtherValue&amp;gt; const&amp;amp; other
    , typename boost::enable_if&amp;lt;
          boost::is_convertible&amp;lt;OtherValue*,Value*&amp;gt;
        , enabler
      &amp;gt;::type = enabler()
  )
    : m_node(other.m_node) {}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;According to the surrounding documentation this is &amp;#8220;magic&amp;#8221;. I find it scary.
&lt;/p&gt;
&lt;p&gt;Luckily it turns out the library is straightforward to use. What you really want, as a newcomer, are the &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#usage"&gt;usage notes&lt;/a&gt; and the &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#tutorial-example"&gt;tutorial example&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;The tutorial walks through the process of skinning a singly-linked list with a forwards iterator facade. This is a different use case to ours: the tutorial shows a basic class which implements what it should, and the facade allows it to be treated as a forwards iterator. In our case we&amp;#8217;ve already created a full-blown random access iterator. We can retrospectively apply &lt;code&gt;iterator_facade&lt;/code&gt; to strip our class back to basics.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc4" name="toctemplates-and-traits" id="toctemplates-and-traits"&gt;Templates and Traits&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Where we had:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;typename item&amp;gt;
class text_file_iter
{
public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef item value_type;
    typedef std::streamoff difference_type;
    typedef item * pointer;
    typedef item &amp;amp; reference;
....
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We now need (my thanks here to Giuseppe for correcting the code I originally posted here):
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;typename value&amp;gt;
class text_file_iter
    : public boost::iterator_facade&amp;lt;
      text_file_iter&amp;lt;value&amp;gt;
    , value
    , std::random_access_iterator_tag
    , value
    , std::streamoff
    &amp;gt;
....
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Yes, the class accepts itself as a template parameter. That&amp;#8217;s the curious recursion.)
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc5" name="tocconstructors-destructors-and-operators" id="tocconstructors-destructors-and-operators"&gt;Constructors, destructors and operators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We still need iterator constructors and destructors &amp;#8212; these are unchanged &amp;#8212; but &lt;strong&gt;we can eliminate every single operator&lt;/strong&gt; shown in the &amp;#8220;Iterator boilerplate&amp;#8221; code block above.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s what we need instead, to ensure &lt;code&gt;iterator_facade&lt;/code&gt; can do its job. The &lt;code&gt;read()&lt;/code&gt; member function we had before doesn&amp;#8217;t need changing.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;    ....
private: // Everything Boost's iterator facade needs
    friend class boost::iterator_core_access;
    
    value dereference() const
    {
        return read();
    }
    
    bool equal(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    void increment()
    {
        advance(1);
    }
    
    void decrement()
    {
        advance(-1);
    }
    
    void advance(std::streamoff n)
    {
        in.seekg(n, std::ios_base::cur);
        pos = in.tellg();
    }
    
    std::streamoff distance_to(iter const &amp;amp; other) const
    {
        return other.pos - pos;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;And that really is all there is to it. I&amp;#8217;m impressed.
&lt;/p&gt;
&lt;p&gt;Notice, by the way, that &lt;code&gt;friend&lt;/code&gt; is used to expose the primitive, private member functions for use by the &lt;code&gt;boost::iterator_core_access&lt;/code&gt; class. This follows the example set by the tutorial. I&amp;#8217;ve written enough C and Python to question C++&amp;#8217;s sophisticated access rules &amp;#8212; you have &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt;, but that&amp;#8217;s &lt;strong&gt;still&lt;/strong&gt; not enough, so you need &lt;code&gt;friend&lt;/code&gt; declaration to cut through it all &amp;#8212; which tempts me to simply make &lt;code&gt;dereference()&lt;/code&gt;, &lt;code&gt;equal()&lt;/code&gt; etc. public, but then the facade wouldn&amp;#8217;t be a proper facade. Users should treat the final class exactly as they would any other random access iterator, and designating these members as &lt;code&gt;private&lt;/code&gt; means they&amp;#8217;ll have to.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc6" name="tocwrinkles" id="tocwrinkles"&gt;Wrinkles&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You&amp;#8217;ll notice the &lt;code&gt;dereference()&lt;/code&gt; member function has a &lt;code&gt;const&lt;/code&gt; signature. However, the &lt;code&gt;read()&lt;/code&gt; member function is non-const.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;    // Return the item at the current position
    value_type read()
    {
        value_type n = 0;
        
        // Reverse till we hit whitespace or the start of the file
        while (in &amp;amp;&amp;amp; !isspace(in.peek()))
        {
            in.unget();
        }
        in.clear();
        
        in &amp;gt;&amp;gt; n;
        return n;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;in&lt;/code&gt; is a data member of type &lt;code&gt;std::ifstream&lt;/code&gt;, and clearly the read call modifies it. That&amp;#8217;s what this alarming compiler error is trying to tell us.
&lt;/p&gt;
&lt;pre&gt;
boost_binary_search_text_file.cpp: In member function 'value text_file_iter&amp;lt;value&amp;gt;::read() const [with value = long long int]':
boost_binary_search_text_file.cpp:90:   instantiated from 'value text_file_iter&amp;lt;value&amp;gt;::dereference() const [with value = long long int]'
/opt/local/include/boost/iterator/iterator_facade.hpp:516:   instantiated from 'static typename Facade::reference boost::iterator_core_access::dereference(const Facade&amp;amp;) [with Facade = text_file_iter&amp;lt;long long int&amp;gt;]'
/opt/local/include/boost/iterator/iterator_facade.hpp:634:   instantiated from 'Reference boost::iterator_facade&amp;lt;I, V, TC, R, D&amp;gt;::operator*() const [with Derived = text_file_iter&amp;lt;long long int&amp;gt;, Value = long long int, CategoryOrTraversal = boost::random_access_traversal_tag, Reference = long long int, Difference = long long int]'
/usr/include/c++/4.2.1/bits/stl_algo.h:4240:   instantiated from 'bool std::binary_search(_ForwardIterator, _ForwardIterator, const _Tp&amp;amp;) [with _ForwardIterator = text_file_iter&amp;lt;long long int&amp;gt;, _Tp = main::number]'
boost_binary_search_text_file.cpp:203:   instantiated from here
boost_binary_search_text_file.cpp:174: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'typename std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::int_type std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::peek() [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
boost_binary_search_text_file.cpp:176: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;&amp;amp; std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::unget() [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
boost_binary_search_text_file.cpp:178: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'void std::basic_ios&amp;lt;_CharT, _Traits&amp;gt;::clear(std::_Ios_Iostate) [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
boost_binary_search_text_file.cpp:180: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;&amp;amp; std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::operator&amp;gt;&amp;gt;(long long int&amp;amp;) [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
&lt;/pre&gt;

&lt;p&gt;Related to this, the &lt;code&gt;Reference&lt;/code&gt; template parameter (shown in bold in the listing below) is actually a &lt;code&gt;value&lt;/code&gt;, rather than the (default) &lt;code&gt;value &amp;amp;&lt;/code&gt;. As we originally implemented it, our file iterator reads values lazily, only when clients request them. We have no reference to return.
&lt;/p&gt;
&lt;pre&gt;
template &amp;lt;typename value&amp;gt;
class text_file_iter
    : public boost::iterator_facade&amp;lt;
      text_file_iter&amp;lt;value&amp;gt;
    , value
    , std::random_access_iterator_tag
    , &lt;strong&gt;value&lt;/strong&gt;
    , std::streamoff
    &amp;gt;
};
&lt;/pre&gt;

&lt;p&gt;I faced a dilemma here. Either I could modify my original file iterator, including a current value data member, which I would take care to update every time we repositioned the file read position. Then our references could be real references and &lt;code&gt;read()&lt;/code&gt; would naturally be &lt;code&gt;const&lt;/code&gt;, simply returning a reference to this member. Or, I could make the &lt;code&gt;in&lt;/code&gt; input stream data member &lt;code&gt;mutable&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Mutable&lt;/code&gt; makes me uneasy for the same reason that &lt;code&gt;friend&lt;/code&gt; does &amp;#8212; if you can shake off the rigours of const-correctness so easily, then why bother with it? &amp;#8212; and for this reason the first option appealed. However, a read-only file is an unusual container: we do not change it, but we cannot supply const references to its elements without reading them in, and that will mean changes to the file input stream. The easier option, involving the smallest code change, was to make &lt;code&gt;in&lt;/code&gt; mutable. So that&amp;#8217;s what I did.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc7" name="tocless-code-more-software" id="tocless-code-more-software"&gt;Less code, more software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;By employing two of my least favourite C++ keywords I now had a class which provided the functions it should, and, thanks to the magic worked by Boost&amp;#8217;s iterator facade, I also had a class which I could use as a standard random access iterator. Most of the code changes were the deletion of boilerplate &amp;#8212; very satisfying. I added code too, since I decided to invest a little more effort in tests. I didn&amp;#8217;t have any doubts about the Boost library&amp;#8217;s correctness but I thought I might not have been using it correctly. Happily these tests all passed.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc8" name="tocperformance" id="tocperformance"&gt;Performance&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s not forget why we originally wanted a random access file iterator: we had a large sorted file, too large to read into memory, and we wanted to test for the presence of the number in this file.
&lt;/p&gt;
&lt;p&gt;For test purposes I created a file just over 4GB in size. A simple linear search through this file took around 180 seconds on my (aging laptop) computer, and was light on memory use. By creating a random access file iterator, boilerplate and all, we took advantage of the standard binary search algorithm and reduced the time to around 4 milliseconds.
&lt;/p&gt;
&lt;p&gt;How would our version using Boost iterator facade do? I wasn&amp;#8217;t expecting it to be faster than the original, but I wouldn&amp;#8217;t have been surprised if it gave it a close run: using Boost doesn&amp;#8217;t usually involve compromise. In fact, over repeated runs of my performance tests there was no significant difference between the two iterator versions &amp;#8212; or at least there wasn&amp;#8217;t once a helpful reader had discovered and fixed a bug in my program, which was causing it to run correctly but slowly.
&lt;/p&gt;
&lt;p&gt;To trust a facade I guess you need some knowledge of what lies behind it.
&lt;/p&gt;
&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: During my original performance tests, reported in the first version of this article, the Boost iterator performed woefully, far slower even than a linear search. By this time I&amp;#8217;d lost patience, and it was left up to a reader, Giuseppe, to &lt;a href="http://wordaligned.org/articles/boost-iterator-facade#comment-60988668"&gt;point out my mistake&lt;/a&gt;. I&amp;#8217;d been using a &lt;code&gt;boost::random_access_traversal_tag&lt;/code&gt; template parameter, with the result that &lt;code&gt;std::distance()&lt;/code&gt; was using repeated increments rather than calling &lt;code&gt;distance_to()&lt;/code&gt; to get an immediate result, and consequently ran very slowly. I should have used &lt;code&gt;std::random_access_iterator_tag&lt;/code&gt;. I modified my code accordingly and confirmed that the Boost version does indeed perform on a par with the original version.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;My thanks to &lt;a href="http://www.flickr.com/photos/chr1sp/" title="Chris. P on Flickr"&gt;Chris P&lt;/a&gt; for permission to use his &lt;a href="http://www.flickr.com/photos/chr1sp/3997724676"&gt;photograph&lt;/a&gt; of the &lt;a href="http://en.wikipedia.org/wiki/Library_of_Celsus" title="Library of Celsus, Wikipedia"&gt;Library of Celsus&lt;/a&gt; at Ephesus, or at rather its beautiful facade. Ephesus is famous for the Temple of Artemis, one of the seven wonders of the ancient world, of which only fragments remain. Thanks too to &lt;a href="http://www.flickr.com/photos/davehamster/"&gt;Dave Hamster&lt;/a&gt; for the boilerplate &lt;a href="http://www.flickr.com/photos/davehamster/2336911145/"&gt;photo&lt;/a&gt; &amp;#8212; actually a detail from the hull of the &lt;a href="http://www.ssgreatbritain.org"&gt;SS Great Britain&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;d like to continue this experiment the code and the tests I used are available via anonymous SVN access from &lt;a href="http://svn.wordaligned.org/svn/etc/search_text_file"&gt;http://svn.wordaligned.org/svn/etc/search_text_file&lt;/a&gt;.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/boost-iterator-facade#fn1link"&gt;[1]&lt;/a&gt;: As of Python 2.7 and 3.2, the standard library will include a version of this recipe. It&amp;#8217;s in the &lt;a href="http://docs.python.org/dev/py3k/library/functools.html#functools.total_ordering" title="functools.total_ordering decorator documentation"&gt;functools module&lt;/a&gt;. For some reason, your class &amp;#8220;should supply an __eq__()&amp;#8221; method.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/boost-iterator-facade#fn2link"&gt;[2]&lt;/a&gt;: According to the Boost.Iterator documentation:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Both &lt;code&gt;iterator_facade&lt;/code&gt; and &lt;code&gt;iterator_adaptor&lt;/code&gt; as well as many of the specialized adaptors mentioned below have been proposed for standardization, and accepted into the first C++ technical report; see our [Standard Proposal For Iterator Facade and Adaptor (PDF)][tr1proposal] for more details.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I assumed this meant there&amp;#8217;d be &lt;code&gt;tr1::iterator_(facade|adaptor)&lt;/code&gt; classes, but I don&amp;#8217;t think that&amp;#8217;s the case. Unlike other (good) bits of Boost, the Iterator library doesn&amp;#8217;t seem likely to be part of the next C++ release.
&lt;/p&gt;</description>
<dc:date>2010-07-07</dc:date>
<guid>http://wordaligned.org/articles/boost-iterator-facade</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/boost-iterator-facade</link>
<category>Python</category>
</item>

<item>
<title>Binary search revisited</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocrecap" name="toc0" id="toc0"&gt;Recap&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocthe-problem" name="toc1" id="toc1"&gt;The Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocinput-iterators" name="toc2" id="toc2"&gt;Input iterators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocfind" name="toc3" id="toc3"&gt;Find&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocrewrite-the-file" name="toc4" id="toc4"&gt;Rewrite the file!&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocadapting-iterators" name="toc5" id="toc5"&gt;Adapting iterators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocmultipass-iterator" name="toc6" id="toc6"&gt;Multipass iterator&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocnot-so-fast" name="toc7" id="toc7"&gt;Not so fast&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocbetter-than-find" name="toc8" id="toc8"&gt;Better than find&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocimplementation" name="toc9" id="toc9"&gt;Implementation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tochardware-used" name="toc10" id="toc10"&gt;Hardware used&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocconclusions" name="toc11" id="toc11"&gt;Conclusions&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc0" name="tocrecap" id="tocrecap"&gt;Recap&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recently &lt;a href="http://wordaligned.org/articles/binary-search.html"&gt;I wrote&lt;/a&gt; about C++&amp;#8217;s standard binary search algorithms (yes, four of them!) which do such a fine job of:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     specifying exactly what kind of range a binary search requires
 &lt;/li&gt;

 &lt;li&gt;
     separating the core algorithm from the details of the range it&amp;#8217;s working on
 &lt;/li&gt;

 &lt;li&gt;
     delivering precise results
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To support these claims I included an implementation of a file iterator, suitable for use with &lt;code&gt;std::binary_search()&lt;/code&gt; etc. to efficiently locate values in very large files.
&lt;/p&gt;
&lt;p&gt;Now, there are a couple of issues with this approach:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     we had to write a lot of code to make a file iterator suitable for use with standard algorithms
 &lt;/li&gt;

 &lt;li&gt;
     this file iterator only works on highly structured files, where each value occupies a fixed number of bytes
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this follow up article we&amp;#8217;ll consider each of these issues in a little more depth by working through two very different solutions to a related problem.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc1" name="tocthe-problem" id="tocthe-problem"&gt;The Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose, once again, that we have a large file, a few gigabytes, say. The file contains numbers, in order, and we&amp;#8217;re interested in testing if this file contains a given number. This time, though, the file is a text file, where the numbers are represented in the usual way as sequences of digits separated by whitespace.
&lt;/p&gt;
&lt;pre&gt;
$ less lots-of-numbers
...
10346  11467 11469 11472  11501 
  11662    12204 12290
...
&lt;/pre&gt;

&lt;p&gt;Note that a number in this file does not occupy a fixed number of bytes. If we jump to a new position in the file using a seek operation, we cannot expect to land exactly where a number starts. Thus the random access file iterator we developed last time won&amp;#8217;t work.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc2" name="tocinput-iterators" id="tocinput-iterators"&gt;Input iterators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In C++ an input file is an example of an input stream, and the standard library gives us &lt;code&gt;istream_iterators&lt;/code&gt; which perform formatted input. In our case, an &lt;code&gt;istream_iterator&amp;lt;int&amp;gt;&lt;/code&gt; effectively converts the file into a stream of numbers.
&lt;/p&gt;
&lt;p&gt;Istream iterators are &lt;a href="http://www.sgi.com/tech/stl/InputIterator.html" title="InputIterator, SGI STL documentation"&gt;input iterators&lt;/a&gt;. They progress through the input stream, item by item, with no repeating or rewinding allowed. Despite their limitations, the C++ standard library provides some algorithms which require nothing more than basic input iterators. For example, to count up even numbers in the file whose name is supplied on the command line we might use &lt;code&gt;std::count_if&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iterator&amp;gt;

bool is_even(int x)
{
    return x % 2 == 0;
}

int main(int argc, char * argv[])
{
    typedef std::istream_iterator&amp;lt;int&amp;gt; i_iter;
    typedef std::ostream_iterator&amp;lt;int&amp;gt; o_iter;
    std::ifstream in(argv[1]);
    
    std::cout &amp;lt;&amp;lt; std::count_if(i_iter(in), i_iter(), is_even) &amp;lt;&amp;lt; '\n';
    
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The next version of C++ supports lambda functions, so you&amp;#8217;ll be able to put &lt;code&gt;is_even&lt;/code&gt; right where it&amp;#8217;s used, in the &lt;code&gt;count_if()&lt;/code&gt; function call. Or, with the current version of C++, you could write:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Ouch!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;    ....
    std::count_if(i_iter(in), i_iter(),
                 std::not1(std::bind2nd(std::modulus&amp;lt;int&amp;gt;(), 2)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Maybe not!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc3" name="tocfind" id="tocfind"&gt;Find&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The very simplest search algorithm, &lt;code&gt;std::find&lt;/code&gt;, needs nothing more than an input iterator. To determine if a number is in a file, we &lt;strong&gt;could&lt;/strong&gt; just invoke &lt;code&gt;std::find&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef std::istream_iterator&amp;lt;int&amp;gt; i_iter;

bool 
is_number_in_file(char const * filename, int n)
{
    std::ifstream in(filename);
    i_iter begin(in);
    i_iter end;
    return std::find(begin, end, n) != end;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the find algorithm advances through the numbers in the file, from start to finish, stopping as soon as it hits one equal to the supplied value, &lt;code&gt;n&lt;/code&gt;. We can expect this function to be light on memory use &amp;#8212; there will be some buffering at the lower levels of the file access, but nothing more &amp;#8212; and the function is evidently correct.
&lt;/p&gt;
&lt;p&gt;It would be correct even if our file was unsorted, however. Is there any way we can do better?
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc4" name="tocrewrite-the-file" id="tocrewrite-the-file"&gt;Rewrite the file!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In the previous article we developed a random access iterator for accessing binary files, and usable for efficient binary searches of sorted binary files. Now would be a good time to question the problem specification. Is this a one off? Or are we going to be testing the presence of more numbers in the file in future? And if so, can we convert the file to binary to save time in the long run? 
&lt;/p&gt;
&lt;p&gt;Although I&amp;#8217;m not going to pursue this option here, it may well be the best approach. For now, though, let&amp;#8217;s assume we have a one-off problem to solve, and that we aren&amp;#8217;t allowed to tinker with the input.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc5" name="tocadapting-iterators" id="tocadapting-iterators"&gt;Adapting iterators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If we want to use &lt;code&gt;std::binary_search&lt;/code&gt; we need, as a minimum, &lt;a href="http://www.sgi.com/tech/stl/ForwardIterator.html" title="ForwardIterator, SGI STL documentation"&gt;forward iterators&lt;/a&gt;. Like input iterators, forward iterators advance, one step at a time. Unlike input iterators, you can copy a forward iterator and dereference or advance that copy in future, independently of the original.
&lt;/p&gt;
&lt;p&gt;Forward iterators are suitable for multipass algorithms, such as &lt;code&gt;std::search&lt;/code&gt;, which looks for the first occurrence of a sequence within a sequence (a generalised &lt;code&gt;strstr&lt;/code&gt;, if you like), or &lt;code&gt;std::adjacent_find&lt;/code&gt; and &lt;code&gt;std::search_n&lt;/code&gt; which look for repeated elements; and of course &lt;code&gt;std::binary_search&lt;/code&gt;, which is our immediate interest.
&lt;/p&gt;
&lt;p&gt;Wouldn&amp;#8217;t it be nice if we could convert our istream iterators into forwards iterators? Then we could plug them directly into all these algorithms.
&lt;/p&gt;
&lt;p&gt;Other languages allow this. You can replicate streams in the Unix shell with &lt;code&gt;tee&lt;/code&gt;. And you can do something similar in Python, thanks to one of the standard &lt;a href="http://docs.python.org/py3k/library/itertools.html"&gt;iterator tools&lt;/a&gt;. Independent iterators over the same sequence needed? &lt;tt&gt;&lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.tee
"&gt;Itertools.tee&lt;/a&gt;&lt;/tt&gt; is your friend. The example below codes up adjacent find in Python.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import tee
import sys

def adjacent_find(xs):
    '''Does the supplied iterable contain any adjacent repeats?
    
    Returns True if xs contains two consecutive, equal items,
    False otherwise. 
    '''
    try:
        curr, next_ = tee(xs)
        next(next_)
        return any(c == n for c, n in zip(curr, next_))
    except StopIteration:
        return False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.jezuk.co.uk/mango" title="Mango: iterators, algorithms, functions, for Java, by Jez Higgins"&gt;&lt;img src="http://www.jezuk.co.uk/files/mango-header.png" alt="Mango: iterators, algorithms, functions, for Java, by Jez Higgins"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Why, even Java has an iterator adaptors, courtesy of Jez Higgins&amp;#8217; &lt;a href="http://www.jezuk.co.uk/mango" title="Mango: iterators, algorithms, functions, for Java, by Jez Higgins"&gt;Mango library&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;What about C++? I couldn&amp;#8217;t find any such iterator adaptors in the standard library, but I turned up something in the standard library research and development unit, also known as &lt;a href="http://www.boost.org" title="Free, peer-reviewed, portable C++ source libraries"&gt;Boost&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://boost.org"&gt;&lt;img src="http://www.boost.org/doc/libs/1_43_0/boost.png" alt="Boost logo"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc6" name="tocmultipass-iterator" id="tocmultipass-iterator"&gt;Multipass iterator&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/index.html"&gt;Boost.Spirit&lt;/a&gt; is a remarkable C++ parser framework, which uses operator overloading to represent parsers directly as EBNF grammars in C++. Somewhere in its depths it tracks back, and hence must adapt input iterators into forward iterators &amp;#8212; or &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/spirit/support/multi_pass.html"&gt;multipass iterators&lt;/a&gt;, to use its own term.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The &lt;code&gt;multi_pass&lt;/code&gt; iterator will convert any input iterator into a forward iterator suitable for use with Spirit.Qi. &lt;code&gt;multi_pass&lt;/code&gt; will buffer data when needed and will discard the buffer when its contents is not needed anymore. This happens either if only one copy of the iterator exists or if no backtracking can occur.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;What&amp;#8217;s good enough for parsing is more than good enough for searching. Here&amp;#8217;s a function which detects whether a number is in a file. Most of the code here just includes the right headers and defines some typedefs. By leaning on high quality support libraries we&amp;#8217;ve overcome our first issue: we no longer have to write loads of code just to call binary search!
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Boost spirit multipass iterators&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;algorithm&amp;gt;

#include &amp;lt;boost/spirit/include/support_multi_pass.hpp&amp;gt;

namespace spirit = boost::spirit;

typedef long long number;
typedef std::istream_iterator&amp;lt;number&amp;gt; in_it;
typedef spirit::multi_pass&amp;lt;in_it&amp;gt; fwd_it;

/*
  Returns true if the input number can be found in the named 
  file, false otherwise. The file must contain ordered, 
  whitespace separated numbers.
*/
bool
is_number_in_file(number n, char const * filename)
{
    std::ifstream in(filename);
    
    fwd_it begin = spirit::make_default_multi_pass(in_it(in));
    fwd_it end = spirit::make_default_multi_pass(in_it());
    
    return std::binary_search(begin, end, n);
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc7" name="tocnot-so-fast" id="tocnot-so-fast"&gt;Not so fast&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If this library-based solution looks too good to be true, that&amp;#8217;s because it is! As we noted &lt;a href="http://wordaligned.org/articles/binary-search.html#tocstdbinarysearch-requirements"&gt;before&lt;/a&gt;, the standard binary search algorithm may indeed work with forward iterators, but it works far better with random access iterators. There&amp;#8217;s no point reducing the number of integer comparisons to &lt;code&gt;O(log(N))&lt;/code&gt; if we&amp;#8217;re going to advance our iterators &lt;code&gt;O(N)&lt;/code&gt; times.
&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s worse, these multipass iterators aren&amp;#8217;t magic. Did you read the smallprint concerning Python&amp;#8217;s &lt;tt&gt;&lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.tee"&gt;tee&lt;/a&gt;&lt;/tt&gt; iterator?
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;This itertool may require significant auxiliary storage (depending on how much temporary data needs to be stored).
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;If teed iterators diverge, intervening values have to be stored somewhere, and the same appears to be true of our inscrutable multipass iterators. Huge chunks of our large input file are buffered into memory. When I ran this function to confirm the presence of a single number somewhere near the middle of a 4.4GB input file, it took over 19 minutes.
&lt;/p&gt;
&lt;pre&gt;
real	19m13.675s
user	5m19.219s
sys	1m26.278s
&lt;/pre&gt;

&lt;p&gt;Much of this time was spent paging.
&lt;/p&gt;
&lt;p&gt;As a comparison, testing for the same value using &lt;code&gt;find&lt;/code&gt; took just under 3 minutes.
&lt;/p&gt;
&lt;pre&gt;
real	2m48.139s
user	2m21.336s
sys	0m7.252s
&lt;/pre&gt;

&lt;p&gt;You&amp;#8217;ll have noticed that we used default multipass iterators. These iterators permit multi-dimensional &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/spirit/support/multi_pass.html"&gt;customisation&lt;/a&gt;. I wasn&amp;#8217;t feeling brave enough to attempt a template storage policy class, and I very much doubt I could have beaten a simple linear find anyway; anything built on a generic input iterator is unlikely to solve our problem efficiently.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc8" name="tocbetter-than-find" id="tocbetter-than-find"&gt;Better than find&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We can beat &lt;code&gt;std::find&lt;/code&gt; with a bit of ingenuity. Standard istream iterators are useful but, in this case, not a good starting point. A better idea is to create a novel iterator which uses file seek operations to advance through the file, then fine-tunes the file position to point at a number.
&lt;/p&gt;
&lt;p&gt;Consider an imagine an iterator which can be positioned at any seekable position in the file, and which we dereference to be the first number in the file which ends at or after that position. The graphic below shows a file with 11 seekable positions, 0 through 10 inclusive. 
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     positions 0 and 1 dereference to the number 42  &lt;br /&gt;
 &lt;/li&gt;

 &lt;li&gt;
     positions 2, 3, 4 and 5 dereference to the number 57
 &lt;/li&gt;

 &lt;li&gt;
     positions 6, 7, 8 and 9 dereference to the number 133
 &lt;/li&gt;

 &lt;li&gt;
     it is an error to try and dereference position 10, at the end of the file
 &lt;/li&gt;
&lt;/ul&gt;
&lt;img src="http://wordaligned.org/images/text-file-iterator.png" alt="Text file iterator"/&gt;

&lt;p&gt;Now, this is a rather unusual iterator. It iterates over the numbers in the file, but each number gets repeated for every byte in the file it occupies. Despite this duality it&amp;#8217;s perfectly usable &amp;#8212; so long as we keep a clear head. Binary searches are fine.
&lt;/p&gt;
&lt;p&gt;How does this version perform?
&lt;/p&gt;
&lt;p&gt;Recall, a linear search for a single value in the middle of a 4.4GB took nearly 3 minutes. Running 10 binary searches through the same file took just 40 milliseconds &amp;#8212; that&amp;#8217;s a rate of 25 searches a second!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc9" name="tocimplementation" id="tocimplementation"&gt;Implementation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s our weird new iterator. It should be usable on files containing whitespace separated items of any type for which the stream read &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; has been defined.
&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s quite a lot of code here, but much of it is random access iterator scaffolding. The interesting functions are the private implementation details towards the end of the class.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;fstream&amp;gt;
#include &amp;lt;ios&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;stdexcept&amp;gt;

#include &amp;lt;ctype.h&amp;gt;

// File read error, thrown when low level file access fails.
class file_read_error : public std::runtime_error
{
public:
    file_read_error(std::string const &amp;amp; what)
        : std::runtime_error(what)
    {
    }
};

/*
  Here's an unusual iterator which can be used to binary search
  for whitespace-separated items in a text file.
  
  It masquerades as a random access iterator but a file
  is not usually a random access device. Nonetheless, file seek
  operations are quicker than stepping through the file item by
  item.
  
  The unusual thing is that the iterators correspond to 
  file offsets rather than items within the file.
  
  Here's a short example where the items are numbers.
  
  +---+---+---+---+---+---+---+---+---+---+
  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
  +---+---+---+---+---+---+---+---+---+---+
  |'4'|'2'|   |   |'5'|'7'|   |'1'|'3'|'3'|
  +---+---+---+---+---+---+---+---+---+---+
  
  The graphic shows a text file which contains 3 numbers,
  42, 57, 133, separated by whitespace.
  
  The file itself is 10 bytes long, and hence there are 11
  iterators over the file, corresponding to actual file positions
  (including the one-past-the end position). To dereference an
  iterator, we step back through the file until we reach either
  whitespace or the start of the file. Then we look forwards 
  again and read in the next item.
  
  In the graphic above:
  
   - Iterators 0 and 1 point to number 42
   - Iterators 2, 3, 4 and 5 point to number 57
   - Iterators 6, 7, 8, 9 point to number 133
   - Iterator 10 is the end, and must not be dereferenced
  
  Dereferencing an iterator always returns an item which is in
  the file, and all items in the file have iterators pointing to
  them, so std::binary_search based on these iterators is valid.
  
  The iterators also expose their underlying file positions
  directory (via the getpos() member function), and with a
  little thought we can make use of std::lower_bound() and
  std::upper_bound().
*/
template &amp;lt;typename item&amp;gt;
class text_file_item_iter
{
    typedef text_file_item_iter&amp;lt;item&amp;gt; iter;
    
private: // Sanity
    
    // Check things are OK, throwing an error on failure.
    void check(bool ok, std::string const &amp;amp; what)
    {
        if (!ok)
        {
            throw file_read_error(what);          
        }
    }
    
public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef item value_type;
    typedef std::streamoff difference_type;
    typedef item * pointer;
    typedef item &amp;amp; reference;
    
    enum start_pos { begin, end };
    
public: // Lifecycle
    text_file_item_iter(iter const &amp;amp; other)
        : fname(other.fname)
    {
        open();
        setpos(other.pos);
    }
    
    text_file_item_iter()
        : pos(-1)
    {
    }
    
    text_file_item_iter(std::string const &amp;amp; fname,
                        start_pos where = begin)
        : fname(fname)
        , pos(-1)
    {
        open();
        if (where == end)
        {
            seek_end();
        }
    }
    
    ~text_file_item_iter()
    {
        close();
    }
    
    iter &amp;amp; operator=(iter const &amp;amp; other)
    {
        close();
        fname = other.fname;
        open();
        setpos(other.pos);
        return *this;
    } 
    
public: // Comparison
        // Note: it's an error to compare iterators over different files.
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }
    
    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }
    
    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }
    
public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }
    
    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }
    
    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }
    
    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }
    
public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }
    
    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }
    
    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }
    
    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }
    
public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return pos - other.pos;
    }
    
public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }
    
    value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }
    
    // Allow direct access to the underlying stream position
    std::streampos getpos()
    {
        std::streampos pos_ = in.tellg();
        check(in, "getpos failed");
        return pos_;
    }
    
private: // Implementation details
    void open()
    {
        in.open(fname.c_str(), std::ios::binary);
        check(in, "open failed");
        pos = getpos();
    }
    
    void close()
    {
        if (in.is_open())
        {
            in.close();
            check(in, "close failed");
        }
    }
    
    void advance(difference_type n)
    {
        check(in.seekg(n, std::ios_base::cur), "advance failed");
        pos = getpos();
    }
    
    void seek_end()
    {
        check(in.seekg(0, std::ios_base::end), "seek_end failed");
        chop_whitespace();
        pos = getpos();
    }
    
    void chop_whitespace()
    {
        do
        {
            in.unget();
        } while (isspace(in.peek()));
        in.get();
        in.clear();
    }
    
    void setpos(std::streampos newpos)
    {
        check(in.seekg(newpos), "setpos failed");
        pos = newpos;
    }
    
    // Return the item at the current position
    value_type read()
    {
        item n = 0;
        // Reverse till we hit whitespace or the start of the file
        while (in &amp;amp;&amp;amp; !isspace(in.peek()))
        {
            in.unget();
        }
        in.clear();
        check(in &amp;gt;&amp;gt; n, "read failed");
        return n;
    }
    
private: // State
    std::string fname;
    std::ifstream in;
    std::streampos pos;
};

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc10" name="tochardware-used" id="tochardware-used"&gt;Hardware used&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;
  Model Name:	            MacBook
  Model Identifier:	    MacBook1,1
  Processor Name:           Intel Core Duo
  Processor Speed:          2 GHz
  Number Of Processors:	    1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://www.flickr.com/photos/photobunny_earl/1008279066" title="Mushroom, by photobunny"&gt;&lt;img src="http://farm2.static.flickr.com/1440/1008279066_847d73c90d.jpg" alt="Mushroom, by photobunny"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc11" name="tocconclusions" id="tocconclusions"&gt;Conclusions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Initially the Boost.Spirit solution looked promising but we pushed it too hard. Suitable abstractions can remove complexity; but they can also hide it. When efficiency matters, we need a handle on what&amp;#8217;s going on.
&lt;/p&gt;
&lt;p&gt;After this false start we &lt;strong&gt;did&lt;/strong&gt; find a way to create a file iterator suitable for use with the standard binary search algorithms. Use it with care, though!
&lt;/p&gt;</description>
<dc:date>2010-05-26</dc:date>
<guid>http://wordaligned.org/articles/binary-search-revisited</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/binary-search-revisited</link>
<category>Python</category>
</item>

<item>
<title>Power programming</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocpowerful-or-dangerous" name="toc0" id="toc0"&gt;Powerful or dangerous?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocdecision-trees" name="toc1" id="toc1"&gt;Decision trees&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toccuteness-calculator" name="toc2" id="toc2"&gt;Cuteness calculator&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toceval" name="toc3" id="toc3"&gt;Eval&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocdynamic-or-hacky" name="toc4" id="toc4"&gt;Dynamic or hacky?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocjam-to-golf" name="toc5" id="toc5"&gt;Jam to golf&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toccode-vs-data" name="toc6" id="toc6"&gt;Code vs data&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocpowerful-language-vs-power-user" name="toc7" id="toc7"&gt;Powerful language vs power user?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocappendix-a-first-impressions-of-arc" name="toc8" id="toc8"&gt;Appendix A: First impressions of Arc&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocappendix-b-c-solution" name="toc9" id="toc9"&gt;Appendix B: C++ solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocappendix-c-a-python-solution" name="toc10" id="toc10"&gt;Appendix C: A Python Solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocnotes" name="toc11" id="toc11"&gt;Notes&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc0" name="tocpowerful-or-dangerous" id="tocpowerful-or-dangerous"&gt;Powerful or dangerous?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recently I &lt;a href="http://wordaligned.org/articles/next-permutation.html" title="Next permutation: when C++ gets it right"&gt;wrote about&lt;/a&gt; one of the &lt;a href="http://code.google.com/codejam/"&gt;Google Code Jam&lt;/a&gt; challenges, where, perhaps surprisingly, the best answer &amp;#8212; the most elegant and obviously correct answer, requiring the fewest lines of code, with virtually zero space overhead, and running the quickest &amp;#8212; the very best answer was coded in C++.
&lt;/p&gt;
&lt;p&gt;Why should this be surprising? C++ is a powerful language.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In my experience there is almost no limit to the damage that a sufficiently ingenious fool can do with C++. But there is also almost no limit to the degree of complexity that a skillful library designer can hide behind a simple, safe, and elegant C++ interface. 
&lt;/p&gt;
&lt;p&gt;&amp;#8212; Greg Colvin, &lt;a href="http://www.artima.com/cppsource/spiritofc2.html" title="Greg Colvin, In the Spirit of C"&gt;&amp;#8220;In the Spirit of C&amp;#8221;&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Yes. And yes! But in this article I wanted to discuss something C++ &lt;strong&gt;can&amp;#8217;t&lt;/strong&gt; do. Let&amp;#8217;s start with another &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#" title="Decision Tree, Google Code Jam 2009"&gt;challenge&lt;/a&gt; from the same round of the 2009 Google Code Jam.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc1" name="tocdecision-trees" id="tocdecision-trees"&gt;Decision trees&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;Decision trees &amp;#8212; in particular, a type called classification trees &amp;#8212; are data structures that are used to classify &lt;i&gt;items&lt;/i&gt; into &lt;i&gt;categories&lt;/i&gt; using &lt;i&gt;features&lt;/i&gt; of those items. For example, each animal is either &amp;#8220;cute&amp;#8221; or not. For any given animal, we can decide whether it is cute by looking at the animal&amp;#8217;s features and using the following decision tree.&lt;/p&gt;
&lt;pre&gt;(0.2 furry
  (0.81 fast
    (0.3)
    (0.2)
  )
  (0.1 fishy
    (0.3 freshwater
      (0.01)
      (0.01)
    )
    (0.1)
  )
)
&lt;/pre&gt;&lt;p&gt;&amp;mdash; &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#"&gt;Decision Trees, Google Code Jam 2009&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="http://www.zazzle.com/cute_beaver_magnet-147411069592023743"&gt;&lt;img src="http://wordaligned.org/images/cute-beaver.png" alt="Cute beaver!" width="227px" height="193px" style="float:right;margin:25px 25px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The challenge goes on to describe the structure more formally, then steps through an example calculation. What is the probability, &lt;code&gt;p&lt;/code&gt;, that a beaver is cute?
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;For example, a beaver is an animal that has two features: &lt;code&gt;furry&lt;/code&gt; and &lt;code&gt;freshwater&lt;/code&gt;. We start at the root with &lt;code&gt;p&lt;/code&gt; equal to &lt;code&gt;1&lt;/code&gt;. We multiply &lt;code&gt;p&lt;/code&gt; by &lt;code&gt;0.2&lt;/code&gt;, the weight of the root and move into the first sub-tree because the beaver has the &lt;code&gt;furry&lt;/code&gt; feature. There, we multiply &lt;code&gt;p&lt;/code&gt; by &lt;code&gt;0.81&lt;/code&gt;, which makes &lt;code&gt;p&lt;/code&gt; equal to &lt;code&gt;0.162&lt;/code&gt;. From there we move further down into the second sub-tree because the beaver does not have the fast feature. Finally, we multiply &lt;code&gt;p&lt;/code&gt; by &lt;code&gt;0.2&lt;/code&gt; and end up with &lt;code&gt;0.0324&lt;/code&gt; &amp;#8212; the probability that the beaver is cute. 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;img src="http://wordaligned.org/images/decision-tree.png" alt="Decision tree calculation"/&gt;

&lt;p&gt;The challenge itself involves processing input comprising a number of test cases. Each test case consists of a decision tree followed by a number of animals. A solution should parse the input and output the calculated cuteness probabilities.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc2" name="toccuteness-calculator" id="toccuteness-calculator"&gt;Cuteness calculator&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def cuteness(decision_tree, features):
    """Return the probability an animal is cute.
    
    - decision_tree, the decision tree
    - features, the animal's features,
    """
    p = 1.0
    dt = decision_tree
    has_feature = features.__contains__
    while dt:
        weight, *dt = dt
        p *= weight
        if dt:
            feat, lt, rt = dt
            dt = lt if has_feature(feat) else rt
    return p

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Calculating an animal&amp;#8217;s cuteness given a decision tree and the animal&amp;#8217;s features isn&amp;#8217;t hard. In Python we don&amp;#8217;t need to code up a specialised decision tree class &amp;#8212; a nested tuple does just fine. The &lt;code&gt;cuteness()&lt;/code&gt; function shown above descends the decision tree, switching left or right according to each feature&amp;#8217;s presence or absence. The efficiency of this algorithm is proportional to the depth of the tree multiplied by the length of the feature list; as far as the code jam challenge goes, it&amp;#8217;s not a concern.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; decision_tree = (
...     0.2, 'furry',
...         (0.81, 'fast',
...             (0.3,),
...             (0.2,),
...         ),
...         (0.1, 'fishy',
...             (0.3, 'freshwater',
...                  (0.01,),
...                  (0.01,),
...             ),
...             (0.1,),
...         ),
...     )
&amp;gt;&amp;gt;&amp;gt; beaver = ('furry', 'freshwater')
&amp;gt;&amp;gt;&amp;gt; cuteness(decision_tree, beaver)
0.032400000000000005

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;No, the real problem here is how to parse the input data to create the decision trees and feature sets. As you can see, though, the textual specification of a decision tree closely resembles a Python representation of that decision tree. Just add punctuation.
&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;Specification&lt;/td&gt;&lt;td&gt;Python&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre&gt;(0.2 furry
  (0.81 fast
    (0.3)
    (0.2)
  )
  (0.1 fishy
    (0.3 freshwater
      (0.01)
      (0.01)
    )
    (0.1)
  )
)&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;(0.2, 'furry',
  (0.81, 'fast',
    (0.3,),
    (0.2,),
  ),
  (0.1, 'fishy',
    (0.3, 'freshwater',
      (0.01,),
      (0.01,),
      ),
      (0.1,),
  ),
)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Rather than parse the decision tree definition by hand, why not tweak it so that it &lt;strong&gt;is&lt;/strong&gt; a valid Python nested tuple? Then we can just let the Python interpreter &lt;a href="http://docs.python.org/library/functions.html#eval"&gt;&lt;tt&gt;eval&lt;/tt&gt;&lt;/a&gt; the tuple and use it directly.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc3" name="toceval" id="toceval"&gt;Eval&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A program&amp;#8217;s ability to read and execute source code at run-time is one of the things which makes &lt;a href="http://en.wikipedia.org/wiki/Dynamic_programming_language#Eval"&gt;dynamic languages&lt;/a&gt; dynamic. You can&amp;#8217;t do it in C and C++ &amp;#8212; no, sneaking instructions &lt;a href="http://en.wikipedia.org/wiki/Buffer_overrun"&gt;past the end of a buffer&lt;/a&gt; doesn&amp;#8217;t count. Should you do it in Python? Well, it won&amp;#8217;t hurt to give it a try.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;spec = '''\
(0.2 furry
  (0.81 fast
    (0.3)
    (0.2)
  )
  (0.1 fishy
    (0.3 freshwater
      (0.01)
      (0.01)
    )
    (0.1)
  )
)
'''

tuple_rep = re.sub(r'([\.\d]+|\))', r'\1,', spec)
tuple_rep = re.sub(r'([a-z]+)', r'"\1",', tuple_rep)
decision_tree = eval(tuple_rep)[0]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, we start with the input specification of the decision tree (imagine this has been read directly from standard input). The first regex substitution inserts commas after numbers, and right parentheses. The second substitution quotes and inserts a comma after feature strings. This turns the decision tree&amp;#8217;s specification into a textual representation of a nested Python tuple. We then &lt;code&gt;eval&lt;/code&gt; that tuple and assign the result to &lt;code&gt;decision_tree&lt;/code&gt; &amp;#8212; a Python decision tree we can go on and use in the rest of our program. And that&amp;#8217;s the code jam challenge cracked, pretty much.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from pprint import pprint
&amp;gt;&amp;gt;&amp;gt; pprint(decision_tree)
(0.2,
 'furry',
 (0.81, 'fast', (0.3,), (0.2,)),
 (0.1, 'fishy', (0.3, 'freshwater', (0.01,), (0.01,)), (0.1,)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Minor wrinkle: you&amp;#8217;ll have spotted the final decision tree is the first element of the evaluated tuple. That&amp;#8217;s because the regex substitution puts a trailing comma after the right parenthesis which closes the decision tree specification, which turns &lt;code&gt;tuple_rep&lt;/code&gt; into a one-tuple. The single element contained in this one-tuple is what we need.)
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc4" name="tocdynamic-or-hacky" id="tocdynamic-or-hacky"&gt;Dynamic or hacky?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As you can see, it doesn&amp;#8217;t take much code to pull the decision tree in ready for use. Python allows us to convert between text and code and to execute code within the current environment: you just need to keep a clear head and remember where you are. Regular expressions may not have the first class language support they enjoy in Perl and Ruby, but they are well supported, and the raw string syntax makes them more readable.
&lt;/p&gt;
&lt;p&gt;Certainly, this code snippet is easier to put together than a full blown &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=0" title="Google's analysis of the decision tree challenge, including a parser"&gt;parser&lt;/a&gt;, but I think it will take more than this to convince a C++ programmer that Python is a powerful language, rather than a dangerous tool for ingenious fools. It fails to convince me. I can&amp;#8217;t remember ever using &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; in production code, where keeping a separation between layers is more important than speed of coding.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc5" name="tocjam-to-golf" id="tocjam-to-golf"&gt;Jam to golf&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://codegolf.com"&gt;&lt;img src="http://codegolf.com/images/logo.png" alt="Code Golf logo" width="332px" height="75px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;That said, Python is a fine language for scripting, and speed of coding &lt;strong&gt;is&lt;/strong&gt; what matters in this particular challenge. Just for fun, what if there were &lt;a href="http://stackoverflow.com/questions/1433263/decision-tree-code-golf" title="Decision tree code golf on Stack Overflow"&gt;a prize for brevity&lt;/a&gt;? Then of course Perl would &lt;a href="http://stackoverflow.com/questions/1433263/decision-tree-code-golf/1442392#1442392" title="gnibbler's winning Perl entry"&gt;win&lt;/a&gt;!
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Code Jam golf, by gnibbler, Stack Overflow&lt;/div&gt;

&lt;pre class="prettyprint"&gt;say("Case #$_:"),
$_=eval"''".'.&amp;lt;&amp;gt;'x&amp;lt;&amp;gt;,
s:[a-z]+:*(/ $&amp;amp;\\s/?:g,s/\)\s*\(/):/g,
eval"\$_=&amp;lt;&amp;gt;;say$_;"x&amp;lt;&amp;gt;for 1..&amp;lt;&amp;gt;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that this does more than simply parse a decision tree &amp;#8212; it&amp;#8217;s a complete solution to the code jam &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#" title="Decision Tree, Google Code Jam 2009"&gt;challenge&lt;/a&gt;, reading trees, features, calculating cutenesses, and producing output in the required format. Sadly that&amp;#8217;s all I can say about it because the details of its operation are beyond me.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc6" name="toccode-vs-data" id="toccode-vs-data"&gt;Code vs data&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Using Python to dynamically execute code may not generally be needed or welcomed in Python production code, and over-reliance on the same trick risks reinforcing Perl&amp;#8217;s  &amp;#8220;write only&amp;#8221; reputation, but Python and Perl aren&amp;#8217;t the only contenders. &lt;span /&gt;The equivalence of code and data marks Lisp&amp;#8217;s apotheosis. Take a look at a &lt;a href="http://stackoverflow.com/questions/1433263/decision-tree-code-golf/1540845#1540845" title="Arc solution to decision tree"&gt;Lisp solution&lt;/a&gt; to the challenge. This one is coded up in &lt;a href="http://arclanguage.org" title="Arc, a new dialect of Lisp"&gt;Arc&lt;/a&gt;.
&lt;/p&gt;
&lt;pre class="prettyprint lang-lisp"&gt;
(def r () (read))
(for i 1 (r)
  (prn "Case #" i ":")
  (r)
  (= z (r))
  (repeat (r)
    (r)
    (loop (= g (n-of (r) (r))
             c z
             p 1)
       c
       (= p (* (pop c) p)
          c (if (pos (pop c) g)
                (c 0)
                (cadr c))))
    (prn p)))
&lt;/pre&gt;

&lt;p&gt;Which challenge does this solve? 
&lt;/p&gt;
&lt;p&gt;I meant the code golf challenge, of solving the decision tree problem using the fewest keystrokes. At 154 characters this Arc program is nearly half as long again as the winning Perl entry, but it&amp;#8217;s hardly flabby. What really impresses me, though, is that the code is (almost) as readable as it is succinct. It&amp;#8217;s elegant code. The only real scars left by the battle for brevity are the one character variable names. Here&amp;#8217;s the same code with improved variable names and some comments added. It&amp;#8217;s the &lt;code&gt;(read)&lt;/code&gt; calls which evaluate expressions on standard input. The &lt;code&gt;(for ...)&lt;/code&gt; and &lt;code&gt;(repeat ...)&lt;/code&gt; expressions operate as you might expect. The third looping construct, &lt;code&gt;(loop ...)&lt;/code&gt; initialises, tests and proceeds, much like a C for loop.
&lt;/p&gt;
&lt;pre class="prettyprint lang-lisp"&gt;
(for i 1 (read)               ; Read N, # test cases, and loop
  (prn "Case #" i ":")
  
  (read)                      ; Skip L, # lines taken by decision tree
  (= dtree (read))            ; and read the tree in directly
  
  (repeat (read)              ; Repeat over A, # animals
    (read)                    ; Skip animal name
    ; Read in the animal's features and walk down the 
    ; decision tree calculating p, the cuteness probability
    (loop (= features (n-of (read) (read)) 
             dt dtree
             p 1)
       dt
       (= p (* (pop dt) p)
          dt (if (pos (pop dt) features)
                (car dt)
                (cadr dt))))
    (prn p)))
&lt;/pre&gt;

&lt;p&gt;You could argue the elegance of this solution is due to the fact the input comprises a sequence of tokens and &lt;a href="http://en.wikipedia.org/wiki/S-expression" title="S-expressions, Wikipedia"&gt;S-expressions&lt;/a&gt;. If commas had been used to separate input elements and the text fields had been enclosed in quotes, then maybe a Python solution would have been equally clean. Or if the input had been in XML, then we&amp;#8217;d be looking to a library rather than &lt;code&gt;eval&lt;/code&gt; for parsing the input.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s a fair point, but the equivalence of code and data counts as Lisp&amp;#8217;s biggest idea. Where Python&amp;#8217;s &lt;code&gt;eval&lt;/code&gt; is workable but rarely needed, Lisp&amp;#8217;s &lt;code&gt;(read)&lt;/code&gt; is fundamental.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc7" name="tocpowerful-language-vs-power-user" id="tocpowerful-language-vs-power-user"&gt;Powerful language vs power user?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So, the most elegant answer to the code jam decision tree challenge would also be the quickest to write, and it would be written in Lisp. Did code jam champion, &lt;a href="http://www.go-hero.net/jam/09/name/ACRush" title="ACRush's code jam solutions"&gt;ACRush&lt;/a&gt;, submit a Lisp solution?
&lt;/p&gt;
&lt;p&gt;Absolutely not!
&lt;/p&gt;
&lt;p&gt;Another fundamental thing about Lisp is that it&amp;#8217;s straightforward to parse. A C++ expert can knock up an input parser for decision trees and features to order. ACRush brushed this round aside with a perfect score, taking just 45 minutes to code up working C++ solutions to this question &lt;strong&gt;and two others&lt;/strong&gt;. I&amp;#8217;ve reproduced his solution to the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#" title="Decision Tree, Google Code Jam 2009"&gt;decision tree challenge&lt;/a&gt; at the end of this article. It&amp;#8217;s plain and direct. Given the time constraints, I think it exhibits astonishing fluency &amp;#8212; the work of someone who can think in C++.
&lt;/p&gt;
&lt;p&gt;In this article we&amp;#8217;ve encountered four programming languages:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Python
 &lt;/li&gt;

 &lt;li&gt;
     Perl
 &lt;/li&gt;

 &lt;li&gt;
     Lisp
 &lt;/li&gt;

 &lt;li&gt;
     C++
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are very different but they share features too. They are all mature, popular and well-supported&lt;a id="fn1link" href="http://wordaligned.org/articles/power-programming#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;. Each is a powerful general purpose programming language. &lt;span /&gt;But ultimately, the power of the programmer is what matters.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc8" name="tocappendix-a-first-impressions-of-arc" id="tocappendix-a-first-impressions-of-arc"&gt;Appendix A: First impressions of Arc&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s another revision of the Arc solution, this time decomposed into subfunctions. I found no complete formal documentation of &lt;a href="http://arclanguage.org" title="Arc, a new dialect of Lisp"&gt;Arc&lt;/a&gt;. You&amp;#8217;ll have to read the source and follow the forum, and to actually run any code you&amp;#8217;ll have to download a an old version of MzScheme. The official line is: by all means have a play, but expect things to change. That said, the language looks delightful, practical, and quite &lt;a href="http://www.paulgraham.com/arcll1.html" title="No onions in the varnish, says Paul Graham"&gt;onion free&lt;/a&gt;. The &lt;a href="http://ycombinator.com/arc/tut.txt"&gt;tutorial&lt;/a&gt; made me smile. Recommended reading.
&lt;/p&gt;
&lt;pre class="prettyprint lang-lisp"&gt;
; The input is a sequence of valid Arc expressions.
; Create some read aliases to execute these.
(= skip read
   decision-tree read
   n-features read 
   n-tests read
   n-animals read)

(def animal-features ()
     ; Get an animal's features
     (skip) ; animal name
     (n-of (n-features) (read)))

(def cuteness (dtree features)
     ; Calculate cuteness from a decision tree and feature set
     (= dt dtree
        p 1.0)
     (while dt
          (= p (* (pop dt) p)
             dt (if (pos (pop dt) features)
                (car dt)
                (cadr dt))))
     p)

; Loop through the tests, printing results
(for i 1 (n-tests)
     (prn "Case #" i ":")
     (skip) ; # lines the tree specification takes
     (= dtree (decision-tree))
     (repeat 
         (n-animals)
         (prn (cuteness dtree (animal-features)))))
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc9" name="tocappendix-b-c-solution" id="tocappendix-b-c-solution"&gt;Appendix B: C++ solution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s champion ACRush&amp;#8217;s C++ solution. I&amp;#8217;ve removed some general purpose macros from the top of the file. You can download the &lt;a href="http://code.google.com/codejam/contest/scoreboard/do?cmd=GetSourceCode&amp;amp;contest=186264&amp;amp;problem=171116&amp;amp;io_set_id=1&amp;amp;username=ACRush"&gt;original here&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;set&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;

using namespace std;

vector&amp;lt;string&amp;gt; A;
vector&amp;lt;int&amp;gt; P;
set&amp;lt;string&amp;gt; M;

#define SIZE(X) ((int)(X.size()))

double solve(int H,int T)
{
    H++;T--;
    double p=atof(A[H].c_str());
    if (H==T) return p;
    if (M.find(A[H+1])!=M.end())
        return p*solve(H+2,P[H+2]);
    else
        return p*solve(P[T],T);
}
int main()
{
    freopen("A-large.in","r",stdin);freopen("A-large.out","w",stdout);
    int testcase;
    scanf("%d",&amp;amp;testcase);
    for (int caseId=1;caseId&amp;lt;=testcase;caseId++)
    {
        int nline;
        scanf("%d",&amp;amp;nline);
        A.clear();
        char str[1024];
        gets(str);
        for (int i=0;i&amp;lt;nline;i++)
        {
            gets(str);
            string s="";
            for (int k=0;str[k];k++)
                if (str[k]=='(' || str[k]==')')
                    s+=" "+string(1,str[k])+" ";
                else
                    s+=str[k];
            istringstream sin(s);
            for (;sin&amp;gt;&amp;gt;s;A.push_back(s));
        }
        P.resize(SIZE(A),-1);
        vector&amp;lt;int&amp;gt; stack;
        for (int i=0;i&amp;lt;SIZE(A);i++)
            if (A[i]=="(")
                stack.push_back(i);
            else if (A[i]==")")
            {
                int p=stack[SIZE(stack)-1];
                P[i]=p;
                P[p]=i;
                stack.pop_back();
            }
        int cnt;
        printf("Case #%d:\n",caseId);
        for (scanf("%d",&amp;amp;cnt);cnt&amp;gt;0;cnt--)
        {
            scanf("%s",str);
            M.clear();
            int length;
            for (scanf("%d",&amp;amp;length);length&amp;gt;0;length--)
            {
                scanf("%s",str);
                M.insert(str);
            }
            double r=solve(0,SIZE(A)-1);
            printf("%.12lf\n",r);
        }
    }
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc10" name="tocappendix-c-a-python-solution" id="tocappendix-c-a-python-solution"&gt;Appendix C: A Python Solution&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import re
from itertools import islice

def cuteness(decision_tree, features):
    p = decision_tree[0]
    if len(decision_tree) &amp;gt; 1:
        _, feat, lt, rt = decision_tree
        p *= cuteness(lt if feat in features else rt, features)
    return p

def read_decision_tree(spec):
    tuple_rep = re.sub(r'([\.\d]+|\))', r'\1,', spec)
    tuple_rep = re.sub(r'([a-z]+)', r'"\1",', tuple_rep)
    return eval(tuple_rep)[0]

def take_lines(lines, n):
    return ''.join(islice(lines, n))

def main(fp):
    lines = iter(fp)
    n_tests = int(next(lines))
    for tc in range(1, n_tests + 1):
        print("Case #%d:" % tc)
        tree_spec = take_lines(lines, int(next(lines)))
        dtree = read_decision_tree(tree_spec)
        n_animals = int(next(lines))
        for line in islice(lines, n_animals):
            features = set(line.split()[2:])
            print(cuteness(dtree, features))

import sys
main(sys.stdin)

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc11" name="tocnotes" id="tocnotes"&gt;Notes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/power-programming#fn1link"&gt;[1]&lt;/a&gt; (Arc may not be mature, popular or well-supported; but Lisp certainly is.)
&lt;/p&gt;</description>
<dc:date>2010-01-26</dc:date>
<guid>http://wordaligned.org/articles/power-programming</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/power-programming</link>
<category>Python</category>
</item>

</channel>
</rss>
