<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>http://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>Find the average of a collection of tuples or dicts using Python</title>
<description>&lt;p&gt;You&amp;#8217;ve been running some tests, each of which returns a 3-tuple of numerical results &amp;#8212; &lt;code&gt;(real, user, sys)&lt;/code&gt; times, maybe &amp;#8212; and you&amp;#8217;d like to combine these into a single 3-tuple, the average result.
&lt;/p&gt;
&lt;p&gt;Easy!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def average(times):
    N = float(len(results))
    return (sum(t[0] for t in times)/N,
            sum(t[1] for t in times)/N,
            sum(t[2] for t in times)/N)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If you want a more generic solution, one which works when the tuples might have any number of elements, you could do this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def average(xs):
    N = float(len(xs))
    R = len(xs[0])
    return tuple(sum(x[i] for x in xs)/N for i in range(R))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;or this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def average(xs):
    N = float(len(xs))
    return tuple(sum(col)/N for col in zip(*xs))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The second generic variant uses &lt;a href="https://docs.python.org/3/library/functions.html#zip"&gt;zip&lt;/a&gt; to transpose its inputs. 
&lt;/p&gt;
&lt;p&gt;Now suppose we have keyed collections of results which we want to average:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; times = [{'real': 34.4, 'user': 26.2, 'sys': 7.3},
             {'real': 28.7, 'user': 21.5, 'sys': 6.4},
             {'real': 29.3, 'user': 22.0, 'sys': 6.9}]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If, as in the example above, each result has the same set of keys, the average result could be calculated like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; N = float(len(times))
&amp;gt;&amp;gt;&amp;gt; { k : sum(t[k] for t in times)/N for k in times[0] }
{'real': 30.8, 'sys': 6.9, 'user': 23.2}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;What if the inputs don&amp;#8217;t have the same keys? Consider the contents of four fridges.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; fridges = [
    { 'egg': 5, 'milk': 1.700, 'sausage': 6 },
    { 'beer': 6, 'milk': 0.568, 'egg': 1 },
    { 'egg': 3, 'sausage': 4, 'milk': 0.125, 'lettuce': 1 },
    { 'carrot': 4 }]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;A &lt;a href="https://docs.python.org/3/library/collections.html#collections.Counter"&gt;Counter&lt;/a&gt; can collect and calculate the average fridge contents. 
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Counter
&amp;gt;&amp;gt;&amp;gt; total = sum(map(Counter, fridges), Counter())
&amp;gt;&amp;gt;&amp;gt; N = float(len(fridges))
&amp;gt;&amp;gt;&amp;gt; { k: v/N for k, v in total.items() }
{'sausage': 2.5, 'lettuce': 0.25, 'beer': 1.5, 'carrot': 1.0, 
 'egg': 2.25, 'milk': 0.59825}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that although &lt;code&gt;Counter&lt;/code&gt;s were primarily designed to work with positive integers to represent counts, there&amp;#8217;s nothing stopping us from using floating point numbers (amount of milk in our example) in the values field.
&lt;/p&gt;</description>
<dc:date>2014-12-03</dc:date>
<guid>http://wordaligned.org/articles/python-averages</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/python-averages</link>
<category>Python</category>
</item>

<item>
<title>Group When</title>
<description>&lt;p&gt;Phil Nash&amp;#8217;s recent tweet intrigued me.
&lt;/p&gt;
&lt;div&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;Functional people: I often (in F#) need to process a seq into a smaller list or seq &amp;ndash; where items from the input are grouped in some way&amp;hellip;&lt;/p&gt;&amp;mdash; Phil Nash (@phil_nash) &lt;a href="https://twitter.com/phil_nash/statuses/489167611641724928"&gt;July 15, 2014&lt;/a&gt;&lt;/blockquote&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;&amp;hellip; the need to group may not be known until after the first item in the group.&amp;#10;I struggle to find a nicely functional way to do this. Ideas?&lt;/p&gt;&amp;mdash; Phil Nash (@phil_nash) &lt;a href="https://twitter.com/phil_nash/statuses/489167962931482626"&gt;July 15, 2014&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="http://wordaligned.org//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/div&gt;

&lt;p&gt;He later clarified what he was after &amp;#8212; and had now found &amp;#8212; linking to a &lt;a href="http://fssnip.net/6A"&gt;solution&lt;/a&gt; posted a couple of years ago by &lt;a href="http://tomasp.net"&gt;Tomas Petricek&lt;/a&gt;. The function &lt;code&gt;groupWhen&lt;/code&gt; splits a sequence into groups, starting a new group whenever the predicate returns true.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt; module Seq =
   /// Iterates over elements of the input sequence and groups adjacent elements.
   /// A new group is started when the specified predicate holds about the element
   /// of the sequence (and at the beginning of the iteration).
   ///
   /// For example: 
   ///    Seq.groupWhen isOdd [3;3;2;4;1;2] = seq [[3]; [3; 2; 4]; [1; 2]]
   let groupWhen f (input:seq&amp;lt;_&amp;gt;) = seq {
     use en = input.GetEnumerator()
     let running = ref true
     
     // Generate a group starting with the current element. Stops generating
     // when it founds element such that 'f en.Current' is 'true'
     let rec group() = 
       [ yield en.Current
         if en.MoveNext() then
           if not (f en.Current) then yield! group() 
         else running := false ]
     
     if en.MoveNext() then
       // While there are still elements, start a new group
       while running.Value do
         yield group() |&amp;gt; Seq.ofList }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a nice Haskell version coded up by &lt;a href="https://twitter.com/sdarlington"&gt;@sdarlington&lt;/a&gt;.
&lt;/p&gt;
&lt;script src="https://gist.github.com/sdarlington/be76048bff124694769d.js"&gt;&lt;/script&gt;

&lt;p&gt;Maybe &lt;a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile"&gt;takewhile&lt;/a&gt; and &lt;a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile"&gt;dropwhile&lt;/a&gt; could power a Python solution, but my first choice would be &lt;a href="https://docs.python.org/3/library/itertools.html#itertools.groupby"&gt;itertools.groupby&lt;/a&gt;. &lt;code&gt;Groupby&lt;/code&gt; chops a sequence into subsequences, where the elements of each subsequence have the same key value. A suitable key function, in this case, must change its return value every time the sequence yields an element for which the predicate holds. It could toggle between a pair of values, for example. Or it could just count the number of times the predicate holds.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;class count_p:
    ''' Return a value which increments every time the predicate holds.
    '''
    def __init__(self, pred):
        self._n = 0
        self._pred = pred
    
    def __call__(self, v):
        self._n += self._pred(v)
        return self._n

def group_when(pred, xs):
    return (gp for _, gp in groupby(xs, count_p(pred)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;group_when&lt;/code&gt; accepts an iterable and returns an iterable sequence of iterable groups. Clients choose how to consume the results.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; def odd(v): return v % 2
&amp;gt;&amp;gt;&amp;gt; xs = group_when(odd, [3, 3, 2, 4, 1, 2])
&amp;gt;&amp;gt;&amp;gt; print([list(g) for g in xs])
[[3], [3, 2, 4], [1, 2]]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that &lt;code&gt;count_p&lt;/code&gt; does something very like &lt;a href="acc"&gt;itertools.accumulate&lt;/a&gt;. Here&amp;#8217;s another version of &lt;code&gt;group_when&lt;/code&gt; which takes advantage of this.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def group_when(pred, xs):
    xs, ys = tee(xs)
    accu = accumulate(map(pred, ys))
    return (gp for _, gp in groupby(xs, lambda _: next(accu)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;After a short break, here&amp;#8217;s a third version of &lt;code&gt;group_when&lt;/code&gt;. This is the first time I&amp;#8217;ve found a use for &lt;code&gt;takewhile&lt;/code&gt; and &lt;code&gt;dropwhile&lt;/code&gt;. Beware: as the teed streams &lt;code&gt;xs&lt;/code&gt; and &lt;code&gt;ys&lt;/code&gt; diverge, the amount of backing storage required will grow &amp;#8230; only for the stored values to then be dropped!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import *
 
def group_when(p, xs):
    def notp(x): return not p(x)
    xs = iter(xs)
    while True:
        x = next(xs)
        xs, ys = tee(xs)
        yield chain([x], takewhile(notp, xs))
        xs = dropwhile(notp, ys)
 
def odd(x):
    return x % 2
 
[list(g) for g in group_when(odd, [3, 3, 2, 4, 1, 2])] # [[3], [3, 2, 4], [1, 2]]

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2014-07-16</dc:date>
<guid>http://wordaligned.org/articles/group-when</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/group-when</link>
<category>Python</category>
</item>

<item>
<title>You wait all day for a bus&#8230;</title>
<description>&lt;p&gt;&lt;a href="http://docs.python.org/3/library/functions.html#any"&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; and &lt;a href="http://docs.python.org/3/library/functions.html#all"&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt;  didn&amp;#8217;t appear in Python until version 2.5, released in 2006, when the language was already well into its teens.
&lt;/p&gt;
&lt;p&gt;Why the delay in offering such fundamental functions? An oversight? Or simply that they&amp;#8217;re so easy to implement they weren&amp;#8217;t thought necessary. Either way, they&amp;#8217;re here now.
&lt;/p&gt;
&lt;p&gt;The functions are closely related and complementary. We can define &lt;code&gt;any&lt;/code&gt; in terms of &lt;code&gt;all&lt;/code&gt; and vice-versa.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def any_(xs):
    return not all(map(operator.not_, xs))

def all_(xs):
    return not any(map(operator.not_, xs))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;C++ reached its 30s before introducing &lt;a href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"&gt;its own versions&lt;/a&gt; of these logical algorithms, &lt;code&gt;any_of&lt;/code&gt; and &lt;code&gt;all_of&lt;/code&gt;, but made up for lost time by finding room for a third, &lt;code&gt;none_of&lt;/code&gt;, which is not &lt;code&gt;any_of&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;class Iter, class Pred&amp;gt;
bool none_of_(Iter b, Iter e, Pred p)
{
    return std::find_if(b, e, p) == e;
}

template &amp;lt;class Iter, class Pred&amp;gt;
bool any_of_(Iter b, Iter e, Pred p)
{
    return !none_of_(b, e, p);
}

template &amp;lt;class Iter, class Pred&amp;gt;
bool all_of_(Iter b, Iter e, Pred p)
{
    return !any_of_(b, e, std::not1(p));
}

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2013-10-02</dc:date>
<guid>http://wordaligned.org/articles/all-any-none</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/all-any-none</link>
<category>Python</category>
</item>

<item>
<title>Python&#8217;s lesser known loop control</title>
<description>&lt;p&gt;I&amp;#8217;ll break out of a loop if I have to but generally prefer to recast code so no &lt;code&gt;break&lt;/code&gt; is needed. It&amp;#8217;s not about avoiding the keyword; but rather that the loop control expression should tell readers when and why the loop exits.
&lt;/p&gt;
&lt;p&gt;In C and C++ such recasting is rarely a problem. Python separates statements and expressions which makes things more difficult. You can&amp;#8217;t assign to a variable in a loop control expression, for example. Consider a function which processes a file one chunk at a time, until the file is exhausted.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;while True:
    data = fp.read(4096)
    if not data:
        break
    ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The control expression, &lt;code&gt;while True&lt;/code&gt;, suggests an infinite loop, which isn&amp;#8217;t what actually happens, but readers must poke around in the loop body to find the actual termination condition.
&lt;/p&gt;
&lt;p&gt;As already mentioned, an assignment statement isn&amp;#8217;t an expression, so we can&amp;#8217;t write this:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Syntax error!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;while data = fp.read(4096):
    ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;You could implement a file reader &lt;a href="http://docs.python.org/3/howto/functional.html#generators"&gt;generator function&lt;/a&gt; which yields chunks of data, allowing clients to write:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;for data in chunked_file_reader(fp):
    ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This at least localises the problem to &lt;code&gt;chunked_file_reader()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Another solution is to use the two argument flavour of &lt;a href="http://docs.python.org/3.3/library/functions.html#iter"&gt;iter&lt;/a&gt;, &lt;code&gt;iter(object, sentinel)&lt;/code&gt;. Here, &lt;code&gt;object&lt;/code&gt; is a callable and &lt;code&gt;sentinel&lt;/code&gt; is a terminal value. &lt;code&gt;Object&lt;/code&gt; is called with no arguments: use &lt;code&gt;&lt;a href="http://docs.python.org/3/library/functools.html#functools.partial"&gt;functools.partial&lt;/a&gt;&lt;/code&gt; to set the chunk size passed to &lt;code&gt;file.read&lt;/code&gt;; and stop when this function returns the empty string.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import functools

chunked_file_reader = functools.partial(fp.read, 4096)

for data in iter(chunked_file_reader, ''):
    ...

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2013-01-14</dc:date>
<guid>http://wordaligned.org/articles/pythons-lesser-known-loop-control</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/pythons-lesser-known-loop-control</link>
<category>Python</category>
</item>

<item>
<title>Set.insert or set.add?</title>
<description>&lt;h2&gt;Get set, go!&lt;/h2&gt;
&lt;p&gt;Suppose you have an element &lt;code&gt;e&lt;/code&gt; to put in a set &lt;code&gt;S&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Should you:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;S.add(e)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;or:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;S.insert(e)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;?
&lt;/p&gt;
&lt;p&gt;It depends on which language you&amp;#8217;re using. I use C++ and Python and I usually get it wrong.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; S.insert(e)
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
AttributeError: 'set' object has no attribute 'insert'

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Try again!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;error: 'class std::set&amp;lt;int, std::less&amp;lt;int&amp;gt;, std::allocator&amp;lt;int&amp;gt; &amp;gt;' 
has no member named 'add'

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Maybe my &lt;a href="http://wordaligned.org/articles/accidental-emacs.html" title="Emacs of course!"&gt;IDE&lt;/a&gt; should auto-complete the correct member function but it doesn&amp;#8217;t, or at least I haven&amp;#8217;t configured it to, so instead I&amp;#8217;ve worked out how to remember.
&lt;/p&gt;
&lt;p&gt;Now, neither C++ nor Python pins down how a set should be implemented &amp;#8212; read the language standard and reference manual respectively and all you&amp;#8217;ll get is an interface and some hints. Read between the lines of these references, though, or study &lt;a href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01064_source.html" title="G++ stl_tree.h, on which std::sets and std::multisets are based"&gt;the&lt;/a&gt; &lt;a href="http://svn.python.org/view/python/trunk/Objects/setobject.c?view=markup" title="setobject.c, from CPython"&gt;implementations&lt;/a&gt;, and you&amp;#8217;ll soon realise a Python set is an unordered container designed for fast membership, union, intersection, and differencing operations &amp;#8212; much like the mathematical sets I learned about at school &amp;#8212; whereas a C++ set is an ordered container, featuring logarithmic access times and persistent iterators. 
&lt;/p&gt;
&lt;p&gt;Think: C++ set &amp;asymp; binary tree; Python set &amp;asymp; hashed array.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s apparent which method is correct for which language now. To put something into a binary tree you must recurse down the tree and find where to &lt;strong&gt;insert&lt;/strong&gt; it. Hence &lt;code&gt;std::set::insert()&lt;/code&gt; is correct C++. To put something into a hashed array you hash it and &lt;strong&gt;add&lt;/strong&gt; it right there. Hence &lt;code&gt;set.add()&lt;/code&gt; is proper Python.
&lt;/p&gt;

&lt;h2&gt;How long is a string?&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m suggesting programmers should know at least some of what goes on in their standard language library implementations. Appreciating an API isn&amp;#8217;t always enough. You &lt;strong&gt;insert&lt;/strong&gt; into trees and &lt;strong&gt;add&lt;/strong&gt; to hashes: so if your set is a tree, call &lt;code&gt;S.insert()&lt;/code&gt;, and if it&amp;#8217;s a hash, &lt;code&gt;S.add()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Such logical arguments don&amp;#8217;t always deliver.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Suppose now that &lt;code&gt;S&lt;/code&gt; is a string and you&amp;#8217;re after its length. Should you use &lt;code&gt;S.length()&lt;/code&gt; or &lt;code&gt;S.size()&lt;/code&gt;?
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Neither or both.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/the-g-uk/3867089043/" title="string [how long?] by the|G|, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2538/3867089043_2f2b3f5fa6.jpg" width="485" height="149" alt="string [how long?]" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;In Python a string is a standard sequence and as for all other sequences &lt;code&gt;len(S)&lt;/code&gt; does the trick. In C++ a string is a standard container and as for all other containers &lt;code&gt;S.size()&lt;/code&gt; returns the number of elements; &lt;strong&gt;but&lt;/strong&gt;, being &lt;code&gt;std::string&lt;/code&gt;, &lt;code&gt;S.length()&lt;/code&gt; does too.
&lt;/p&gt;
&lt;p&gt;Oh, and the next revision of C++ features an &lt;code&gt;unordered_set&lt;/code&gt; (available now as &lt;code&gt;std::tr1::unordered_set&lt;/code&gt;) which is a hashed container. I think &lt;code&gt;unordered_set&lt;/code&gt; is a poor name for something which models a set better than &lt;code&gt;std::set&lt;/code&gt; does but that&amp;#8217;s the price it pays for coming late to the party. And you don&amp;#8217;t &lt;code&gt;std::unordered_set::add&lt;/code&gt; elements to it, you &lt;code&gt;std::unordered_set::insert&lt;/code&gt; them.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;My thanks to &lt;a href="http://www.flickr.com/photos/the-g-uk"&gt;the|G|&amp;trade;&lt;/a&gt; for permission to use his &lt;a href="http://www.flickr.com/photos/the-g-uk/3867089043" title="string [how long?] on Flickr"&gt;string&lt;/a&gt;.
&lt;/p&gt;</description>
<dc:date>2010-11-17</dc:date>
<guid>http://wordaligned.org/articles/setinsert-or-setadd</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/setinsert-or-setadd</link>
<category>Python</category>
</item>

<item>
<title>Hiding iterator boilerplate behind a Boost facade</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocfilling-in-missing-methods-python" name="toc0" id="toc0"&gt;Filling in missing methods. Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocfilling-in-missing-methods-c" name="toc1" id="toc1"&gt;Filling in missing methods. C++&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocenter-boost-iterators" name="toc2" id="toc2"&gt;Enter Boost iterators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocusing-boostiteratorfacade" name="toc3" id="toc3"&gt;Using boost::iterator_facade&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toctemplates-and-traits" name="toc4" id="toc4"&gt;Templates and Traits&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocconstructors-destructors-and-operators" name="toc5" id="toc5"&gt;Constructors, destructors and operators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocwrinkles" name="toc6" id="toc6"&gt;Wrinkles&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocless-code-more-software" name="toc7" id="toc7"&gt;Less code, more software&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#tocperformance" name="toc8" id="toc8"&gt;Performance&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;p&gt;&lt;a href="http://www.flickr.com/photos/davehamster/2336911145/" title="SS Great Britain by Dave Hamster, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2379/2336911145_5275811ec0_m.jpg" width="240" height="160" alt="SS Great Britain"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc0" name="tocfilling-in-missing-methods-python" id="tocfilling-in-missing-methods-python"&gt;Filling in missing methods. Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s another wholesome &lt;a href="http://code.activestate.com/recipes/576685" title="Total ordering class decorator, by Raymond Hettinger"&gt;recipe&lt;/a&gt; served up by Raymond Hettinger.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Total ordering class decorator&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def total_ordering(cls):
    'Class decorator that fills-in missing ordering methods'    
    convert = {
        '__lt__': [('__gt__', lambda self, other: other &amp;lt; self),
                   ('__le__', lambda self, other: not other &amp;lt; self),
                   ('__ge__', lambda self, other: not self &amp;lt; other)],
        '__le__': [('__ge__', lambda self, other: other &amp;lt;= self),
                   ('__lt__', lambda self, other: not other &amp;lt;= self),
                   ('__gt__', lambda self, other: not self &amp;lt;= other)],
        '__gt__': [('__lt__', lambda self, other: other &amp;gt; self),
                   ('__ge__', lambda self, other: not other &amp;gt; self),
                   ('__le__', lambda self, other: not self &amp;gt; other)],
        '__ge__': [('__le__', lambda self, other: other &amp;gt;= self),
                   ('__gt__', lambda self, other: not other &amp;gt;= self),
                   ('__lt__', lambda self, other: not self &amp;gt;= other)]
    }
    roots = set(dir(cls)) &amp;amp; set(convert)
    assert roots, 'must define at least one ordering operation: &amp;lt; &amp;gt; &amp;lt;= &amp;gt;='
    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__
    for opname, opfunc in convert[root]:
        if opname not in roots:
            opfunc.__name__ = opname
            opfunc.__doc__ = getattr(int, opname).__doc__
            setattr(cls, opname, opfunc)
    return cls

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If you have a class, &lt;code&gt;X&lt;/code&gt;, which implements one or more of the ordering operators, &lt;code&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; then &lt;code&gt;total_ordering(X)&lt;/code&gt; adapts and returns the class with the missing operators filled-in. Alternatively, use standard decorator syntax to adapt a class. If we apply &lt;code&gt;@total_ordering&lt;/code&gt; to a &lt;code&gt;Point&lt;/code&gt; class
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;@total_ordering
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __lt__(self, other):
        return (self.x, self.y) &amp;lt; (other.x, other.y)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;then we can compare points however we like
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; p = Point(1,2)
&amp;gt;&amp;gt;&amp;gt; q = Point(1,3)
&amp;gt;&amp;gt;&amp;gt; p &amp;lt; q, p &amp;gt; q, p &amp;gt;= q, p &amp;lt;= q
(True, False, False, True)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a nice touch: the freshly-baked methods even have documentation!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; help(Point)
Help on class Point in module __main__:

class Point
 |  Methods defined here:
 |  
 |  __ge__(self, other)
 |      x.__ge__(y) &amp;lt;==&amp;gt; x&amp;gt;=y
 |  
 |  __gt__(self, other)
 |      x.__gt__(y) &amp;lt;==&amp;gt; x&amp;gt;y
 |  
 |  __init__(self, x, y)
 |  
 |  __le__(self, other)
 |      x.__le__(y) &amp;lt;==&amp;gt; x&amp;lt;=y
 |  
 |  __lt__(self, other)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Writing class decorators may not be the first thing a new Python programmer attempts, but once you&amp;#8217;ve discovered the relationship between Python&amp;#8217;s special method names and the more familiar operator symbols, I think this recipe is remarkably straightforward.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;convert = {
    '__lt__': [('__gt__', lambda self, other: other &amp;lt; self),
               ('__le__', lambda self, other: not other &amp;lt; self),
               ('__ge__', lambda self, other: not self &amp;lt; other)],
    '__le__': [('__ge__', lambda self, other: other &amp;lt;= self),
               ('__lt__', lambda self, other: not other &amp;lt;= self),
               ('__gt__', lambda self, other: not self &amp;lt;= other)],
    '__gt__': [('__lt__', lambda self, other: other &amp;gt; self),
               ('__ge__', lambda self, other: not other &amp;gt; self),
               ('__le__', lambda self, other: not self &amp;gt; other)],
    '__ge__': [('__le__', lambda self, other: other &amp;gt;= self),
               ('__gt__', lambda self, other: not other &amp;gt;= self),
               ('__lt__', lambda self, other: not self &amp;gt;= other)]
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Before moving on to something more challenging, look again at one of the recipe&amp;#8217;s key ingredients, the &lt;code&gt;convert&lt;/code&gt; dict, which helps create the missing ordering functions from existing ones. As you can see, there&amp;#8217;s much repetition here, and plenty of opportunities for cut-and-paste errors.
&lt;/p&gt;
&lt;p&gt;This block of code is an example of what programmers term &lt;a href="http://en.wikipedia.org/wiki/Boilerplate_(text)#Boilerplate_code"&gt;boilerplate&lt;/a&gt;. By using the total ordering decorator, we can avoid boilerplating our own code.&lt;a id="fn1link" href="http://wordaligned.org/articles/boost-iterator-facade#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc1" name="tocfilling-in-missing-methods-c" id="tocfilling-in-missing-methods-c"&gt;Filling in missing methods. C++&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Python is dynamic and self-aware, happy to expose its internals for this kind of tinkering.  It takes real wizardry to achieve similar results with a &lt;a href="http://sites.google.com/site/steveyegge2/tour-de-babel" title="C++ is the dumbest language on earth ... doesn't know about itself. It is not introspective"&gt;less flexible language, such as C++&lt;/a&gt; &amp;#8212; but it can be done.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;In a &lt;a href="http://wordaligned.org/articles/binary-search-revisited.html"&gt;previous article&lt;/a&gt; we developed a random access file iterator in C++. At its heart, this iterator simply repositioned itself using file-seeks and dereferenced itself using file-reads. There wasn&amp;#8217;t much to it.
&lt;/p&gt;
&lt;p&gt;Unfortunately we had to fill-out the iterator with the various members required to make it comply with the standard random access iterator requirements (which was the whole point, since we wanted something we could use with standard binary search algorithms).
&lt;/p&gt;
&lt;p&gt;We had to expose standard typedefs:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef std::random_access_iterator_tag iterator_category;
typedef item value_type;
typedef std::streamoff difference_type;
typedef item * pointer;
typedef item &amp;amp; reference;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Worse, we had to implement a full set of comparison, iteration, step and access functions. Please, page down past the following code block! I only include it here so you can see how long it goes on for.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Iterator boilerplate&lt;/div&gt;

&lt;pre class="prettyprint"&gt;public: // Comparison
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }
    
    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }
    
    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }
    
public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }
    
    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }
    
    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }
    
    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }
    
public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }
    
    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }
    
    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }
    
    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }
    
public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return pos - other.pos;
    }
    
public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }

value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How tiresome! Most of these member functions are directly and unsurprisingly implemented in a standard way. It would be nice if we could write (and test!) what we actually needed to and have a decorator fill in the rest.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/chr1sp/3997724676/" title="Library - Ephesus by Chris. P, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2554/3997724676_bf73106637.jpg" width="500" height="334" alt="Library - Ephesus"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc2" name="tocenter-boost-iterators" id="tocenter-boost-iterators"&gt;Enter Boost iterators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Actually, we can! I&amp;#8217;m grateful to proggitor dzorz for &lt;a href="http://www.reddit.com/r/programming/comments/c8fsk/binary_search_revisited/c0quxr0"&gt;telling me how&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;A nicer solution would use boost::iterator_facade and just implement dereference, equal, increment, decrement, advance and distance_to.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Like many programmers I have mixed feelings about C++ &amp;#8212; when it&amp;#8217;s good it&amp;#8217;s very very good, but when it&amp;#8217;s bad it&amp;#8217;s horrid &amp;#8212; and these feelings are only amplified by the &lt;a href="http://www.boost.org" title="Boost library home page"&gt;Boost&lt;/a&gt; library. Boost is superb, so long as you stick to the good parts.
&lt;/p&gt;
&lt;p&gt;So which parts are good? It depends. On you, who you work with, and the platforms you&amp;#8217;re working on.
&lt;/p&gt;
&lt;p&gt;In my previous article I used an ingenious iterator adaptor from the &lt;a href="http://www.boost.org/doc/libs/release/libs/spirit/index.html"&gt;Boost.Spirit&lt;/a&gt; parser library to disastrous effect. If only I&amp;#8217;d looked a little more carefully I&amp;#8217;d have discovered something more useful in a more obvious place. &lt;a href="http://www.boost.org/doc/libs/release/libs/iterator/"&gt;Boost.Iterator&lt;/a&gt; could have helped.
&lt;/p&gt;
&lt;p&gt;As dzorz points out, &lt;code&gt;boost::iterator_facade&lt;/code&gt; can work with any C++ iterable. Implement whatever subset of 
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     dereference
 &lt;/li&gt;

 &lt;li&gt;
     equal
 &lt;/li&gt;

 &lt;li&gt;
     increment 
 &lt;/li&gt;

 &lt;li&gt;
     decrement
 &lt;/li&gt;

 &lt;li&gt;
     advance
 &lt;/li&gt;

 &lt;li&gt;
     distance_to
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;is appropriate and &lt;code&gt;iterator_facade&lt;/code&gt; will fill in the boilerplate required to standardise your iterator.
&lt;/p&gt;
&lt;p&gt;In our case, we&amp;#8217;ll need the full set. That&amp;#8217;s because we&amp;#8217;re after a random access iterator. Other iterators need rather less. Here&amp;#8217;s a &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#iterator-facade-requirements"&gt;table&lt;/a&gt; showing the relationship between core operations and iterator concepts.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#iterator-facade-requirements"&gt;&lt;img src="http://wordaligned.org/images/iterator-facade.png" alt="iterator_facade Core Operations"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc3" name="tocusing-boostiteratorfacade" id="tocusing-boostiteratorfacade"&gt;Using boost::iterator_facade&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href="http://www.boost.org/doc/libs/release/libs/iterator/"&gt;Boost.Iterator&lt;/a&gt; documentation is well-written but daunting. Read it from top-to bottom and you&amp;#8217;ll get:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     rationale and theory
 &lt;/li&gt;

 &lt;li&gt;
     plans for standardisation (which don&amp;#8217;t seem correct &lt;a id="fn2link" href="http://wordaligned.org/articles/boost-iterator-facade#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;)
 &lt;/li&gt;

 &lt;li&gt;
     &lt;strong&gt;usage notes&lt;/strong&gt;
 &lt;/li&gt;

 &lt;li&gt;
     some subtle points on the implementation and its predecessor
 &lt;/li&gt;

 &lt;li&gt;
     a namecheck for the curiously recurring template pattern
 &lt;/li&gt;

 &lt;li&gt;
     a fat reference section detailing the boilerplate which this library allows you to forget
 &lt;/li&gt;

 &lt;li&gt;
     a &lt;strong&gt;tutorial&lt;/strong&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&amp;#8217;re tempted to skip to the end of the page, you&amp;#8217;ll see this code block.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;boost/type_traits/is_convertible.hpp&amp;gt;
#include &amp;lt;boost/utility/enable_if.hpp&amp;gt;
  
  ....
  
private:
  struct enabler {};
  
public:
  template &amp;lt;class OtherValue&amp;gt;
  node_iter(
      node_iter&amp;lt;OtherValue&amp;gt; const&amp;amp; other
    , typename boost::enable_if&amp;lt;
          boost::is_convertible&amp;lt;OtherValue*,Value*&amp;gt;
        , enabler
      &amp;gt;::type = enabler()
  )
    : m_node(other.m_node) {}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;According to the surrounding documentation this is &amp;#8220;magic&amp;#8221;. I find it scary.
&lt;/p&gt;
&lt;p&gt;Luckily it turns out the library is straightforward to use. What you really want, as a newcomer, are the &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#usage"&gt;usage notes&lt;/a&gt; and the &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#tutorial-example"&gt;tutorial example&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;The tutorial walks through the process of skinning a singly-linked list with a forwards iterator facade. This is a different use case to ours: the tutorial shows a basic class which implements what it should, and the facade allows it to be treated as a forwards iterator. In our case we&amp;#8217;ve already created a full-blown random access iterator. We can retrospectively apply &lt;code&gt;iterator_facade&lt;/code&gt; to strip our class back to basics.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc4" name="toctemplates-and-traits" id="toctemplates-and-traits"&gt;Templates and Traits&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Where we had:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;typename item&amp;gt;
class text_file_iter
{
public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef item value_type;
    typedef std::streamoff difference_type;
    typedef item * pointer;
    typedef item &amp;amp; reference;
....
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We now need (my thanks here to Giuseppe for correcting the code I originally posted here):
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;typename value&amp;gt;
class text_file_iter
    : public boost::iterator_facade&amp;lt;
      text_file_iter&amp;lt;value&amp;gt;
    , value
    , std::random_access_iterator_tag
    , value
    , std::streamoff
    &amp;gt;
....
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Yes, the class accepts itself as a template parameter. That&amp;#8217;s the curious recursion.)
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc5" name="tocconstructors-destructors-and-operators" id="tocconstructors-destructors-and-operators"&gt;Constructors, destructors and operators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We still need iterator constructors and destructors &amp;#8212; these are unchanged &amp;#8212; but &lt;strong&gt;we can eliminate every single operator&lt;/strong&gt; shown in the &amp;#8220;Iterator boilerplate&amp;#8221; code block above.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s what we need instead, to ensure &lt;code&gt;iterator_facade&lt;/code&gt; can do its job. The &lt;code&gt;read()&lt;/code&gt; member function we had before doesn&amp;#8217;t need changing.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;    ....
private: // Everything Boost's iterator facade needs
    friend class boost::iterator_core_access;
    
    value dereference() const
    {
        return read();
    }
    
    bool equal(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    void increment()
    {
        advance(1);
    }
    
    void decrement()
    {
        advance(-1);
    }
    
    void advance(std::streamoff n)
    {
        in.seekg(n, std::ios_base::cur);
        pos = in.tellg();
    }
    
    std::streamoff distance_to(iter const &amp;amp; other) const
    {
        return other.pos - pos;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;And that really is all there is to it. I&amp;#8217;m impressed.
&lt;/p&gt;
&lt;p&gt;Notice, by the way, that &lt;code&gt;friend&lt;/code&gt; is used to expose the primitive, private member functions for use by the &lt;code&gt;boost::iterator_core_access&lt;/code&gt; class. This follows the example set by the tutorial. I&amp;#8217;ve written enough C and Python to question C++&amp;#8217;s sophisticated access rules &amp;#8212; you have &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt;, but that&amp;#8217;s &lt;strong&gt;still&lt;/strong&gt; not enough, so you need &lt;code&gt;friend&lt;/code&gt; declaration to cut through it all &amp;#8212; which tempts me to simply make &lt;code&gt;dereference()&lt;/code&gt;, &lt;code&gt;equal()&lt;/code&gt; etc. public, but then the facade wouldn&amp;#8217;t be a proper facade. Users should treat the final class exactly as they would any other random access iterator, and designating these members as &lt;code&gt;private&lt;/code&gt; means they&amp;#8217;ll have to.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc6" name="tocwrinkles" id="tocwrinkles"&gt;Wrinkles&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You&amp;#8217;ll notice the &lt;code&gt;dereference()&lt;/code&gt; member function has a &lt;code&gt;const&lt;/code&gt; signature. However, the &lt;code&gt;read()&lt;/code&gt; member function is non-const.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;    // Return the item at the current position
    value_type read()
    {
        value_type n = 0;
        
        // Reverse till we hit whitespace or the start of the file
        while (in &amp;amp;&amp;amp; !isspace(in.peek()))
        {
            in.unget();
        }
        in.clear();
        
        in &amp;gt;&amp;gt; n;
        return n;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;in&lt;/code&gt; is a data member of type &lt;code&gt;std::ifstream&lt;/code&gt;, and clearly the read call modifies it. That&amp;#8217;s what this alarming compiler error is trying to tell us.
&lt;/p&gt;
&lt;pre&gt;
boost_binary_search_text_file.cpp: In member function 'value text_file_iter&amp;lt;value&amp;gt;::read() const [with value = long long int]':
boost_binary_search_text_file.cpp:90:   instantiated from 'value text_file_iter&amp;lt;value&amp;gt;::dereference() const [with value = long long int]'
/opt/local/include/boost/iterator/iterator_facade.hpp:516:   instantiated from 'static typename Facade::reference boost::iterator_core_access::dereference(const Facade&amp;amp;) [with Facade = text_file_iter&amp;lt;long long int&amp;gt;]'
/opt/local/include/boost/iterator/iterator_facade.hpp:634:   instantiated from 'Reference boost::iterator_facade&amp;lt;I, V, TC, R, D&amp;gt;::operator*() const [with Derived = text_file_iter&amp;lt;long long int&amp;gt;, Value = long long int, CategoryOrTraversal = boost::random_access_traversal_tag, Reference = long long int, Difference = long long int]'
/usr/include/c++/4.2.1/bits/stl_algo.h:4240:   instantiated from 'bool std::binary_search(_ForwardIterator, _ForwardIterator, const _Tp&amp;amp;) [with _ForwardIterator = text_file_iter&amp;lt;long long int&amp;gt;, _Tp = main::number]'
boost_binary_search_text_file.cpp:203:   instantiated from here
boost_binary_search_text_file.cpp:174: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'typename std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::int_type std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::peek() [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
boost_binary_search_text_file.cpp:176: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;&amp;amp; std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::unget() [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
boost_binary_search_text_file.cpp:178: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'void std::basic_ios&amp;lt;_CharT, _Traits&amp;gt;::clear(std::_Ios_Iostate) [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
boost_binary_search_text_file.cpp:180: error: passing 'const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;' as 'this' argument of 'std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;&amp;amp; std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::operator&amp;gt;&amp;gt;(long long int&amp;amp;) [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]' discards qualifiers
&lt;/pre&gt;

&lt;p&gt;Related to this, the &lt;code&gt;Reference&lt;/code&gt; template parameter (shown in bold in the listing below) is actually a &lt;code&gt;value&lt;/code&gt;, rather than the (default) &lt;code&gt;value &amp;amp;&lt;/code&gt;. As we originally implemented it, our file iterator reads values lazily, only when clients request them. We have no reference to return.
&lt;/p&gt;
&lt;pre&gt;
template &amp;lt;typename value&amp;gt;
class text_file_iter
    : public boost::iterator_facade&amp;lt;
      text_file_iter&amp;lt;value&amp;gt;
    , value
    , std::random_access_iterator_tag
    , &lt;strong&gt;value&lt;/strong&gt;
    , std::streamoff
    &amp;gt;
};
&lt;/pre&gt;

&lt;p&gt;I faced a dilemma here. Either I could modify my original file iterator, including a current value data member, which I would take care to update every time we repositioned the file read position. Then our references could be real references and &lt;code&gt;read()&lt;/code&gt; would naturally be &lt;code&gt;const&lt;/code&gt;, simply returning a reference to this member. Or, I could make the &lt;code&gt;in&lt;/code&gt; input stream data member &lt;code&gt;mutable&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Mutable&lt;/code&gt; makes me uneasy for the same reason that &lt;code&gt;friend&lt;/code&gt; does &amp;#8212; if you can shake off the rigours of const-correctness so easily, then why bother with it? &amp;#8212; and for this reason the first option appealed. However, a read-only file is an unusual container: we do not change it, but we cannot supply const references to its elements without reading them in, and that will mean changes to the file input stream. The easier option, involving the smallest code change, was to make &lt;code&gt;in&lt;/code&gt; mutable. So that&amp;#8217;s what I did.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc7" name="tocless-code-more-software" id="tocless-code-more-software"&gt;Less code, more software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;By employing two of my least favourite C++ keywords I now had a class which provided the functions it should, and, thanks to the magic worked by Boost&amp;#8217;s iterator facade, I also had a class which I could use as a standard random access iterator. Most of the code changes were the deletion of boilerplate &amp;#8212; very satisfying. I added code too, since I decided to invest a little more effort in tests. I didn&amp;#8217;t have any doubts about the Boost library&amp;#8217;s correctness but I thought I might not have been using it correctly. Happily these tests all passed.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/boost-iterator-facade#toc8" name="tocperformance" id="tocperformance"&gt;Performance&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s not forget why we originally wanted a random access file iterator: we had a large sorted file, too large to read into memory, and we wanted to test for the presence of the number in this file.
&lt;/p&gt;
&lt;p&gt;For test purposes I created a file just over 4GB in size. A simple linear search through this file took around 180 seconds on my (aging laptop) computer, and was light on memory use. By creating a random access file iterator, boilerplate and all, we took advantage of the standard binary search algorithm and reduced the time to around 4 milliseconds.
&lt;/p&gt;
&lt;p&gt;How would our version using Boost iterator facade do? I wasn&amp;#8217;t expecting it to be faster than the original, but I wouldn&amp;#8217;t have been surprised if it gave it a close run: using Boost doesn&amp;#8217;t usually involve compromise. In fact, over repeated runs of my performance tests there was no significant difference between the two iterator versions &amp;#8212; or at least there wasn&amp;#8217;t once a helpful reader had discovered and fixed a bug in my program, which was causing it to run correctly but slowly.
&lt;/p&gt;
&lt;p&gt;To trust a facade I guess you need some knowledge of what lies behind it.
&lt;/p&gt;
&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: During my original performance tests, reported in the first version of this article, the Boost iterator performed woefully, far slower even than a linear search. By this time I&amp;#8217;d lost patience, and it was left up to a reader, Giuseppe, to &lt;a href="http://wordaligned.org/articles/boost-iterator-facade#comment-60988668"&gt;point out my mistake&lt;/a&gt;. I&amp;#8217;d been using a &lt;code&gt;boost::random_access_traversal_tag&lt;/code&gt; template parameter, with the result that &lt;code&gt;std::distance()&lt;/code&gt; was using repeated increments rather than calling &lt;code&gt;distance_to()&lt;/code&gt; to get an immediate result, and consequently ran very slowly. I should have used &lt;code&gt;std::random_access_iterator_tag&lt;/code&gt;. I modified my code accordingly and confirmed that the Boost version does indeed perform on a par with the original version.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;My thanks to &lt;a href="http://www.flickr.com/photos/chr1sp/" title="Chris. P on Flickr"&gt;Chris P&lt;/a&gt; for permission to use his &lt;a href="http://www.flickr.com/photos/chr1sp/3997724676"&gt;photograph&lt;/a&gt; of the &lt;a href="http://en.wikipedia.org/wiki/Library_of_Celsus" title="Library of Celsus, Wikipedia"&gt;Library of Celsus&lt;/a&gt; at Ephesus, or at rather its beautiful facade. Ephesus is famous for the Temple of Artemis, one of the seven wonders of the ancient world, of which only fragments remain. Thanks too to &lt;a href="http://www.flickr.com/photos/davehamster/"&gt;Dave Hamster&lt;/a&gt; for the boilerplate &lt;a href="http://www.flickr.com/photos/davehamster/2336911145/"&gt;photo&lt;/a&gt; &amp;#8212; actually a detail from the hull of the &lt;a href="http://www.ssgreatbritain.org"&gt;SS Great Britain&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;d like to continue this experiment the code and the tests I used are available via anonymous SVN access from &lt;a href="http://svn.wordaligned.org/svn/etc/search_text_file"&gt;http://svn.wordaligned.org/svn/etc/search_text_file&lt;/a&gt;.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/boost-iterator-facade#fn1link"&gt;[1]&lt;/a&gt;: As of Python 2.7 and 3.2, the standard library will include a version of this recipe. It&amp;#8217;s in the &lt;a href="http://docs.python.org/dev/py3k/library/functools.html#functools.total_ordering" title="functools.total_ordering decorator documentation"&gt;functools module&lt;/a&gt;. For some reason, your class &amp;#8220;should supply an __eq__()&amp;#8221; method.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/boost-iterator-facade#fn2link"&gt;[2]&lt;/a&gt;: According to the Boost.Iterator documentation:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Both &lt;code&gt;iterator_facade&lt;/code&gt; and &lt;code&gt;iterator_adaptor&lt;/code&gt; as well as many of the specialized adaptors mentioned below have been proposed for standardization, and accepted into the first C++ technical report; see our [Standard Proposal For Iterator Facade and Adaptor (PDF)][tr1proposal] for more details.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I assumed this meant there&amp;#8217;d be &lt;code&gt;tr1::iterator_(facade|adaptor)&lt;/code&gt; classes, but I don&amp;#8217;t think that&amp;#8217;s the case. Unlike other (good) bits of Boost, the Iterator library doesn&amp;#8217;t seem likely to be part of the next C++ release.
&lt;/p&gt;</description>
<dc:date>2010-07-07</dc:date>
<guid>http://wordaligned.org/articles/boost-iterator-facade</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/boost-iterator-facade</link>
<category>Python</category>
</item>

<item>
<title>Binary search revisited</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocrecap" name="toc0" id="toc0"&gt;Recap&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocthe-problem" name="toc1" id="toc1"&gt;The Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocinput-iterators" name="toc2" id="toc2"&gt;Input iterators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocfind" name="toc3" id="toc3"&gt;Find&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocrewrite-the-file" name="toc4" id="toc4"&gt;Rewrite the file!&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocadapting-iterators" name="toc5" id="toc5"&gt;Adapting iterators&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocmultipass-iterator" name="toc6" id="toc6"&gt;Multipass iterator&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocnot-so-fast" name="toc7" id="toc7"&gt;Not so fast&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocbetter-than-find" name="toc8" id="toc8"&gt;Better than find&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocimplementation" name="toc9" id="toc9"&gt;Implementation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tochardware-used" name="toc10" id="toc10"&gt;Hardware used&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#tocconclusions" name="toc11" id="toc11"&gt;Conclusions&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc0" name="tocrecap" id="tocrecap"&gt;Recap&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recently &lt;a href="http://wordaligned.org/articles/binary-search.html"&gt;I wrote&lt;/a&gt; about C++&amp;#8217;s standard binary search algorithms (yes, four of them!) which do such a fine job of:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     specifying exactly what kind of range a binary search requires
 &lt;/li&gt;

 &lt;li&gt;
     separating the core algorithm from the details of the range it&amp;#8217;s working on
 &lt;/li&gt;

 &lt;li&gt;
     delivering precise results
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To support these claims I included an implementation of a file iterator, suitable for use with &lt;code&gt;std::binary_search()&lt;/code&gt; etc. to efficiently locate values in very large files.
&lt;/p&gt;
&lt;p&gt;Now, there are a couple of issues with this approach:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     we had to write a lot of code to make a file iterator suitable for use with standard algorithms
 &lt;/li&gt;

 &lt;li&gt;
     this file iterator only works on highly structured files, where each value occupies a fixed number of bytes
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this follow up article we&amp;#8217;ll consider each of these issues in a little more depth by working through two very different solutions to a related problem.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc1" name="tocthe-problem" id="tocthe-problem"&gt;The Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose, once again, that we have a large file, a few gigabytes, say. The file contains numbers, in order, and we&amp;#8217;re interested in testing if this file contains a given number. This time, though, the file is a text file, where the numbers are represented in the usual way as sequences of digits separated by whitespace.
&lt;/p&gt;
&lt;pre&gt;
$ less lots-of-numbers
...
10346  11467 11469 11472  11501 
  11662    12204 12290
...
&lt;/pre&gt;

&lt;p&gt;Note that a number in this file does not occupy a fixed number of bytes. If we jump to a new position in the file using a seek operation, we cannot expect to land exactly where a number starts. Thus the random access file iterator we developed last time won&amp;#8217;t work.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc2" name="tocinput-iterators" id="tocinput-iterators"&gt;Input iterators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In C++ an input file is an example of an input stream, and the standard library gives us &lt;code&gt;istream_iterators&lt;/code&gt; which perform formatted input. In our case, an &lt;code&gt;istream_iterator&amp;lt;int&amp;gt;&lt;/code&gt; effectively converts the file into a stream of numbers.
&lt;/p&gt;
&lt;p&gt;Istream iterators are &lt;a href="http://www.sgi.com/tech/stl/InputIterator.html" title="InputIterator, SGI STL documentation"&gt;input iterators&lt;/a&gt;. They progress through the input stream, item by item, with no repeating or rewinding allowed. Despite their limitations, the C++ standard library provides some algorithms which require nothing more than basic input iterators. For example, to count up even numbers in the file whose name is supplied on the command line we might use &lt;code&gt;std::count_if&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iterator&amp;gt;

bool is_even(int x)
{
    return x % 2 == 0;
}

int main(int argc, char * argv[])
{
    typedef std::istream_iterator&amp;lt;int&amp;gt; i_iter;
    typedef std::ostream_iterator&amp;lt;int&amp;gt; o_iter;
    std::ifstream in(argv[1]);
    
    std::cout &amp;lt;&amp;lt; std::count_if(i_iter(in), i_iter(), is_even) &amp;lt;&amp;lt; '\n';
    
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The next version of C++ supports lambda functions, so you&amp;#8217;ll be able to put &lt;code&gt;is_even&lt;/code&gt; right where it&amp;#8217;s used, in the &lt;code&gt;count_if()&lt;/code&gt; function call. Or, with the current version of C++, you could write:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Ouch!&lt;/div&gt;

&lt;pre class="prettyprint"&gt;    ....
    std::count_if(i_iter(in), i_iter(),
                 std::not1(std::bind2nd(std::modulus&amp;lt;int&amp;gt;(), 2)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Maybe not!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc3" name="tocfind" id="tocfind"&gt;Find&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The very simplest search algorithm, &lt;code&gt;std::find&lt;/code&gt;, needs nothing more than an input iterator. To determine if a number is in a file, we &lt;strong&gt;could&lt;/strong&gt; just invoke &lt;code&gt;std::find&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;typedef std::istream_iterator&amp;lt;int&amp;gt; i_iter;

bool 
is_number_in_file(char const * filename, int n)
{
    std::ifstream in(filename);
    i_iter begin(in);
    i_iter end;
    return std::find(begin, end, n) != end;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the find algorithm advances through the numbers in the file, from start to finish, stopping as soon as it hits one equal to the supplied value, &lt;code&gt;n&lt;/code&gt;. We can expect this function to be light on memory use &amp;#8212; there will be some buffering at the lower levels of the file access, but nothing more &amp;#8212; and the function is evidently correct.
&lt;/p&gt;
&lt;p&gt;It would be correct even if our file was unsorted, however. Is there any way we can do better?
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc4" name="tocrewrite-the-file" id="tocrewrite-the-file"&gt;Rewrite the file!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In the previous article we developed a random access iterator for accessing binary files, and usable for efficient binary searches of sorted binary files. Now would be a good time to question the problem specification. Is this a one off? Or are we going to be testing the presence of more numbers in the file in future? And if so, can we convert the file to binary to save time in the long run? 
&lt;/p&gt;
&lt;p&gt;Although I&amp;#8217;m not going to pursue this option here, it may well be the best approach. For now, though, let&amp;#8217;s assume we have a one-off problem to solve, and that we aren&amp;#8217;t allowed to tinker with the input.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc5" name="tocadapting-iterators" id="tocadapting-iterators"&gt;Adapting iterators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If we want to use &lt;code&gt;std::binary_search&lt;/code&gt; we need, as a minimum, &lt;a href="http://www.sgi.com/tech/stl/ForwardIterator.html" title="ForwardIterator, SGI STL documentation"&gt;forward iterators&lt;/a&gt;. Like input iterators, forward iterators advance, one step at a time. Unlike input iterators, you can copy a forward iterator and dereference or advance that copy in future, independently of the original.
&lt;/p&gt;
&lt;p&gt;Forward iterators are suitable for multipass algorithms, such as &lt;code&gt;std::search&lt;/code&gt;, which looks for the first occurrence of a sequence within a sequence (a generalised &lt;code&gt;strstr&lt;/code&gt;, if you like), or &lt;code&gt;std::adjacent_find&lt;/code&gt; and &lt;code&gt;std::search_n&lt;/code&gt; which look for repeated elements; and of course &lt;code&gt;std::binary_search&lt;/code&gt;, which is our immediate interest.
&lt;/p&gt;
&lt;p&gt;Wouldn&amp;#8217;t it be nice if we could convert our istream iterators into forwards iterators? Then we could plug them directly into all these algorithms.
&lt;/p&gt;
&lt;p&gt;Other languages allow this. You can replicate streams in the Unix shell with &lt;code&gt;tee&lt;/code&gt;. And you can do something similar in Python, thanks to one of the standard &lt;a href="http://docs.python.org/py3k/library/itertools.html"&gt;iterator tools&lt;/a&gt;. Independent iterators over the same sequence needed? &lt;tt&gt;&lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.tee
"&gt;Itertools.tee&lt;/a&gt;&lt;/tt&gt; is your friend. The example below codes up adjacent find in Python.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import tee
import sys

def adjacent_find(xs):
    '''Does the supplied iterable contain any adjacent repeats?
    
    Returns True if xs contains two consecutive, equal items,
    False otherwise. 
    '''
    try:
        curr, next_ = tee(xs)
        next(next_)
        return any(c == n for c, n in zip(curr, next_))
    except StopIteration:
        return False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.jezuk.co.uk/mango" title="Mango: iterators, algorithms, functions, for Java, by Jez Higgins"&gt;&lt;img src="http://www.jezuk.co.uk/files/mango-header.png" alt="Mango: iterators, algorithms, functions, for Java, by Jez Higgins"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Why, even Java has an iterator adaptors, courtesy of Jez Higgins&amp;#8217; &lt;a href="http://www.jezuk.co.uk/mango" title="Mango: iterators, algorithms, functions, for Java, by Jez Higgins"&gt;Mango library&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;What about C++? I couldn&amp;#8217;t find any such iterator adaptors in the standard library, but I turned up something in the standard library research and development unit, also known as &lt;a href="http://www.boost.org" title="Free, peer-reviewed, portable C++ source libraries"&gt;Boost&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://boost.org"&gt;&lt;img src="http://www.boost.org/doc/libs/1_43_0/boost.png" alt="Boost logo"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc6" name="tocmultipass-iterator" id="tocmultipass-iterator"&gt;Multipass iterator&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/index.html"&gt;Boost.Spirit&lt;/a&gt; is a remarkable C++ parser framework, which uses operator overloading to represent parsers directly as EBNF grammars in C++. Somewhere in its depths it tracks back, and hence must adapt input iterators into forward iterators &amp;#8212; or &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/spirit/support/multi_pass.html"&gt;multipass iterators&lt;/a&gt;, to use its own term.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The &lt;code&gt;multi_pass&lt;/code&gt; iterator will convert any input iterator into a forward iterator suitable for use with Spirit.Qi. &lt;code&gt;multi_pass&lt;/code&gt; will buffer data when needed and will discard the buffer when its contents is not needed anymore. This happens either if only one copy of the iterator exists or if no backtracking can occur.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;What&amp;#8217;s good enough for parsing is more than good enough for searching. Here&amp;#8217;s a function which detects whether a number is in a file. Most of the code here just includes the right headers and defines some typedefs. By leaning on high quality support libraries we&amp;#8217;ve overcome our first issue: we no longer have to write loads of code just to call binary search!
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Boost spirit multipass iterators&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;algorithm&amp;gt;

#include &amp;lt;boost/spirit/include/support_multi_pass.hpp&amp;gt;

namespace spirit = boost::spirit;

typedef long long number;
typedef std::istream_iterator&amp;lt;number&amp;gt; in_it;
typedef spirit::multi_pass&amp;lt;in_it&amp;gt; fwd_it;

/*
  Returns true if the input number can be found in the named 
  file, false otherwise. The file must contain ordered, 
  whitespace separated numbers.
*/
bool
is_number_in_file(number n, char const * filename)
{
    std::ifstream in(filename);
    
    fwd_it begin = spirit::make_default_multi_pass(in_it(in));
    fwd_it end = spirit::make_default_multi_pass(in_it());
    
    return std::binary_search(begin, end, n);
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc7" name="tocnot-so-fast" id="tocnot-so-fast"&gt;Not so fast&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If this library-based solution looks too good to be true, that&amp;#8217;s because it is! As we noted &lt;a href="http://wordaligned.org/articles/binary-search.html#tocstdbinarysearch-requirements"&gt;before&lt;/a&gt;, the standard binary search algorithm may indeed work with forward iterators, but it works far better with random access iterators. There&amp;#8217;s no point reducing the number of integer comparisons to &lt;code&gt;O(log(N))&lt;/code&gt; if we&amp;#8217;re going to advance our iterators &lt;code&gt;O(N)&lt;/code&gt; times.
&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s worse, these multipass iterators aren&amp;#8217;t magic. Did you read the smallprint concerning Python&amp;#8217;s &lt;tt&gt;&lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.tee"&gt;tee&lt;/a&gt;&lt;/tt&gt; iterator?
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;This itertool may require significant auxiliary storage (depending on how much temporary data needs to be stored).
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;If teed iterators diverge, intervening values have to be stored somewhere, and the same appears to be true of our inscrutable multipass iterators. Huge chunks of our large input file are buffered into memory. When I ran this function to confirm the presence of a single number somewhere near the middle of a 4.4GB input file, it took over 19 minutes.
&lt;/p&gt;
&lt;pre&gt;
real	19m13.675s
user	5m19.219s
sys	1m26.278s
&lt;/pre&gt;

&lt;p&gt;Much of this time was spent paging.
&lt;/p&gt;
&lt;p&gt;As a comparison, testing for the same value using &lt;code&gt;find&lt;/code&gt; took just under 3 minutes.
&lt;/p&gt;
&lt;pre&gt;
real	2m48.139s
user	2m21.336s
sys	0m7.252s
&lt;/pre&gt;

&lt;p&gt;You&amp;#8217;ll have noticed that we used default multipass iterators. These iterators permit multi-dimensional &lt;a href="http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/spirit/support/multi_pass.html"&gt;customisation&lt;/a&gt;. I wasn&amp;#8217;t feeling brave enough to attempt a template storage policy class, and I very much doubt I could have beaten a simple linear find anyway; anything built on a generic input iterator is unlikely to solve our problem efficiently.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc8" name="tocbetter-than-find" id="tocbetter-than-find"&gt;Better than find&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We can beat &lt;code&gt;std::find&lt;/code&gt; with a bit of ingenuity. Standard istream iterators are useful but, in this case, not a good starting point. A better idea is to create a novel iterator which uses file seek operations to advance through the file, then fine-tunes the file position to point at a number.
&lt;/p&gt;
&lt;p&gt;Consider an imagine an iterator which can be positioned at any seekable position in the file, and which we dereference to be the first number in the file which ends at or after that position. The graphic below shows a file with 11 seekable positions, 0 through 10 inclusive. 
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     positions 0 and 1 dereference to the number 42  &lt;br /&gt;
 &lt;/li&gt;

 &lt;li&gt;
     positions 2, 3, 4 and 5 dereference to the number 57
 &lt;/li&gt;

 &lt;li&gt;
     positions 6, 7, 8 and 9 dereference to the number 133
 &lt;/li&gt;

 &lt;li&gt;
     it is an error to try and dereference position 10, at the end of the file
 &lt;/li&gt;
&lt;/ul&gt;
&lt;img src="http://wordaligned.org/images/text-file-iterator.png" alt="Text file iterator"/&gt;

&lt;p&gt;Now, this is a rather unusual iterator. It iterates over the numbers in the file, but each number gets repeated for every byte in the file it occupies. Despite this duality it&amp;#8217;s perfectly usable &amp;#8212; so long as we keep a clear head. Binary searches are fine.
&lt;/p&gt;
&lt;p&gt;How does this version perform?
&lt;/p&gt;
&lt;p&gt;Recall, a linear search for a single value in the middle of a 4.4GB took nearly 3 minutes. Running 10 binary searches through the same file took just 40 milliseconds &amp;#8212; that&amp;#8217;s a rate of 25 searches a second!
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc9" name="tocimplementation" id="tocimplementation"&gt;Implementation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s our weird new iterator. It should be usable on files containing whitespace separated items of any type for which the stream read &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; has been defined.
&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s quite a lot of code here, but much of it is random access iterator scaffolding. The interesting functions are the private implementation details towards the end of the class.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;fstream&amp;gt;
#include &amp;lt;ios&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;stdexcept&amp;gt;

#include &amp;lt;ctype.h&amp;gt;

// File read error, thrown when low level file access fails.
class file_read_error : public std::runtime_error
{
public:
    file_read_error(std::string const &amp;amp; what)
        : std::runtime_error(what)
    {
    }
};

/*
  Here's an unusual iterator which can be used to binary search
  for whitespace-separated items in a text file.
  
  It masquerades as a random access iterator but a file
  is not usually a random access device. Nonetheless, file seek
  operations are quicker than stepping through the file item by
  item.
  
  The unusual thing is that the iterators correspond to 
  file offsets rather than items within the file.
  
  Here's a short example where the items are numbers.
  
  +---+---+---+---+---+---+---+---+---+---+
  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
  +---+---+---+---+---+---+---+---+---+---+
  |'4'|'2'|   |   |'5'|'7'|   |'1'|'3'|'3'|
  +---+---+---+---+---+---+---+---+---+---+
  
  The graphic shows a text file which contains 3 numbers,
  42, 57, 133, separated by whitespace.
  
  The file itself is 10 bytes long, and hence there are 11
  iterators over the file, corresponding to actual file positions
  (including the one-past-the end position). To dereference an
  iterator, we step back through the file until we reach either
  whitespace or the start of the file. Then we look forwards 
  again and read in the next item.
  
  In the graphic above:
  
   - Iterators 0 and 1 point to number 42
   - Iterators 2, 3, 4 and 5 point to number 57
   - Iterators 6, 7, 8, 9 point to number 133
   - Iterator 10 is the end, and must not be dereferenced
  
  Dereferencing an iterator always returns an item which is in
  the file, and all items in the file have iterators pointing to
  them, so std::binary_search based on these iterators is valid.
  
  The iterators also expose their underlying file positions
  directory (via the getpos() member function), and with a
  little thought we can make use of std::lower_bound() and
  std::upper_bound().
*/
template &amp;lt;typename item&amp;gt;
class text_file_item_iter
{
    typedef text_file_item_iter&amp;lt;item&amp;gt; iter;
    
private: // Sanity
    
    // Check things are OK, throwing an error on failure.
    void check(bool ok, std::string const &amp;amp; what)
    {
        if (!ok)
        {
            throw file_read_error(what);          
        }
    }
    
public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef item value_type;
    typedef std::streamoff difference_type;
    typedef item * pointer;
    typedef item &amp;amp; reference;
    
    enum start_pos { begin, end };
    
public: // Lifecycle
    text_file_item_iter(iter const &amp;amp; other)
        : fname(other.fname)
    {
        open();
        setpos(other.pos);
    }
    
    text_file_item_iter()
        : pos(-1)
    {
    }
    
    text_file_item_iter(std::string const &amp;amp; fname,
                        start_pos where = begin)
        : fname(fname)
        , pos(-1)
    {
        open();
        if (where == end)
        {
            seek_end();
        }
    }
    
    ~text_file_item_iter()
    {
        close();
    }
    
    iter &amp;amp; operator=(iter const &amp;amp; other)
    {
        close();
        fname = other.fname;
        open();
        setpos(other.pos);
        return *this;
    } 
    
public: // Comparison
        // Note: it's an error to compare iterators over different files.
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }
    
    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }
    
    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }
    
    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }
    
public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }
    
    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }
    
    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }
    
    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }
    
public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }
    
    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }
    
    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }
    
    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }
    
public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return pos - other.pos;
    }
    
public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }
    
    value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }
    
    // Allow direct access to the underlying stream position
    std::streampos getpos()
    {
        std::streampos pos_ = in.tellg();
        check(in, "getpos failed");
        return pos_;
    }
    
private: // Implementation details
    void open()
    {
        in.open(fname.c_str(), std::ios::binary);
        check(in, "open failed");
        pos = getpos();
    }
    
    void close()
    {
        if (in.is_open())
        {
            in.close();
            check(in, "close failed");
        }
    }
    
    void advance(difference_type n)
    {
        check(in.seekg(n, std::ios_base::cur), "advance failed");
        pos = getpos();
    }
    
    void seek_end()
    {
        check(in.seekg(0, std::ios_base::end), "seek_end failed");
        chop_whitespace();
        pos = getpos();
    }
    
    void chop_whitespace()
    {
        do
        {
            in.unget();
        } while (isspace(in.peek()));
        in.get();
        in.clear();
    }
    
    void setpos(std::streampos newpos)
    {
        check(in.seekg(newpos), "setpos failed");
        pos = newpos;
    }
    
    // Return the item at the current position
    value_type read()
    {
        item n = 0;
        // Reverse till we hit whitespace or the start of the file
        while (in &amp;amp;&amp;amp; !isspace(in.peek()))
        {
            in.unget();
        }
        in.clear();
        check(in &amp;gt;&amp;gt; n, "read failed");
        return n;
    }
    
private: // State
    std::string fname;
    std::ifstream in;
    std::streampos pos;
};

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc10" name="tochardware-used" id="tochardware-used"&gt;Hardware used&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;
  Model Name:	            MacBook
  Model Identifier:	    MacBook1,1
  Processor Name:           Intel Core Duo
  Processor Speed:          2 GHz
  Number Of Processors:	    1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://www.flickr.com/photos/photobunny_earl/1008279066" title="Mushroom, by photobunny"&gt;&lt;img src="http://farm2.static.flickr.com/1440/1008279066_847d73c90d.jpg" alt="Mushroom, by photobunny"/&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/binary-search-revisited#toc11" name="tocconclusions" id="tocconclusions"&gt;Conclusions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Initially the Boost.Spirit solution looked promising but we pushed it too hard. Suitable abstractions can remove complexity; but they can also hide it. When efficiency matters, we need a handle on what&amp;#8217;s going on.
&lt;/p&gt;
&lt;p&gt;After this false start we &lt;strong&gt;did&lt;/strong&gt; find a way to create a file iterator suitable for use with the standard binary search algorithms. Use it with care, though!
&lt;/p&gt;</description>
<dc:date>2010-05-26</dc:date>
<guid>http://wordaligned.org/articles/binary-search-revisited</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/binary-search-revisited</link>
<category>Python</category>
</item>

<item>
<title>Power programming</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocpowerful-or-dangerous" name="toc0" id="toc0"&gt;Powerful or dangerous?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocdecision-trees" name="toc1" id="toc1"&gt;Decision trees&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toccuteness-calculator" name="toc2" id="toc2"&gt;Cuteness calculator&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toceval" name="toc3" id="toc3"&gt;Eval&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocdynamic-or-hacky" name="toc4" id="toc4"&gt;Dynamic or hacky?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocjam-to-golf" name="toc5" id="toc5"&gt;Jam to golf&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toccode-vs-data" name="toc6" id="toc6"&gt;Code vs data&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocpowerful-language-vs-power-user" name="toc7" id="toc7"&gt;Powerful language vs power user?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocappendix-a-first-impressions-of-arc" name="toc8" id="toc8"&gt;Appendix A: First impressions of Arc&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocappendix-b-c-solution" name="toc9" id="toc9"&gt;Appendix B: C++ solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocappendix-c-a-python-solution" name="toc10" id="toc10"&gt;Appendix C: A Python Solution&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/power-programming#tocnotes" name="toc11" id="toc11"&gt;Notes&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc0" name="tocpowerful-or-dangerous" id="tocpowerful-or-dangerous"&gt;Powerful or dangerous?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Recently I &lt;a href="http://wordaligned.org/articles/next-permutation.html" title="Next permutation: when C++ gets it right"&gt;wrote about&lt;/a&gt; one of the &lt;a href="http://code.google.com/codejam/"&gt;Google Code Jam&lt;/a&gt; challenges, where, perhaps surprisingly, the best answer &amp;#8212; the most elegant and obviously correct answer, requiring the fewest lines of code, with virtually zero space overhead, and running the quickest &amp;#8212; the very best answer was coded in C++.
&lt;/p&gt;
&lt;p&gt;Why should this be surprising? C++ is a powerful language.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In my experience there is almost no limit to the damage that a sufficiently ingenious fool can do with C++. But there is also almost no limit to the degree of complexity that a skillful library designer can hide behind a simple, safe, and elegant C++ interface. 
&lt;/p&gt;
&lt;p&gt;&amp;#8212; Greg Colvin, &lt;a href="http://www.artima.com/cppsource/spiritofc2.html" title="Greg Colvin, In the Spirit of C"&gt;&amp;#8220;In the Spirit of C&amp;#8221;&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Yes. And yes! But in this article I wanted to discuss something C++ &lt;strong&gt;can&amp;#8217;t&lt;/strong&gt; do. Let&amp;#8217;s start with another &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#" title="Decision Tree, Google Code Jam 2009"&gt;challenge&lt;/a&gt; from the same round of the 2009 Google Code Jam.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc1" name="tocdecision-trees" id="tocdecision-trees"&gt;Decision trees&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;Decision trees &amp;#8212; in particular, a type called classification trees &amp;#8212; are data structures that are used to classify &lt;i&gt;items&lt;/i&gt; into &lt;i&gt;categories&lt;/i&gt; using &lt;i&gt;features&lt;/i&gt; of those items. For example, each animal is either &amp;#8220;cute&amp;#8221; or not. For any given animal, we can decide whether it is cute by looking at the animal&amp;#8217;s features and using the following decision tree.&lt;/p&gt;
&lt;pre&gt;(0.2 furry
  (0.81 fast
    (0.3)
    (0.2)
  )
  (0.1 fishy
    (0.3 freshwater
      (0.01)
      (0.01)
    )
    (0.1)
  )
)
&lt;/pre&gt;&lt;p&gt;&amp;mdash; &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#"&gt;Decision Trees, Google Code Jam 2009&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="http://www.zazzle.com/cute_beaver_magnet-147411069592023743"&gt;&lt;img src="http://wordaligned.org/images/cute-beaver.png" alt="Cute beaver!" width="227px" height="193px" style="float:right;margin:25px 25px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The challenge goes on to describe the structure more formally, then steps through an example calculation. What is the probability, &lt;code&gt;p&lt;/code&gt;, that a beaver is cute?
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;For example, a beaver is an animal that has two features: &lt;code&gt;furry&lt;/code&gt; and &lt;code&gt;freshwater&lt;/code&gt;. We start at the root with &lt;code&gt;p&lt;/code&gt; equal to &lt;code&gt;1&lt;/code&gt;. We multiply &lt;code&gt;p&lt;/code&gt; by &lt;code&gt;0.2&lt;/code&gt;, the weight of the root and move into the first sub-tree because the beaver has the &lt;code&gt;furry&lt;/code&gt; feature. There, we multiply &lt;code&gt;p&lt;/code&gt; by &lt;code&gt;0.81&lt;/code&gt;, which makes &lt;code&gt;p&lt;/code&gt; equal to &lt;code&gt;0.162&lt;/code&gt;. From there we move further down into the second sub-tree because the beaver does not have the fast feature. Finally, we multiply &lt;code&gt;p&lt;/code&gt; by &lt;code&gt;0.2&lt;/code&gt; and end up with &lt;code&gt;0.0324&lt;/code&gt; &amp;#8212; the probability that the beaver is cute. 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;img src="http://wordaligned.org/images/decision-tree.png" alt="Decision tree calculation"/&gt;

&lt;p&gt;The challenge itself involves processing input comprising a number of test cases. Each test case consists of a decision tree followed by a number of animals. A solution should parse the input and output the calculated cuteness probabilities.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc2" name="toccuteness-calculator" id="toccuteness-calculator"&gt;Cuteness calculator&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def cuteness(decision_tree, features):
    """Return the probability an animal is cute.
    
    - decision_tree, the decision tree
    - features, the animal's features,
    """
    p = 1.0
    dt = decision_tree
    has_feature = features.__contains__
    while dt:
        weight, *dt = dt
        p *= weight
        if dt:
            feat, lt, rt = dt
            dt = lt if has_feature(feat) else rt
    return p

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Calculating an animal&amp;#8217;s cuteness given a decision tree and the animal&amp;#8217;s features isn&amp;#8217;t hard. In Python we don&amp;#8217;t need to code up a specialised decision tree class &amp;#8212; a nested tuple does just fine. The &lt;code&gt;cuteness()&lt;/code&gt; function shown above descends the decision tree, switching left or right according to each feature&amp;#8217;s presence or absence. The efficiency of this algorithm is proportional to the depth of the tree multiplied by the length of the feature list; as far as the code jam challenge goes, it&amp;#8217;s not a concern.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; decision_tree = (
...     0.2, 'furry',
...         (0.81, 'fast',
...             (0.3,),
...             (0.2,),
...         ),
...         (0.1, 'fishy',
...             (0.3, 'freshwater',
...                  (0.01,),
...                  (0.01,),
...             ),
...             (0.1,),
...         ),
...     )
&amp;gt;&amp;gt;&amp;gt; beaver = ('furry', 'freshwater')
&amp;gt;&amp;gt;&amp;gt; cuteness(decision_tree, beaver)
0.032400000000000005

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;No, the real problem here is how to parse the input data to create the decision trees and feature sets. As you can see, though, the textual specification of a decision tree closely resembles a Python representation of that decision tree. Just add punctuation.
&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;Specification&lt;/td&gt;&lt;td&gt;Python&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre&gt;(0.2 furry
  (0.81 fast
    (0.3)
    (0.2)
  )
  (0.1 fishy
    (0.3 freshwater
      (0.01)
      (0.01)
    )
    (0.1)
  )
)&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;(0.2, 'furry',
  (0.81, 'fast',
    (0.3,),
    (0.2,),
  ),
  (0.1, 'fishy',
    (0.3, 'freshwater',
      (0.01,),
      (0.01,),
      ),
      (0.1,),
  ),
)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Rather than parse the decision tree definition by hand, why not tweak it so that it &lt;strong&gt;is&lt;/strong&gt; a valid Python nested tuple? Then we can just let the Python interpreter &lt;a href="http://docs.python.org/library/functions.html#eval"&gt;&lt;tt&gt;eval&lt;/tt&gt;&lt;/a&gt; the tuple and use it directly.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc3" name="toceval" id="toceval"&gt;Eval&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A program&amp;#8217;s ability to read and execute source code at run-time is one of the things which makes &lt;a href="http://en.wikipedia.org/wiki/Dynamic_programming_language#Eval"&gt;dynamic languages&lt;/a&gt; dynamic. You can&amp;#8217;t do it in C and C++ &amp;#8212; no, sneaking instructions &lt;a href="http://en.wikipedia.org/wiki/Buffer_overrun"&gt;past the end of a buffer&lt;/a&gt; doesn&amp;#8217;t count. Should you do it in Python? Well, it won&amp;#8217;t hurt to give it a try.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;spec = '''\
(0.2 furry
  (0.81 fast
    (0.3)
    (0.2)
  )
  (0.1 fishy
    (0.3 freshwater
      (0.01)
      (0.01)
    )
    (0.1)
  )
)
'''

tuple_rep = re.sub(r'([\.\d]+|\))', r'\1,', spec)
tuple_rep = re.sub(r'([a-z]+)', r'"\1",', tuple_rep)
decision_tree = eval(tuple_rep)[0]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, we start with the input specification of the decision tree (imagine this has been read directly from standard input). The first regex substitution inserts commas after numbers, and right parentheses. The second substitution quotes and inserts a comma after feature strings. This turns the decision tree&amp;#8217;s specification into a textual representation of a nested Python tuple. We then &lt;code&gt;eval&lt;/code&gt; that tuple and assign the result to &lt;code&gt;decision_tree&lt;/code&gt; &amp;#8212; a Python decision tree we can go on and use in the rest of our program. And that&amp;#8217;s the code jam challenge cracked, pretty much.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from pprint import pprint
&amp;gt;&amp;gt;&amp;gt; pprint(decision_tree)
(0.2,
 'furry',
 (0.81, 'fast', (0.3,), (0.2,)),
 (0.1, 'fishy', (0.3, 'freshwater', (0.01,), (0.01,)), (0.1,)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Minor wrinkle: you&amp;#8217;ll have spotted the final decision tree is the first element of the evaluated tuple. That&amp;#8217;s because the regex substitution puts a trailing comma after the right parenthesis which closes the decision tree specification, which turns &lt;code&gt;tuple_rep&lt;/code&gt; into a one-tuple. The single element contained in this one-tuple is what we need.)
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc4" name="tocdynamic-or-hacky" id="tocdynamic-or-hacky"&gt;Dynamic or hacky?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As you can see, it doesn&amp;#8217;t take much code to pull the decision tree in ready for use. Python allows us to convert between text and code and to execute code within the current environment: you just need to keep a clear head and remember where you are. Regular expressions may not have the first class language support they enjoy in Perl and Ruby, but they are well supported, and the raw string syntax makes them more readable.
&lt;/p&gt;
&lt;p&gt;Certainly, this code snippet is easier to put together than a full blown &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=0" title="Google's analysis of the decision tree challenge, including a parser"&gt;parser&lt;/a&gt;, but I think it will take more than this to convince a C++ programmer that Python is a powerful language, rather than a dangerous tool for ingenious fools. It fails to convince me. I can&amp;#8217;t remember ever using &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; in production code, where keeping a separation between layers is more important than speed of coding.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc5" name="tocjam-to-golf" id="tocjam-to-golf"&gt;Jam to golf&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://codegolf.com"&gt;&lt;img src="http://codegolf.com/images/logo.png" alt="Code Golf logo" width="332px" height="75px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;That said, Python is a fine language for scripting, and speed of coding &lt;strong&gt;is&lt;/strong&gt; what matters in this particular challenge. Just for fun, what if there were &lt;a href="http://stackoverflow.com/questions/1433263/decision-tree-code-golf" title="Decision tree code golf on Stack Overflow"&gt;a prize for brevity&lt;/a&gt;? Then of course Perl would &lt;a href="http://stackoverflow.com/questions/1433263/decision-tree-code-golf/1442392#1442392" title="gnibbler's winning Perl entry"&gt;win&lt;/a&gt;!
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Code Jam golf, by gnibbler, Stack Overflow&lt;/div&gt;

&lt;pre class="prettyprint"&gt;say("Case #$_:"),
$_=eval"''".'.&amp;lt;&amp;gt;'x&amp;lt;&amp;gt;,
s:[a-z]+:*(/ $&amp;amp;\\s/?:g,s/\)\s*\(/):/g,
eval"\$_=&amp;lt;&amp;gt;;say$_;"x&amp;lt;&amp;gt;for 1..&amp;lt;&amp;gt;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note that this does more than simply parse a decision tree &amp;#8212; it&amp;#8217;s a complete solution to the code jam &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#" title="Decision Tree, Google Code Jam 2009"&gt;challenge&lt;/a&gt;, reading trees, features, calculating cutenesses, and producing output in the required format. Sadly that&amp;#8217;s all I can say about it because the details of its operation are beyond me.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc6" name="toccode-vs-data" id="toccode-vs-data"&gt;Code vs data&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Using Python to dynamically execute code may not generally be needed or welcomed in Python production code, and over-reliance on the same trick risks reinforcing Perl&amp;#8217;s  &amp;#8220;write only&amp;#8221; reputation, but Python and Perl aren&amp;#8217;t the only contenders. &lt;span /&gt;The equivalence of code and data marks Lisp&amp;#8217;s apotheosis. Take a look at a &lt;a href="http://stackoverflow.com/questions/1433263/decision-tree-code-golf/1540845#1540845" title="Arc solution to decision tree"&gt;Lisp solution&lt;/a&gt; to the challenge. This one is coded up in &lt;a href="http://arclanguage.org" title="Arc, a new dialect of Lisp"&gt;Arc&lt;/a&gt;.
&lt;/p&gt;
&lt;pre class="prettyprint lang-lisp"&gt;
(def r () (read))
(for i 1 (r)
  (prn "Case #" i ":")
  (r)
  (= z (r))
  (repeat (r)
    (r)
    (loop (= g (n-of (r) (r))
             c z
             p 1)
       c
       (= p (* (pop c) p)
          c (if (pos (pop c) g)
                (c 0)
                (cadr c))))
    (prn p)))
&lt;/pre&gt;

&lt;p&gt;Which challenge does this solve? 
&lt;/p&gt;
&lt;p&gt;I meant the code golf challenge, of solving the decision tree problem using the fewest keystrokes. At 154 characters this Arc program is nearly half as long again as the winning Perl entry, but it&amp;#8217;s hardly flabby. What really impresses me, though, is that the code is (almost) as readable as it is succinct. It&amp;#8217;s elegant code. The only real scars left by the battle for brevity are the one character variable names. Here&amp;#8217;s the same code with improved variable names and some comments added. It&amp;#8217;s the &lt;code&gt;(read)&lt;/code&gt; calls which evaluate expressions on standard input. The &lt;code&gt;(for ...)&lt;/code&gt; and &lt;code&gt;(repeat ...)&lt;/code&gt; expressions operate as you might expect. The third looping construct, &lt;code&gt;(loop ...)&lt;/code&gt; initialises, tests and proceeds, much like a C for loop.
&lt;/p&gt;
&lt;pre class="prettyprint lang-lisp"&gt;
(for i 1 (read)               ; Read N, # test cases, and loop
  (prn "Case #" i ":")
  
  (read)                      ; Skip L, # lines taken by decision tree
  (= dtree (read))            ; and read the tree in directly
  
  (repeat (read)              ; Repeat over A, # animals
    (read)                    ; Skip animal name
    ; Read in the animal's features and walk down the 
    ; decision tree calculating p, the cuteness probability
    (loop (= features (n-of (read) (read)) 
             dt dtree
             p 1)
       dt
       (= p (* (pop dt) p)
          dt (if (pos (pop dt) features)
                (car dt)
                (cadr dt))))
    (prn p)))
&lt;/pre&gt;

&lt;p&gt;You could argue the elegance of this solution is due to the fact the input comprises a sequence of tokens and &lt;a href="http://en.wikipedia.org/wiki/S-expression" title="S-expressions, Wikipedia"&gt;S-expressions&lt;/a&gt;. If commas had been used to separate input elements and the text fields had been enclosed in quotes, then maybe a Python solution would have been equally clean. Or if the input had been in XML, then we&amp;#8217;d be looking to a library rather than &lt;code&gt;eval&lt;/code&gt; for parsing the input.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s a fair point, but the equivalence of code and data counts as Lisp&amp;#8217;s biggest idea. Where Python&amp;#8217;s &lt;code&gt;eval&lt;/code&gt; is workable but rarely needed, Lisp&amp;#8217;s &lt;code&gt;(read)&lt;/code&gt; is fundamental.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc7" name="tocpowerful-language-vs-power-user" id="tocpowerful-language-vs-power-user"&gt;Powerful language vs power user?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So, the most elegant answer to the code jam decision tree challenge would also be the quickest to write, and it would be written in Lisp. Did code jam champion, &lt;a href="http://www.go-hero.net/jam/09/name/ACRush" title="ACRush's code jam solutions"&gt;ACRush&lt;/a&gt;, submit a Lisp solution?
&lt;/p&gt;
&lt;p&gt;Absolutely not!
&lt;/p&gt;
&lt;p&gt;Another fundamental thing about Lisp is that it&amp;#8217;s straightforward to parse. A C++ expert can knock up an input parser for decision trees and features to order. ACRush brushed this round aside with a perfect score, taking just 45 minutes to code up working C++ solutions to this question &lt;strong&gt;and two others&lt;/strong&gt;. I&amp;#8217;ve reproduced his solution to the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#" title="Decision Tree, Google Code Jam 2009"&gt;decision tree challenge&lt;/a&gt; at the end of this article. It&amp;#8217;s plain and direct. Given the time constraints, I think it exhibits astonishing fluency &amp;#8212; the work of someone who can think in C++.
&lt;/p&gt;
&lt;p&gt;In this article we&amp;#8217;ve encountered four programming languages:
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     Python
 &lt;/li&gt;

 &lt;li&gt;
     Perl
 &lt;/li&gt;

 &lt;li&gt;
     Lisp
 &lt;/li&gt;

 &lt;li&gt;
     C++
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are very different but they share features too. They are all mature, popular and well-supported&lt;a id="fn1link" href="http://wordaligned.org/articles/power-programming#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;. Each is a powerful general purpose programming language. &lt;span /&gt;But ultimately, the power of the programmer is what matters.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc8" name="tocappendix-a-first-impressions-of-arc" id="tocappendix-a-first-impressions-of-arc"&gt;Appendix A: First impressions of Arc&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s another revision of the Arc solution, this time decomposed into subfunctions. I found no complete formal documentation of &lt;a href="http://arclanguage.org" title="Arc, a new dialect of Lisp"&gt;Arc&lt;/a&gt;. You&amp;#8217;ll have to read the source and follow the forum, and to actually run any code you&amp;#8217;ll have to download a an old version of MzScheme. The official line is: by all means have a play, but expect things to change. That said, the language looks delightful, practical, and quite &lt;a href="http://www.paulgraham.com/arcll1.html" title="No onions in the varnish, says Paul Graham"&gt;onion free&lt;/a&gt;. The &lt;a href="http://ycombinator.com/arc/tut.txt"&gt;tutorial&lt;/a&gt; made me smile. Recommended reading.
&lt;/p&gt;
&lt;pre class="prettyprint lang-lisp"&gt;
; The input is a sequence of valid Arc expressions.
; Create some read aliases to execute these.
(= skip read
   decision-tree read
   n-features read 
   n-tests read
   n-animals read)

(def animal-features ()
     ; Get an animal's features
     (skip) ; animal name
     (n-of (n-features) (read)))

(def cuteness (dtree features)
     ; Calculate cuteness from a decision tree and feature set
     (= dt dtree
        p 1.0)
     (while dt
          (= p (* (pop dt) p)
             dt (if (pos (pop dt) features)
                (car dt)
                (cadr dt))))
     p)

; Loop through the tests, printing results
(for i 1 (n-tests)
     (prn "Case #" i ":")
     (skip) ; # lines the tree specification takes
     (= dtree (decision-tree))
     (repeat 
         (n-animals)
         (prn (cuteness dtree (animal-features)))))
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc9" name="tocappendix-b-c-solution" id="tocappendix-b-c-solution"&gt;Appendix B: C++ solution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s champion ACRush&amp;#8217;s C++ solution. I&amp;#8217;ve removed some general purpose macros from the top of the file. You can download the &lt;a href="http://code.google.com/codejam/contest/scoreboard/do?cmd=GetSourceCode&amp;amp;contest=186264&amp;amp;problem=171116&amp;amp;io_set_id=1&amp;amp;username=ACRush"&gt;original here&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;set&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;

using namespace std;

vector&amp;lt;string&amp;gt; A;
vector&amp;lt;int&amp;gt; P;
set&amp;lt;string&amp;gt; M;

#define SIZE(X) ((int)(X.size()))

double solve(int H,int T)
{
    H++;T--;
    double p=atof(A[H].c_str());
    if (H==T) return p;
    if (M.find(A[H+1])!=M.end())
        return p*solve(H+2,P[H+2]);
    else
        return p*solve(P[T],T);
}
int main()
{
    freopen("A-large.in","r",stdin);freopen("A-large.out","w",stdout);
    int testcase;
    scanf("%d",&amp;amp;testcase);
    for (int caseId=1;caseId&amp;lt;=testcase;caseId++)
    {
        int nline;
        scanf("%d",&amp;amp;nline);
        A.clear();
        char str[1024];
        gets(str);
        for (int i=0;i&amp;lt;nline;i++)
        {
            gets(str);
            string s="";
            for (int k=0;str[k];k++)
                if (str[k]=='(' || str[k]==')')
                    s+=" "+string(1,str[k])+" ";
                else
                    s+=str[k];
            istringstream sin(s);
            for (;sin&amp;gt;&amp;gt;s;A.push_back(s));
        }
        P.resize(SIZE(A),-1);
        vector&amp;lt;int&amp;gt; stack;
        for (int i=0;i&amp;lt;SIZE(A);i++)
            if (A[i]=="(")
                stack.push_back(i);
            else if (A[i]==")")
            {
                int p=stack[SIZE(stack)-1];
                P[i]=p;
                P[p]=i;
                stack.pop_back();
            }
        int cnt;
        printf("Case #%d:\n",caseId);
        for (scanf("%d",&amp;amp;cnt);cnt&amp;gt;0;cnt--)
        {
            scanf("%s",str);
            M.clear();
            int length;
            for (scanf("%d",&amp;amp;length);length&amp;gt;0;length--)
            {
                scanf("%s",str);
                M.insert(str);
            }
            double r=solve(0,SIZE(A)-1);
            printf("%.12lf\n",r);
        }
    }
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc10" name="tocappendix-c-a-python-solution" id="tocappendix-c-a-python-solution"&gt;Appendix C: A Python Solution&lt;/a&gt;&lt;/h3&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import re
from itertools import islice

def cuteness(decision_tree, features):
    p = decision_tree[0]
    if len(decision_tree) &amp;gt; 1:
        _, feat, lt, rt = decision_tree
        p *= cuteness(lt if feat in features else rt, features)
    return p

def read_decision_tree(spec):
    tuple_rep = re.sub(r'([\.\d]+|\))', r'\1,', spec)
    tuple_rep = re.sub(r'([a-z]+)', r'"\1",', tuple_rep)
    return eval(tuple_rep)[0]

def take_lines(lines, n):
    return ''.join(islice(lines, n))

def main(fp):
    lines = iter(fp)
    n_tests = int(next(lines))
    for tc in range(1, n_tests + 1):
        print("Case #%d:" % tc)
        tree_spec = take_lines(lines, int(next(lines)))
        dtree = read_decision_tree(tree_spec)
        n_animals = int(next(lines))
        for line in islice(lines, n_animals):
            features = set(line.split()[2:])
            print(cuteness(dtree, features))

import sys
main(sys.stdin)

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/power-programming#toc11" name="tocnotes" id="tocnotes"&gt;Notes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/power-programming#fn1link"&gt;[1]&lt;/a&gt; (Arc may not be mature, popular or well-supported; but Lisp certainly is.)
&lt;/p&gt;</description>
<dc:date>2010-01-26</dc:date>
<guid>http://wordaligned.org/articles/power-programming</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/power-programming</link>
<category>Python</category>
</item>

<item>
<title>Python, Surprise me!</title>
<description>&lt;h3&gt;A Simple Function&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple function which converts the third item of a list into an integer and returns it, returning -1 if the list has fewer than three entries or if the third entry fails to convert.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def third_int(xs):
    '''Convert the third item of xs into an int and return it.
        
    Returns -1 on failure.
    '''    
    try:
        return int(xs[2])
    except IndexError, ValueError:
        return -1

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Unfortunately this simple function is simply wrong. Evidently some exceptions aren&amp;#8217;t being caught.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; third_int([1, 2, 3, 4])
3
&amp;gt;&amp;gt;&amp;gt; third_int([1])
-1
&amp;gt;&amp;gt;&amp;gt; third_int(('1', '2', '3', '4',))
3
&amp;gt;&amp;gt;&amp;gt; third_int(['one', 'two', 'three', 'four'])
Traceback (most recent call last):
    ....
ValueError: invalid literal for int() with base 10: 'three'

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How ever did a &lt;code&gt;ValueError&lt;/code&gt; sneak past the &lt;code&gt;except&lt;/code&gt; clause?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;The Real Surprise&lt;/h3&gt;
&lt;p&gt;There&amp;#8217;s nothing mysterious or surprising going on here, but I&amp;#8217;ll delay answering this question for a moment. For me, the real surprise about Python is that, generally, I get it right first time. Python similarly &lt;a href="http://www.python.org/about/success/esr" title="Why Python? by Eric S. Raymond"&gt;caught Eric S. Raymond by surprise&lt;/a&gt;. His first surprise was that it took him just 20 minutes to get used to syntactically significant whitespace. And just 100 minutes later &amp;#8230;
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;My second [surprise] came a couple of hours into the project, when I noticed (allowing for pauses needed to look up new features in &lt;em&gt;Programming Python&lt;/em&gt;) I was generating working code nearly as fast as I could type. When I realized this, I was quite startled. An important measure of effort in coding is the frequency with which you write something that doesn&amp;#8217;t actually match your mental representation of the problem, and have to backtrack on realizing that what you just typed won&amp;#8217;t actually tell the language to do what you&amp;#8217;re thinking. An important measure of good language design is how rapidly the percentage of missteps of this kind falls as you gain experience with the language.
&lt;/p&gt;
&lt;p&gt;&amp;#8212; Eric S. Raymond, &lt;a href="http://www.python.org/about/success/esr" title="Why Python? by Eric S. Raymond"&gt;Why Python?&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I certainly don&amp;#8217;t generate working code as fast as I can type, and I&amp;#8217;m not even a particularly &lt;a href="http://steve-yegge.blogspot.com/2008/09/programmings-dirtiest-little-secret.html" title="Learn to type, Yegge says"&gt;quick typist&lt;/a&gt;, but I rarely make syntactic errors when writing Python &amp;#8212; and I don&amp;#8217;t often need to consult the documentation on such matters. As Chuck Allison memorably puts it: &lt;a href="http://www.artima.com/cppsource/simple.html"&gt;&amp;#8220;the syntax is so clean it squeaks&amp;#8221;&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;Parentheses Required(?)&lt;/h3&gt;
&lt;p&gt;There are some oddities and gotchas though. I don&amp;#8217;t object to the &lt;a href="http://effbot.org/pyfaq/why-must-self-be-used-explicitly-in-method-definitions-and-calls.htm"&gt;explicit &lt;code&gt;self&lt;/code&gt;&lt;/a&gt; in methods, but I do sometimes forget to write it &amp;#8212; especially if I&amp;#8217;ve just switched over from C++. 
&lt;/p&gt;
&lt;p&gt;A side-effect of the whitespace thing is that you can&amp;#8217;t just wrap a long line. The &lt;a href="http://docs.python.org/reference/lexical_analysis.html#explicit-line-joining"&gt;line ending&lt;/a&gt; needs to be escaped.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;if 1900 &amp;lt; year &amp;lt; 2100 and 1 &amp;lt;= month &amp;lt;= 12 \
    and 1 &amp;lt;= day &amp;lt;= 31 and 0 &amp;lt;= hour &amp;lt; 24 \
    and 0 &amp;lt;= minute &amp;lt; 60 and 0 &amp;lt;= second &amp;lt; 60: # Looks like a valid date
    return 1

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Alternatively, parenthesize.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;if (1900 &amp;lt; year &amp;lt; 2100 and 1 &amp;lt;= month &amp;lt;= 12
    and 1 &amp;lt;= day &amp;lt;= 31 and 0 &amp;lt;= hour &amp;lt; 24
    and 0 &amp;lt;= minute &amp;lt; 60 and 0 &amp;lt;= second &amp;lt; 60): # Looks like a valid date
    return 1

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;In the above, the parentheses aren&amp;#8217;t required to group terms, but instead serve to implicitly continue the line of code past a couple of newline characters.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Tree_%28data_structure%29"&gt;&lt;img width="360px" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/500px-Binary_tree.svg.png" alt="Wikipedia Tree"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Parentheses serve more than one role in Python&amp;#8217;s syntax. As in all C-family languages, they can group expressions. They also get involved building tuples, &lt;code&gt;(1, 2, 3)&lt;/code&gt; or &lt;code&gt;('red', 0xff0000)&lt;/code&gt; for example. Beware the special case: a one-tuple needs a trailing comma, &lt;code&gt;("singleton",)&lt;/code&gt;. This isn&amp;#8217;t something I forget or accidentally omit, but it can make things fiddly. Here&amp;#8217;s a tuple-tised &lt;a href="http://en.wikipedia.org/wiki/Tree_%28data_structure%29"&gt;tree&lt;/a&gt;, where we represent a tree as a tuple whose first element is a node value, and any subsequent elements are sub-trees. Careful with those commas!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;tree = (2, (7, (2,), (6, (5,), (11,))), (5, (9, (4,))))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Actually, tuples are just comma-separated lists of expressions &amp;#8212; no parentheses required &amp;#8212; so we might equally well have written.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;tree = 2, (7, (2,), (6, (5,), (11,))), (5, (9, (4,)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the superfluous outermost parentheses have been omitted; the inner ones are still required for grouping.
&lt;/p&gt;
&lt;p&gt;How about we always append a trailing comma to our tuples so the one-tuple no longer looks different?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;tree = 2, (7, (2,), (6, (5,), (11,))), (5, (9, (4,))),

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;That&amp;#8217;s allowed and fine. Unless we need an empty tuple, that is, in which case the parentheses &lt;strong&gt;are&lt;/strong&gt; required. And a comma would be wrong.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; ()
()
&amp;gt;&amp;gt;&amp;gt; (),
((),)
&amp;gt;&amp;gt;&amp;gt; ,
   ....
SyntaxError: invalid syntax
&amp;gt;&amp;gt;&amp;gt; (,)
   ....
SyntaxError: invalid syntax
&amp;gt;&amp;gt;&amp;gt; tuple()
()

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Python 3 introduces a nice new syntax for &lt;code&gt;set&lt;/code&gt; literals, reusing the braces which traditionally enclose &lt;code&gt;dict&lt;/code&gt;s.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; ls = { 1, 11, 21, 1211, 111221, 312211 }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Again, beware the edge case: &lt;code&gt;{}&lt;/code&gt; is an empty &lt;code&gt;dict&lt;/code&gt;, not an empty set.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; zs = {}
&amp;gt;&amp;gt;&amp;gt; type(zs)
&amp;lt;class 'dict'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; zs = set()
&amp;gt;&amp;gt;&amp;gt; type(zs)
&amp;lt;class 'set'&amp;gt;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Python 3 allows non-ascii characters in identifiers, but not any old character, so we &lt;strong&gt;cannot&lt;/strong&gt; get away with
&lt;/p&gt;
&lt;pre&gt;
&gt;&gt;&gt; &amp;empty; = set()
      ^
SyntaxError: invalid character in identifier
&lt;/pre&gt;

&lt;p&gt;Parentheses are used for function calls too, and also for generator expressions. Here&amp;#8217;s a lazy list of squares of numbers less than a million.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; sqs = (x * x for x in range(1000000))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s the sum of these numbers.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; sum((x * x for x in range(1000000)))
333332833333500000

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Actually, we can omit the generator-expression parentheses in the sum. The function call parentheses magically turn the enclosed &lt;code&gt;x * x for x in range(1000000)&lt;/code&gt; into a generator expression. As usual, Python does what we want.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; sum(x * x for x in range(1000000))
333332833333500000

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Serious about Syntax&lt;/h3&gt;
&lt;p&gt;If you&amp;#8217;ve read this far you may well be thinking: &amp;#8220;So what?&amp;#8221; I haven&amp;#8217;t shown any gotchas, merely a few quirks and corner cases. As already mentioned, the real surprise is that Python fails to surprise. Part of this, as I hope I&amp;#8217;ve shown here, can be attributed to the interpreter, which positively invites you to experiment; but mainly &lt;span /&gt;Python&amp;#8217;s clean and transparent design takes the credit. Repeating Eric S. Raymond: you don&amp;#8217;t have to &amp;#8220;actually tell the language to do what you&amp;#8217;re thinking&amp;#8221;.
&lt;/p&gt;
&lt;p&gt;Since I first started using Python the syntax has grown considerably, yet the extensions and additions seem almost as if they&amp;#8217;d been planned from the start&lt;a id="fn1link" href="http://wordaligned.org/articles/python-surprise-me#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;. Generator expressions complement list comprehensions. The yield statement fits nicely with iteration.
&lt;/p&gt;
&lt;p&gt;Even more remarkably, Python 3 has chosen to break backwards compatibility, so it can undo those few early choices which now seem mistakes. Which brings us back to the broken function at the top of this article. Here it is again, docstring omitted for brevity.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def third_int(xs):
    try:
        return int(xs[2])
    except IndexError, ValueError:
        return -1

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I really did write a function like this, and I really did get it wrong in just this way. The code is syntactically valid, but I should have written
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def third_int(xs):
    try:
        return int(xs[2])
    except (IndexError, ValueError):
        return -1

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The parentheses in the &lt;code&gt;except&lt;/code&gt; clause are crucial. The formal syntax of this form of &lt;a href="http://docs.python.org/reference/compound_stmts.html#the-try-statement"&gt;try statement&lt;/a&gt; is
&lt;/p&gt;
&lt;pre&gt;
try1_stmt ::=  "try" ":" suite
               ("except" [expression [("as" | ",") target]] ":" suite)+
               ["else" ":" suite]
               ["finally" ":" suite]
&lt;/pre&gt;

&lt;p&gt;In the corrected version of &lt;code&gt;third_int()&lt;/code&gt;, the parentheses group &lt;code&gt;IndexError, ValueError&lt;/code&gt; into a single expression, a tuple, and the except clause matches any object with class (or base class) &lt;code&gt;IndexError&lt;/code&gt; or &lt;code&gt;ValueError&lt;/code&gt;. The broken version is very different, as becomes clear if we use the alternative &lt;code&gt;"as"&lt;/code&gt; form.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def third_int(xs):
    try:
        return int(xs[2])
    except IndexError as ValueError:
        return -1

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the except clause will match an object with class or base class &lt;code&gt;IndexError&lt;/code&gt;, and assigns that object to the target, which is called &lt;code&gt;ValueError&lt;/code&gt; (and which shadows the &amp;#8220;real&amp;#8221; ValueError in the rest of the function definition). If &lt;code&gt;int()&lt;/code&gt; raises a &lt;code&gt;ValueError&lt;/code&gt;, it will not be matched.
&lt;/p&gt;

&lt;h3&gt;Won&amp;#8217;t Get Fooled Again&lt;/h3&gt;
&lt;p&gt;Oh, I get it, now. It &lt;strong&gt;is&lt;/strong&gt; a bit subtle, but I won&amp;#8217;t make that mistake again.
&lt;/p&gt;
&lt;p&gt;Wait, there&amp;#8217;s more! In Python 3k, my broken implementation is properly broken &amp;#8212; a syntax error.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;Python 3.1
&amp;gt;&amp;gt;&amp;gt; def third_int(xs):
...     try:
...         return int(xs[2])
...     except IndexError, ValueError:
  File "&amp;lt;stdin&amp;gt;", line 4
    except IndexError, ValueError:
                     ^
SyntaxError: invalid syntax

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The Python 3k syntax of this form of &lt;a href="http://docs.python.org/py3k/reference/compound_stmts.html#the-try-statement"&gt;try statement&lt;/a&gt; reads.
&lt;/p&gt;
&lt;pre&gt;
try1_stmt ::=  "try" ":" suite
               ("except" [expression "as" target]] ":" suite)+
               ["else" ":" suite]
               ["finally" ":" suite]
&lt;/pre&gt;

&lt;p&gt;You can&amp;#8217;t use a comma to capture the target any more. It&amp;#8217;s an advance and a simplification. Why am I not surprised?
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/python-surprise-me#fn1link"&gt;[1]&lt;/a&gt;: With the possible exception of &lt;a href="http://docs.python.org/reference/expressions.html#boolean-operations"&gt;conditional expressions&lt;/a&gt;, that is.
&lt;/p&gt;</description>
<dc:date>2009-12-15</dc:date>
<guid>http://wordaligned.org/articles/python-surprise-me</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/python-surprise-me</link>
<category>Python</category>
</item>

<item>
<title>Next permutation: When C++ gets it right</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocthe-next-number-problem" name="toc0" id="toc0"&gt;The Next Number Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocchoice-of-algorithm" name="toc1" id="toc1"&gt;Choice of Algorithm&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toclexicographical-ordering" name="toc2" id="toc2"&gt;Lexicographical Ordering&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocnext-permutation-in-action" name="toc3" id="toc3"&gt;Next permutation in action&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocsnail-sorts-revenge" name="toc4" id="toc4"&gt;Snail sort&amp;#8217;s revenge&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocthe-next-number-solved" name="toc5" id="toc5"&gt;The Next Number, Solved&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocimplementation" name="toc6" id="toc6"&gt;Implementation&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocwhats-happening-here" name="toc7" id="toc7"&gt;What&amp;#8217;s happening here?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocbeautiful-c" name="toc8" id="toc8"&gt;Beautiful C++?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#tocpermutations-in-python" name="toc9" id="toc9"&gt;Permutations in Python&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc0" name="tocthe-next-number-problem" id="tocthe-next-number-problem"&gt;The Next Number Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose you have a fixed list of digits chosen from the range 1..9. What numbers can you make with them? You&amp;#8217;re allowed as many zeros as you want. Write the numbers in increasing order.
&lt;/p&gt;
&lt;p&gt;Exactly &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;this puzzle&lt;/a&gt; came up in the recent &lt;a href="http://code.google.com/codejam"&gt;Google Code Jam&lt;/a&gt; programming contest:
&lt;/p&gt;
&lt;blockquote&gt;You are writing out a list of numbers. Your list contains all numbers with exactly &lt;strong&gt;D&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt; digits in its decimal representation which are equal to i, for each i between 1 and 9, inclusive. You are writing them out in ascending order.&lt;/p&gt;&lt;p&gt;For example, you might be writing every number with two &amp;#8216;1&amp;#8217;s and one &amp;#8216;5&amp;#8217;. Your list would begin 115, 151, 511, 1015, 1051.&lt;/p&gt;&lt;p&gt;Given N, the last number you wrote, compute what the next number in the list will be.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The competition has closed now, but if you&amp;#8217;d like to give it a go sample input files can be found on the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;website&lt;/a&gt;, where you can also upload your results and have them checked.
&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a short section from a trial I ran on my computer. Input numbers are in the left-hand column: the corresponding output numbers are in the right-hand column.
&lt;/p&gt;
&lt;pre style="font-size:150%"&gt;
50110812884911623516 &amp;rarr; 50110812884911623561
82454322474161687049 &amp;rarr; 82454322474161687094
82040229261723155710 &amp;rarr; 82040229261723157015
43888989554234187388 &amp;rarr; 43888989554234187838
76080994872481480636 &amp;rarr; 76080994872481480663
31000989133449480678 &amp;rarr; 31000989133449480687
20347716554681051891 &amp;rarr; 20347716554681051918
&lt;/pre&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc1" name="tocchoice-of-algorithm" id="tocchoice-of-algorithm"&gt;Choice of Algorithm&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Like many of the code jam challenges, you&amp;#8217;ll need to write a program which runs fast enough; but choosing the right algorithm is more important than choosing the right language. Typically a high-level interpreted language like Python allows me to code and test a solution far more quickly than using a low-level language like C or C++.
&lt;/p&gt;
&lt;p&gt;In this particular case, though, like most &lt;a href="http://www.go-hero.net/jam/09/problems/2/2"&gt;successful candidates&lt;/a&gt;, I used C++. &lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;Here&amp;#8217;s why&lt;/a&gt;.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;&lt;code&gt;Next_permutation&lt;/code&gt;&lt;/a&gt; transforms the range of elements &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically next greater permutation of the elements. [&amp;#8230;] If such a permutation exists, &lt;code&gt;next_permutation&lt;/code&gt; transforms &lt;code&gt;[first, last)&lt;/code&gt; into that permutation and returns true. Otherwise it transforms &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically smallest permutation and returns &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Although the next number problem appears to be about numbers and lexicographical ordering appears to be about words, &lt;code&gt;std::next_permutation&lt;/code&gt; is exactly what&amp;#8217;s needed here.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc2" name="toclexicographical-ordering" id="toclexicographical-ordering"&gt;Lexicographical Ordering&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/4099819327/" title="Lexicographical order by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2449/4099819327_4063635302.jpg" width="500" height="216" alt="Lexicographical order" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;A dictionary provides the canonical example of lexicographical ordering. Words are built from characters, which can be alphabetically ordered A, B, C, &amp;#8230; , so in the dictionary words which begin with &lt;strong&gt;A&lt;/strong&gt; appear before words which begin with &lt;strong&gt;B&lt;/strong&gt;, which themselves come in front of words beginning with &lt;strong&gt;C&lt;/strong&gt;, etc. If two words start with the same letter, pop that letter from the head of the word and compare their tails, which puts AARDVARK before ANIMAL, and &amp;#8212; applying this rule recursively &amp;#8212; after &lt;a href="http://www.aardman.com/" title="Bristol's finest"&gt;AARDMAN&lt;/a&gt;. Imagine there&amp;#8217;s an empty word marking position zero, before A, right at the front of the dictionary, and our recursive  definition is complete.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc3" name="tocnext-permutation-in-action" id="tocnext-permutation-in-action"&gt;Next permutation in action&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple program which shows &lt;code&gt;next_permutation()&lt;/code&gt; in action.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int main()
{
    char xs[] = "123";
    do
    {
        std::puts(xs);
    }
    while (std::next_permutation(xs, xs + sizeof(xs) - 1));
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This program outputs lexicographically ordered permutations of 1, 2 and 3. When the main function returns, the array &lt;code&gt;xs&lt;/code&gt; will have cycled round to hold the lexicographically smallest arrangement of its elements, which is &lt;code&gt;"123"&lt;/code&gt;. Note that we never convert the characters &lt;code&gt;'1'&lt;/code&gt;, &lt;code&gt;'2'&lt;/code&gt;, &lt;code&gt;'3'&lt;/code&gt; into the numbers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;. The values of both sets of data types appear in the same order, so all works as expected.
&lt;/p&gt;
&lt;pre&gt;
123
132
213
231
312
321
&lt;/pre&gt;

&lt;p&gt;If we tweak and rerun the same program with &lt;code&gt;xs&lt;/code&gt; initialised to &lt;code&gt;"AAADKRRV"&lt;/code&gt; we get rather more output.
&lt;/p&gt;
&lt;pre&gt;
AAADKRRV
AAADKRVR
AAADKVRR
...
AARDVARK
...
VRRKAADA
VRRKADAA
VRRKDAAA
&lt;/pre&gt;

&lt;p&gt;The sequence &lt;strong&gt;doesn&amp;#8217;t&lt;/strong&gt; start by repeating &lt;code&gt;"AAADKRRV"&lt;/code&gt; 6 times, once for every permutation of the 3 A&amp;#8217;s. Only strictly increasing permutations are included. And although the repeated calls to &lt;code&gt;next_permutation&lt;/code&gt; generate a series of permutations, the algorithm holds no state. Each function call works on its input range afresh.
&lt;/p&gt;
&lt;p&gt;This second run of the program yields 3360 lines of output, even though there are 8! = 40320 possible permutations of 8 characters. Each unique permutation corresponds to 3! &amp;times; 2! = 12 actual permutations of the 8 characters (because there are 3 A&amp;#8217;s and 2 R&amp;#8217;s), and 40320 &amp;divide; 12 is 3360.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc4" name="tocsnail-sorts-revenge" id="tocsnail-sorts-revenge"&gt;Snail sort&amp;#8217;s revenge&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/tim_norris/2789759648/"&gt;&lt;img src="http://farm4.static.flickr.com/3143/2789759648_ab4bfb5ea8.jpg" width="500px" height="333px" alt="...and in last place. By Tim Norris"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;As you can see, &lt;code&gt;next_permutation&lt;/code&gt; sorts an input range, one step at a time.  When &lt;code&gt;next_permutation&lt;/code&gt; eventually returns false, the range will be perfectly ordered. Hence we have &lt;code&gt;snail_sort()&lt;/code&gt;, hailed by the SGI STL &lt;a href="http://www.sgi.com/tech/stl/next_permutation.html"&gt;documentation&lt;/a&gt; as the worst known deterministic sorting algorithm.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template &amp;lt;class Iter&amp;gt; 
void snail_sort(Iter first, Iter last)
{
    while (next_permutation(first, last)) {}
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Very witty, and evidence that code can be both &lt;a href="http://wordaligned.org/articles/elegance-and-efficiency.html"&gt;elegant and inefficient&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;In two important edge cases, though, &lt;code&gt;snail_sort&lt;/code&gt; performs on a par with super-charged &lt;code&gt;quicksort&lt;/code&gt;!
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     I snail sorted an array filled with 100000000 zeros in 0.502 seconds. Running quicksort on the same array took 5.504 seconds. 
 &lt;/li&gt;

 &lt;li&gt;
     Starting with an array of the same size filled with the values 99999999, 99999998, 99999997, &amp;#8230; 1, 0 snail sort&amp;#8217;s 0.500 seconds trounced quicksort&amp;#8217;s 4.08 seconds.
 &lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc5" name="tocthe-next-number-solved" id="tocthe-next-number-solved"&gt;The Next Number, Solved&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s an outline solution to the &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=p1"&gt;next number problem&lt;/a&gt;. (I&amp;#8217;ve glossed over the exact input and output file formats for clarity.) It reads numbers from standard input and writes next numbers to standard output. &lt;code&gt;Next_permutation&lt;/code&gt; does the hard work, and there&amp;#8217;s a bit of fiddling when we have to increase the number of digits by adding a zero.&lt;a id="fn1link" href="http://wordaligned.org/articles/next-permutation#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

/*
 Given a string of digits, shift any leading '0's
 past the first non-zero digit and insert an extra zero.
 
 Examples:
  
 123 -&amp;gt; 1023
 008 -&amp;gt; 8000
 034 -&amp;gt; 3004
*/
void insert_a_zero(std::string &amp;amp; number)
{
    size_t nzeros = number.find_first_not_of('0');
    number = number.substr(nzeros);
    number.insert(1, nzeros + 1, '0');
}

/*
 Outline solution to the 2009 code jam Next Number problem.
 
 Given a string representing a decimal number, find the next
 number which can be formed from the same set of digits. Add
 another zero if necessary. Repeat for all such strings read
 from standard input.
*/
int main()
{
    std::string number;
    while (std::cin &amp;gt;&amp;gt; number)
    {
        if (!next_permutation(number.begin(), number.end()))
        {
            insert_a_zero(number);
        }
        std::cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; '\n';
    }
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc6" name="tocimplementation" id="tocimplementation"&gt;Implementation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having used the C++ standard library to solve the puzzle, let&amp;#8217;s take a look at how it works. Next permutation is a clever algorithm which shuffles a collection in place. My system implements it like this&lt;a id="fn2link" href="http://wordaligned.org/articles/next-permutation#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;
        
    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We start with a range delimited by a pair of bi-directional iterators, &lt;code&gt;[first, last)&lt;/code&gt;. If the range contains one item or fewer, there can be no next permutation, so leave the range as is and return &lt;code&gt;false&lt;/code&gt;. Otherwise, enter the &lt;code&gt;for&lt;/code&gt; loop with an iterator &lt;code&gt;i&lt;/code&gt; pointing at the final item in the range.
&lt;/p&gt;
&lt;p&gt;At each pass through the body of this for loop we decrement &lt;code&gt;i&lt;/code&gt; by one, stepping towards the first item in the range. We are looking for one of two conditions:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     the value pointed to by &lt;code&gt;i&lt;/code&gt; is smaller than the one it pointed to previously
 &lt;/li&gt;

 &lt;li&gt;
     &lt;code&gt;i&lt;/code&gt; reaches into the first item in the range
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Put another way, we divide the range into a head and tail, where the tail is the longest possible decreasing tail of the range.
&lt;/p&gt;
&lt;p&gt;If this tail is the whole range (the second condition listed above) then the whole range is in reverse order, and we have the lexicographical maximum formed from its elements. Reversing the range returns it to its lexicographical minimum, and we can return &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;If this tail is not the whole range, then the final item in the head of the range, the item &lt;code&gt;i&lt;/code&gt; points to, this item is smaller than at least one of the items in the tail of the range, and we can certainly generate a greater permutation by moving the item towards the end of the range. To find the next permutation, we reverse iterate from the end of the range until we find an item &lt;code&gt;*j&lt;/code&gt; bigger than &lt;code&gt;*i&lt;/code&gt; &amp;#8212; that&amp;#8217;s what the while loop does. Swapping the items pointed to by &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; ensures the head of the range is bigger than it was, and the tail of the range remains in reverse order. Finally, we reverse the tail of the range, leaving us with a permutation exactly one beyond the input permutation, and we return &lt;code&gt;true&lt;/code&gt;. 
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc7" name="tocwhats-happening-here" id="tocwhats-happening-here"&gt;What&amp;#8217;s happening here?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s clear from this paper analysis that the algorithm is of linear complexity. Essentially, it walks up and down the tail of the list, comparing and swapping. But why does it work?
&lt;/p&gt;
&lt;p&gt;Let &lt;code&gt;xs&lt;/code&gt; be the range &lt;code&gt;(first, last)&lt;/code&gt;. As described above, divide this range into prefix and suffix subranges, &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, where &lt;code&gt;tail&lt;/code&gt; is the longest monotonically decreasing tail of the range.
&lt;/p&gt;
&lt;p&gt;If the &lt;code&gt;head&lt;/code&gt; of the range is empty, then the range &lt;code&gt;xs&lt;/code&gt; is clearly at its lexicographical maximum. 
&lt;/p&gt;
&lt;p&gt;Otherwise, &lt;code&gt;tail&lt;/code&gt; is a lexicographical maximum of the elements it contains, and &lt;code&gt;xs&lt;/code&gt; is therefore the largest permutation which starts with the subrange &lt;code&gt;head&lt;/code&gt;. What will the &lt;code&gt;head&lt;/code&gt; of the next permutation be? We have to swap the final item in &lt;code&gt;head&lt;/code&gt; with the smallest item of &lt;code&gt;tail&lt;/code&gt; which exceeds it: the definition of &lt;code&gt;tail&lt;/code&gt; guarantees at least one such item exists. Now we want to permute the new &lt;code&gt;tail&lt;/code&gt; to be at a its lexicographical minimum, which is a matter of sorting it from low to high.
&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;tail&lt;/code&gt; is in reverse order, finding the smallest item larger than &lt;code&gt;head[-1]&lt;/code&gt; is a matter of walking back from the end of the range to find the first such items; and once we&amp;#8217;ve swapped these items, &lt;code&gt;tail&lt;/code&gt; remains in reverse order, so a simple reversed will sort it.
&lt;/p&gt;
&lt;p&gt;As an example consider finding the next permutation of:
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8342666411
&lt;/pre&gt;

&lt;p&gt;The longest monotonically decreasing tail is &lt;code&gt;666411&lt;/code&gt;, and the corresponding head is &lt;code&gt;8342&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8342 666411
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;666411&lt;/code&gt; is, by definition, reverse-ordered, and cannot be increased by permuting its elements. To find the next permutation, we must increase the head; a matter of finding the smallest tail element larger than the head&amp;#8217;s final &lt;code&gt;2&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;2&lt;/span&gt; 666411
&lt;/pre&gt;

&lt;p&gt;Walking back from the end of tail, the first element greater than &lt;code&gt;2&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;2&lt;/span&gt;  666&lt;span style="color:#930"&gt;4&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Swap the &lt;code&gt;2&lt;/code&gt; and the &lt;code&gt;4&lt;/code&gt;
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
834&lt;span style="color:#930"&gt;4&lt;/span&gt; 666&lt;span style="color:#930"&gt;2&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Since head has increased, we now have a greater permutation. To reduce to the next permutation, we reverse tail, putting it into increasing order.
&lt;/p&gt;
&lt;pre style="font-size:250%;"&gt;
8344 112666
&lt;/pre&gt;

&lt;p&gt;Join the head and tail back together. The permutation one greater than &lt;code&gt;8342666411&lt;/code&gt; is &lt;code&gt;8344112666&lt;/code&gt;.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc8" name="tocbeautiful-c" id="tocbeautiful-c"&gt;Beautiful C++?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/looping-forever-and-ever.html"&gt;&lt;img  src="http://wordaligned.org/images/mite.jpg" alt="for(;;) dust mite"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;C++ has its &lt;a href="http://yosefk.com/c++fqa/defective.html" title="If you are an expert in the intricacies of C++, please consider this knowledge a kind of martial art - something a real master never uses. Yossi Keinin"&gt;detractors&lt;/a&gt;, who characterise it as subtle, &lt;a href="http://twitter.com/dabeaz/status/5677453478" title="C++0x reminds me of blocks stacked by my toddler. Really wobbly and one block too many makes it topple. @dabeaz"&gt;complex&lt;/a&gt;, and &lt;a href="http://www2.research.att.com/~bs/bs_faq.html#really-say-that" title="C++ can blow your whole leg off. Bjarne Stroustrup"&gt;dangerous&lt;/a&gt;; but sometimes it excels. Look once more at the C++ implementation of this algorithm.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;
    
    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span /&gt;With its special cases, boolean literals, multiple returns (4, count them!), disembodied and infinite loops, this code fails to exhibit conventional beauty. Yet &lt;em&gt;it is&lt;/em&gt; beautiful. All the next permutation algorithm needs are iterators which can advance forwards or backwards, step by step. And that&amp;#8217;s all this implementation uses.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m as excited as anyone by the mathematical rigour of &lt;a href="http://www.informit.com/articles/article.aspx?p=1407357&amp;amp;seqNum=3" title="Great article by Andrei Alexandrescu, which questions a pure Haskell quicksort implementation"&gt;functional programming&lt;/a&gt;, but sometimes computer science is about algorithms with virtually no space overhead, algorithms which loop rather than recurse. Sometimes it&amp;#8217;s about shuffling, nudging and swapping &amp;#8212; operations which map directly to the machine&amp;#8217;s most primitive operations. In such cases, C++ gets it right.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/next-permutation#toc9" name="tocpermutations-in-python" id="tocpermutations-in-python"&gt;Permutations in Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For the code jam, though, as mentioned earlier, having a super-fast program rarely matters. More often, it&amp;#8217;s about developing a fast enough program super-quickly.
&lt;/p&gt;
&lt;p&gt;I find Python a far quicker language for developing code than C++. (Indeed, sometimes when it&amp;#8217;s obvious from the outset that a final program will need implementing in C++, I put together a working prototype using Python, which I then translate.) Could we solve the next number problem using code from the standard Python library?
&lt;/p&gt;
&lt;p&gt;At a first glance, &lt;a href="http://docs.python.org/py3k/library/itertools.html#itertools.permutations"&gt;itertools.permutations&lt;/a&gt; looks promising.
&lt;/p&gt;
&lt;blockquote&gt;&lt;h3&gt;&lt;tt&gt;itertools.permutations(&lt;em&gt;iterable&lt;/em&gt;, &lt;em&gt;r=None&lt;/em&gt;)&lt;/tt&gt;&lt;/h3&gt;&lt;p&gt;Return successive &lt;em&gt;r&lt;/em&gt; length permutations of elements in the &lt;em&gt;iterable&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;If &lt;em&gt;r&lt;/em&gt; is not specified or is &lt;tt&gt;None&lt;/tt&gt;, then &lt;em&gt;r&lt;/em&gt; defaults to the length
of the &lt;em&gt;iterable&lt;/em&gt; and all possible full-length permutations
are generated.&lt;/p&gt;&lt;p&gt;Permutations are emitted in lexicographic sort order.  So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the permutation tuples will be produced in sorted order.&lt;/p&gt;&lt;p&gt;Elements are treated as unique based on their position, not on their value.  So if the input elements are unique, there will be no repeat values in each permutation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;However, this algorithm doesn&amp;#8217;t care about the values of the items in the iterable, and the lexicographic sort order applies to the indices of these items. So although the ordering of the generated items is well-defined:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     we get repeats, and
 &lt;/li&gt;

 &lt;li&gt;
     it&amp;#8217;s not the ordering we want (in this case)
 &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; concat = ''.join
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations('AAA')))
['AAA', 'AAA', 'AAA', 'AAA', 'AAA', 'AAA']
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations('231')))
['231', '213', '321', '312', '123', '132']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It &lt;strong&gt;is&lt;/strong&gt; possible to code up &lt;code&gt;next_permutation&lt;/code&gt; using nothing more than the standard itertools, but it isn&amp;#8217;t advisable.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Snail permute&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import permutations, groupby

def next_permutation(xs):
    """Calculate the next permutation of the sequence xs.
    
    Returns a pair (yn, xs'), where yn is a boolean and xs' is the 
    next permutation. If yn is True, xs' will be the lexicographic 
    next permutation of xs, otherwise xs' is the lexicographic 
    smallest permutation of xs.
    """
    xs = tuple(xs)
    if not xs:
        return False, xs
    else:
        ps = [p for p, gp in groupby(sorted(permutations(xs)))]
        np = len(ps)
        ix = ps.index(xs) + 1
        if ix == len(ps):
            return False, ps[0]
        else:
            return True, ps[ix]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As it happens, a solution based on this exhaustive search would score points in the code jam since it copes with the small input set. For the large input set its factorial complexity rules it out, and we&amp;#8217;d need to implement the next permutation algorithm &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1"&gt;from scratch&lt;/a&gt;.
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/next-permutation#fn1link"&gt;[1]&lt;/a&gt;: A more cunning &lt;a href="http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1"&gt;solution&lt;/a&gt; avoids the special case by pushing the extra zero to head of the string before applying &lt;code&gt;next_permutation&lt;/code&gt;, then popping it if it hasn&amp;#8217;t been moved.
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/next-permutation#fn2link"&gt;[2]&lt;/a&gt;: I&amp;#8217;ve tweaked the layout and parameter names for use on this site.
&lt;/p&gt;</description>
<dc:date>2009-11-19</dc:date>
<guid>http://wordaligned.org/articles/next-permutation</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/next-permutation</link>
<category>Python</category>
</item>

<item>
<title>Python on Ice</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/antipep#tocpython" name="toc0" id="toc0"&gt;Python?&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/antipep#toctwisted-81-on-python-25" name="toc1" id="toc1"&gt;Twisted 8.1 on Python 2.5&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/antipep#tocpython-3-on-word-aligned" name="toc2" id="toc2"&gt;Python 3 on Word Aligned&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/antipep#tocpython-3-absent-from-europython" name="toc3" id="toc3"&gt;Python 3 absent from Europython&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/antipep#tocpython-3-literature" name="toc4" id="toc4"&gt;Python 3 Literature&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/antipep#tocthe-cost-of-python-3" name="toc5" id="toc5"&gt;The Cost of Python 3&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/antipep#tocevolution-of-python" name="toc6" id="toc6"&gt;Evolution of Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/antipep#tocaccepting-python-3" name="toc7" id="toc7"&gt;Accepting Python 3&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;A moratorium on Python changes is probably a good thing&amp;#8212;the last edition of my book nearly made my head explode. &amp;#8212; &lt;a href="http://twitter.com/dabeaz/status/5055586588"&gt;@dabeaz&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/antipep#toc0" name="tocpython" id="tocpython"&gt;Python?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&amp;#8220;Python?&amp;#8221;
&lt;/p&gt;
&lt;p&gt;&amp;#8220;Yes, Python. It&amp;#8217;s a &lt;a href="http://wordaligned.org/articles/pitching-python-in-three-syllables.html"&gt;high-level&lt;/a&gt; language, we used it for the prototype. We can use it for parts of the system where performance isn&amp;#8217;t critical. Connecting components together. The web server.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;&amp;#8220;But what will we do when Python changes? It&amp;#8217;s a developing language, right? How can we maintain our system.&amp;#8221;
&lt;/p&gt;
&lt;p&gt;Not an issue, I explained. Python takes backwards compatibility very seriously. Besides, we choose which version of Python to deploy with, we choose when we migrate &amp;#8212; maybe never. Look, you can &lt;a href="http://python.org/download/releases"&gt;download the source&lt;/a&gt; for every version of Python ever released. All you need is a &lt;a href="http://www.python.org/dev/peps/pep-0007" title="A C89 compiler, in fact. (PEP 7, Style Guide for C Code)"&gt;C compiler&lt;/a&gt;. C is the porting layer, if you like, and C isn&amp;#8217;t going anywhere in a hurry.
&lt;/p&gt;
&lt;p&gt;In all honesty, I expected more maintenance issues with the C++ parts of our product, where the language may not have changed in a decade but &lt;a href="http://wordaligned.org/articles/code-rot.html"&gt;compilers are only just catching up&lt;/a&gt; with it; and in fact I didn&amp;#8217;t have to argue for long to persuade senior management, not on this issue at least. They&amp;#8217;d already seen how quickly I could get things up and running using Python. Even though the company had more experience with C, C++, Java, and even .Net, I convinced them Python had a role on the server-based system we were developing.
&lt;/p&gt;
&lt;p&gt;Nonetheless, I didn&amp;#8217;t think it the right time to mention Python 3. Why confuse things?
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/antipep#toc1" name="toctwisted-81-on-python-25" id="toctwisted-81-on-python-25"&gt;Twisted 8.1 on Python 2.5&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I won&amp;#8217;t go into detail about the product. Data flowed through it, redirected dynamically using tees and filters, and robots were attached to the resulting streams to monitor them. A web UI presented controls and a view of the system. We used C and C++ for managing the bulk of the flow. The robots we coded in both Python and C++. We connected and coordinated everything using &lt;a href="http://twistedmatrix.com" title="Twisted is an event-driven networking engine written in Python"&gt;Twisted&lt;/a&gt;, a Python networking engine. Our initial deployment used Python 2.5 and Twisted 8.1. We&amp;#8217;ve since upgraded to Python 2.6 and Twisted 8.2.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/antipep#toc2" name="tocpython-3-on-word-aligned" id="tocpython-3-on-word-aligned"&gt;Python 3 on Word Aligned&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At work there was no question of using Python 3 even though it became available when we started development. Twisted hadn&amp;#8217;t been released against Python 3 (&lt;a href="http://stackoverflow.com/questions/172306/how-are-you-planning-on-handling-the-migration-to-python-3/214601#214601"&gt;it still hasn&amp;#8217;t&lt;/a&gt;) and even if it had been, we wouldn&amp;#8217;t have trusted it immediately. Here at &lt;a href="http://wordaligned.org/"&gt;Word Aligned&lt;/a&gt;, though, I switched to Python 3 pretty much as soon as it was officially released. Since the start of 2009, &lt;a href="http://wordaligned.org/articles/perl-6-python-3.html#tocword-aligned-and-python-30"&gt;any Python code published on this site has been written in Python 3&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Since then I&amp;#8217;ve come to question my decision. I want people to visit my site and I want them to stay long enough to read any code here. Python is perfect because it&amp;#8217;s readable and accessible. Anyone who&amp;#8217;s ever written a program, whatever the  language, can understand Python. But many times I&amp;#8217;ve felt the need to explain my Python 3 code, not to Java, C#, C++ and C users, not even to Perl and Ruby users, but to Python users!
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Note that in Python 3 &amp;#8230; whereas in Python 2 &amp;#8230; available in Python 3.1 only &amp;#8230; you&amp;#8217;d need to write &amp;#8230; from __future__ import print_function
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I wouldn&amp;#8217;t have felt the need to say any of this if I&amp;#8217;d stuck with Python 2.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/antipep#toc3" name="tocpython-3-absent-from-europython" id="tocpython-3-absent-from-europython"&gt;Python 3 absent from Europython&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/4036266347/" title="Europython 2009 bag code by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2700/4036266347_9862579d68.jpg" width="500" height="208" alt="Code on the Europython 2009 bag" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;At Europython 2009 I was struck by the absence of Python 3 from the agenda. None of &lt;a href="http://www.europython.eu/talks/timetable/" title="Europython 2009 timetable"&gt;the sessions&lt;/a&gt; covered Python 3, used Python 3, or even mentioned Python 3 (unless you count David Jones&amp;#8217; talk on &lt;a href="http://www.europython.eu/talks/talk_abstracts/index.html#talk74"&gt;Loving Old Versions of Python&lt;/a&gt;). The only Python 3 code I saw appeared on the conference bag; a lightly obfuscated script which printed out the conference destination. Note that &lt;code&gt;print&lt;/code&gt; is being used in a way which works with both 2.x and 3.x &amp;#8212; that is, with parentheses and taking a single parameter. Very few systems resolve &lt;code&gt;/usr/bin/env python&lt;/code&gt; as Python 3, though&lt;a id="fn1link" href="http://wordaligned.org/articles/antipep#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;, which is lucky since even this simple function raises an exception under Python 3 (and transforming the code using &lt;code&gt;&lt;a href="http://docs.python.org/library/2to3.html"&gt;2to3&lt;/a&gt;&lt;/code&gt; makes it worse).
&lt;/p&gt;
&lt;p&gt;This Python 3 silence was at last broken during the question and answer session which followed the final keynote on the final day of the conference. An audibly nervous member of the audience asks &lt;a href="http://www.python.org/psf"&gt;Python Software Foundation&lt;/a&gt; supremo &lt;a href="http://holdenweb.com"&gt;Steve Holden&lt;/a&gt; a question:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Audience member: A source of confusion is the Python 2 Python 3 thing. How are you going about getting people to move from Python 2 to Python 3?
&lt;/p&gt;
&lt;p&gt;Steve Holden: I&amp;#8217;m not trying to get people to move to Python 3. [Audience applauds].
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Steve Holden went on to round out this answer, saying that 2.6 is the recommended production version of Python. Anyone who took Python 3.0 into production, he said, would have been &amp;#8220;kicked in the teeth by the fact that the IO subsystem performed execrably slowly, it was really dreadful&amp;#8221; &amp;#8212; a fact the 3.0 release notes failed to mention, but which has been &lt;a href="http://docs.python.org/3.1/whatsnew/3.1.html#optimizations"&gt;fixed in Python 3.1&lt;/a&gt;. For teaching purposes, or for greenfield development which doesn&amp;#8217;t need to reuse other people&amp;#8217;s code, by all means try Python 3, he said. Python 3 is the future of Python. There&amp;#8217;s a migration strategy in place.
&lt;/p&gt;
&lt;p&gt;And what about the overhead on the core Python development team, who now have two versions to maintain? Well, Steve Holden said, there are tools to automate patching and merging, but yes, there&amp;#8217;s an overhead.
&lt;/p&gt;
&lt;p&gt;(To hear the question and full response, there&amp;#8217;s &lt;a href="http://blip.tv/file/2351630" title="The Python Software Foundation and Us, Steve Holden, Europython 2009"&gt;a video at blip.tv&lt;/a&gt;. Fast forward to 52 minutes and 40 seconds.)
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/antipep#toc4" name="tocpython-3-literature" id="tocpython-3-literature"&gt;Python 3 Literature&lt;/a&gt;&lt;/h3&gt;
&lt;div class="amazon"&gt;&lt;a href="http://www.amazon.com/Python-Essential-Reference-Developers-Library/dp/0672329786"&gt;&lt;img src="http://wordaligned.org/images/books/python-essential-reference4.png" alt="Python Essential Reference, 4th edition"/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class="amazon"&gt;&lt;a href="http://www.amazon.com/gp/product/1430224150?ie=UTF8&amp;amp;tag=diveintomark-20"&gt;&lt;img height="222px" src="http://ecx.images-amazon.com/images/I/51N9HK%2B7WGL._SL300_.jpg" alt="Dive into Python 3 cover"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;How have book authors reacted to Python 3? Mark Pilgrim has dived in with  aplomb. His introductory book, &lt;a href="http://www.diveintopython3.org"&gt;Dive into Python 3&lt;/a&gt;, uses Python 3 as Python 3 was intended. For example, you won&amp;#8217;t find &lt;a href="http://docs.python.org/py3k/library/stdtypes.html#old-string-formatting-operations"&gt;% characters&lt;/a&gt; used in string formatting; {up to date &lt;a href="http://www.python.org/dev/peps/pep-3101/" title="PEP 3101, Advanced String Formatting"&gt;braces&lt;/a&gt; are used exclusively}. It&amp;#8217;s an engaging, painstakingly-written book, and (bonus!) the online version is an object lesson in how to craft HTML.
&lt;/p&gt;
&lt;p&gt;David Beazley attacks the problem in a different way, but then his subject is different. His comprehensive &lt;a href="http://www.amazon.com/Python-Essential-Reference-Developers-Library/dp/0672329786"&gt;Python Essential Reference&lt;/a&gt; aims to cover the core language and its standard library in its entirety: think of it as the reference any serious Python programmer &lt;a href="http://www.dabeaz.com/blog/2009/08/essential-misconceptions.html"&gt;would like to have within reach&lt;/a&gt;. David Beazley&amp;#8217;s approach is to concentrate on the common subset of Python 2 and 3, omitting features of 2 which aren&amp;#8217;t in 3 and avoiding features of 3 which haven&amp;#8217;t been backported to 2. His book succeeds but it does raise some awkward questions. Will Pythonistas find themselves maintaining parallel code-bases, and end up twisting their code until it fits into the intersection of two flavours of the language?
&lt;/p&gt;
&lt;img src="http://chart.apis.google.com/chart?cht=v&amp;amp;chco=ffdd66,33ccff&amp;amp;chs=450x330&amp;amp;chd=t:100,90,100,70,100,70,70&amp;amp;chdl=Python+2|Python+3&amp;amp;chf=bg,s,EFEFEF&amp;amp;chdlp=l&amp;amp;chtt=Safe+Programming+Zone|Python+2+%e2%88%a9+Python+3&amp;amp;chts=333333,24" alt="Safe Python Programming zone"/&gt;

&lt;p&gt;Or will they simply avoid Python 3?
&lt;/p&gt;
&lt;p&gt;David Beazley eventually covers new Python 3 features in an appendix, by which time the strain has started to show:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Finally, even though Python 3.0 is described as the latest and greatest, it suffers from numerous performance and behavioral problems [&amp;#8230;] in the opinion of this author, Python 3.0 is really only suitable for experimental use by seasoned Python veterans.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/antipep#toc5" name="tocthe-cost-of-python-3" id="tocthe-cost-of-python-3"&gt;The Cost of Python 3&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;David Beazley may have ended up feeling like a Python 3 beta tester, but, as discussed at the start of this article, most Python users have a free choice. We can live a little longer with Python 2 &lt;a href="http://wiki.python.org/moin/PythonWarts"&gt;warts&lt;/a&gt; in exchange for a proven platform and an excellent set of supporting libraries. We can try and write to a language subset. We can use Python 2 and import much of the future. Or we can dive into Python 3.
&lt;/p&gt;
&lt;p&gt;The people who must find the language fork tough are the Python suppliers. Our choice, as consumers, means work for them: we&amp;#8217;ve mentioned the core Python team, who must surely spend more time patching and testing; think of Python library writers (such as the wizards behind Twisted).
&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s another important class of supplier: the people working on alternative Python implementations, the ones which work on &lt;a href="http://www.jython.org"&gt;Java&lt;/a&gt;, or &lt;a href="http://www.codeplex.com/IronPython"&gt;.Net&lt;/a&gt;, the ones which have no global interpreter lock, the ones which can run deeply recursive functions. Pythonistas are understandably excited about &lt;a href="http://code.google.com/p/unladen-swallow/"&gt;Unladen Swallow&lt;/a&gt;, a development branch of CPython 2.6. Just look at the project &lt;a href="http://code.google.com/p/unladen-swallow/wiki/ProjectPlan"&gt;goals&lt;/a&gt;!
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We want to make Python faster, but we also want to make it easy for large, well-established applications to switch to Unladen Swallow.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     Produce a version of Python at least 5x faster than CPython.
 &lt;/li&gt;

 &lt;li&gt;
     Python application performance should be stable.
 &lt;/li&gt;

 &lt;li&gt;
     Maintain source-level compatibility with CPython applications.
 &lt;/li&gt;

 &lt;li&gt;
     Maintain source-level compatibility with CPython extension modules.
 &lt;/li&gt;

 &lt;li&gt;
     We do not want to maintain a Python implementation forever; we view our work as a branch, not a fork. 
 &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;p&gt;In summary, if Unladen Swallow touches down safely, it will become CPython, and anyone using CPython will benefit from a high-level language capable of performing at native speeds.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;d like to highlight the final goal, the one about maintaining, branching and forking. Unladen Swallow is a branch taken from CPython 2.6&lt;a id="fn2link" href="http://wordaligned.org/articles/antipep#fn2"&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;. If it succeeds, much hard and unglamorous work will be needed to merge it to the latest CPython 2, and patch it across to CPython 3. Python implementers must pay a high price, in terms of increased workload, for the Python 2, Python 3 fork.
&lt;/p&gt;
&lt;p&gt;Could Python have evolved in a more linear way, by deprecating then removing features, while adding in new ones? I guess not, a mature language wouldn&amp;#8217;t dare break backwards compatibility. 
&lt;/p&gt;
&lt;p&gt;Would it?
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/antipep#toc6" name="tocevolution-of-python" id="tocevolution-of-python"&gt;Evolution of Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;My employers were right to characterise Python as a developing language. On the subject of incremental change, I wanted to highlight again the &lt;a href="http://wordaligned.org/articles/python-counters.html"&gt;evolution of the multiset in Python&lt;/a&gt;, from Python 1.4, released in 2001, through to Python 3.1, just 4 months old.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Evolution of the Multiset in Python&lt;/div&gt;

&lt;pre class="prettyprint"&gt;def multiset_14(xs):
    multiset = {}
    for x in xs:
        if multiset.has_key(x):
            multiset[x] = multiset[x] + 1
        else:
            multiset[x] = 1
    return multiset

def multiset_15(xs):
    multiset = {}        
    for x in xs:
        multiset[x] = multiset.get(x, 0) + 1
    return multiset

import collections

def multiset_25(xs):
    multiset = collections.defaultdict(int)
    for x in xs:
        multiset[x] += 1
    return multiset

def multiset_31(xs):
    return collections.Counter(xs)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Lovely!
&lt;/p&gt;
&lt;p&gt;&lt;span style="font-size:8px"&gt;&lt;code&gt;multiset_14()&lt;/code&gt; won&amp;#8217;t work in Python 3, and &lt;code&gt;multiset_31()&lt;/code&gt; won&amp;#8217;t work in Python 2 (not yet, anyway).&lt;/span&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/antipep#toc7" name="tocaccepting-python-3" id="tocaccepting-python-3"&gt;Accepting Python 3&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;The main goal of the Python development community at this point should be to get widespread acceptance of Python 3000. &amp;#8212; Guido van Rossum, &lt;a href="http://mail.python.org/pipermail/python-ideas/2009-October/006305.html"&gt;2009-10-21&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Unlike Steve Holden, Guido van Rossum &lt;strong&gt;is&lt;/strong&gt; trying to get people to move to Python 3, or at least to accept it. &lt;a href="http://mail.python.org/pipermail/python-ideas/2009-October/006305.html"&gt;Here&amp;#8217;s how&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I propose a moratorium on language changes. This would be a period of several years during which no changes to Python&amp;#8217;s grammar or language semantics will be accepted. The reason is that frequent changes to the language cause pain for implementers of alternate implementations (Jython, IronPython, PyPy, and others probably already in the wings) at little or no benefit to the average user (who won&amp;#8217;t see the changes for years to come and might not be in a position to upgrade to the latest version for years after).
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Wow!
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m not close enough to Python development to know exactly what&amp;#8217;s involved here, but a scan of the &lt;a href="http://mail.python.org/pipermail/python-ideas/2009-October/thread.html#6305"&gt;email thread&lt;/a&gt; suggests this proposal has been widely accepted. I think it&amp;#8217;s clear from the rest of this article that I sympathise with the motivation behind it. Yet I can&amp;#8217;t help feeling uneasy about putting Python on ice. Yes, there have been changes to the language grammar over the past fifteen years. I wouldn&amp;#8217;t say they&amp;#8217;ve been frequent, and there aren&amp;#8217;t many I&amp;#8217;d want to do without, even if I only get to use them (in production) a year or two after they&amp;#8217;ve been released. Yes, these changes cause pain to implementers&lt;a id="fn3link" href="http://wordaligned.org/articles/antipep#fn3"&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;, but that&amp;#8217;s not the whole story. Who said implementing a language would be easy? Perhaps much of the pain comes from implementing the changes twice, once for 2 and once for 3.
&lt;/p&gt;
&lt;p&gt;Soon there&amp;#8217;ll be a &lt;a href="http://www.python.org/dev/peps" title="Python Enhancement Proposals"&gt;PEP&lt;/a&gt; stating more formally what exactly a moratorium on language changes will mean. That is,
&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;P&lt;/strong&gt;ython &lt;strong&gt;E&lt;/strong&gt;nhancement &lt;strong&gt;P&lt;/strong&gt;roposal which &lt;strong&gt;P&lt;/strong&gt;roposes: Stop &lt;strong&gt;E&lt;/strong&gt;nhancing &lt;strong&gt;P&lt;/strong&gt;ython!
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/antipep#fn1link"&gt;[1]&lt;/a&gt; I wonder if anyone can guess why this code fails, just by looking at it? As a hint, highlight the rest of this paragraph. &lt;span style="color:white"&gt;Some Python 2 codecs are byte rather than text oriented, and Python 3 prohibits this kind of confusion.&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a id="fn2" href="http://wordaligned.org/articles/antipep#fn2link"&gt;[2]&lt;/a&gt; More details of the Unladen Swallow branch approach. 
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In order to achieve our combination of performance and compatibility goals, we opt to modify CPython, rather than start our own implementation from scratch. In particular, we opt to start working on CPython 2.6.1: Python 2.6 nestles nicely between 2.4/2.5 (which most interesting applications are using) and 3.x (which is the eventual future). Starting from a CPython release allows us to avoid reimplementing a wealth of built-in functions, objects and standard library modules, and allows us to reuse the existing, well-used CPython C extension API. Starting from a 2.x CPython release allows us to more easily migrate existing applications; if we were to start with 3.x, and ask large application maintainers to first port their application, we feel this would be a non-starter for our intended audience. 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;a id="fn3" href="http://wordaligned.org/articles/antipep#fn3link"&gt;[3]&lt;/a&gt;: C++ compiler writers, gear up for C++0x!
&lt;/p&gt;</description>
<dc:date>2009-10-28</dc:date>
<guid>http://wordaligned.org/articles/antipep</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/antipep</link>
<category>Python</category>
</item>

<item>
<title>A useful octal escape sequence</title>
<description>&lt;p&gt;&lt;a href="http://wordaligned.org/articles/integer-literal-values.html"&gt;Previously&lt;/a&gt; I grumbled about &lt;a href="http://wordaligned.org/articles/octal-literals.html"&gt;octal integer literals&lt;/a&gt;, suggesting:
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     they aren&amp;#8217;t much use, not when you&amp;#8217;ve got hexademical and binary literals.
 &lt;/li&gt;

 &lt;li&gt;
     they&amp;#8217;re risky. As Doug Napoleone noted in a &lt;a href="http://wordaligned.org/articles/integer-literal-values.html#comment-14394465"&gt;comment&lt;/a&gt;, &lt;code&gt;011&lt;/code&gt; is all too easily read as eleven rather than nine.
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python 3 attempts to patch the readability issue: octal nine must be written as &lt;code&gt;0o11&lt;/code&gt; or &lt;code&gt;0O11&lt;/code&gt;. Choose your fonts with care, &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; look similar!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; 0o11, 0O11
(9, 9)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Octal numbers can also appear in escape sequences embedded in &lt;a href="http://docs.python.org/py3k/reference/lexical_analysis.html#string-and-bytes-literals"&gt;string and bytes literals&lt;/a&gt;. The syntax hasn&amp;#8217;t changed for Python 3 and the rules are as in C: the escape sequence &lt;code&gt;\OOO&lt;/code&gt; embeds a character/byte with octal value &lt;code&gt;OOO&lt;/code&gt;. Up to three octal digits are allowed in an octal escape sequence.
&lt;/p&gt;
&lt;p&gt;&lt;img src="http://wordaligned.org/images/buttons/octopus-small.jpg" alt="Smart mollusc"/&gt;
   &lt;img src="http://wordaligned.org/images/buttons/octopus-small.jpg" alt="Smart mollusc"/&gt;
   &lt;img src="http://wordaligned.org/images/buttons/octopus-small.jpg" alt="Smart mollusc"/&gt;
&lt;/p&gt;
&lt;p&gt;Like  octal integers, these octal escape sequences may appear to be of limited use &amp;#8212; a syntactic oddity rarely seen in the wild &amp;#8212; but in fact there&amp;#8217;s one particular use case which is so common we don&amp;#8217;t even notice it.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;char const terminator = '\0';

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2009-08-09</dc:date>
<guid>http://wordaligned.org/articles/a-useful-octal-escape-sequence</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/a-useful-octal-escape-sequence</link>
<category>Python</category>
</item>

<item>
<title>Converting integer literals in C++ and Python</title>
<description>&lt;p&gt;An integral literal in a C program can be decimal, hexadecimal or octal.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;int percent = 110;
unsigned flags = 0x80;
unsigned agent = 007;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This snippet would be equivalent to (e.g.):
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;int percent = 0156;
unsigned flags = 128;
unsigned agent = 0x7;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So programmers can choose the best of these options when including numbers in their code.
&lt;/p&gt;
&lt;p&gt;Python adopted this same C syntax, but has recently gone on to extend and modify it. Some Python 2.6 numbers:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;Python 2.6
&amp;gt;&amp;gt;&amp;gt; 0x80, 110, 007, 0O7, 0o7, 0b10000000
(128, 110, 7, 7, 7, 128)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I&amp;#8217;m pleased to see support for binary literals, which are useful for (e.g.) bitmasks. I&amp;#8217;ve never really seen the point of &lt;a href="http://wordaligned.org/articles/octal-literals.html"&gt;octals&lt;/a&gt;; nonetheless, they&amp;#8217;ve been enhanced for Python 3. Python 2.6 backports the new improved &lt;a href="http://www.python.org/dev/peps/pep-3127"&gt;octal literal syntax&lt;/a&gt; whilst retaining support for classic C-style octals. Python 3 drops C-style octals.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;Python 3.1
&amp;gt;&amp;gt;&amp;gt; 007
  File "&amp;lt;stdin&amp;gt;", line 1
    007
      ^
SyntaxError: invalid token
&amp;gt;&amp;gt;&amp;gt; 0O7
7

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now consider the compiler/interpreter writer&amp;#8217;s problem. Clearly it must be possible to take a string representing an integer literal and work out what number it represents. At a first glance, the &lt;a href="http://docs.python.org/library/functions.html#int"&gt;int()&lt;/a&gt; builtin isn&amp;#8217;t quite smart enough to do the job without us supplying an explicit base for the conversion:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; int('0xff')
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
ValueError: invalid literal for int() with base 10: '0xff'
&amp;gt;&amp;gt;&amp;gt; int('0xff', 16)
255

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We might consider reading any prefix from the literal and dispatching the string to an appropriate handler. Something like this:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def integer_literal_value(s):
    if s.startswith('0x'):
        return int(s, 16)
    if s.startswith('0b'):
        return int(s, 2)
    ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Yuck! Surely there&amp;#8217;s an easier way to do something this fundamental? Well, there&amp;#8217;s always &lt;a href="http://docs.python.org/library/functions.html#eval"&gt;eval()&lt;/a&gt;, which turns the interpreter on itself.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; def integer_literal_value(s): return eval(s)
... 
&amp;gt;&amp;gt;&amp;gt; v = integer_literal_value
&amp;gt;&amp;gt;&amp;gt; v('0x80'), v('0o7'), v('0b1010101'), v('42')
(128, 7, 85, 42)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We should have looked more carefully at the &lt;a href="http://docs.python.org/library/functions.html#int"&gt;int()&lt;/a&gt; documentation:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;int([x[, radix]])&lt;/strong&gt; &amp;#8230; The &lt;em&gt;radix&lt;/em&gt; parameter gives the base for the conversion (which is 10 by default) and may be any integer in the range [2, 36], or zero. If &lt;em&gt;radix&lt;/em&gt; is zero, the proper &lt;em&gt;radix&lt;/em&gt; is determined based on the contents of string; the interpretation is the same as for integer literals. 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Perfect!
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from functools import partial
&amp;gt;&amp;gt;&amp;gt; integer_literal_value = partial(int, base=0)
&amp;gt;&amp;gt;&amp;gt; v = integer_literal_value
&amp;gt;&amp;gt;&amp;gt; v('0x80'), v('0o7'), v('0b1010101'), v('42')
(128, 7, 85, 42)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Notice, by the way, that &lt;em&gt;radix&lt;/em&gt; is used in the online documentation but the actual argument name is &lt;em&gt;base&lt;/em&gt;. I&amp;#8217;ll confess that before I wrote this note I hadn&amp;#8217;t spotted this use of zero as a special value for string&amp;rarr;integer conversions even though it&amp;#8217;s been available since Python 2.1)
&lt;/p&gt;
&lt;p&gt;C++ also offers a way to convert integer literals into the numbers they represent, but it&amp;#8217;s not very well known. As is usual for format conversions, we use streams &amp;#8212; stringstreams typically, but here I show an example using standard input and output. The trick is to disable any numeric formatting of the input stream.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;integer_literal_value.cpp&lt;/div&gt;

&lt;pre class="prettyprint"&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    int x;
    std::cin.unsetf(std::ios::basefield);
    while (std::cin &amp;gt;&amp;gt; x)
    {
        std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; '\n';
    }
    return std::cin.eof() ? 0 : 1;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It &lt;a href="http://www.cplusplus.com/reference/iostream/ios_base/fmtflags"&gt;works by magic&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ g++ integer_literal_value.cpp -o integer_literal_value
$ echo 007 0x80 110 | ./integer_literal_value
7
128
110

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2009-08-06</dc:date>
<guid>http://wordaligned.org/articles/integer-literal-values</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/integer-literal-values</link>
<category>Python</category>
</item>

<item>
<title>Inner, Outer, Shake it all abouter</title>
<description>&lt;p&gt;C++ programmers enjoy three levels of access control: &lt;a href="http://www.parashift.com/c++-faq-lite/basics-of-inheritance.html#faq-19.5"&gt;private, protected and public&lt;/a&gt;. Some programmers use protected instead of private just in case someone might want to derive from their class some day. Others keep everything as private as possible, hiding nested classes in anonymous namespaces; these inner classes never seem to work quite the way you&amp;#8217;d want, but if you get tangled up a &lt;a href="http://www.parashift.com/c++-faq-lite/friends.html"&gt;friend&lt;/a&gt; can cut through the knots!
&lt;/p&gt;
&lt;p&gt;Python is less sophisticated. Prefix class members with a double underscore and &lt;a href="http://docs.python.org/tutorial/classes.html#private-variables"&gt;their names are disguised&lt;/a&gt; to the world outside. Prefix module members with a single underscore to indicate they won&amp;#8217;t be exported from that module. Many Python programmers use single underscore prefix in classes too (no mangling but better looking).
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://accu.org"&gt;&lt;img style="float:right" src="http://accu.org/content/images/buttonl_120x60.gif" width="120px" alt="ACCU Button" height="60px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Once you&amp;#8217;ve used Python for a while you may well question the benefits of the C++ model. Recently a C++ question came up on the &lt;a href="http://accu.org/index.php/mailinglists"&gt;accu-general&lt;/a&gt; mailing list. It involved nested classes, &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; and code which refused to compile. You&amp;#8217;ll have to trawl through the list archives if you want the exact question: I didn&amp;#8217;t give it much attention since it seemed an example of the kind of struggle with the language which causes me to throw in the towel. I would like to quote from one of the answers though.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Surely your issue is that f() is a friend of Inner only. f() is &lt;b&gt;not&lt;/b&gt; a friend of Outer. Inner is private to Outer. Therefore in the global scope, outside Outer, f() cannot access Inner via Outer::Inner, as that is private.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Wow, some &lt;a href="http://yosefk.com/c++fqa/class.html#fqa-7.7" title="#define private public from the C++ FQA"&gt;brain twister&lt;/a&gt;!
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.kleinbottle.com"&gt;&lt;img src="http://www.kleinbottle.com/images/giantKleinbotandCliff2.jpg" alt="Giant Klein bottle and Cliff Stoll" width="240px" height="461px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Time to get back to basics.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Encapsulation is about allocating responsibility and easing utility rather than protecting data, which is a side effect. &amp;#8212; &lt;a href="http://twitter.com/KevlinHenney/status/2684963420"&gt;@KevlinHenney&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;My thanks to &lt;a href="http://libjmmcg.sourceforge.net"&gt;Jason McGuiness&lt;/a&gt; for allowing me to quote from his expert answer to a tricky C++ question. The photo shows Cliff Stoll holding the world&amp;#8217;s largest glass klein bottle, which was produced by the company he owns, operates and mismanages, &lt;a href="http://www.kleinbottle.com"&gt;Acme Klein Bottles&lt;/a&gt;. Klein bottles get a mention here because they don&amp;#8217;t have an outside or an inside, they just have a side. You can solve every computing problem with an extra dimension, except the problem of too many dimensions.
&lt;/p&gt;</description>
<dc:date>2009-07-29</dc:date>
<guid>http://wordaligned.org/articles/inner-outer-shake-it-all-abouter</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/inner-outer-shake-it-all-abouter</link>
<category>Python</category>
</item>

<item>
<title>Blackmail made easy using Python counters</title>
<description>&lt;div class="toc"&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocthe-obsessive-blackmailer" name="toc0" id="toc0"&gt;The Obsessive Blackmailer&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocmodeling-the-problem" name="toc1" id="toc1"&gt;Modeling the Problem&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocthe-evolution-of-multisets-in-python" name="toc2" id="toc2"&gt;The evolution of multisets in Python&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocwait-theres-more" name="toc3" id="toc3"&gt;Wait, there&amp;#8217;s more!&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocback-to-blackmail" name="toc4" id="toc4"&gt;Back to Blackmail&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocgeneric-code" name="toc5" id="toc5"&gt;Generic Code&lt;/a&gt;
 &lt;/li&gt;

 &lt;li&gt;&lt;a href="http://wordaligned.org/articles/python-counters#tocend-of-message" name="toc6" id="toc6"&gt;End of Message&lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc0" name="tocthe-obsessive-blackmailer" id="tocthe-obsessive-blackmailer"&gt;The Obsessive Blackmailer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;An obsessive blackmailer writes anonymous messages by by cut-and-pasting letters from newspapers. Being obsessive, the blackmailer only writes messages which can be composed entirely from a single newspaper.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3754867981/" title="word aligned by Thomas Guest, on Flickr"&gt;&lt;img src="http://farm3.static.flickr.com/2567/3754867981_a752d15f74_o.png" width="480" height="309" alt="word aligned" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Devise an algorithm which determines whether a given message can be written using a given newspaper.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc1" name="tocmodeling-the-problem" id="tocmodeling-the-problem"&gt;Modeling the Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This is a nice little problem but I&amp;#8217;m about to spoil it since I&amp;#8217;m using it here as a study in Python&amp;#8217;s evolution. So if you&amp;#8217;d like to try it yourself, look away now.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;We can represent both inputs to the algorithm as sequences of characters: a message string, length M, and a newspaper string, length N. We &lt;em&gt;could&lt;/em&gt; process the message string one character at a time, at each step scanning through the newspaper and noting the first occurrence of that character we haven&amp;#8217;t used before; but this is inefficient since we potentially read the whole paper M times.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s better to think of this problem in terms of multisets, sometimes known as bags. A multiset is a set which can have repeated elements. Our blackmailer can proceed if the multiset of letters used in the message is contained entirely within the multiset of letters used in the newspaper.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc2" name="tocthe-evolution-of-multisets-in-python" id="tocthe-evolution-of-multisets-in-python"&gt;The evolution of multisets in Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A dictionary provides a compact and efficient way to represent a multiset in Python: each dictionary key represents an item in the multiset, and the value associated with that key is the number of times the key appears in the multiset. Python dictionaries are implemented as hashed arrays, meaning that member insertion and access take constant time, on average.
&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s not hard to create such a multiset from a sequence but it&amp;#8217;s interesting to see how advances in the Python language have simplified the code. 
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python.org/doc/1.4/lib/node13.html#SECTION00316000000000000000"&gt;&lt;img src="http://python.org/doc/1.4/lib/img7.gif" height="181px" width="469px"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The complete documentation for &lt;a href="http://python.org/doc/1.4/"&gt;Python 1.4&lt;/a&gt;, released in 1996, is still available on the Python website. In version 1.4 you could write:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_14(xs):
    multiset = {}
    for x in xs:
        if multiset.has_key(x):
            multiset[x] = multiset[x] + 1
        else:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code works unchanged in the current Python release, 2.6 (though note &lt;code&gt;dict.has_key()&lt;/code&gt; doesn&amp;#8217;t exist in Python 3.*). Alternatively, you might catch the &lt;code&gt;KeyError&lt;/code&gt; raised when trying to access the dict with an invalid key:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_14(xs):
    multiset = {}        
    for x in xs:
        try:
            multiset[x] = multiset[x] + 1
        except KeyError:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Python 1.5 introduces an exception-free dictionary access method, &lt;code&gt;dict.get()&lt;/code&gt;, which returns a user supplied default (defaulting to &lt;code&gt;None&lt;/code&gt;) for missing keys.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_15(xs):
    multiset = {}        
    for x in xs:
        multiset[x] = multiset.get(x, 0) + 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s certainly shorter, a little cleaner maybe, but perhaps it takes more effort for readers to see what exactly is going on.
&lt;/p&gt;
&lt;p&gt;At Python 2.2, &lt;code&gt;x in multiset&lt;/code&gt; improves on the equivalent &lt;code&gt;multiset.has_key(x)&lt;/code&gt; and we can use augmented arithmetic operators (&lt;code&gt;+=, -=, *=, /=, %=, **=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;amp;=, =, |=&lt;/code&gt;), allowing:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def multiset_22(xs):
    multiset = {}
    for x in xs:
        if x in multiset:
            multiset[x] += 1
        else:
            multiset[x] = 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I think I prefer the &lt;code&gt;dict.get()&lt;/code&gt; version, though.
&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;collections&lt;/code&gt; module makes its first appearance in Python 2.4 offering a &lt;code&gt;deque&lt;/code&gt; and a promise of more high performance container types to come. Python 2.5 makes good on this promise, adding &lt;code&gt;defaultdict&lt;/code&gt; to the module. A &lt;code&gt;defaultdict&lt;/code&gt; is a specialised dictionary which calls a client supplied factory function for missing keys. Setting this factory function to &lt;code&gt;int&lt;/code&gt; turns the &lt;code&gt;defaultdict&lt;/code&gt; into a multiset. No need for &lt;code&gt;dict.get()&lt;/code&gt; any more.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from collections import defaultdict

def multiset_25(xs):
    multiset = defaultdict(int)
    for x in xs:
        multiset[x] += 1
    return multiset

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc3" name="tocwait-theres-more" id="tocwait-theres-more"&gt;Wait, there&amp;#8217;s more!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The final improvement is available in Python 3.1 right now (or in Python 2.7, coming soon), courtesy once again of the collections module. &lt;a href="http://docs.python.org/dev/library/collections.html#collections.Counter"&gt;Collections.Counter&lt;/a&gt; is exactly what we&amp;#8217;ve been waiting for.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from collections import Counter

def multiset_31(xs):
    return Counter(xs)

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc4" name="tocback-to-blackmail" id="tocback-to-blackmail"&gt;Back to Blackmail&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So our blackmailer should first generate a multiset representation of the letters in the message. Then it&amp;#8217;s a matter of iterating through the newspaper and reducing the multiset each time a letter matches up. We keep a tally of the number of letters we still need to match, and stop when this tally is zero or when we get to the end of the newspaper. Here&amp;#8217;s a sketch of an implementation.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def blackmailable(message, newspaper):
    """Return True if newspaper can be used to write the blackmail 
    message, False otherwise.
    """
    m = len(message)
    if m == 0:
        return True
    counts = multiset(message)
    for ch in newspaper:
        if counts[ch] &amp;gt; 0:
            counts[ch] -= 1
            m -= 1
            if m == 0:
                return True
    return False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This code assumes the multiset is represented as a &lt;code&gt;Counter&lt;/code&gt; or a &lt;code&gt;defaultdict&lt;/code&gt;, since it depends on &lt;code&gt;counts[ch]&lt;/code&gt; returning 0 for any character not in the message. If we&amp;#8217;d used a plain dict, we&amp;#8217;d need to employ &lt;code&gt;dict.get(ch, 0)&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m not entirely happy with the code shown. It&amp;#8217;s what I first came up with. Here&amp;#8217;s an alternative, which I also find a bit clunky. I&amp;#8217;d welcome any improvements. It&amp;#8217;s also worth noting that the algorithm locates the matching characters in the newspaper, so we might want to cache some indices for later use.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def blackmailable(message, newspaper):
    """Return True if newspaper can be used to write the blackmail 
    message, False otherwise.
    """
    counts = multiset(message)
    m = len(message)
    n = len(newspaper)
    i = 0
    while m != 0 and i != n:
        ch = newspaper[i]
        if counts[ch] &amp;gt; 0:
            counts[ch] -= 1
            m -= 1
        i += 1
    return m == 0

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We can avoid the ugly code by persuading the obssessive blackmailer to generate and maintain multiset representations of the entire newspaper library. Then &lt;code&gt;blackmailable()&lt;/code&gt; can be implemented as multiset containment, something which the &lt;code&gt;Counter&lt;/code&gt; class handles nicely using the subtraction operator. Note here that multiset subtraction never results in any negative counts, even though a &lt;code&gt;Counter&lt;/code&gt; instance could itself have negative counts.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Counter
&amp;gt;&amp;gt;&amp;gt; missing_letters = Counter(message) - Counter(newspaper)
&amp;gt;&amp;gt;&amp;gt; blackmailable = len(missing_letters) == 0

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Alternatively:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; blackmailable = not missing_letters

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc5" name="tocgeneric-code" id="tocgeneric-code"&gt;Generic Code&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Suppose the blackmailer prefers to compose a message from words, rather than letters? (For an example, see the threat to stay away from Grimpen Moor delivered to Sir Henry Baskerville discussed later in this article.) The code works as is &amp;#8212; just pass in message and newspaper as word sequences, rather than character sequences. Anything we can hash can be counted.
&lt;/p&gt;

&lt;h3&gt;&lt;a href="http://wordaligned.org/articles/python-counters#toc6" name="tocend-of-message" id="tocend-of-message"&gt;End of Message&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In the age of the interweb anonymous cowardice is far easier and blackmailers don&amp;#8217;t need to resort to manual cut and paste techniques unless they&amp;#8217;re after a retro threatening effect.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Never_Mind_the_Bollocks,_Here's_the_Sex_Pistols"&gt;&lt;img src="http://wordaligned.org/images/never-mind-the-bollocks.jpg" alt="Never Mind the Bollocks"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;img style="float:right" alt="Sherlock Holmes" src="http://wordaligned.org/images/sherlock-holmes.png"/&gt;

&lt;p&gt;What&amp;#8217;s more, a detective can figure out plenty from these messages: so when Sir Henry Baskerville receives a threatening letter during his stay at the Northumberland Hotel, he shows it promptly to Sherlock Holmes:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Across the middle of it a single sentence had been formed by the expedient of pasting printed words upon it. It ran: &amp;#8220;As you value your life or your reason keep away from the moor.&amp;#8221; The word &amp;#8220;moor&amp;#8221; only was printed in ink.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;In a virtuso display of deductive reasoning, Holmes shows the author of the message was in a hurry, afraid of being interrupted, and working in a hotel room using nail-scissors. (He also deduces something else, which he does not reveal at the time.) Identifying the source of the words to be yesterday&amp;#8217;s Times leader is elementary.
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The detection of types is one of the most elementary branches of knowledge to the special expert in crime, though I confess that once when I was very young I confused the Leeds Mercury with the Western Morning News. But a Times leader is entirely distinctive, and these words could have been taken from nothing else.
&lt;/p&gt;
&lt;p&gt;&amp;#8212; Sherlock Holmes, &lt;a href="http://www.gutenberg.org/dirs/etext02/bskrv11a.txt"&gt;The Hound of the Baskervilles&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Can anyone identify the newspaper I used to create the image at the start of this article?
&lt;/p&gt;
&lt;p&gt;&lt;hr /&gt;
   My thanks to jay for a &lt;a href="http://wordaligned.org/articles/python-counters#comment-13418772"&gt;correction&lt;/a&gt; to the original version of this article.
&lt;/p&gt;</description>
<dc:date>2009-07-27</dc:date>
<guid>http://wordaligned.org/articles/python-counters</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/python-counters</link>
<category>Python</category>
</item>

<item>
<title>Undogfooding</title>
<description>&lt;p&gt;David Jones perfectly &lt;a href="http://drj11.wordpress.com/2009/07/04/tony-hoare-man-of-science/"&gt;captures the look and feel&lt;/a&gt; of Sir Tony Hoare&amp;#8217;s presentation at &lt;a href="http://www.europython.eu"&gt;Europython 2009&lt;/a&gt;
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Tony Hoare is clearly old skool. His slides had the calm and aged patina of the &lt;a href="http://en.wikipedia.org/wiki/Overhead_projector"&gt;OHP&lt;/a&gt; era, and I thought they were all the better for that. If you have a message, then that message can be conveyed without all the flash and shine that PowerPoint tempts you with (although, being a Microsoft man, of course his slides &lt;em&gt;were&lt;/em&gt; in PowerPoint). 
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;a href="http://docs.python.org/library/turtle.html#module-turtle"&gt;&lt;img src="http://wordaligned.org/images/my-1st-turtle.png" alt="My first turtle sketch"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Note the parenthetical comment: Tony Hoare works for Microsoft and he uses Microsoft software, an activity developers refer to as &lt;a href="http://catb.org/jargon/html/D/dogfood.html"&gt;&amp;#8220;eating your own dogfood&amp;#8221;&lt;/a&gt;. Also eating dogfood at Europython, &lt;a href="http://www.europython.eu/talks/speakers/index.html#lingl_gregor"&gt;Gregor Lingl&lt;/a&gt; employed his very own &lt;a href="http://docs.python.org/library/turtle.html#module-turtle"&gt;turtle&lt;/a&gt; to guide the audience through a nifty presentation belying the reptile&amp;#8217;s slow-and-steady reputation. I&amp;#8217;ve always enjoyed sketching code using the Python interpreter, and sketching pictures with a turtle feels very pythonic.
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;My first turtle sketch&lt;/div&gt;

&lt;pre class="prettyprint"&gt;Python 3.1
&amp;gt;&amp;gt;&amp;gt; from turtle import *
&amp;gt;&amp;gt;&amp;gt; shape('turtle')
&amp;gt;&amp;gt;&amp;gt; circle(100)
&amp;gt;&amp;gt;&amp;gt; fillcolour('red')
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
NameError: name 'fillcolour' is not defined
&amp;gt;&amp;gt;&amp;gt; fillcolor('red')
&amp;gt;&amp;gt;&amp;gt; begin_fill(); circle(100); end_fill()
&amp;gt;&amp;gt;&amp;gt; def grey(pc): c = pc/100; fillcolor(c, c, c)
... 
&amp;gt;&amp;gt;&amp;gt; clear()
&amp;gt;&amp;gt;&amp;gt; def doit(r): begin_fill(); grey(r); circle(r); end_fill()
... 
&amp;gt;&amp;gt;&amp;gt; for r in range(100): doit(r)
... 
^C^C
Traceback (most recent call last):
...
&amp;gt;&amp;gt;&amp;gt; clear()
&amp;gt;&amp;gt;&amp;gt; for r in range(100, 0, -5): doit(r)
...
&amp;gt;&amp;gt;&amp;gt; fillcolor('white')
&amp;gt;&amp;gt;&amp;gt; forward(150)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Gregor Lingl&amp;#8217;s session at Europython wasn&amp;#8217;t the only one delivered using software developed by the presenter. What would be the opposite of eating your own dogfood, I wondered? Abusing someone else&amp;#8217;s software, perhaps.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;blockquote&gt;&lt;p&gt;After one too many bad presentations at a meeting in January 2000, I decided to see if I could do something about it. &amp;#8212; &lt;a href="http://norvig.com/Gettysburg/making.html" title="The Making of the Gettysburg PowerPoint Presentation"&gt;Peter Norvig&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;I&amp;#8217;m fairly sure Peter Norvig had no part in PowerPoint&amp;#8217;s development. In a &lt;a href="http://norvig.com/Gettysburg"&gt;hilarious satire&lt;/a&gt; he skewers the popular presentation tool with its own Autocontent Wizard.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://norvig.com/Gettysburg/index.htm"&gt;&lt;img src="http://norvig.com/Gettysburg/img001.gif" width="500px" height="375px" alt="Gettysburg PPT, slide 1"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Back on the subject of overhead projectors, I saw one put to good use by another eminent old-skooler, Donald Knuth, at the recent &lt;a href="http://www.dcs.warwick.ac.uk/bshm/meetings/Fiction.html"&gt;Mathematics and Fiction&lt;/a&gt; workshop in Oxford. Asked by passport control at London Heathrow if he&amp;#8217;d be visiting Oxford on a business trip or a pleasure trip, Knuth had answered: no, he&amp;#8217;d come on a ego trip.
&lt;/p&gt;
&lt;p&gt;Knuth was in Oxford to talk to his fans about about &lt;a href="http://www-cs-faculty.stanford.edu/~knuth/sn.html"&gt;Surreal Numbers&lt;/a&gt;, a       book he wrote in just a couple of weeks in 1973 while taking a break from working on &lt;a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming"&gt;The Art of Computer Programming&lt;/a&gt; in a hotel in Oslo, and which may well be the only example of a mathematical &lt;a href="http://en.wikipedia.org/wiki/Surreal_numbers"&gt;theory&lt;/a&gt; first published in fictional form.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www-cs-faculty.stanford.edu/~knuth/sn.html"&gt;&lt;img src="http://wordaligned.org/images/books/surreal-numbers.jpg" width="240px" height="240px" alt="Surreal Numbers book cover" style="float:right;"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;For the workshop Knuth had gone back to his files and found his working notes, the original hotel brochure, photos, hand-written reviews by P&amp;oacute;lya and others, though he couldn&amp;#8217;t locate the paper napkin on which &lt;a href="http://en.wikipedia.org/wiki/John_Horton_Conway"&gt;John Horton Conway&lt;/a&gt; had sketched the axioms underpinning the number system a few months before&lt;a id="fn1link" href="http://wordaligned.org/articles/undogfooding#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt; &amp;#8212; Knuth had copied this source material onto acetates which he then sorted and shuffled on the OHP according to the direction his reminiscences and questions from the audience took him.
&lt;/p&gt;
&lt;p&gt;Unlike Tony Hoare, Donald Knuth wasn&amp;#8217;t making a formal presentation, but I was struck by some advantages offered by the OHP. For one, the process of getting slides displayed seemed foolproof &amp;#8212; at Europython we had the usual catalogue of computer/screen interface glitches (unwanted dialog boxes popping up, batteries dying, screensavers kicking in, missing Mac display dongles, delays while rebooting Ubuntu, alignment issues). The OHP also facilitated a dynamic presentation style: Knuth accessed his slides at random, composing screens from more than one slide on the fly, and pointing to areas of interest directly using a finger. He didn&amp;#8217;t modify his slides during the session by writing on them, but that would also have been possible.
&lt;/p&gt;
&lt;p&gt;In a supreme example of dogfood consumption, a couple of years after publishing Surreal Numbers Knuth took a rather longer break from TAOCP to work on &lt;a href="http://en.wikipedia.org/wiki/TeX"&gt;TeX&lt;/a&gt;, a typesetting system whose results match the beauty of his writing.
&lt;/p&gt;
&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&amp;#8230; You get surreal numbers by playing games. I used to feel guilty in Cambridge that I spent all day playing games, while I was supposed to be doing mathematics. Then, when I discovered surreal numbers, I realized that playing games IS mathematics. &amp;#8212; &lt;a href="http://www.gap-system.org/~history/Quotations/Conway.html"&gt;John Horton Conway&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/undogfooding#fn1link"&gt;[1]&lt;/a&gt; In fact, he&amp;#8217;d lost the napkin before his stay in the hotel in Oslo, which explains the difference between the axioms used in Surreal Numbers and the ones originally suggested by John Horton Conway.
&lt;/p&gt;</description>
<dc:date>2009-07-08</dc:date>
<guid>http://wordaligned.org/articles/undogfooding</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/undogfooding</link>
<category>Python</category>
</item>

<item>
<title>Tony Hoare&#8217;s vision, car crashes, and Alan Turing</title>
<description>&lt;p&gt;&lt;a href="http://www.europython.eu"&gt;&lt;img src="http://www.europython.eu/images/europython_logo.png" alt="Europython Logo"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Yesterday afternoon, at &lt;a href="http://www.europython.eu"&gt;Europython 2009&lt;/a&gt;, David Jones addressed the subject &lt;a href="http://www.europython.eu/talks/talk_abstracts/index.html#talk21"&gt;&amp;#8220;What sucks about Python?&amp;#8221;&lt;/a&gt; Despite this provocative title, David Jones had lots of good things to say about Python, and the two topics which really roused the audience (the global interpreter lock and the over-crowded Python packaging space) had more to do with the Python-the-platform than Python-the-language. He also failed to mention the thing I miss most when working with Python: via Peter Norvig&amp;#8217;s &lt;a href="http://norvig.com/python-iaq.html"&gt;Python IAQ&lt;/a&gt;, quoting Bjarne Stroustrup:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;#8220;If I were to design a language from scratch, I would follow the Algol68 path and make every statement and declaration an expression that yields a value.&amp;#8221;
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Of course what &lt;strong&gt;really&lt;/strong&gt; matters to an engineer is Python-the-platform rather than Python-the-language. Python famously comes with batteries included, and, stretching the metaphor, it also excels at integrating with the other batteries used in modern software applications. The packaging confusion is a side-effect of Python-the-platform&amp;#8217;s success. More on over-stretched batteries later &amp;#8230;
&lt;/p&gt;
&lt;p&gt;The day had started with &lt;a href="http://www.mindviewinc.com"&gt;Bruce Eckel&lt;/a&gt;&amp;#8217;s keynote on Software Archeology. Bruce Eckel is a relaxed and engaging speaker but I found his presentation rather flimsy. Its substance could (and did!) fit on to a couple of David Jones&amp;#8217; slides and the remainder dwelt a little too long on Bruce Eckel, his Java and C++ books, blogs, and &lt;a href="http://www.mindviewinc.com"&gt;www.mindviewinc.com&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;During the rest of the day, I had a choice of 4 or 5 different presentations at any one time, generally on the subject of Python modules or frameworks. The common theme I took away is that &lt;strong&gt;people turn to Python to get things done&lt;/strong&gt;, and they&amp;#8217;re reluctant to turn back. As the afternoon drew on everyone regathered in the Adrian Boult Hall to listen to a brilliant series of lightning talks which developed on this same theme. We also heard a wonderful &lt;a href="http://europython09.blip.tv/file/2351409"&gt;short story&lt;/a&gt; about the best way to wreck cars and software systems.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.europython.eu/gallery/europython-2009"&gt;&lt;img alt="Sir Tony Hoare" src="http://www.europython.eu/gallery/media/gallery-title/thumbs/3kxu_jpg_310x260_crop_q85.jpg"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;On the subject of car crashes, it seemed a shame to stem the flow of these talks and keep &lt;a href="http://research.microsoft.com/en-us/people/thoare/"&gt;Sir Tony Hoare&lt;/a&gt; waiting in the wings in order to pull Guido van Rossum on stage, especially since Guido wasn&amp;#8217;t even at the conference. Nonetheless, the the benevolent dictator for life dutifully skyped in, and his face beamed up on the 12m&lt;sup&gt;2&lt;/sup&gt; screen. We could see and hear him. He couldn&amp;#8217;t hear us. The connection fizzed and chirped until all protocol broke down. Eventually the skype laptop popped up a message warning its batteries were running low, then promptly and mercifully shut down, ending the experiment.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/C._A._R._Hoare"&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/70/CAR_Hoare.jpg/225px-CAR_Hoare.jpg" alt="Sir Tony Hoare"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;On walked Sir Tony Hoare, the programmer, software engineer, computer scientist and academic who now works for Microsoft research. His thoughtful keynote analysed the differences between science and engineering, and considered their interplay in the field of software development. His presentation challenged my way of thinking about software specification and program correctness, and the message on his closing slide was both shaming and inspirational:
&lt;/p&gt;
&lt;blockquote&gt;&lt;h3&gt;One Day&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Software will be the most reliable component of every product which contains it&lt;/li&gt;
&lt;li&gt;Software engineering will be the most dependable of all engineering professions&lt;/li&gt;
&lt;li&gt;Because of the successful interplay of research
&lt;ul&gt;&lt;li&gt;into the science of programming&lt;/li&gt;
&lt;li&gt;and the engineering of software&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;#8212; &lt;a href="http://research.microsoft.com/en-us/people/thoare/"&gt;Tony Hoare&lt;/a&gt;, The Science of Computing and the Engineering of Software, 2009
&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="http://www.flickr.com/photos/thomasguest/3681644236/" title="Enigma machine by Thomas Guest, on Flickr"&gt;&lt;img style="float:right;" src="http://farm4.static.flickr.com/3614/3681644236_2b40e5b726_m.jpg" width="240" height="199" alt="Enigma machine" /&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Sir Tony Hoare is a Turing Award winner. I think he said he&amp;#8217;d been working with computers for 50 years &amp;#8212; it may well have been longer. Certainly he remembered when ALGOL was the hot new language, poised to supplant FORTRAN. The conference provided an opportunity to go further back, to Turing himself, and to the first ever programmable digital computer. In another memorable keynote session after lunch &lt;a href="http://www.europython.eu/talks/speakers/index.html#greenish_simon"&gt;Simon Greenish&lt;/a&gt; and &lt;a href="http://www.europython.eu/talks/speakers/index.html#black_sue"&gt;Dr Sue Black&lt;/a&gt; spoke passionately about &lt;a href="http://www.bletchleypark.org.uk/"&gt;Bletchley Park&lt;/a&gt;, the expansive Milton Keynes mansion which was converted into a code-breaking factory during the second World War and which is now a museum struggling to make ends meet. At the end of the presentation they unveiled a real Enigma machine to a huge round of applause.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Colossus_computer"&gt;Colossus&lt;/a&gt;, the world&amp;#8217;s first ever programmable digital computer, &lt;a href="http://www.codesandciphers.org.uk/lorenz/rebuild.htm"&gt;has been painstakingly rebuilt&lt;/a&gt; at Bletchley Park. Although it won&amp;#8217;t be running Python, it will resume its orginal task of cracking the &lt;a href="http://en.wikipedia.org/wiki/Lorenz_cipher"&gt;Lorenz cipher&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.bletchleypark.org.uk"&gt;&lt;img src="http://www.bletchleypark.org.uk/doc/image.rhtm/Head%20detail%20web.jpg" alt="Statue of Turing at Bletchley Park"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;There can be no such return for &lt;a href="http://www.turing.org.uk/turing/"&gt;Alan Turing&lt;/a&gt;, who would have been 97 last week, but who tragically took his own life 55 years ago. He was a brilliant mathematician and scientist, famously eccentric, yet his papers on machine intelligence and computability remain highly accessible, forming the way we now think about computers. Over 11 thousand people worked at Bletchley Park during the war, and Alan Turing helped direct the decryption effort, a huge task which succeeded in shortening the war by two years and saving an estimated 22 million lives. In 2007 a statue of Alan Turing was erected at Bletchley Park. Dr Sue Black showed us a photo of his coffee mug which remains where he kept it, chained to a radiator.
&lt;/p&gt;</description>
<dc:date>2009-07-02</dc:date>
<guid>http://wordaligned.org/articles/europython-2009</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/europython-2009</link>
<category>Python</category>
</item>

<item>
<title>Partitioning with Python</title>
<description>&lt;h3&gt;Sums and Splits&lt;/h3&gt;
&lt;p&gt;On the subject of &lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;hunting for eodermdromes&lt;/a&gt;, here are a couple of semi-related partitioning problems.
&lt;/p&gt;
&lt;ol&gt;
 &lt;li&gt;
     for a positive integer, N, find the positive integer sequences which sum to N
 &lt;/li&gt;

 &lt;li&gt;
     for a sequence, S, find the distinct partitions of that sequence
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As an example of the first, the 16 distinct integer sequences which sum to 5 are:
&lt;/p&gt;
&lt;pre&gt;
5
4 + 1
3 + 1 + 1
3 + 2
2 + 1 + 2
2 + 1 + 1 + 1
2 + 2 + 1
2 + 3
1 + 1 + 3
1 + 1 + 2 + 1
1 + 1 + 1 + 1 + 1
1 + 1 + 1 + 2
1 + 2 + 2
1 + 2 + 1 + 1
1 + 3 + 1
1 + 4
&lt;/pre&gt;

&lt;p&gt;and of the second, the 8 distinct ways of partitioning the sequence ABCD are:
&lt;/p&gt;
&lt;pre&gt;
ABCD
A BCD
AB CD
ABC D
A B CD
A BC D
AB C D
A B C D
&lt;/pre&gt;

&lt;p&gt;Note that I&amp;#8217;ve counted 2 + 1 + 2, 2 + 2 + 1, and 1 + 2 + 2 as distinct sums totalling 5. That happens to be the formulation of the problem which interested me.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;


&lt;h3&gt;Context&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;&lt;img src="http://wordaligned.org/images/eodermdrome.png" width="200px" height="200px" style="float:right" alt="eodermdrome"/&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Before discussing a solution to these problems, some context. Recall that an &lt;a href="http://wordaligned.org/articles/oulipo-eodermdrome.html"&gt;eodermdrome&lt;/a&gt; is a sequence which forms an Eulerian circuit through the fully connected graph whose vertices are the set of its elements. Put more simply: when you trace through the letters you get the figure shown, with no edge covered twice. Examples include:
&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;span style="color:#930"&gt;O&lt;/span&gt;&lt;span style="color:#036"&gt;D&lt;/span&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;R&lt;/span&gt;&lt;span style="color:#e50"&gt;M&lt;/span&gt;&lt;span style="color:#036"&gt;D&lt;/span&gt;&lt;span style="color:#555"&gt;R&lt;/span&gt;&lt;span style="color:#930"&gt;O&lt;/span&gt;&lt;span style="color:#e50"&gt;M&lt;/span&gt;&lt;span style="color:#888"&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;span style="color:#555"&gt;N&lt;/span&gt;&lt;span style="color:#036"&gt;H&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#555"&gt;N&lt;/span&gt;&lt;span style="color:#888"&gt;C&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt; &lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#888"&gt;C&lt;/span&gt;&lt;span style="color:#036"&gt;H&lt;/span&gt;&lt;span style="color:#e50"&gt;E&lt;/span&gt;&lt;/p&gt;
&lt;p style="margin:0;font-size:300%"&gt;&lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#888"&gt;X&lt;/span&gt; &lt;span style="color:#e50"&gt;D&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#930"&gt;A&lt;/span&gt;&lt;span style="color:#e50"&gt;D&lt;/span&gt; &lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;span style="color:#555"&gt;E&lt;/span&gt;&lt;span style="color:#888"&gt;X&lt;/span&gt;&lt;span style="color:#036"&gt;T&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Eodermdromes turn out to be surprisingly rare. Writing a computer program to find them is a nice exercise in searching and text processing. Clearly, we should start with a collection of words. Then we can generate combinations of words from this collection and filter out the eodermdromes.
&lt;/p&gt;
&lt;pre&gt;
(filter eodermdrome? (combinations words))
&lt;/pre&gt;

&lt;p&gt;A large set of words (note: &amp;#8220;set&amp;#8221; not &amp;#8220;collection&amp;#8221;, we don&amp;#8217;t need duplicates) gives the best chance of success. I started with a file containing more than 35 thousand distinct words. This gives over a billion possible word pairs, and when we consider word triples and quartets the numbers get silly even for a modern computer.
&lt;/p&gt;
&lt;p&gt;As is so often the case in computing, we have a tension between opposing concerns. We&amp;#8217;d like code which separates the task of generating candidates and the task of testing these candidates for eodermdromicity, but in order to run this code in a timely manner we need some of the eodermdrome testing to leak into the candidate generation. For example, we could preprocess the word set removing words which contain double Ls (all, ball, call, ill, Bill, kill &amp;#8230;) since these can never appear in an eodermdrome. And we could similarly remove words which end ETE (delete, Pete, effete). As I hope you can see, it&amp;#8217;s easy to end up with finickity code and co-dependent functions.
&lt;/p&gt;
&lt;p&gt;I chose a simple but effective strategy to reduce the search space to something manageable, based on word length. First, then, I loaded my word set into a Python dict collecting lists of words keyed by their length.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import defaultdict
&amp;gt;&amp;gt;&amp;gt; words = defaultdict(list)
&amp;gt;&amp;gt;&amp;gt; for word in open('word-set.txt').read().split():
...     words[len(word)].append(word)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Given this dict, picking out single word eodermdromes is easy.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; list(filter(is_eodermdrome, words[11]))
['eodermdrome']

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about eodermdromes composed of a 6 letter word followed by a 5 letter word? We can form the &lt;a href="http://docs.python.org/library/itertools.html#itertools.product"&gt;cartesian product&lt;/a&gt; of the lists of 6 and 5 letter words and filter out the ones we want.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import product
&amp;gt;&amp;gt;&amp;gt; eod_6_5 = filter(is_eodermdrome, product(words[6], words[5]))
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
('earned', 'andre')
&amp;gt;&amp;gt;&amp;gt; next(eod_6_5)
('yearly', 'relay')

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How about &lt;em&gt;all eodermdromes&lt;/em&gt; of length 11?
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import chain.from_iterable as seq
&amp;gt;&amp;gt;&amp;gt; word_lens = sum_to_n(11)
&amp;gt;&amp;gt;&amp;gt; candidates = seq(product(*[words[i] for i in s]) for s in word_lens)
&amp;gt;&amp;gt;&amp;gt; eods = filter(is_eodermdrome, candidates)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Note here that I&amp;#8217;m using Python 3.0, and that &lt;a href="http://docs.python.org/py3k/library/functions.html#filter"&gt;filter&lt;/a&gt; is therefore a lazy function. The interactive session shown above hasn&amp;#8217;t actually started taking anything from these lazily-evaluated streams.
&lt;/p&gt;
&lt;p&gt;I certainly don&amp;#8217;t claim this is the quickest way to search for eodermdromes. In fact, this little program took several hours to complete. But a back-of-an-envelope calculation showed it &lt;em&gt;would&lt;/em&gt; complete in a few hours, and that was good enough.
&lt;/p&gt;
&lt;p&gt;Note also that we haven&amp;#8217;t shown an implementation of &lt;code&gt;sum_to_n()&lt;/code&gt; yet, which takes us back to the problems posed at the start of this article.
&lt;/p&gt;

&lt;h3&gt;Sum to N&lt;/h3&gt;
&lt;p&gt;Finding the positive integer series which sum to a positive integer N is a job for &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;itertools.combinations&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import combinations, chain

def sum_to_n(n):
    'Generate the series of +ve integer lists which sum to a +ve integer, n.'
    from operator import sub
    b, mid, e = [0], list(range(1, n)), [n]
    splits = (d for i in range(n) for d in combinations(mid, i)) 
    return (list(map(sub, chain(s, e), chain(b, s))) for s in splits)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The idea here is straightforward: there&amp;#8217;s a 1-to-1 correspondence between the sums we want and ordered combinations drawn from the series 1, 2, &amp;#8230; n-1. For example, if n is 11 one such combination would be:
&lt;/p&gt;
&lt;pre&gt;
(1, 5, 7, 10)
&lt;/pre&gt;

&lt;p&gt;we can extend this by pushing 0 in front and n at the end
&lt;/p&gt;
&lt;pre&gt;
(0, 1, 5, 7, 10, 11)
&lt;/pre&gt;

&lt;p&gt;This extended tuple can now be seen as partial sums of a series which sums to 11. Taking differences gives the series
&lt;/p&gt;
&lt;pre&gt;
(1-0, 5-1, 7-5, 10-7, 11-10)
&lt;/pre&gt;

&lt;p&gt;which is
&lt;/p&gt;
&lt;pre&gt;
(1, 4, 2, 3, 1)
&lt;/pre&gt;

&lt;p&gt;which does indeed sum to 11
&lt;/p&gt;
&lt;pre&gt;
1 + 4 + 2 + 3 + 1 = 11
&lt;/pre&gt;

&lt;p&gt;The Python code shown uses a clever idea to implement this staggered differencing, an idea I &lt;a href="http://newsimg.bbc.co.uk/media/images/45909000/jpg/_45909582_badartists.jpg" title="Bristol's famous artist and thief"&gt;cleverly stole&lt;/a&gt; from one of &lt;a href="http://code.activestate.com/recipes/users/178123/"&gt;Raymond Hettinger&amp;#8217;s brilliant Python recipes&lt;/a&gt;.
&lt;/p&gt;

&lt;h3&gt;Partitioning a Sequence&lt;/h3&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;Python Cookbook: Recipe 576795&lt;/div&gt;

&lt;pre class="prettyprint"&gt;from itertools import chain, combinations

def partition(iterable, chain=chain, map=map):
    s = iterable if hasattr(iterable, '__getslice__') else tuple(iterable)
    n = len(s)
    first, middle, last = [0], range(1, n), [n]
    getslice = s.__getslice__
    return [map(getslice, chain(first, div), chain(div, last))
            for i in range(n) for div in combinations(middle, i)]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This &lt;a href="http://code.activestate.com/recipes/576795"&gt;recipe&lt;/a&gt; shows sum-to-n and partitioning to be very similar problems. In fact, we could easily implement &lt;code&gt;sum_to_n()&lt;/code&gt; on top of  &lt;code&gt;partition()&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def sum_to_n(n):
    return ([len(t) for t in p] for p in partition(range(n)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The posted recipe needs a minor overhaul to get it working with Python 3.0, &lt;a href="http://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods"&gt;which does away&lt;/a&gt; with &lt;code&gt;__getslice__&lt;/code&gt;: getting a slice is simply what &lt;code&gt;__getitem__&lt;/code&gt; does when given a slice object. The 2to3 tool fails to convert the recipe, which must be recast as something like:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import chain, combinations

def sliceable(xs):
    '''Return a sliceable version of the iterable xs.'''
    try:
        xs[:0]
        return xs
    except TypeError:
        return tuple(xs)

def partition(iterable):
    s = sliceable(iterable)
    n = len(s)
    b, mid, e = [0], list(range(1, n)), [n]
    getslice = s.__getitem__
    splits = (d for i in range(n) for d in combinations(mid, i))
    return [[s[sl] for sl in map(slice, chain(b, d), chain(d, e))]
            for d in splits]

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Sum to N, again&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a variant implementation of &lt;code&gt;sum_to_n()&lt;/code&gt;. The idea here is to fill N slots with a pattern of 0&amp;#8217;s and 1&amp;#8217;s. We then reduce this pattern to the lengths of runs of repeated elements, giving a series which sums to N. &lt;code&gt;Itertools.product('01', repeat=n)&lt;/code&gt; generates all possible binary patterns of length N, which turns out to be twice as many as we want since (e.g.) 00001111100 and 11110000011 represent the same sum, 4 + 5 + 2; hence the n-1 &lt;code&gt;repeat&lt;/code&gt; count and the call to &lt;code&gt;chain&lt;/code&gt; in the code below&lt;a id="fn1link" href="http://wordaligned.org/articles/partitioning-with-python#fn1"&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;from itertools import groupby, chain, product

def ilen(it):
    return sum(1 for _ in it)

def sum_to_n(n):
    return ([ilen(gp) for _, gp in groupby(chain('1', O1))]
            for O1 in product('01', repeat=n-1))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Fun, but the version using &lt;a href="http://docs.python.org/library/itertools.html#itertools.combinations"&gt;combinations&lt;/a&gt; is better!
&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;a id="fn1" href="http://wordaligned.org/articles/partitioning-with-python#fn1link"&gt;[1]&lt;/a&gt; My first thought was to use &lt;code&gt;itertools.islice&lt;/code&gt; to limit the stream to the first 2&lt;sup&gt;n-1&lt;/sup&gt; values, but I discovered &lt;code&gt;islice&lt;/code&gt; has a surprising &lt;a href="http://bugs.python.org/issue6305" title="I've reported this as a bug"&gt;limitation&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import islice, count
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31) - 1)
&amp;lt;itertools.islice object at 0x63a0c0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; islice(count(), (1&amp;lt;&amp;lt;31))
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
ValueError: Stop argument for islice() must be a non-negative integer or None.

&lt;/pre&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;p style="text-align:center"&gt;&amp;sect;&lt;/p&gt;
&lt;p style="text-align:center"&gt;so reuse ours&lt;/p&gt;</description>
<dc:date>2009-06-17</dc:date>
<guid>http://wordaligned.org/articles/partitioning-with-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/partitioning-with-python</link>
<category>Python</category>
</item>

<item>
<title>Run-length encoding in Python</title>
<description>&lt;p&gt;Recently I discussed &lt;a href="http://wordaligned.org/articles/deflate-runlength-encoding-but-better.html" title="DEFLATE: run-length encoding, but better"&gt;run-length encoding and DEFLATE&lt;/a&gt; compression. I never actually showed a Python implementation of a run-length encoder, so here&amp;#8217;s one now.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;import itertools as its

def ilen(it):
    '''Return the length of an iterable.
    
    &amp;gt;&amp;gt;&amp;gt; ilen(range(7))
    7
    '''
    return sum(1 for _ in it)

def runlength_enc(xs):
    '''Return a run-length encoded version of the stream, xs.
    
    The resulting stream consists of (count, x) pairs.
    
    &amp;gt;&amp;gt;&amp;gt; ys = runlength_enc('AAABBCCC')
    &amp;gt;&amp;gt;&amp;gt; next(ys)
    (3, 'A')
    &amp;gt;&amp;gt;&amp;gt; list(ys)
    [(2, 'B'), (3, 'C')]
    '''
    return ((ilen(gp), x) for x, gp in its.groupby(xs))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The decoder is equally simple. &lt;code&gt;Itertools.repeat&lt;/code&gt; expands a &lt;code&gt;(count, value)&lt;/code&gt; pair into an iterable which will generate &lt;code&gt;count&lt;/code&gt; elements. &lt;code&gt;Itertools.chain&lt;/code&gt; flattens these iterables into a single stream.
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def runlength_dec(xs):
    '''Expand a run-length encoded stream.
    
    Each element of xs is a pair, (count, x).
    
    &amp;gt;&amp;gt;&amp;gt; ys = runlength_dec(((3, 'A'), (2, 'B')))
    &amp;gt;&amp;gt;&amp;gt; next(ys)
    'A'
    &amp;gt;&amp;gt;&amp;gt; ''.join(ys)
    'AABB'
    '''
    return its.chain.from_iterable(its.repeat(x, n) for n, x in xs)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If you haven&amp;#8217;t seen &lt;code&gt;&lt;a href="http://docs.python.org/library/itertools.html#itertools.itertools.chain.from_iterable"&gt;itertools.chain.from_iterable()&lt;/a&gt;&lt;/code&gt; yet, it was introduced at Python 3.0/2.6. The important feature here is that it lazily works its way through a single iterable argument. If instead we&amp;#8217;d written:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def runlength_dec(xs):
    ....
    return its.chain(*(its.repeat(x, n) for n, x in xs))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;then our run-length decoder would need to consume all of &lt;code&gt;xs&lt;/code&gt; before yielding results (which is why we must interrupt the interpreter&amp;#8217;s execution below).
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; xs = its.cycle((3, 'A'), (2, 'B'))
&amp;gt;&amp;gt;&amp;gt; runlength_dec(xs)
  C-c C-cTraceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
  File "&amp;lt;string&amp;gt;", line 25, in runlength_dec
  File "&amp;lt;string&amp;gt;", line 25, in &amp;lt;genexpr&amp;gt;
KeyboardInterrupt

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;Named tuples for clarity&lt;/h3&gt;
&lt;p&gt;Streams of pairs (as shown above) are perfectly Pythonic. If we run-length encode a stream of numbers, clients will just have to read the manual and remember that &lt;code&gt;item[0]&lt;/code&gt; is a repeat count and &lt;code&gt;item[1]&lt;/code&gt; is a value.
&lt;/p&gt;
&lt;p&gt;If this seems fragile, a new-ish member of the &lt;a href="http://docs.python.org/dev/library/collections.html"&gt;collections module&lt;/a&gt; can give the pair more structure.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;&amp;gt;&amp;gt;&amp;gt; from collections import namedtuple
&amp;gt;&amp;gt;&amp;gt; Run = namedtuple('Run', 'count value') 
&amp;gt;&amp;gt;&amp;gt; run1 = Run(count=10, value=2)
&amp;gt;&amp;gt;&amp;gt; run2 = Run(value=2, count=10)
&amp;gt;&amp;gt;&amp;gt; run1
Run(count=10, value=2)
&amp;gt;&amp;gt;&amp;gt; run2
Run(count=10, value=2)
&amp;gt;&amp;gt;&amp;gt; run1.count
10
&amp;gt;&amp;gt;&amp;gt; run1[0]
10

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s how we&amp;#8217;d change &lt;code&gt;runlength_enc()&lt;/code&gt; to use the new type.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;def runlength_enc(xs):
    '''Return a run-length encoded version of the stream, xs.
    
    &amp;gt;&amp;gt;&amp;gt; ys = runlength_enc('AAABBCCC')
    &amp;gt;&amp;gt;&amp;gt; next(ys)
    Run(count=3, value='A')
    &amp;gt;&amp;gt;&amp;gt; list(ys)
    [Run(count=2, value='B'), Run(count=3, value='C')]
    '''
    return (Run(ilen(gp), x) for x, gp in its.groupby(xs))

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2009-06-01</dc:date>
<guid>http://wordaligned.org/articles/runlength-encoding-in-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/runlength-encoding-in-python</link>
<category>Python</category>
</item>

<item>
<title>DEFLATE: run-length encoding, but better</title>
<description>&lt;h3&gt;Run-length encoding&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Run-length_encoding"&gt;Run-length encoding&lt;/a&gt; is a simple compression scheme in which runs of equal values are represented by the value and a repeat count. For example, a supermarket cashier might process this line of shopping
&lt;/p&gt;
&lt;img src="http://wordaligned.org/images/fruit-line.png" alt="Fruit salad"/&gt;

&lt;p&gt;as
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
     4 bananas
 &lt;/li&gt;

 &lt;li&gt;
     3 apples
 &lt;/li&gt;

 &lt;li&gt;
     2 bananas
 &lt;/li&gt;

 &lt;li&gt;
     1 pineapple
 &lt;/li&gt;

 &lt;li&gt;
     3 apples
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unix packs in its very own run length encoder, &lt;code&gt;uniq -c&lt;/code&gt;. It works just fine &amp;#8212; so long as the values you want to encode are newline separated byte strings, that is.
&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s use a sequence of coin tosses as an example stream. &lt;code&gt;$RANDOM&lt;/code&gt; generates random numbers. We use the least significant bit of these numbers as an index into an array containing the values &lt;code&gt;heads&lt;/code&gt;, &lt;code&gt;tails&lt;/code&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ HT=(heads tails)
$ toss() { echo ${HT[$RANDOM&amp;amp;1]}; }
$ toss; toss; toss
heads
tails
tails
$ tosses() { while [ 1 ]; do toss; done; }
$ tosses | head
tails
tails
tails
heads
tails
heads
heads
heads
tails
tails

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;img src="http://wordaligned.org/images/tails.jpg" alt="tails"/&gt;
   &lt;img src="http://wordaligned.org/images/tails.jpg" alt="tails"/&gt;
   &lt;img src="http://wordaligned.org/images/tails.jpg" alt="tails"/&gt;
   &lt;img src="http://wordaligned.org/images/heads.jpg" alt="heads"/&gt;
   &lt;img src="http://wordaligned.org/images/tails.jpg" alt="tails"/&gt;
   &lt;img src="http://wordaligned.org/images/heads.jpg" alt="heads"/&gt;
   &lt;img src="http://wordaligned.org/images/heads.jpg" alt="heads"/&gt;
   &lt;img src="http://wordaligned.org/images/heads.jpg" alt="heads"/&gt;
   &lt;img src="http://wordaligned.org/images/tails.jpg" alt="tails"/&gt;
   &lt;img src="http://wordaligned.org/images/tails.jpg" alt="tails"/&gt;
&lt;/p&gt;
&lt;span id="continue-reading"/&gt;

&lt;p&gt;Passing a fresh sample from this same stream through our run-length encoder we get:
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ tosses | uniq -c | head
   2 heads
   1 tails
   1 heads
   1 tails
   1 heads
   6 tails
   3 heads
   1 tails
   4 heads
   1 tails

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;An &lt;code&gt;awk&lt;/code&gt; script can be used as a run-length decoder. (There must be a neater way, using &lt;code&gt;sed&lt;/code&gt; maybe?)
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;$ runlendec() { awk '{ while ($1--) print $2 }'; }
$ tosses | head | tee orig.log | uniq -c | runlendec | tee encdec.log
heads
tails
heads
tails
heads
heads
tails
tails
heads
heads
$ diff orig.log encdec.log

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, we toss a coin 10 times teeing the original sequence to a file. The next two links in the pipeline compress and decompress the sequence, teeing the results to another file. Finally, as a sanity check, we confirm the round trip results are the same.
&lt;/p&gt;

&lt;h3&gt;Run-length encoding in Python&lt;/h3&gt;
&lt;p&gt;This Unix run-length codec is fun, but of limited practical use. One good feature, though, is the way it operates on streams of data (including infinite streams), leaving clients free to decide how best to slice and buffer these streams.
&lt;/p&gt;
&lt;p&gt;Python has a fine library of high-level &lt;a href="http://docs.python.org/library/itertools.html"&gt;stream transformation tools&lt;/a&gt; from which we can build a generic and flexible run-length codec in just a few lines. Since I want to progress from run-length coding to something more advanced, I&amp;#8217;ll leave discussing how to implement this codec for now, but if you&amp;#8217;d like to write your own version, here&amp;#8217;s a description suitable for &lt;a href="http://docs.python.org/library/doctest#simple-usage-checking-examples-in-a-text-file"&gt;doctesting&lt;/a&gt;.
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;Import the run-length codec functions and compress a short string.
&amp;gt;&amp;gt;&amp;gt; from runlength import compress, decompress
&amp;gt;&amp;gt;&amp;gt; comp = compress('AABBBACC')

The returned compressor is a stream (an iterable).
&amp;gt;&amp;gt;&amp;gt; next(comp)
(2, 'A')

Pull the rest of the stream into memory.
&amp;gt;&amp;gt;&amp;gt; rest = list(comp)
&amp;gt;&amp;gt;&amp;gt; rest
[(3, 'B'), (1, 'A'), (2, 'C')]

Simple decompress example.
&amp;gt;&amp;gt;&amp;gt; concat = ''.join
&amp;gt;&amp;gt;&amp;gt; concat(decompress(rest))
'BBBACC'

Compress, decompress also work with infinite streams, like the 
a2b3 stream, which repeatedly cycles two pairs. 
&amp;gt;&amp;gt;&amp;gt; from itertools import cycle, islice
&amp;gt;&amp;gt;&amp;gt; a2b3 = cycle([(2, 'a'), (3, 'b')])
&amp;gt;&amp;gt;&amp;gt; dec = decompress(a2b3)

Pull 8 values from the decompressed stream.
&amp;gt;&amp;gt;&amp;gt; concat(islice(dec, 8))
'aabbbaab'

Now compress the decompressed stream, and explore a few items.
&amp;gt;&amp;gt;&amp;gt; comp = compress(dec)
&amp;gt;&amp;gt;&amp;gt; next(comp)
(2, 'b')
&amp;gt;&amp;gt;&amp;gt; list(islice(comp, 2))
[(2, 'a'), (3, 'b')]

&lt;/pre&gt;

&lt;/div&gt;


&lt;h3&gt;DEFLATE&lt;/h3&gt;
&lt;img style="border: 2px solid #ccc;" src="http://wordaligned.org/images/chessboard-monochrome.png" alt="Chessboard"/&gt;

&lt;p&gt;The Wikipedia page on &lt;a href="http://en.wikipedia.org/wiki/Run-length_encoding"&gt;run-length encoding&lt;/a&gt; identifies monochrome images as good candidates for run-length compression. The white and black pixels typically group into long runs. Indeed, any simple image using a limited palette should reduce well using this compression scheme.
&lt;/p&gt;
&lt;p&gt;The chessboard above is 256&amp;times;256 pixels, each square being 32&amp;times;32 pixels. We &lt;em&gt;could&lt;/em&gt; run-length encode this 64K pixel image as 256&amp;times;8 = 2K runs of 32 pixels, a decent saving. (Actually, we should do slightly better, noting that there are runs of length 64 at the chessboard rank boundaries, but  you get the idea.)
&lt;/p&gt;
&lt;pre&gt;
(32,W)(32,B)(32,W)(32,B)(32,W)(32,B)(32,W)(32,B),
(32,W)(32,B)(32,W)(32,B)(32,W)(32,B)(32,W)(32,B),
....
(32,B)(32,W)(32,B)(32,W)(32,B)(32,W)(32,B)(32,W)
&lt;/pre&gt;

&lt;p&gt;Like a paletted image, a block of text &amp;#8212; the web page you&amp;#8217;re reading now, for example &amp;#8212; employs a limited alphabet. Although the characters in this text don&amp;#8217;t usually group into long runs there&amp;#8217;s plenty of repetition, especially in the raw HTML: all the occurrences of &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; used for CSS styling, for example. The &lt;a href="http://en.wikipedia.org/wiki/DEFLATE"&gt;DEFLATE&lt;/a&gt; compression algorithm uses a clever twist on run-length encoding to remove this redundancy:
&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The compressed data consists of a series of elements of two types: literal bytes (of strings that have not been detected as duplicated within the previous 32K input bytes), and pointers to duplicated strings, where a pointer is represented as a pair &amp;lt;length, backward distance&amp;gt;. (&lt;a href="http://tools.ietf.org/html/rfc1951"&gt;RFC-1951&lt;/a&gt;)
&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;(In addition, a multiple-level dynamic Huffman encoding scheme reduces the space needed for the strings, distances and lengths themselves.)
&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s more to these pointer elements than first appears: the length can exceed the backward distance. Thus the sequence:
&lt;/p&gt;
&lt;pre&gt;
heads
heads
heads
heads
heads
&lt;/pre&gt;

&lt;p&gt;can be deflated as the literal type &lt;code&gt;heads\n&lt;/code&gt; followed by the pointer type &lt;code&gt;&amp;lt;24, 6&amp;gt;&lt;/code&gt;. 
&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;ve spotted the potential for recursion, good! The inflating stream can reference itself, which can reference itself, which can &amp;#8230; &lt;a href="http://steike.com/code/useless/zip-file-quine/" title="Best ever Quine!"&gt;Confusing?&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;Zipping pixels&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.libpng.org/pub/png/" title="Check out the graphics on the PNG home page!"&gt;PNG&lt;/a&gt; images use DEFLATE compression (as implemented by &lt;a href="http://www.zlib.net"&gt;zlib&lt;/a&gt;) to save on pixel storage space. Here&amp;#8217;s a binary view of the raw data in the chessboard graphic shown above, all &lt;strong&gt;137 bytes&lt;/strong&gt; of it. The 64K pixels themselves compress into a 88 byte IDAT chunk, of which the final 8 bytes are a checksum and (I think?) some padding. Maybe the image could be &lt;a href="http://drj11.wordpress.com/2009/02/20/i-crush-optipng/"&gt;squeezed harder&lt;/a&gt;, but I&amp;#8217;m impressed!
&lt;/p&gt;
&lt;pre&gt;
8950 4e47 0d0a 1a0a 0000 000d 4948 4452  .&lt;b&gt;PNG&lt;/b&gt;........&lt;b&gt;IHDR&lt;/b&gt;
0000 0100 0000 0100 0100 0000 0074 0995  .............t..
cb00 0000 5049 4441 5468 81ed ceb1 0d00  ....P&lt;b&gt;IDAT&lt;/b&gt;h......
200c 0341 f65f 1a58 803a 2f74 6e52 e424   ..A._.X.:/tnR.$
7bed 9b75 f3ba cf07 0000 df83 ca0e 0000  {..u............
7a60 ba1f 0080 2ea8 ec00 00a0 07a6 fb01  z`..............
00e8 82ca 0e00 007a 60ba 1f00 802e a8ec  .......z`.......
0000 2007 0e8a 69f0 e2b9 9471 c700 0000  .. ...i....q....
0049 454e 44ae 4260 82                   .&lt;b&gt;IEND&lt;/b&gt;.B`.
&lt;/pre&gt;

&lt;p&gt;Here&amp;#8217;s a trace of how zlib inflates the compressed pixels in this &lt;a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html"&gt;IDAT chunk&lt;/a&gt;. (Source code available via anonymous SVN at &lt;a href="http://wordaligned.org/svn/etc/zlib_trace"&gt;http://wordaligned.org/svn/etc/zlib_trace&lt;/a&gt;.)
&lt;/p&gt;
&lt;div class="typocode"&gt;

&lt;pre class="prettyprint"&gt;inflate: allocated
inflate: reset
inflate:   zlib header ok
inflate:     dynamic codes block (last)
inflate:       table sizes ok
inflate:       code lengths ok
inflate:       codes ok
inflate:         literal 0x00
inflate:         literal 0xff
inflate:         length 3
inflate:         distance 1
inflate:         literal 0x00
inflate:         length 3
inflate:         distance 1
inflate:         length 24
inflate:         distance 8
inflate:         length 25
inflate:         distance 25
inflate:         length 258
inflate:         distance 33
....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I&amp;#8217;ve attempted to show the first few stages of the genesis of the uncompressed stream in the picture below. The way the stream recursively inflates itself is quite beautiful.
&lt;/p&gt;
&lt;img style="border: 2px solid #ccc;" src="http://wordaligned.org/images/inflate.png" alt="Inflating pixels"/&gt;

&lt;ol&gt;
 &lt;li&gt;
     put 00
 &lt;/li&gt;

 &lt;li&gt;
     put ff
 &lt;/li&gt;

 &lt;li&gt;
     go back 1 (to ff), put 3
 &lt;/li&gt;

 &lt;li&gt;
     put 00
 &lt;/li&gt;

 &lt;li&gt;
     go back 1 (to 00), put 3
 &lt;/li&gt;

 &lt;li&gt;
     go back 8 (to 00 00 00 00 ff ff ff ff)
 &lt;/li&gt;

 &lt;li&gt;
     put 24
 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Two elements later, and the repeat length has grown to 258. In fact, the entire chessboard is generated from just 3 literal and 43 pointer elements.
&lt;/p&gt;
&lt;p&gt;(Not all graphics have such a regular pattern, of course, so we can&amp;#8217;t always achieve such dramatic compression.)
&lt;/p&gt;

&lt;h3&gt;Deflated HTML&lt;/h3&gt;
&lt;p&gt;Web servers can and do save on band-width by transferring &lt;a href="http://www.gzip.org/"&gt;gzip&lt;/a&gt; compressed HTML to gzip capable clients. (Gzip is a simple wrapper around DEFLATE.) Any PNG images transferred will also have their pixels DEFLATE compressed.
&lt;/p&gt;
&lt;pre&gt;
$ curl http://wordaligned.org --head --compress
HTTP/1.1 200 OK
Date: Sun, 17 May 2009 17:41:53 GMT
Server: lighttpd | Word Aligned
Content-Type: text/html; charset=UTF-8
....
Vary: Accept-Encoding
&lt;b&gt;Content-Encoding: gzip&lt;/b&gt;
Content-Length: 20
&lt;/pre&gt;

&lt;p&gt;The Word Aligned &lt;a href="http://wordaligned.org/"&gt;front page&lt;/a&gt; contains about 75Kb of HTML, which gzips to just 16Kb &amp;#8212; a decent saving. Relevant lines from the &lt;a href="http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs:ModCompress"&gt;lighttpd configuration file&lt;/a&gt; read:
&lt;/p&gt;
&lt;div class="typocode"&gt;&lt;div class="codetitle"&gt;lighttpd mod_compress&lt;/div&gt;

&lt;pre class="prettyprint"&gt;server.modules = (
    ....
    "mod_compress"
)
compress.cache-dir = basedir + "lighttpd/cache/compress/"
compress.filetype  = ("text/plain", "text/html", "text/css")

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I uphold Gzip (built on zlib, which implements DEFLATE) as a hero of the web. As we&amp;#8217;ve seen, it implements a powerful and elegant algorithm, but perhaps the best thing about it is that it&amp;#8217;s free to use, a freedom worth fighting for. Check out this battle report from the &lt;a href="http://www.gzip.org/#faq"&gt;FAQ&lt;/a&gt;.
&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3&gt;What about patents?&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;gzip&lt;/em&gt; was developed as a replacement for compress because of the UNISYS and IBM &lt;a href="http://www.faqs.org/faqs/compression-faq/part1/section-6.html"&gt;patents&lt;/a&gt; covering the &lt;a href="http://www.faqs.org/faqs/compression-faq/part2/section-1.html"&gt;LZW&lt;/a&gt; algorithm used by compress.
&lt;/p&gt;
&lt;p&gt;I have probably spent more time studying data compression patents than actually implementing data compression algorithms. I maintain a list of several hundred patents on lossless data compression algorithms, and I made sure that &lt;em&gt;gzip&lt;/em&gt; isn&amp;#8217;t covered by any of them. In particular, the &lt;code&gt;--fast&lt;/code&gt; option of gzip is not as fast it could, precisely to avoid a patented technique.  &amp;#8212; Jean-Loup Gailly, &lt;a href="http://www.gzip.org/#faq11"&gt;Gzip FAQ&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;</description>
<dc:date>2009-05-21</dc:date>
<guid>http://wordaligned.org/articles/deflate-runlength-encoding-but-better</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>http://wordaligned.org/articles/deflate-runlength-encoding-but-better</link>
<category>Python</category>
</item>

</channel>
</rss>
