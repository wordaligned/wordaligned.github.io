<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" >
<channel>
<title>Word Aligned</title>
<link>https://wordaligned.org</link>
<description>tales from the code face</description>
<dc:creator>tag@wordaligned.org</dc:creator>
<language>en-gb</language>
<item>
<title>A language people use and bitch about</title>
<description>&lt;p&gt;Every so often a new essay hits the top of the programming news sites:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;why I&amp;#8217;m rewriting &lt;a href=&quot;http://250bpm.com/blog:4&quot; title=&quot;Why should I have written ZeroMQ in C, not C++&quot;&gt;X in C&lt;/a&gt; (and abandoning C++)&lt;/li&gt;
&lt;li&gt;why we will never use C++ for Y (which has always been written in C)&lt;/li&gt;
&lt;li&gt;why C++ is a &lt;a href=&quot;http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918&quot; title=&quot;Torvalds rants about C++&quot;&gt;horrible language&lt;/a&gt; (it isn&amp;#8217;t C)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;#8217;m a sucker for these articles and have some sympathy with them. Every so often I work with C code rather than C++, and find the experience refreshing: rapid compilation, clear build diagnostics, comprehensible APIs, easy debugging, and an agreeable reduction in layering and punctuation.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s always easy to return to C because it hasn&amp;#8217;t really changed. Well, it &lt;strong&gt;has&lt;/strong&gt; changed, conservatively, and C programmers seem conservative in adopting new features.&lt;/p&gt;
&lt;p&gt;By contrast, C++ &lt;strong&gt;does&lt;/strong&gt; change. Sure, C++0X was a long time coming &amp;#8212; finally realised as C++11 &amp;#8212; but since that giant step, smaller improvements continue apace. As a result C++ code soon looks stale. Every time I visit a source file it seems I have to freshen it, using the new way to prevent copying, or return containers, or manage resources, or pass functions, or &amp;#8230; you get the idea.&lt;/p&gt;
&lt;p&gt;The truth is, every substantial C++ codebase I&amp;#8217;ve worked on reads like a history of C++. Somewhere low down there&amp;#8217;ll be hand-written intrusive linked lists; then there&amp;#8217;ll be a few layers of classes, some nested for good measure; then templates, &lt;a href=&quot;http://www.boost.org/&quot;&gt;boost&lt;/a&gt;, functions disguised as classes for use in algorithms; and finally the good stuff, in which auto, lambda, move semantics and intialisers allow us to code as we&amp;#8217;ve always wanted.&lt;/p&gt;
&lt;p&gt;Bjarne Stroustrup &lt;a href=&quot;http://www.stroustrup.com/blast.html&quot;&gt;defends C++ on his website&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As someone remarked: There are only two kinds of programming languages: those people always bitch about and those nobody uses.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If that &amp;#8220;someone&amp;#8221; wasn&amp;#8217;t Stroustrup, it is now &amp;#8212; he has become the source of his own quotation. His point is that C++ is well-used and must therefore be bitched about.&lt;/p&gt;
&lt;p&gt;C provides an immediate counter-example, however. It is undeniably used, but its &lt;a href=&quot;https://en.wikipedia.org/wiki/C_Traps_and_Pitfalls&quot;&gt;traps and pitfalls&lt;/a&gt; are known and respected, rather than bitched about.&lt;/p&gt;
&lt;p&gt;Ultimately, though, I find C too limited. The lack of standard containers and algorithms combined with the overheads of heap management and ubiquitous error checking make programming in C heavy going.&lt;/p&gt;
&lt;p&gt;C++ is hard to learn and hard to keep up with. The language has grown, considerably, but the progression is necessary. It&amp;#8217;s the more recent extensions which fully realise the power of the standard template library, for example. Stick with C++. The reward will be code which is expressive and efficient.&lt;/p&gt;</description>
<dc:date>2016-08-24</dc:date>
<guid>https://wordaligned.org/articles/a-language-people-use-and-bitch-about</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/a-language-people-use-and-bitch-about</link>
<category>C++</category>
</item>

<item>
<title>Negative Sequence Indices in Python</title>
<description>&lt;p&gt;Supply a negative index when accessing a sequence and Python counts back from the end. So, for example, &lt;code&gt;my_list[-2]&lt;/code&gt; is the penultimate element of &lt;code&gt;my_list&lt;/code&gt;, which is much better than &lt;code&gt;my_list[len(my_list)-2]&lt;/code&gt; or even &lt;code&gt;*(++my_list.rbegin())&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That final example uses one of C++&amp;#8217;s reverse iterators. It gets the penultimate element of a collection by advancing an iterator from the reversed beginning of that collection. If you&amp;#8217;re addicted to negative indices you &lt;strong&gt;can&lt;/strong&gt; use them with C++ arrays, sort of.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Negative array indices in C++&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    char const * domain = &quot;wordaligned.org&quot;;
    char const * end = domain + strlen(domain);
    std::cout &amp;lt;&amp;lt; end[-3] &amp;lt;&amp;lt; end[-2] &amp;lt;&amp;lt; end[-1] &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Compiling and running this program outputs the string &amp;#8220;org&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Going back to Python, the valid indices into a sequence of length &lt;code&gt;L&lt;/code&gt; are &lt;code&gt;-L&lt;/code&gt;, &lt;code&gt;-L+1&lt;/code&gt;, &amp;#8230; , &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &amp;#8230; &lt;code&gt;L-1&lt;/code&gt;. Whenever you write code to calculate an index used for accessing a sequence, and especially if you&amp;#8217;re catching any resulting &lt;code&gt;IndexError&lt;/code&gt;s, it&amp;#8217;s worth checking if the result of the calculation can be negative, and if &amp;#8212; in this case &amp;#8212; you really do want the from-the-back indexing behaviour.&lt;/p&gt;
&lt;div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;0&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;1&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;2&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;3&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;4&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;5&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;6&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;7&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;8&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;9&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;10&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;11&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;12&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;13&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;hellip;&lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;W&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;O&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;R&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;D&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;A&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;L&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;I&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;G&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;N&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;E&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;D&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;hellip;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-14&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-13&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-12&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-11&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-10&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-9&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-8&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-7&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-6&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-5&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-4&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-3&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-2&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;-1&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;line-height: 30px;font-family: monospace;text-align:center;border: 1px solid black;width: 30px;height:30px;display:inline-block;&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The power of negative indices increases with slicing. Take a slice of a sequence by supplying begin and end indices.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; domain = &amp;#x27;wordaligned.org&amp;#x27;
&amp;gt;&amp;gt;&amp;gt; domain[4:9]
&amp;#x27;align&amp;#x27;
&amp;gt;&amp;gt;&amp;gt; domain[4:-4]
&amp;#x27;aligned&amp;#x27;
&amp;gt;&amp;gt;&amp;gt; digits = list(range(10))
&amp;gt;&amp;gt;&amp;gt; digits
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&amp;gt;&amp;gt;&amp;gt; digits[3:4]
[3]
&amp;gt;&amp;gt;&amp;gt; digits[1:-1]
[1, 2, 3, 4, 5, 6, 7, 8]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Omitting an index defaults it to the end of the sequence. Omit both indices and both ends of the sequence are defaulted, giving a sliced copy.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; domain[-3:]
&amp;#x27;org&amp;#x27;
&amp;gt;&amp;gt;&amp;gt; domain[:4]
&amp;#x27;word&amp;#x27;
&amp;gt;&amp;gt;&amp;gt; digits[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I prefer the &lt;code&gt;list(digits)&lt;/code&gt; form for copying &lt;code&gt;digits&lt;/code&gt; but you should certainly be familiar with the &lt;code&gt;digits[:]&lt;/code&gt; version.&lt;/p&gt;
&lt;p&gt;You can supply any indices as slice limits, even ones which wouldn&amp;#8217;t be valid for item access. Imagine laying your sequence out on an indexed chopping board, slicing it at the specified points, then taking whatever lies between these points.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; digits[-1000000]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&amp;gt;&amp;gt;&amp;gt; digits[1000000]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&amp;gt;&amp;gt;&amp;gt; digits[-1000000:1000000]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Sequence slicing also takes a step parameter.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; digits[::2]
[0, 2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; digits[1::2]
[1, 3, 5, 7, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This parameter too can be negative. The sign of the step affects which limiting values the &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; slice parameters default to. It&amp;#8217;s subtle behaviour, but you soon get used to it.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; digits[0:10:-2]
[]
&amp;gt;&amp;gt;&amp;gt; digits[::-2]
[9, 7, 5, 3, 1]
&amp;gt;&amp;gt;&amp;gt; digits[-2::-2]
[8, 6, 4, 2, 0]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How do you reverse a string? Slice it back to front!&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; domain[::-1]
&amp;#x27;gro.dengiladrow&amp;#x27;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To recap: the default slice limits are the start and end of the sequence, &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;-1&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; if the step is negative. The default step is &lt;code&gt;1&lt;/code&gt; whichever way round the limits are. When slicing, &lt;code&gt;s[i:j:k]&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; may take any integer value, and &lt;code&gt;k&lt;/code&gt; can take any integer value &lt;strong&gt;except&lt;/strong&gt; &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The zero value creates another interesting edge case. Here&amp;#8217;s a function to return the last &lt;code&gt;n&lt;/code&gt; items of a sequence.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; def tail(xs, n)
...     return xs[-n:]
...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It fails when &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; tail(digits, 3)
[7, 8, 9]
&amp;gt;&amp;gt;&amp;gt; tail(digits, 2)
[8, 9]
&amp;gt;&amp;gt;&amp;gt; tail(digits, 1)
[9]
&amp;gt;&amp;gt;&amp;gt; tail(digits, 0)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;By the way, we&amp;#8217;ve already seen slicing working well with lists and strings. It also works nicely with range objects.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; r = range(10)
&amp;gt;&amp;gt;&amp;gt; r[::2]
range(0, 10, 2)
&amp;gt;&amp;gt;&amp;gt; r[1::2]
range(1, 10, 2)

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2016-08-01</dc:date>
<guid>https://wordaligned.org/articles/negative-sequence-indices-in-python</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/negative-sequence-indices-in-python</link>
<category>C++</category>
</item>

<item>
<title>8 Queens Puzzle++</title>
<description>&lt;p&gt;&lt;a href=&quot;https://wordaligned.org/articles/8-queens-puzzle&quot;&gt;Yesterday I wrote about&lt;/a&gt; a Python solution to the 8 Queens puzzle.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n = 8
sqs = range(n)

Qs = (Q for Q in itertools.permutations(sqs)
      if n == len({Q[i]+i for i in sqs})
           == len({Q[i]-i for i in sqs}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;#8217;s possible to reproduce this strategy in C++:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;range(n) &amp;#8594; &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/iota&quot;&gt;std::iota&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;itertools.permutations &amp;#8594; &lt;a href=&quot;https://wordaligned.org/articles/next-permutation&quot;&gt;std::next_permutation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;set comprehension &amp;#8594; set insertion&lt;/li&gt;
&lt;/ul&gt;
&lt;script src=&quot;https://gist.github.com/wordaligned/c94649d6b37ec08a9bda16e53c43b888.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;The &lt;code&gt;std::next_permutation&lt;/code&gt; algorithm stands alone in the C++ standard library. Used here, it pairs well with the similarly uncommon &lt;code&gt;do ... while&lt;/code&gt; loop. The solution depends on the vector &lt;code&gt;sqs&lt;/code&gt; starting off in sorted order, and by the end of the loop the vector will have been returned to &lt;a href=&quot;https://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort&quot;&gt;this state&lt;/a&gt;.&lt;/p&gt;</description>
<dc:date>2016-04-05</dc:date>
<guid>https://wordaligned.org/articles/8-queens-puzzle-cpp</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/8-queens-puzzle-cpp</link>
<category>C++</category>
</item>

<item>
<title>Easy as Py</title>
<description>&lt;h2 id=&quot;what-makes-python-simple&quot;&gt;What makes Python Simple?&lt;/h2&gt;
&lt;p&gt;I consider Python a simple language. Here&amp;#8217;s why.&lt;/p&gt;
&lt;h2 id=&quot;easy-to-read&quot;&gt;Easy to Read&lt;/h2&gt;
&lt;p&gt;I can read and understand Python code (unless it&amp;#8217;s &lt;a href=&quot;https://benkurtovic.com/2014/06/01/obfuscating-hello-world.html&quot;&gt;wilfully perverse&lt;/a&gt;). Syntactic whitespace and the associated removal of punctuation results in a regular, open layout. The combination of built in containers, extensive standard libraries and high level constructs allow for clear, compact code: code which fits in your head.&lt;/p&gt;
&lt;h2 id=&quot;easy-to-write&quot;&gt;Easy to Write&lt;/h2&gt;
&lt;p&gt;I can write Python code which is free of syntax errors and which does what I want. Of course it helps that I&amp;#8217;ve been actively using the language for 15 years, but I&amp;#8217;ve been using C++ for longer and still make mistakes with it: ask me to declare a pointer to a member function, for example, or to knock up a variadic template function, and I&amp;#8217;ll need a moment or two.&lt;/p&gt;
&lt;h2 id=&quot;transparent&quot;&gt;Transparent&lt;/h2&gt;
&lt;p&gt;I also consider C a simple language. C offers a transparent abstraction of a register machine, with a stack, a heap, and addressable memory. If you can imagine the operation of such a machine, you can figure out C. Python is less transparent but reveals its workings if pressed. Dicts form a part of the language seen by users, and under the hood they provide the dynamic context which supports a running program. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop&quot;&gt;read-eval-print loop&lt;/a&gt; makes it easy to poke and reshape your program. You can &lt;a href=&quot;https://docs.python.org/3/library/dis.html&quot;&gt;disassemble code&lt;/a&gt; to see what the virtual machine sees.&lt;/p&gt;
&lt;h2 id=&quot;consistent-improvement&quot;&gt;Consistent improvement&lt;/h2&gt;
&lt;p&gt;The language has got better since I first started using it. It has also got bigger, and this growth would, at first, seem at odds with simplicity. However, consider &amp;#8212; as an example &amp;#8212; the point when list comprehensions were introduced. Language support for building a list from an iterable results in compact declarative code. Simple code. What&amp;#8217;s more, the square brackets which now delimit list comprehensions are the same square brackets that were previously used to delimit lists. The syntax may have been new but it didn&amp;#8217;t surprise. Now consider the introduction of set and dict comprehensions, which follow logically and naturally from list comprehensions, almost as if they were discovered rather than invented.&lt;/p&gt;
&lt;p&gt;There are many other examples where additions to the language have unified and simplified.&lt;/p&gt;
&lt;h2 id=&quot;vision&quot;&gt;Vision&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m not a Python insider and cannot comment on the exact balance of benevolence and dictatorship which goes into the &lt;a href=&quot;https://www.python.org/dev/peps/&quot;&gt;language enhancement process&lt;/a&gt;. I would say Python doesn&amp;#8217;t suffer from being designed by a committee. It sticks to its strengths and its direction, to its vision.&lt;/p&gt;</description>
<dc:date>2016-03-23</dc:date>
<guid>https://wordaligned.org/articles/easy-as-py</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/easy-as-py</link>
<category>C++</category>
</item>

<item>
<title>2147483647</title>
<description>&lt;h1 id=&quot;magic&quot;&gt;Magic!&lt;/h1&gt;
&lt;p&gt;When software developers refer to &amp;#8220;magic numbers&amp;#8221; they mean those numeric literals which appear in a program without explanation &amp;#8212; as if by magic. Consider the mysterious figures in this incantation:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;int cigarettes()
{
    return 365 * 20 * 10 + 2 * 20 + 17;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Why is the &lt;code&gt;&lt;a href=&quot;http://www.richardbeard.info/category/my-books/x20/
&quot;&gt;20&lt;/a&gt;&lt;/code&gt; repeated? Does the first &lt;code&gt;20&lt;/code&gt; mean the same as the second one? Could &lt;code&gt;365&lt;/code&gt; be the number of days in a year? Named constants would make the code easier to read and maintain.&lt;/p&gt;
&lt;p&gt;Some numbers truly are &lt;strong&gt;magical&lt;/strong&gt; though.&lt;/p&gt;
&lt;h1 id=&quot;2147483647&quot;&gt;2147483647&lt;/h1&gt;
&lt;p&gt;The number 2147483647 is special and terrible.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s a substantial number, far greater than the number of goals Lionel Messi has scored or the number of hot dinners I&amp;#8217;ve eaten, and comparable with the number of heart beats in a lifetime or the number of instructions a processor executes in a second; but it&amp;#8217;s not that large. You&amp;#8217;ll need more than 2147483647 bytes to install a modern operating system, let alone store your video collection. And shuffling a pack of just 52 cards has 80658175170943878571660636856403766975289505440883277824000000000000 possible outcomes.&lt;/p&gt;
&lt;p&gt;If 2147483647 isn&amp;#8217;t remarkable for its size it certainly has a noteworthy history. In 1772 the Swiss mathematician Leonhard Euler proved it a prime. I&amp;#8217;m guessing it was the largest known prime at the time. Euler didn&amp;#8217;t have a computer to hunt for primes so he narrowed the field by focusing on &lt;a href=&quot;http://www.mersenne.org/&quot;&gt;Mersenne numbers&lt;/a&gt; &amp;#8212; numbers one less than a power of two &amp;#8212; a strategy which remains a winner even today, when computers are networked to search.&lt;/p&gt;
&lt;p&gt;Actually, 2147483647 is a double Mersenne prime, which is to say it takes the form 2&lt;sup&gt;m&lt;/sup&gt; - 1, where &lt;code&gt;m&lt;/code&gt; itself takes the form 2&lt;sup&gt;n&lt;/sup&gt; - 1. &lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 2**(2**5 - 1) - 1
2147483647

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Magic!&lt;/p&gt;
&lt;h1 id=&quot;dragons&quot;&gt;Dragons!&lt;/h1&gt;
&lt;p&gt;2147483647 has a special significance for C programmers, who know it by the name &lt;code&gt;INT_MAX&lt;/code&gt;, and for C++ programmers, who demystify the digits as &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Remember, 2147483647 is Mersenne(Mersenne(5)), which is Mersenne(31), or 2 to the power 31 minus 1. In binary arithmetic you add a zero on the right to multiply by 2 so 2 to the 31 is 1 followed by 31 zeros; and subtracting 1 leaves 31 1&amp;#8217;s. It&amp;#8217;s the largest signed value you can fit in a 32 bit register.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; mersenne31 = 2**31-1
&amp;gt;&amp;gt;&amp;gt; bin(mersenne31)
&amp;#x27;0b1111111111111111111111111111111&amp;#x27;
&amp;gt;&amp;gt;&amp;gt; hex(mersenne31)
&amp;#x27;0x7fffffffL&amp;#x27;
&amp;gt;&amp;gt;&amp;gt; mersenne31
2147483647L

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s quite possible to inadvertantly increment an &lt;code&gt;int&lt;/code&gt; which has reached &lt;code&gt;INT_MAX&lt;/code&gt;. The result is undefined behaviour: anything could happen. &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Myth_of_the_Flat_Earth&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/flammarion.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;gangnam-style&quot;&gt;Gangnam Style&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;We never thought a video would be watched in numbers greater than a 32-bit integer (=2,147,483,647 views), but that was before we met PSY. Gangnam Style has been viewed so many times we had to upgrade to a 64-bit integer (9,223,372,036,854,775,808)!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;mdash; &lt;a href=&quot;https://plus.google.com/u/0/wm/4/+youtube/posts/BUXfdWqu86Q&quot;&gt;youtube developers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/psy.png&quot; alt=&quot;Psy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Exactly what undefined behaviour was provoked when PSY&amp;#8217;s popularity broke the magic limit isn&amp;#8217;t disclosed. Maybe a server leaked account details to North Korean hackers. Or maybe the video&amp;#8217;s viewing figures were wrong for a while. &lt;/p&gt;
&lt;p&gt;Note that the new limit of 9,223,372,036,854,775,808 is an unsigned value, which is exempt from this flavour of undefined behaviour and wraps to zero when you bump it up.&lt;/p&gt;
&lt;h1 id=&quot;bugwards-compatibility&quot;&gt;Bugwards compatibility&lt;/h1&gt;
&lt;p&gt;There&amp;#8217;s another reason for preferring &lt;code&gt;INT_MAX&lt;/code&gt; to the magical 2147483647: the two values might be different. 2147483647 is 2147483647 but &lt;code&gt;INT_MAX&lt;/code&gt; depends on the implementation.&lt;/p&gt;
&lt;p&gt;A modern computer probably has 64 bit registers making a 64 bit &lt;code&gt;int&lt;/code&gt; a more natural choice. However, for compatibility reasons, &lt;code&gt;int&lt;/code&gt;s may intentionally be limited to 32 bits!&lt;/p&gt;</description>
<dc:date>2015-02-12</dc:date>
<guid>https://wordaligned.org/articles/2147483647</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/2147483647</link>
<category>C++</category>
</item>

<item>
<title>You wait all day for a bus&#8230;</title>
<description>&lt;p&gt;&lt;a href=&quot;http://docs.python.org/3/library/functions.html#any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://docs.python.org/3/library/functions.html#all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt;  didn&amp;#8217;t appear in Python until version 2.5, released in 2006, when the language was already well into its teens.&lt;/p&gt;
&lt;p&gt;Why the delay in offering such fundamental functions? An oversight? Or simply that they&amp;#8217;re so easy to implement they weren&amp;#8217;t thought necessary. Either way, they&amp;#8217;re here now.&lt;/p&gt;
&lt;p&gt;The functions are closely related and complementary. We can define &lt;code&gt;any&lt;/code&gt; in terms of &lt;code&gt;all&lt;/code&gt; and vice-versa.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def any_(xs):
    return not all(map(operator.not_, xs))

def all_(xs):
    return not any(map(operator.not_, xs))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;C++ reached its 30s before introducing &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/all_any_none_of&quot;&gt;its own versions&lt;/a&gt; of these logical algorithms, &lt;code&gt;any_of&lt;/code&gt; and &lt;code&gt;all_of&lt;/code&gt;, but made up for lost time by finding room for a third, &lt;code&gt;none_of&lt;/code&gt;, which is not &lt;code&gt;any_of&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template &amp;lt;class Iter, class Pred&amp;gt;
bool none_of_(Iter b, Iter e, Pred p)
{
    return std::find_if(b, e, p) == e;
}

template &amp;lt;class Iter, class Pred&amp;gt;
bool any_of_(Iter b, Iter e, Pred p)
{
    return !none_of_(b, e, p);
}

template &amp;lt;class Iter, class Pred&amp;gt;
bool all_of_(Iter b, Iter e, Pred p)
{
    return !any_of_(b, e, std::not1(p));
}

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2013-10-02</dc:date>
<guid>https://wordaligned.org/articles/all-any-none</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/all-any-none</link>
<category>C++</category>
</item>

<item>
<title>Reverse, Esrever</title>
<description>&lt;p&gt;&lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/reverse&quot;&gt;Reverse&lt;/a&gt;&lt;/code&gt; is a member of the C++ standard library, but its reverse, &lt;code&gt;esrever&lt;/code&gt;, isn&amp;#8217;t. Similarly &lt;code&gt;keep&lt;/code&gt; isn&amp;#8217;t but &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/basic_istream/peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; is.&lt;/p&gt;
&lt;p&gt;Can anyone think of a C++ standard library member whose reverse &lt;strong&gt;is also a member&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Answers in the comments below.&lt;/p&gt;
&lt;p&gt;Go!&lt;/p&gt;</description>
<dc:date>2013-09-27</dc:date>
<guid>https://wordaligned.org/articles/reverse-esrever</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/reverse-esrever</link>
<category>C++</category>
</item>

<item>
<title>&#8220;Solutions&#8221;</title>
<description>&lt;p&gt;I like working around enthusiasts and optimists but that doesn&amp;#8217;t mean I want to use chirpy or bombastic software.&lt;/p&gt;
&lt;p&gt;These days I build programs using visual studio. Sure, it&amp;#8217;s a decent tool but part of me cringes every time I&amp;#8217;m asked to open a &lt;strong&gt;&amp;#8220;Solution&amp;#8221;&lt;/strong&gt; especially when what I get seems more like a &lt;strong&gt;&amp;#8220;Muddle&amp;#8221;&lt;/strong&gt;. A progress bar slides into action after my program links: &lt;strong&gt;&amp;#8220;Updating Intellisense &amp;#8230;&amp;#8221;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Who coined that galumphing portmanteau? It means auto-completion and I don&amp;#8217;t want to know it&amp;#8217;s going on &amp;#8212; especially since I edit code using &lt;a href=&quot;https://wordaligned.org/articles/accidental-emacs.html&quot;&gt;Emacs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Perforce is new to me and I lean on a &lt;a href=&quot;http://www.perforce.com/product/components/perforce-visual-client&quot; title=&quot;P4V&quot;&gt;graphical client&lt;/a&gt; so heavily I sometimes trip over it. So when I&amp;#8217;m trying to dance round client workspaces and their half-baked integration with microsoft &lt;del&gt;muddles&lt;/del&gt; solutions, the last thing I want is to be asked to &lt;strong&gt;&amp;#8220;Choose a Favorite Connection&amp;#8221;&lt;/strong&gt;. When it comes to Perforce Servers I don&amp;#8217;t have favourites let alone favorites. Sorry.&lt;/p&gt;</description>
<dc:date>2013-04-17</dc:date>
<guid>https://wordaligned.org/articles/solutions</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/solutions</link>
<category>C++</category>
</item>

<item>
<title>ACCU 2013</title>
<description>&lt;p&gt;&lt;img src=&quot;http://accu.org/content/images/conferences/2013/accu2013web.png&quot; alt=&quot;ACCU 2013&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Brian Marick opened the second day of ACCU 2013 with a keynote presentation entitled: &lt;a href=&quot;http://accu.org/index.php/conferences/accu_conference_2013/accu2013_sessions#cheating_decline:acting_now_to_let_you_program_well_for_a_really_long_time&quot;&gt;&amp;#8220;Cheating Decline: Acting now to let you program well for a really long time&amp;#8221;&lt;/a&gt;. He drew a distinction between effortful and automatic thinking. For example, we can drive a car along a clear road automatically but it requires considerable concentration to parallel park that same car. By tuning out unwanted signals crickets can locate their mates using minimal brainpower, and cricket players have no need of Newtonian dynamics to track the trajectory of a ball &amp;#8212; they apply a simple visual self-calibrating algorithm to catch out batsmen. Tango dancers disturb and re-establish invariants. A robot can walk for hours without thinking about what it&amp;#8217;s doing. Actually, if it&amp;#8217;s your job to park cars, you can probably do &lt;strong&gt;that&lt;/strong&gt; without thinking; and this was Brian Marick&amp;#8217;s main cheat &amp;#8212; find the work practices which allow you to lean on your perceptions and so avoid effortful thinking.&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://www.youtube.com/embed/rhu2xNIpgDE?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Anthony Williams&amp;#8217; talk on &lt;a href=&quot;http://accu.org/index.php/conferences/accu_conference_2013/accu2013_sessions#c_11_features_and_real-world_code&quot;&gt;C++11 Features and Real World code&lt;/a&gt; did require effortful thinking but that was what I&amp;#8217;d hoped for. He provided a concise and expert summary of the new language features in action, focusing on the biggest early winners. Leading with &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;, &lt;code&gt;range-for&lt;/code&gt;, he went on to talk about concurrency and move semantics. I learned that &lt;code&gt;lambda&lt;/code&gt; functions can have a mutable qualifier. Ha!&lt;/p&gt;
&lt;p&gt;I couldn&amp;#8217;t resist &lt;a href=&quot;http://www.pvv.org/~oma/&quot;&gt;Olve Maudal&amp;#8217;s&lt;/a&gt; C++11 pub quiz, appropriately held in the Marriot Hotel bar, for which we formed teams and mentally compiled and executed dodgy code, capturing standard output on an answer sheet. Some of the answers may well have have been implementation dependent but Olve specified an implementation: our answers should match &lt;strong&gt;this&lt;/strong&gt; laptop running &lt;strong&gt;this&lt;/strong&gt; software. I was simultaneously appalled by the limits of my knowledge on fundamental subjects such as integral promotion and initialisation order, and surprised by my ability to correctly predict the behaviour of some esoteric and perverse code. I&amp;#8217;m chastened and will be studying the answers in the cold light of day. Brian Marick may have advocated programming after a beer or two in his morning session, but the afternoon pub quiz proved that coffee works better for me!&lt;/p&gt;
&lt;p&gt;A programmer&amp;#8217;s dozen (13, which is 12 counting from zero!) lightning talks kept the day crackling with energy. Ewan Milne chaired the session expertly, adeptly dispatching a birthday cake as proceedings commenced. I wish I could describe all the talks but you really had to be there. Phil Nash&amp;#8217;s use of the little known &lt;a href=&quot;http://ideone.com/jWHxu2&quot;&gt;left arrow operator&lt;/a&gt; &amp;larr; got a well deserved response from the audience. Sander Hoogendoorn stuck the boot into &lt;a href=&quot;http://sanderhoogendoorn.com/blog/?p=1059&quot;&gt;&amp;#8220;Agile Fluffiness&amp;#8221;&lt;/a&gt;. &lt;a href=&quot;http://www.renaissancesoftware.net/blog/&quot;&gt;James Grenning&amp;#8217;s&lt;/a&gt; talk on embedded development was a lightning keynote: hilarious, moving and, ultimately, tragic.&lt;/p&gt;</description>
<dc:date>2013-04-11</dc:date>
<guid>https://wordaligned.org/articles/accu-2013</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/accu-2013</link>
<category>C++</category>
</item>

<item>
<title>More adventures in C++</title>
<description>&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;bool operator&amp;lt;(version const &amp;amp; v1, version const &amp;amp; v2)
{
    if (v1.major != v2.major)
        return v1.major &amp;lt; v2.major;
    if (v1.minor != v2.minor)
        return v1.minor &amp;lt; v2.minor;
    if (v1.patch != v2.patch)
        return v1.patch &amp;lt; v2.patch;
    return v1.build &amp;lt; v2.build;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;C++ programmers are sticklers for tradition and unlikely to be swayed by &lt;a href=&quot;http://www.zemanta.com/blog/i-bet-you-over-engineered-your-startup/#comment-685047168&quot; title=&quot;unlike web developers&quot;&gt;what&amp;#8217;s in fashion&lt;/a&gt;. C++ suits those who want to control the machine, and who respect the rigour and discipline this imposes. C++ programmers are generally a conservative bunch.&lt;/p&gt;
&lt;p&gt;Some history: C++ was standardized in 1998. The next major revision of the language was developed under the working title of C++0x, where the &amp;#8220;0x&amp;#8221; stood for the year the job would be finished. The X gave the standardizers some slack, but not enough. C++0x became C++11 which is now, thankfully, simply C++.&lt;/p&gt;
&lt;p&gt;Although the language&amp;#8217;s development has been painstakingly slow the developments themselves have been extensive and radical. What&amp;#8217;s more, users are rushing to use the new features &amp;#8212; even before they have access to compilers which support them! I&amp;#8217;ve seen answers to C++ topics on Q&amp;amp;A sites which use aspects of the language the contributors cheerfully admit they have no access to. I&amp;#8217;ve worked on a project which used elaborate shims to hide the fact that GCC 4.6 couldn&amp;#8217;t compile C++ as well as GCC 4.7 does, and this despite the fact that &lt;a href=&quot;http://gcc.gnu.org/projects/cxx0x.html&quot; title=&quot;Important: GCC&#x27;s support for C++11 is still experimental&quot;&gt;GCC&amp;#8217;s C++11 support remains, officially, &amp;#8220;experimental&amp;#8221;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;p&gt;At home, I&amp;#8217;m downloading compiler and library updates I&amp;#8217;m in no position to use at work; and at work, I&amp;#8217;ve already been sent on a C++11 training course.  I&amp;#8217;ve streamed high quality &lt;a href=&quot;http://channel9.msdn.com/Events/GoingNative/GoingNative-2012&quot; title=&quot;Going Native 2012 - good stuff here!&quot;&gt;videos&lt;/a&gt; starring C++&amp;#8217;s big hitters which promote the new C++, explaining its principles, its foundations, and even where it&amp;#8217;s going next.&lt;/p&gt;
&lt;p&gt;What exactly is it about C++11 that&amp;#8217;s roused such a normally phlegmatic audience?&lt;/p&gt;
&lt;p&gt;Before I try and answer that, I&amp;#8217;ll venture to suggest new C++ isn&amp;#8217;t going to win many new recruits. I don&amp;#8217;t even think it will persuade those who have abandoned the language to return. C++11 contains all of C++98, a notoriously complex and subtle language, then adds &lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#learn&quot; title=&quot;Is C++11 hard to learn? Stroustrup C++11 FAQ&quot;&gt;a whole lot more&lt;/a&gt;. Yes, it &lt;strong&gt;is&lt;/strong&gt; possible to write new C++ which is more compact and efficient than traditional C++, but you&amp;#8217;ll also need to maintain old C++ code and build new expertise. And the language update fails to address some of C++&amp;#8217;s worst characteristics: slow compile times and impenetrable compiler diagnostics.&lt;/p&gt;
&lt;p&gt;No, C++11 is primarily a win for existing C++ programmers; those of us who already have a fair understanding of the language and its trade-offs, and who can appreciate the rationale behind the changes. For traditionalists and pragmatists, the transition isn&amp;#8217;t hard &amp;#8212; at least, no harder than any port between compiler revisions. For progressives, there are several immediate wins: the &lt;code&gt;auto&lt;/code&gt; keyword has been repurposed, reducing repetition and making code more flexible; lambdas enable functions to be plugged directly into algorithms; smart pointers are standard, allowing accurate memory management; and on the subject of memory, rvalues and move semantics mean you&amp;#8217;ll waste less of it on temporaries.&lt;/p&gt;
&lt;p&gt;I could go on.&lt;/p&gt;
&lt;p&gt;Rather than risk more generalisations, here&amp;#8217;s a specific example of C++11 in action. Consider an object with multiple fields, a four part version number, say.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;struct version
{
    unsigned major, minor, patch, build;
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To compare version numbers, or sort them, or put them in a &lt;code&gt;std::set&lt;/code&gt;, we&amp;#8217;ll need &lt;code&gt;operator&amp;lt;()&lt;/code&gt;. This operator must model a &lt;a href=&quot;http://www.sgi.com/tech/stl/StrictWeakOrdering.html&quot;&gt;strict weak ordering&lt;/a&gt;. The canonical form looks something like.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;bool operator&amp;lt;(version const &amp;amp; v1, version const &amp;amp; v2)
{
    if (v1.major != v2.major)
        return v1.major &amp;lt; v2.major;
    if (v1.minor != v2.minor)
        return v1.minor &amp;lt; v2.minor;
    if (v1.patch != v2.patch)
        return v1.patch &amp;lt; v2.patch;
    return v1.build &amp;lt; v2.build;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;#8217;s not so hard to write this code for the &lt;code&gt;version&lt;/code&gt; struct, where we have a clear idea of what it means for one version number to be less than another. It would be rather more tricky if we were dealing with points, for example, &lt;code&gt;struct point { int x, y; };&lt;/code&gt;. Ordering points makes little sense but we might well want them as keys in an associative container, and we&amp;#8217;d better have a suitable &lt;code&gt;operator&amp;lt;()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;No, no, no!&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;bool operator&amp;lt;(point const &amp;amp; p1, point const &amp;amp; p2)
{
    return p1.x &amp;lt; p2.x &amp;amp;&amp;amp; p1.y &amp;lt; p2.y;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;With C++11 &amp;#8212; &lt;strong&gt;with the current version of C++&lt;/strong&gt; &amp;#8212; we can use &lt;code&gt;std::tie()&lt;/code&gt; to create a tuple of references, recasting &lt;code&gt;operator&amp;lt;()&lt;/code&gt; into a form that&amp;#8217;s easy to read and hard to get wrong.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Yes, yes, yes!&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;bool operator&amp;lt;(version const &amp;amp; v1, version const &amp;amp; v2)
{
    return std::tie(v1.major, v1.minor, v1.patch, v1.build)
         &amp;lt; std::tie(v2.major, v2.minor, v2.patch, v2.build);
}

bool operator&amp;lt;(point const &amp;amp; p1, point const &amp;amp; p2)
{
    return std::tie(p1.x, p1.y) &amp;lt; std::tie(p2.x, p2.y);
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p style=&quot;text-align:center&quot;&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;My thanks to Jonathan Wakely for sharing the &lt;code&gt;std::tie()&lt;/code&gt; recipe on the &lt;a href=&quot;http://accu.org/index.php/mailinglists&quot;&gt;accu-general mailing list&lt;/a&gt; and for letting me use it here.&lt;/p&gt;</description>
<dc:date>2013-02-21</dc:date>
<guid>https://wordaligned.org/articles/more-adventures-in-c++</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/more-adventures-in-c++</link>
<category>C++</category>
</item>

<item>
<title>Singly Linked Lists in C++</title>
<description>&lt;p&gt;In a &lt;a href=&quot;https://wordaligned.org/articles/two-star-programming.html&quot;&gt;recent post&lt;/a&gt; I wrote about removing items from a singly linked list. I presented a couple of alternative implementations, and in the comments section readers suggested yet more versions.&lt;/p&gt;
&lt;p&gt;My implementations were written in C: the post was inspired by something &lt;a href=&quot;http://meta.slashdot.org/story/12/10/11/0030249/linus-torvalds-answers-your-questions&quot;&gt;Linus Torvalds had said&lt;/a&gt; about low-level programming skills, and I&amp;#8217;m guessing he meant C programming skills. The fact is, C programmers are condemned to reimplement these basic functions on this basic structure because the C standard library has nothing to say about singly linked lists. Until recently the C++ standard library was similarly silent on the subject, only offering a doubly linked list.&lt;/p&gt;
&lt;h3 id=&quot;c-introduces-the-linked-list&quot;&gt;C++ introduces &amp;#8230; the linked list!&lt;/h3&gt;
&lt;p&gt;That&amp;#8217;s all changed now with the introduction of &lt;code&gt;std::forward_list&lt;/code&gt;. The &lt;a href=&quot;http://en.cppreference.com/w/cpp/container/forward_list&quot;&gt;class interface&lt;/a&gt; doesn&amp;#8217;t mention links or pointers but a quick glance through its contents makes it clear that if you imagine the container to be a templated version of a classic singly-linked list, you won&amp;#8217;t go far wrong.&lt;/p&gt;
&lt;p&gt;This gives &lt;code&gt;forward_list&lt;/code&gt; some members you won&amp;#8217;t find elsewhere in the &lt;code&gt;std::&lt;/code&gt; namespace. For example, &lt;code&gt;std::forward_list::before_begin()&lt;/code&gt;, which returns an iterator just before the beginning of the list &amp;#8212; much as the more familiar &lt;code&gt;end()&lt;/code&gt; is just past the end.&lt;/p&gt;
&lt;p&gt;Why is &lt;code&gt;before_begin()&lt;/code&gt; necessary? You can&amp;#8217;t dereference it and you can&amp;#8217;t reverse through a forward list till you get to it. Well, since forward list iterators can only go forwards, instead of the familiar sequence &lt;code&gt;insert()&lt;/code&gt;, &lt;code&gt;erase()&lt;/code&gt; and &lt;code&gt;emplace()&lt;/code&gt; methods we have &lt;code&gt;insert_after()&lt;/code&gt;, &lt;code&gt;erase_after()&lt;/code&gt; and &lt;code&gt;emplace_after()&lt;/code&gt;, not to mention &lt;code&gt;splice_after()&lt;/code&gt;. The before-the-beginning iterator allows you to use these operations to modify the node at the head of the list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quick question&lt;/strong&gt;: what&amp;#8217;s the complexity of &lt;code&gt;std::list::size()&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Trick question&lt;/strong&gt;: and how about &lt;code&gt;std::forward_list::size()&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;remove_if-for-forward-lists&quot;&gt;Remove_if for forward lists&lt;/h3&gt;
&lt;p&gt;Using pointers-to-pointers to modify linked lists gives this elegant and compact C implementation of &lt;code&gt;remove_if()&lt;/code&gt;, which de-lists all nodes which match a supplied predicate.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;void remove_if(node ** head, remove_fn rm)
{
    for (node** curr = head; *curr; )
    {
        node * entry = *curr;
        if (rm(entry))
        {
            *curr = entry-&amp;gt;next;
            free(entry);
        }
        else
            curr = &amp;amp;entry-&amp;gt;next;
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How does the C++ standard library support this algorithm?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/remove&quot;&gt;&lt;code&gt;Std::remove_if()&lt;/code&gt;&lt;/a&gt; operates on an iterator range, &lt;code&gt;remove_if(first, last, pred)&lt;/code&gt;. All it requires is that the iterators are forward iterators so it should just work on a &lt;code&gt;forward_list&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hang on though: what if &lt;code&gt;pred(*first)&lt;/code&gt; is true? How can a node be removed from a linked list without reference to its predecessor? Actually, the node isn&amp;#8217;t removed &amp;#8212; the value it contains gets overwritten by the value in the first node (if any!) for which the predicate returns false. In fact, &lt;code&gt;remove_if&lt;/code&gt; &lt;strong&gt;doesn&amp;#8217;t remove anything&lt;/strong&gt; from the container! What it does is return an iterator, call it &lt;code&gt;new_last&lt;/code&gt;, such that the range &lt;code&gt;(first, new_last)&lt;/code&gt; holds the elements which have been kept, and &lt;code&gt;(new_last, last)&lt;/code&gt; holds those which have been &amp;#8220;removed&amp;#8221;, which is to say they can still be dereferenced but their value is implementation dependent.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Remove_if&lt;/code&gt; usually pairs up with erase:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;container.erase(remove_if(first, last, pred), last);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;There is no &lt;code&gt;std::forward_list::erase(iterator)&lt;/code&gt; &amp;#8212; remember, we can only erase &lt;strong&gt;after&lt;/strong&gt; &amp;#8212; so the usual remove_if algorithm is of little use for forward lists.&lt;/p&gt;
&lt;h3 id=&quot;forward_listremove_if&quot;&gt;Forward_list::remove_if()&lt;/h3&gt;
&lt;p&gt;As usual, we should &lt;a href=&quot;http://www.informit.com/articles/article.aspx?p=21851&quot; title=&quot;Scott Meyers, Effective STL&quot;&gt;prefer member functions to algorithms with the same names&lt;/a&gt;. C++&amp;#8217;s &lt;code&gt;forward_list&lt;/code&gt; has its very own &lt;code&gt;remove_if&lt;/code&gt; which manipulates pointers rather than moves values, and which really does remove and destroy items.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/container/forward_list/remove&quot;&gt;&lt;code&gt;Forward_list::remove_if()&lt;/code&gt;&lt;/a&gt; operates on the list as a whole, not an iterator range &amp;#8212; as we&amp;#8217;ve seen, an iterator cannot remove itself. I took a look at a couple of implementations of this function to see how it&amp;#8217;s done.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s LLVM&amp;#8217;s libc++ &lt;a href=&quot;http://llvm.org/svn/llvm-project/libcxx/trunk/include/forward_list&quot;&gt;implementation&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template &amp;lt;class _Tp, class _Alloc&amp;gt;
template &amp;lt;class _Predicate&amp;gt;
void
forward_list&amp;lt;_Tp, _Alloc&amp;gt;::remove_if(_Predicate __pred)
{
    iterator __e = end();
    for (iterator __i = before_begin(); __i.__ptr_-&amp;gt;__next_ != nullptr;)
    {
        if (__pred(__i.__ptr_-&amp;gt;__next_-&amp;gt;__value_))
        {
            iterator __j = _VSTD::next(__i, 2);
            for (; __j != __e &amp;amp;&amp;amp; __pred(*__j); ++__j)
                ;
            erase_after(__i, __j);
            if (__j == __e)
                break;
            __i = __j;
        }
        else
            ++__i;
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;There&amp;#8217;s no need for any special treatment of the first list node here, since we have its predecessor, the &lt;code&gt;before_begin()&lt;/code&gt; node. The function does double back though, figuring out the next range to erase before going back to erase it &amp;#8212; and the erase function isn&amp;#8217;t pretty.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template &amp;lt;class _Tp, class _Alloc&amp;gt;
typename forward_list&amp;lt;_Tp, _Alloc&amp;gt;::iterator
forward_list&amp;lt;_Tp, _Alloc&amp;gt;::erase_after(const_iterator __f, const_iterator __l)
{
    __node_pointer __e = const_cast&amp;lt;__node_pointer&amp;gt;(__l.__ptr_);
    if (__f != __l)
    {
        __node_pointer __p = const_cast&amp;lt;__node_pointer&amp;gt;(__f.__ptr_);
        __node_pointer __n = __p-&amp;gt;__next_;
        if (__n != __e)
        {
            __p-&amp;gt;__next_ = __e;
            __node_allocator&amp;amp; __a = base::__alloc();
            do
            {
                __p = __n-&amp;gt;__next_;
                __node_traits::destroy(__a, _VSTD::addressof(__n-&amp;gt;__value_));
                __node_traits::deallocate(__a, __n, 1);
                __n = __p;
            } while (__n != __e);
        }
    }
    return iterator(__e);
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;For comparison, here&amp;#8217;s how GCC&amp;#8217;s &lt;a href=&quot;http://gcc.gnu.org/viewcvs/trunk/libstdc%2B%2B-v3/include/bits/forward_list.tcc?view=markup&quot;&gt;libstdc++ does the same thing&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template&amp;lt;typename _Tp, typename _Alloc&amp;gt;
    template&amp;lt;typename _Pred&amp;gt;
      void
      forward_list&amp;lt;_Tp, _Alloc&amp;gt;::
      remove_if(_Pred __pred)
      {
    _Node* __curr = static_cast&amp;lt;_Node*&amp;gt;(&amp;amp;this-&amp;gt;_M_impl._M_head);
        while (_Node* __tmp = static_cast&amp;lt;_Node*&amp;gt;(__curr-&amp;gt;_M_next))
          {
            if (__pred(*__tmp-&amp;gt;_M_valptr()))
              this-&amp;gt;_M_erase_after(__curr);
            else
              __curr = static_cast&amp;lt;_Node*&amp;gt;(__curr-&amp;gt;_M_next);
          }
      }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, erasing (after a) node reads:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template&amp;lt;typename _Tp, typename _Alloc&amp;gt;
    _Fwd_list_node_base*
    _Fwd_list_base&amp;lt;_Tp, _Alloc&amp;gt;::
    _M_erase_after(_Fwd_list_node_base* __pos)
    {
      _Node* __curr = static_cast&amp;lt;_Node*&amp;gt;(__pos-&amp;gt;_M_next);
      __pos-&amp;gt;_M_next = __curr-&amp;gt;_M_next;
      _Tp_alloc_type __a(_M_get_Node_allocator());
      allocator_traits&amp;lt;_Tp_alloc_type&amp;gt;::destroy(__a, __curr-&amp;gt;_M_valptr());
      __curr-&amp;gt;~_Node();
      _M_put_node(__curr);
      return __pos-&amp;gt;_M_next;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This version walks through the list removing nodes which match the predicate as it finds them. Don&amp;#8217;t be confused by &lt;code&gt;&amp;amp;this-&amp;gt;_M_impl._M_head&lt;/code&gt;: it&amp;#8217;s not the node at the head of the list, it&amp;#8217;s the one before.&lt;/p&gt;
&lt;h3 id=&quot;lessons-from-c&quot;&gt;Lessons from C++&lt;/h3&gt;
&lt;p&gt;Maybe this code wouldn&amp;#8217;t persaude Linus Torvalds to rethink &lt;a href=&quot;http://harmful.cat-v.org/software/c++/linus&quot; title=&quot;C++ is a horrible language&quot;&gt;his opinion of C++&lt;/a&gt;, but if you can see past the angle brackets, underscores and allocators, it&amp;#8217;s simple enough.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s also:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;subtle, so I&amp;#8217;m glad someone else has written and checked it&lt;/li&gt;
&lt;li&gt;generic, so I can put what I want in a list without casting or indirection&lt;/li&gt;
&lt;li&gt;standard, so I know what to expect&lt;/li&gt;
&lt;li&gt;supported&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The before-begin node idea serves &lt;a href=&quot;https://wordaligned.org/articles/two-star-programming.html#comment-760751047&quot;&gt;equally well in C&lt;/a&gt;, enabling list modifiers which have no need of double indirection or special case code for the list head.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;void remove_after(node * prev, remove_fn rm)
{
    while (prev-&amp;gt;next != NULL)
    {
        node * curr = prev-&amp;gt;next;
        if (rm(curr))
        {
            prev-&amp;gt;next = curr-&amp;gt;next;
            free(curr);
        }
        else
            prev = curr;
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Pass this function the before-begin node to remove all items from the list which match the predicate. &lt;/p&gt;</description>
<dc:date>2013-02-07</dc:date>
<guid>https://wordaligned.org/articles/singly-linked-lists-in-c++</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/singly-linked-lists-in-c++</link>
<category>C++</category>
</item>

<item>
<title>C++ Concurrency in Action</title>
<description>&lt;p&gt;&lt;span style=&quot;text-align:center;font-size:72px;color:gold;&quot;&gt;&amp;#9733;&amp;#9733;&amp;#9733;&amp;#9733;&amp;#9733;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.amazon.co.uk/C-Concurrency-Action-Practical-Multithreading/dp/1933988770&quot; title=&quot;C++ Concurrency in Action, on Amazon&quot;&gt;C++ Concurrency in Action&lt;/a&gt; is an excellent book. You should buy it if you want to use the support for concurrency added by the new C++ standard, C++11; and if you&amp;#8217;re using C++11 you&amp;#8217;ll deepen your understanding of the various language enhancements and how they work together.&lt;/p&gt;
&lt;div class=&quot;amazon&quot;&gt;&lt;a href=&quot;http://www.amazon.co.uk/C-Concurrency-Action-Practical-Multithreading/dp/1933988770&quot;&gt;&lt;img src=&quot;http://www.justsoftwaresolutions.co.uk/images/ccia.jpg&quot; alt=&quot;C++ Concurrency in Action cover&quot;&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Who&amp;#8217;s the author? What makes him qualified to write this book?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.justsoftwaresolutions.co.uk/&quot; title=&quot;Anthony Willams&#x27; website&quot;&gt;Anthony Williams&lt;/a&gt; is a UK-based developer and consultant with many years experience in C++. He has been an active member of the BSI C++ Standards Panel since 2001, and is author or coauthor of many of the C++ Standards Committee papers that led up to the inclusion of the thread library in the new C++ Standard, known as C++11 or C++0x. He has been the maintainer of the Boost Thread library since 2006, and is the developer of the &lt;a href=&quot;http://www.stdthread.co.uk/&quot; title=&quot;just::thread, a C++ Standard Thread Library implementation&quot;&gt;just::thread&lt;/a&gt; implementation of the C++11 thread library from Just Software Solutions Ltd. Anthony lives in the far west of Cornwall, England. &amp;#8212; &lt;a href=&quot;http://www.manning.com/williams/&quot; title=&quot;Williams&#x27; author page on Manning website&quot;&gt;About the Author, Manning website&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It&amp;#8217;s clear the experience of writing papers for the standards committee has paid off. The book is well organised and clearly written. Accurate and thorough, it&amp;#8217;s also a pleasure to read. The examples are practical, and range from launching threads through to lock-free message queues. The largest case study &amp;#8212; a message passing framework and an ATM application built on this framework &amp;#8212; shows the expert use of modern C++ to write elegant and compact code.&lt;/p&gt;
&lt;p&gt;The clarity of the text is matched by the book&amp;#8217;s clean and functional design. It looks good. I bought the dead-tree version which gave me free access to the ebook and I&amp;#8217;ve made use of both formats.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m new to C++11 and compilers are still catching up with the standard. This book is steeped in C++11. Reading through it, I came to realise that a close look at the standard thread library helps explain the evolution of the language as a whole: so &lt;strong&gt;that&amp;#8217;s&lt;/strong&gt; why variadic templates are needed, and move semantics work &lt;strong&gt;there&lt;/strong&gt;, and &amp;#8212; &lt;strong&gt;I get it!&lt;/strong&gt; &amp;#8212; lambda functions fit nicely with condition variables.&lt;/p&gt;
&lt;p&gt;Recommended++&lt;/p&gt;</description>
<dc:date>2013-01-21</dc:date>
<guid>https://wordaligned.org/articles/c++-concurrency-in-action</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/c++-concurrency-in-action</link>
<category>C++</category>
</item>

<item>
<title>Set.insert or set.add?</title>
<description>&lt;h2 id=&quot;get-set-go&quot;&gt;Get set, go!&lt;/h2&gt;
&lt;p&gt;Suppose you have an element &lt;code&gt;e&lt;/code&gt; to put in a set &lt;code&gt;S&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Should you:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;S.add(e)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;or:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;S.insert(e)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;?&lt;/p&gt;
&lt;p&gt;It depends on which language you&amp;#8217;re using. I use C++ and Python and I usually get it wrong.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; S.insert(e)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &amp;#x27;set&amp;#x27; object has no attribute &amp;#x27;insert&amp;#x27;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Try again!&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;error: &amp;#x27;class std::set&amp;lt;int, std::less&amp;lt;int&amp;gt;, std::allocator&amp;lt;int&amp;gt; &amp;gt;&amp;#x27; 
has no member named &amp;#x27;add&amp;#x27;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Maybe my &lt;a href=&quot;https://wordaligned.org/articles/accidental-emacs.html&quot; title=&quot;Emacs of course!&quot;&gt;IDE&lt;/a&gt; should auto-complete the correct member function but it doesn&amp;#8217;t, or at least I haven&amp;#8217;t configured it to, so instead I&amp;#8217;ve worked out how to remember.&lt;/p&gt;
&lt;p&gt;Now, neither C++ nor Python pins down how a set should be implemented &amp;#8212; read the language standard and reference manual respectively and all you&amp;#8217;ll get is an interface and some hints. Read between the lines of these references, though, or study &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01064_source.html&quot; title=&quot;G++ stl_tree.h, on which std::sets and std::multisets are based&quot;&gt;the&lt;/a&gt; &lt;a href=&quot;http://svn.python.org/view/python/trunk/Objects/setobject.c?view=markup&quot; title=&quot;setobject.c, from CPython&quot;&gt;implementations&lt;/a&gt;, and you&amp;#8217;ll soon realise a Python set is an unordered container designed for fast membership, union, intersection, and differencing operations &amp;#8212; much like the mathematical sets I learned about at school &amp;#8212; whereas a C++ set is an ordered container, featuring logarithmic access times and persistent iterators. &lt;/p&gt;
&lt;p&gt;Think: C++ set &amp;asymp; binary tree; Python set &amp;asymp; hashed array.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s apparent which method is correct for which language now. To put something into a binary tree you must recurse down the tree and find where to &lt;strong&gt;insert&lt;/strong&gt; it. Hence &lt;code&gt;std::set::insert()&lt;/code&gt; is correct C++. To put something into a hashed array you hash it and &lt;strong&gt;add&lt;/strong&gt; it right there. Hence &lt;code&gt;set.add()&lt;/code&gt; is proper Python.&lt;/p&gt;
&lt;h2 id=&quot;how-long-is-a-string&quot;&gt;How long is a string?&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m suggesting programmers should know at least some of what goes on in their standard language library implementations. Appreciating an API isn&amp;#8217;t always enough. You &lt;strong&gt;insert&lt;/strong&gt; into trees and &lt;strong&gt;add&lt;/strong&gt; to hashes: so if your set is a tree, call &lt;code&gt;S.insert()&lt;/code&gt;, and if it&amp;#8217;s a hash, &lt;code&gt;S.add()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Such logical arguments don&amp;#8217;t always deliver.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Suppose now that &lt;code&gt;S&lt;/code&gt; is a string and you&amp;#8217;re after its length. Should you use &lt;code&gt;S.length()&lt;/code&gt; or &lt;code&gt;S.size()&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Neither or both.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/the-g-uk/3867089043/&quot; title=&quot;string [how long?] by the|G|, on Flickr&quot;&gt;&lt;img src=&quot;http://farm3.static.flickr.com/2538/3867089043_2f2b3f5fa6.jpg&quot; width=&quot;485&quot; height=&quot;149&quot; alt=&quot;string [how long?]&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In Python a string is a standard sequence and as for all other sequences &lt;code&gt;len(S)&lt;/code&gt; does the trick. In C++ a string is a standard container and as for all other containers &lt;code&gt;S.size()&lt;/code&gt; returns the number of elements; &lt;strong&gt;but&lt;/strong&gt;, being &lt;code&gt;std::string&lt;/code&gt;, &lt;code&gt;S.length()&lt;/code&gt; does too.&lt;/p&gt;
&lt;p&gt;Oh, and the next revision of C++ features an &lt;code&gt;unordered_set&lt;/code&gt; (available now as &lt;code&gt;std::tr1::unordered_set&lt;/code&gt;) which is a hashed container. I think &lt;code&gt;unordered_set&lt;/code&gt; is a poor name for something which models a set better than &lt;code&gt;std::set&lt;/code&gt; does but that&amp;#8217;s the price it pays for coming late to the party. And you don&amp;#8217;t &lt;code&gt;std::unordered_set::add&lt;/code&gt; elements to it, you &lt;code&gt;std::unordered_set::insert&lt;/code&gt; them.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;My thanks to &lt;a href=&quot;http://www.flickr.com/photos/the-g-uk&quot;&gt;the|G|&amp;trade;&lt;/a&gt; for permission to use his &lt;a href=&quot;http://www.flickr.com/photos/the-g-uk/3867089043&quot; title=&quot;string [how long?] on Flickr&quot;&gt;string&lt;/a&gt;.&lt;/p&gt;</description>
<dc:date>2010-11-17</dc:date>
<guid>https://wordaligned.org/articles/setinsert-or-setadd</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/setinsert-or-setadd</link>
<category>C++</category>
</item>

<item>
<title>Define pedantic</title>
<description>&lt;p&gt;My dictionary &lt;span id=&quot;definition&quot;&gt;defines a pedant&lt;/span&gt; as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;pedant&lt;/strong&gt; &lt;em&gt;n.&lt;/em&gt; &lt;strong&gt;1.&lt;/strong&gt; A person who relies too much on academic learning or who is concerned chiefly with academic detail.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Apparently the word derives from the Italian, &lt;em&gt;pedante&lt;/em&gt;, meaning teacher. During my career as a computer programmer a number of my colleagues have been surprisingly pedantic about the proper use of English.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;#8220;I refuse to join a supermarket queue marked &lt;strong&gt;10 items or less&lt;/strong&gt;.&amp;#8221;&lt;/p&gt;
&lt;p&gt;&amp;#8220;I do wish people would stop using &lt;strong&gt;target&lt;/strong&gt; as a verb. You &lt;strong&gt;aim&lt;/strong&gt; at a target, you don&amp;#8217;t &lt;strong&gt;target&lt;/strong&gt; it.&amp;#8221;&lt;/p&gt;
&lt;p&gt;&amp;#8220;I am an exceptionally &lt;strong&gt;skilled grammarian&lt;/strong&gt; in English &amp;#8230; Take that rule and shove it!&amp;#8221;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some of this fussiness may well be a reaction against &lt;a href=&quot;http://news.bbc.co.uk/1/hi/7457287.stm&quot;&gt;corporate double-speak&lt;/a&gt;. Still, I wouldn&amp;#8217;t have expected programmers to be 1) so particular and 2) so certain they&amp;#8217;re right. Maybe this attitude comes from all those years of writing code. Programming languages are strict about what they&amp;#8217;ll accept: after all, they have standards!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/thomasguest/5142421926/&quot; title=&quot;The C++ Standard vs Perl in a Nutshell by Thomas Guest, on Flickr&quot;&gt;&lt;img src=&quot;http://farm2.static.flickr.com/1072/5142421926_6b76c52749_m.jpg&quot; width=&quot;240&quot; height=&quot;183&quot; alt=&quot;The C++ Standard vs Perl in a Nutshell&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Some programming languages are more pedantic than others. Paul Graham memorably characterises C++ as a pernickety aunt&lt;a id=&quot;fn1link&quot; href=&quot;https://wordaligned.org/articles/define-pedantic#fn1&quot;&gt;&lt;sup&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;. By contrast, Perl won&amp;#8217;t pick nits. Designed by Larry Wall to be his software &lt;a href=&quot;http://www.wall.org/~larry/pm.html&quot; title=&quot;Perl, the first postmodern computer language. Larry Wall&quot;&gt;butler&lt;/a&gt;, Perl interprets your ill-expressed wishes with discretion and assurance. Hence you can end up with a Perl program which gets on with its job but which no-one fully understands.&lt;/p&gt;
&lt;p&gt;Pedants, by definition, take things too far, but pedantry in programming isn&amp;#8217;t all bad. GCC has a useful &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Standards.html&quot;&gt;&lt;code&gt;-pedantic&lt;/code&gt;&lt;/a&gt; flag. It helps you write portable programs. Perl has a &lt;a href=&quot;http://perldoc.perl.org/strict.html&quot;&gt;&lt;code&gt;use strict&lt;/code&gt;&lt;/a&gt; pragma which recasts the butler as a personal trainer. &lt;/p&gt;
&lt;p&gt;When it comes to correctness, attention to detail matters. What if this input parameter goes negative? Will that file be closed when an exception is thrown? Can your algorithm handle an empty container?&lt;/p&gt;
&lt;p&gt;I recently fixed a defect in some (of my own) code which assumed conformant input. When faced with garbage-in this code failed even to generate garbage-out, instead getting caught in an infinite loop. Should a pedantic program insist on correct inputs or should it consider how to handle all possible inputs? &lt;a href=&quot;https://wordaligned.org/articles/define-pedantic#definition&quot;&gt;Define pedantic&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a id=&quot;fn1&quot; href=&quot;https://wordaligned.org/articles/define-pedantic#fn1link&quot;&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/a&gt;: It turns out my memory is at fault here. When I checked the reference I discovered Paul Graham makes no explicit mention of C++. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We need a language that lets us scribble and smudge and smear, not a language where you have to sit with a teacup of types balanced on your knee and make polite conversation with a strict old aunt of a compiler. &amp;#8212; Paul Graham, &lt;a href=&quot;http://www.paulgraham.com/hp.html&quot; title=&quot;Hackers and Painters&quot;&gt;Hackers and Painters&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You might have guessed which language he&amp;#8217;s promoting for scribbling but there&amp;#8217;s no mention of Lisp either in this particular essay. In fact only one programming language earns a name-check. I&amp;#8217;ll let you find out which one for yourselves.&lt;/p&gt;</description>
<dc:date>2010-11-02</dc:date>
<guid>https://wordaligned.org/articles/define-pedantic</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/define-pedantic</link>
<category>C++</category>
</item>

<item>
<title>Hiding iterator boilerplate behind a Boost facade</title>
<description>&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/davehamster/2336911145/&quot; title=&quot;SS Great Britain by Dave Hamster, on Flickr&quot;&gt;&lt;img src=&quot;http://farm3.static.flickr.com/2379/2336911145_5275811ec0_m.jpg&quot; width=&quot;240&quot; height=&quot;160&quot; alt=&quot;SS Great Britain&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;filling-in-missing-methods-python&quot;&gt;Filling in missing methods. Python&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s another wholesome &lt;a href=&quot;http://code.activestate.com/recipes/576685&quot; title=&quot;Total ordering class decorator, by Raymond Hettinger&quot;&gt;recipe&lt;/a&gt; served up by Raymond Hettinger.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Total ordering class decorator&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def total_ordering(cls):
    &amp;#x27;Class decorator that fills-in missing ordering methods&amp;#x27;    
    convert = {
        &amp;#x27;__lt__&amp;#x27;: [(&amp;#x27;__gt__&amp;#x27;, lambda self, other: other &amp;lt; self),
                   (&amp;#x27;__le__&amp;#x27;, lambda self, other: not other &amp;lt; self),
                   (&amp;#x27;__ge__&amp;#x27;, lambda self, other: not self &amp;lt; other)],
        &amp;#x27;__le__&amp;#x27;: [(&amp;#x27;__ge__&amp;#x27;, lambda self, other: other &amp;lt;= self),
                   (&amp;#x27;__lt__&amp;#x27;, lambda self, other: not other &amp;lt;= self),
                   (&amp;#x27;__gt__&amp;#x27;, lambda self, other: not self &amp;lt;= other)],
        &amp;#x27;__gt__&amp;#x27;: [(&amp;#x27;__lt__&amp;#x27;, lambda self, other: other &amp;gt; self),
                   (&amp;#x27;__ge__&amp;#x27;, lambda self, other: not other &amp;gt; self),
                   (&amp;#x27;__le__&amp;#x27;, lambda self, other: not self &amp;gt; other)],
        &amp;#x27;__ge__&amp;#x27;: [(&amp;#x27;__le__&amp;#x27;, lambda self, other: other &amp;gt;= self),
                   (&amp;#x27;__gt__&amp;#x27;, lambda self, other: not other &amp;gt;= self),
                   (&amp;#x27;__lt__&amp;#x27;, lambda self, other: not self &amp;gt;= other)]
    }
    roots = set(dir(cls)) &amp;amp; set(convert)
    assert roots, &amp;#x27;must define at least one ordering operation: &amp;lt; &amp;gt; &amp;lt;= &amp;gt;=&amp;#x27;
    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__
    for opname, opfunc in convert[root]:
        if opname not in roots:
            opfunc.__name__ = opname
            opfunc.__doc__ = getattr(int, opname).__doc__
            setattr(cls, opname, opfunc)
    return cls

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If you have a class, &lt;code&gt;X&lt;/code&gt;, which implements one or more of the ordering operators, &lt;code&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; then &lt;code&gt;total_ordering(X)&lt;/code&gt; adapts and returns the class with the missing operators filled-in. Alternatively, use standard decorator syntax to adapt a class. If we apply &lt;code&gt;@total_ordering&lt;/code&gt; to a &lt;code&gt;Point&lt;/code&gt; class&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;@total_ordering
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __lt__(self, other):
        return (self.x, self.y) &amp;lt; (other.x, other.y)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;then we can compare points however we like&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; p = Point(1,2)
&amp;gt;&amp;gt;&amp;gt; q = Point(1,3)
&amp;gt;&amp;gt;&amp;gt; p &amp;lt; q, p &amp;gt; q, p &amp;gt;= q, p &amp;lt;= q
(True, False, False, True)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here&amp;#8217;s a nice touch: the freshly-baked methods even have documentation!&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; help(Point)
Help on class Point in module __main__:

class Point
 |  Methods defined here:
 |  
 |  __ge__(self, other)
 |      x.__ge__(y) &amp;lt;==&amp;gt; x&amp;gt;=y
 |  
 |  __gt__(self, other)
 |      x.__gt__(y) &amp;lt;==&amp;gt; x&amp;gt;y
 |  
 |  __init__(self, x, y)
 |  
 |  __le__(self, other)
 |      x.__le__(y) &amp;lt;==&amp;gt; x&amp;lt;=y
 |  
 |  __lt__(self, other)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Writing class decorators may not be the first thing a new Python programmer attempts, but once you&amp;#8217;ve discovered the relationship between Python&amp;#8217;s special method names and the more familiar operator symbols, I think this recipe is remarkably straightforward.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;convert = {
    &amp;#x27;__lt__&amp;#x27;: [(&amp;#x27;__gt__&amp;#x27;, lambda self, other: other &amp;lt; self),
               (&amp;#x27;__le__&amp;#x27;, lambda self, other: not other &amp;lt; self),
               (&amp;#x27;__ge__&amp;#x27;, lambda self, other: not self &amp;lt; other)],
    &amp;#x27;__le__&amp;#x27;: [(&amp;#x27;__ge__&amp;#x27;, lambda self, other: other &amp;lt;= self),
               (&amp;#x27;__lt__&amp;#x27;, lambda self, other: not other &amp;lt;= self),
               (&amp;#x27;__gt__&amp;#x27;, lambda self, other: not self &amp;lt;= other)],
    &amp;#x27;__gt__&amp;#x27;: [(&amp;#x27;__lt__&amp;#x27;, lambda self, other: other &amp;gt; self),
               (&amp;#x27;__ge__&amp;#x27;, lambda self, other: not other &amp;gt; self),
               (&amp;#x27;__le__&amp;#x27;, lambda self, other: not self &amp;gt; other)],
    &amp;#x27;__ge__&amp;#x27;: [(&amp;#x27;__le__&amp;#x27;, lambda self, other: other &amp;gt;= self),
               (&amp;#x27;__gt__&amp;#x27;, lambda self, other: not other &amp;gt;= self),
               (&amp;#x27;__lt__&amp;#x27;, lambda self, other: not self &amp;gt;= other)]
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Before moving on to something more challenging, look again at one of the recipe&amp;#8217;s key ingredients, the &lt;code&gt;convert&lt;/code&gt; dict, which helps create the missing ordering functions from existing ones. As you can see, there&amp;#8217;s much repetition here, and plenty of opportunities for cut-and-paste errors.&lt;/p&gt;
&lt;p&gt;This block of code is an example of what programmers term &lt;a href=&quot;http://en.wikipedia.org/wiki/Boilerplate_(text)#Boilerplate_code&quot;&gt;boilerplate&lt;/a&gt;. By using the total ordering decorator, we can avoid boilerplating our own code.&lt;a id=&quot;fn1link&quot; href=&quot;https://wordaligned.org/articles/boost-iterator-facade#fn1&quot;&gt;&lt;sup&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;filling-in-missing-methods-c&quot;&gt;Filling in missing methods. C++&lt;/h3&gt;
&lt;p&gt;Python is dynamic and self-aware, happy to expose its internals for this kind of tinkering.  It takes real wizardry to achieve similar results with a &lt;a href=&quot;http://sites.google.com/site/steveyegge2/tour-de-babel&quot; title=&quot;C++ is the dumbest language on earth ... doesn&#x27;t know about itself. It is not introspective&quot;&gt;less flexible language, such as C++&lt;/a&gt; &amp;#8212; but it can be done.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In a &lt;a href=&quot;https://wordaligned.org/articles/binary-search-revisited.html&quot;&gt;previous article&lt;/a&gt; we developed a random access file iterator in C++. At its heart, this iterator simply repositioned itself using file-seeks and dereferenced itself using file-reads. There wasn&amp;#8217;t much to it.&lt;/p&gt;
&lt;p&gt;Unfortunately we had to fill-out the iterator with the various members required to make it comply with the standard random access iterator requirements (which was the whole point, since we wanted something we could use with standard binary search algorithms).&lt;/p&gt;
&lt;p&gt;We had to expose standard typedefs:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;typedef std::random_access_iterator_tag iterator_category;
typedef item value_type;
typedef std::streamoff difference_type;
typedef item * pointer;
typedef item &amp;amp; reference;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Worse, we had to implement a full set of comparison, iteration, step and access functions. Please, page down past the following code block! I only include it here so you can see how long it goes on for.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Iterator boilerplate&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;public: // Comparison
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }

    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }

    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }

    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }

public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }

    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }

    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }

    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }

public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }

    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }

    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }

    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }

public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return pos - other.pos;
    }

public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }

    value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }
    ....

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;How tiresome! Most of these member functions are directly and unsurprisingly implemented in a standard way. It would be nice if we could write (and test!) what we actually needed to and have a decorator fill in the rest.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/chr1sp/3997724676/&quot; title=&quot;Library - Ephesus by Chris. P, on Flickr&quot;&gt;&lt;img src=&quot;http://farm3.static.flickr.com/2554/3997724676_bf73106637.jpg&quot; width=&quot;500&quot; height=&quot;334&quot; alt=&quot;Library - Ephesus&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;enter-boost-iterators&quot;&gt;Enter Boost iterators&lt;/h3&gt;
&lt;p&gt;Actually, we can! I&amp;#8217;m grateful to proggitor dzorz for &lt;a href=&quot;http://www.reddit.com/r/programming/comments/c8fsk/binary_search_revisited/c0quxr0&quot;&gt;telling me how&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A nicer solution would use boost::iterator_facade and just implement dereference, equal, increment, decrement, advance and distance_to.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Like many programmers I have mixed feelings about C++ &amp;#8212; when it&amp;#8217;s good it&amp;#8217;s very very good, but when it&amp;#8217;s bad it&amp;#8217;s horrid &amp;#8212; and these feelings are only amplified by the &lt;a href=&quot;http://www.boost.org&quot; title=&quot;Boost library home page&quot;&gt;Boost&lt;/a&gt; library. Boost is superb, so long as you stick to the good parts.&lt;/p&gt;
&lt;p&gt;So which parts are good? It depends. On you, who you work with, and the platforms you&amp;#8217;re working on.&lt;/p&gt;
&lt;p&gt;In my previous article I used an ingenious iterator adaptor from the &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/spirit/index.html&quot;&gt;Boost.Spirit&lt;/a&gt; parser library to disastrous effect. If only I&amp;#8217;d looked a little more carefully I&amp;#8217;d have discovered something more useful in a more obvious place. &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iterator/&quot;&gt;Boost.Iterator&lt;/a&gt; could have helped.&lt;/p&gt;
&lt;p&gt;As dzorz points out, &lt;code&gt;boost::iterator_facade&lt;/code&gt; can work with any C++ iterable. Implement whatever subset of &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dereference&lt;/li&gt;
&lt;li&gt;equal&lt;/li&gt;
&lt;li&gt;increment &lt;/li&gt;
&lt;li&gt;decrement&lt;/li&gt;
&lt;li&gt;advance&lt;/li&gt;
&lt;li&gt;distance_to&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;is appropriate and &lt;code&gt;iterator_facade&lt;/code&gt; will fill in the boilerplate required to standardise your iterator.&lt;/p&gt;
&lt;p&gt;In our case, we&amp;#8217;ll need the full set. That&amp;#8217;s because we&amp;#8217;re after a random access iterator. Other iterators need rather less. Here&amp;#8217;s a &lt;a href=&quot;http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#iterator-facade-requirements&quot;&gt;table&lt;/a&gt; showing the relationship between core operations and iterator concepts.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#iterator-facade-requirements&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/iterator-facade.png&quot; alt=&quot;iterator_facade Core Operations&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;using-boostiterator_facade&quot;&gt;Using boost::iterator_facade&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iterator/&quot;&gt;Boost.Iterator&lt;/a&gt; documentation is well-written but daunting. Read it from top-to bottom and you&amp;#8217;ll get:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rationale and theory&lt;/li&gt;
&lt;li&gt;plans for standardisation (which don&amp;#8217;t seem correct &lt;a id=&quot;fn2link&quot; href=&quot;https://wordaligned.org/articles/boost-iterator-facade#fn2&quot;&gt;&lt;sup&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;usage notes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;some subtle points on the implementation and its predecessor&lt;/li&gt;
&lt;li&gt;a namecheck for the curiously recurring template pattern&lt;/li&gt;
&lt;li&gt;a fat reference section detailing the boilerplate which this library allows you to forget&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;tutorial&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&amp;#8217;re tempted to skip to the end of the page, you&amp;#8217;ll see this code block.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;boost/type_traits/is_convertible.hpp&amp;gt;
#include &amp;lt;boost/utility/enable_if.hpp&amp;gt;

  ....

private:
  struct enabler {};

public:
  template &amp;lt;class OtherValue&amp;gt;
  node_iter(
      node_iter&amp;lt;OtherValue&amp;gt; const&amp;amp; other
    , typename boost::enable_if&amp;lt;
          boost::is_convertible&amp;lt;OtherValue*,Value*&amp;gt;
        , enabler
      &amp;gt;::type = enabler()
  )
    : m_node(other.m_node) {}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;According to the surrounding documentation this is &amp;#8220;magic&amp;#8221;. I find it scary.&lt;/p&gt;
&lt;p&gt;Luckily it turns out the library is straightforward to use. What you really want, as a newcomer, are the &lt;a href=&quot;http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#usage&quot;&gt;usage notes&lt;/a&gt; and the &lt;a href=&quot;http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/iterator_facade.html#tutorial-example&quot;&gt;tutorial example&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The tutorial walks through the process of skinning a singly-linked list with a forwards iterator facade. This is a different use case to ours: the tutorial shows a basic class which implements what it should, and the facade allows it to be treated as a forwards iterator. In our case we&amp;#8217;ve already created a full-blown random access iterator. We can retrospectively apply &lt;code&gt;iterator_facade&lt;/code&gt; to strip our class back to basics.&lt;/p&gt;
&lt;h3 id=&quot;templates-and-traits&quot;&gt;Templates and Traits&lt;/h3&gt;
&lt;p&gt;Where we had:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template &amp;lt;typename item&amp;gt;
class text_file_iter
{
public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef item value_type;
    typedef std::streamoff difference_type;
    typedef item * pointer;
    typedef item &amp;amp; reference;
....
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We now need (my thanks here to Giuseppe for correcting the code I originally posted here):&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template &amp;lt;typename value&amp;gt;
class text_file_iter
    : public boost::iterator_facade&amp;lt;
      text_file_iter&amp;lt;value&amp;gt;
    , value
    , std::random_access_iterator_tag
    , value
    , std::streamoff
    &amp;gt;
....
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Yes, the class accepts itself as a template parameter. That&amp;#8217;s the curious recursion.)&lt;/p&gt;
&lt;h3 id=&quot;constructors-destructors-and-operators&quot;&gt;Constructors, destructors and operators&lt;/h3&gt;
&lt;p&gt;We still need iterator constructors and destructors &amp;#8212; these are unchanged &amp;#8212; but &lt;strong&gt;we can eliminate every single operator&lt;/strong&gt; shown in the &amp;#8220;Iterator boilerplate&amp;#8221; code block above.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s what we need instead, to ensure &lt;code&gt;iterator_facade&lt;/code&gt; can do its job. The &lt;code&gt;read()&lt;/code&gt; member function we had before doesn&amp;#8217;t need changing.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;    ....
private: // Everything Boost&amp;#x27;s iterator facade needs
    friend class boost::iterator_core_access;

    value dereference() const
    {
        return read();
    }

    bool equal(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }

    void increment()
    {
        advance(1);
    }

    void decrement()
    {
        advance(-1);
    }

    void advance(std::streamoff n)
    {
        in.seekg(n, std::ios_base::cur);
        pos = in.tellg();
    }

    std::streamoff distance_to(iter const &amp;amp; other) const
    {
        return other.pos - pos;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;And that really is all there is to it. I&amp;#8217;m impressed.&lt;/p&gt;
&lt;p&gt;Notice, by the way, that &lt;code&gt;friend&lt;/code&gt; is used to expose the primitive, private member functions for use by the &lt;code&gt;boost::iterator_core_access&lt;/code&gt; class. This follows the example set by the tutorial. I&amp;#8217;ve written enough C and Python to question C++&amp;#8217;s sophisticated access rules &amp;#8212; you have &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt;, but that&amp;#8217;s &lt;strong&gt;still&lt;/strong&gt; not enough, so you need &lt;code&gt;friend&lt;/code&gt; declaration to cut through it all &amp;#8212; which tempts me to simply make &lt;code&gt;dereference()&lt;/code&gt;, &lt;code&gt;equal()&lt;/code&gt; etc. public, but then the facade wouldn&amp;#8217;t be a proper facade. Users should treat the final class exactly as they would any other random access iterator, and designating these members as &lt;code&gt;private&lt;/code&gt; means they&amp;#8217;ll have to.&lt;/p&gt;
&lt;h3 id=&quot;wrinkles&quot;&gt;Wrinkles&lt;/h3&gt;
&lt;p&gt;You&amp;#8217;ll notice the &lt;code&gt;dereference()&lt;/code&gt; member function has a &lt;code&gt;const&lt;/code&gt; signature. However, the &lt;code&gt;read()&lt;/code&gt; member function is non-const.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;    // Return the item at the current position
    value_type read()
    {
        value_type n = 0;

        // Reverse till we hit whitespace or the start of the file
        while (in &amp;amp;&amp;amp; !isspace(in.peek()))
        {
            in.unget();
        }
        in.clear();

        in &amp;gt;&amp;gt; n;
        return n;
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;in&lt;/code&gt; is a data member of type &lt;code&gt;std::ifstream&lt;/code&gt;, and clearly the read call modifies it. That&amp;#8217;s what this alarming compiler error is trying to tell us.&lt;/p&gt;
&lt;pre&gt;
boost_binary_search_text_file.cpp: In member function &#x27;value text_file_iter&amp;lt;value&amp;gt;::read() const [with value = long long int]&#x27;:
boost_binary_search_text_file.cpp:90:   instantiated from &#x27;value text_file_iter&amp;lt;value&amp;gt;::dereference() const [with value = long long int]&#x27;
/opt/local/include/boost/iterator/iterator_facade.hpp:516:   instantiated from &#x27;static typename Facade::reference boost::iterator_core_access::dereference(const Facade&amp;amp;) [with Facade = text_file_iter&amp;lt;long long int&amp;gt;]&#x27;
/opt/local/include/boost/iterator/iterator_facade.hpp:634:   instantiated from &#x27;Reference boost::iterator_facade&amp;lt;I, V, TC, R, D&amp;gt;::operator*() const [with Derived = text_file_iter&amp;lt;long long int&amp;gt;, Value = long long int, CategoryOrTraversal = boost::random_access_traversal_tag, Reference = long long int, Difference = long long int]&#x27;
/usr/include/c++/4.2.1/bits/stl_algo.h:4240:   instantiated from &#x27;bool std::binary_search(_ForwardIterator, _ForwardIterator, const _Tp&amp;amp;) [with _ForwardIterator = text_file_iter&amp;lt;long long int&amp;gt;, _Tp = main::number]&#x27;
boost_binary_search_text_file.cpp:203:   instantiated from here
boost_binary_search_text_file.cpp:174: error: passing &#x27;const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;&#x27; as &#x27;this&#x27; argument of &#x27;typename std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::int_type std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::peek() [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]&#x27; discards qualifiers
boost_binary_search_text_file.cpp:176: error: passing &#x27;const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;&#x27; as &#x27;this&#x27; argument of &#x27;std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;&amp;amp; std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::unget() [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]&#x27; discards qualifiers
boost_binary_search_text_file.cpp:178: error: passing &#x27;const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;&#x27; as &#x27;this&#x27; argument of &#x27;void std::basic_ios&amp;lt;_CharT, _Traits&amp;gt;::clear(std::_Ios_Iostate) [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]&#x27; discards qualifiers
boost_binary_search_text_file.cpp:180: error: passing &#x27;const std::basic_ifstream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;&#x27; as &#x27;this&#x27; argument of &#x27;std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;&amp;amp; std::basic_istream&amp;lt;_CharT, _Traits&amp;gt;::operator&amp;gt;&amp;gt;(long long int&amp;amp;) [with _CharT = char, _Traits = std::char_traits&amp;lt;char&amp;gt;]&#x27; discards qualifiers
&lt;/pre&gt;

&lt;p&gt;Related to this, the &lt;code&gt;Reference&lt;/code&gt; template parameter (shown in bold in the listing below) is actually a &lt;code&gt;value&lt;/code&gt;, rather than the (default) &lt;code&gt;value &amp;amp;&lt;/code&gt;. As we originally implemented it, our file iterator reads values lazily, only when clients request them. We have no reference to return.&lt;/p&gt;
&lt;pre&gt;
template &amp;lt;typename value&amp;gt;
class text_file_iter
    : public boost::iterator_facade&amp;lt;
      text_file_iter&amp;lt;value&amp;gt;
    , value
    , std::random_access_iterator_tag
    , &lt;strong&gt;value&lt;/strong&gt;
    , std::streamoff
    &amp;gt;
};
&lt;/pre&gt;

&lt;p&gt;I faced a dilemma here. Either I could modify my original file iterator, including a current value data member, which I would take care to update every time we repositioned the file read position. Then our references could be real references and &lt;code&gt;read()&lt;/code&gt; would naturally be &lt;code&gt;const&lt;/code&gt;, simply returning a reference to this member. Or, I could make the &lt;code&gt;in&lt;/code&gt; input stream data member &lt;code&gt;mutable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Mutable&lt;/code&gt; makes me uneasy for the same reason that &lt;code&gt;friend&lt;/code&gt; does &amp;#8212; if you can shake off the rigours of const-correctness so easily, then why bother with it? &amp;#8212; and for this reason the first option appealed. However, a read-only file is an unusual container: we do not change it, but we cannot supply const references to its elements without reading them in, and that will mean changes to the file input stream. The easier option, involving the smallest code change, was to make &lt;code&gt;in&lt;/code&gt; mutable. So that&amp;#8217;s what I did.&lt;/p&gt;
&lt;h3 id=&quot;less-code-more-software&quot;&gt;Less code, more software&lt;/h3&gt;
&lt;p&gt;By employing two of my least favourite C++ keywords I now had a class which provided the functions it should, and, thanks to the magic worked by Boost&amp;#8217;s iterator facade, I also had a class which I could use as a standard random access iterator. Most of the code changes were the deletion of boilerplate &amp;#8212; very satisfying. I added code too, since I decided to invest a little more effort in tests. I didn&amp;#8217;t have any doubts about the Boost library&amp;#8217;s correctness but I thought I might not have been using it correctly. Happily these tests all passed.&lt;/p&gt;
&lt;h3 id=&quot;performance&quot;&gt;Performance&lt;/h3&gt;
&lt;p&gt;Let&amp;#8217;s not forget why we originally wanted a random access file iterator: we had a large sorted file, too large to read into memory, and we wanted to test for the presence of the number in this file.&lt;/p&gt;
&lt;p&gt;For test purposes I created a file just over 4GB in size. A simple linear search through this file took around 180 seconds on my (aging laptop) computer, and was light on memory use. By creating a random access file iterator, boilerplate and all, we took advantage of the standard binary search algorithm and reduced the time to around 4 milliseconds.&lt;/p&gt;
&lt;p&gt;How would our version using Boost iterator facade do? I wasn&amp;#8217;t expecting it to be faster than the original, but I wouldn&amp;#8217;t have been surprised if it gave it a close run: using Boost doesn&amp;#8217;t usually involve compromise. In fact, over repeated runs of my performance tests there was no significant difference between the two iterator versions &amp;#8212; or at least there wasn&amp;#8217;t once a helpful reader had discovered and fixed a bug in my program, which was causing it to run correctly but slowly.&lt;/p&gt;
&lt;p&gt;To trust a facade I guess you need some knowledge of what lies behind it.&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;&amp;sect;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: During my original performance tests, reported in the first version of this article, the Boost iterator performed woefully, far slower even than a linear search. By this time I&amp;#8217;d lost patience, and it was left up to a reader, Giuseppe, to &lt;a href=&quot;https://wordaligned.org/articles/boost-iterator-facade#comment-60988668&quot;&gt;point out my mistake&lt;/a&gt;. I&amp;#8217;d been using a &lt;code&gt;boost::random_access_traversal_tag&lt;/code&gt; template parameter, with the result that &lt;code&gt;std::distance()&lt;/code&gt; was using repeated increments rather than calling &lt;code&gt;distance_to()&lt;/code&gt; to get an immediate result, and consequently ran very slowly. I should have used &lt;code&gt;std::random_access_iterator_tag&lt;/code&gt;. I modified my code accordingly and confirmed that the Boost version does indeed perform on a par with the original version.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;My thanks to &lt;a href=&quot;http://www.flickr.com/photos/chr1sp/&quot; title=&quot;Chris. P on Flickr&quot;&gt;Chris P&lt;/a&gt; for permission to use his &lt;a href=&quot;http://www.flickr.com/photos/chr1sp/3997724676&quot;&gt;photograph&lt;/a&gt; of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Library_of_Celsus&quot; title=&quot;Library of Celsus, Wikipedia&quot;&gt;Library of Celsus&lt;/a&gt; at Ephesus, or at rather its beautiful facade. Ephesus is famous for the Temple of Artemis, one of the seven wonders of the ancient world, of which only fragments remain. Thanks too to &lt;a href=&quot;http://www.flickr.com/photos/davehamster/&quot;&gt;Dave Hamster&lt;/a&gt; for the boilerplate &lt;a href=&quot;http://www.flickr.com/photos/davehamster/2336911145/&quot;&gt;photo&lt;/a&gt; &amp;#8212; actually a detail from the hull of the &lt;a href=&quot;http://www.ssgreatbritain.org&quot;&gt;SS Great Britain&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;d like to continue this experiment the code and the tests I used are available via anonymous SVN access from &lt;a href=&quot;http://svn.wordaligned.org/svn/etc/search_text_file&quot;&gt;http://svn.wordaligned.org/svn/etc/search_text_file&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a id=&quot;fn1&quot; href=&quot;https://wordaligned.org/articles/boost-iterator-facade#fn1link&quot;&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/a&gt;: As of Python 2.7 and 3.2, the standard library will include a version of this recipe. It&amp;#8217;s in the &lt;a href=&quot;http://docs.python.org/dev/py3k/library/functools.html#functools.total_ordering&quot; title=&quot;functools.total_ordering decorator documentation&quot;&gt;functools module&lt;/a&gt;. For some reason, your class &amp;#8220;should supply an __eq__()&amp;#8221; method.&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn2&quot; href=&quot;https://wordaligned.org/articles/boost-iterator-facade#fn2link&quot;&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/a&gt;: According to the Boost.Iterator documentation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Both &lt;code&gt;iterator_facade&lt;/code&gt; and &lt;code&gt;iterator_adaptor&lt;/code&gt; as well as many of the specialized adaptors mentioned below have been proposed for standardization, and accepted into the first C++ technical report; see our [Standard Proposal For Iterator Facade and Adaptor (PDF)][tr1proposal] for more details.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I assumed this meant there&amp;#8217;d be &lt;code&gt;tr1::iterator_(facade|adaptor)&lt;/code&gt; classes, but I don&amp;#8217;t think that&amp;#8217;s the case. Unlike other (good) bits of Boost, the Iterator library doesn&amp;#8217;t seem likely to be part of the next C++ release.&lt;/p&gt;</description>
<dc:date>2010-07-07</dc:date>
<guid>https://wordaligned.org/articles/boost-iterator-facade</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/boost-iterator-facade</link>
<category>C++</category>
</item>

<item>
<title>Binary search revisited</title>
<description>&lt;h3 id=&quot;recap&quot;&gt;Recap&lt;/h3&gt;
&lt;p&gt;Recently &lt;a href=&quot;https://wordaligned.org/articles/binary-search.html&quot;&gt;I wrote&lt;/a&gt; about C++&amp;#8217;s standard binary search algorithms (yes, four of them!) which do such a fine job of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;specifying exactly what kind of range a binary search requires&lt;/li&gt;
&lt;li&gt;separating the core algorithm from the details of the range it&amp;#8217;s working on&lt;/li&gt;
&lt;li&gt;delivering precise results&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To support these claims I included an implementation of a file iterator, suitable for use with &lt;code&gt;std::binary_search()&lt;/code&gt; etc. to efficiently locate values in very large files.&lt;/p&gt;
&lt;p&gt;Now, there are a couple of issues with this approach:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;we had to write a lot of code to make a file iterator suitable for use with standard algorithms&lt;/li&gt;
&lt;li&gt;this file iterator only works on highly structured files, where each value occupies a fixed number of bytes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this follow up article we&amp;#8217;ll consider each of these issues in a little more depth by working through two very different solutions to a related problem.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;the-problem&quot;&gt;The Problem&lt;/h3&gt;
&lt;p&gt;Suppose, once again, that we have a large file, a few gigabytes, say. The file contains numbers, in order, and we&amp;#8217;re interested in testing if this file contains a given number. This time, though, the file is a text file, where the numbers are represented in the usual way as sequences of digits separated by whitespace.&lt;/p&gt;
&lt;pre&gt;
$ less lots-of-numbers
...
10346  11467 11469 11472  11501 
  11662    12204 12290
...
&lt;/pre&gt;

&lt;p&gt;Note that a number in this file does not occupy a fixed number of bytes. If we jump to a new position in the file using a seek operation, we cannot expect to land exactly where a number starts. Thus the random access file iterator we developed last time won&amp;#8217;t work.&lt;/p&gt;
&lt;h3 id=&quot;input-iterators&quot;&gt;Input iterators&lt;/h3&gt;
&lt;p&gt;In C++ an input file is an example of an input stream, and the standard library gives us &lt;code&gt;istream_iterators&lt;/code&gt; which perform formatted input. In our case, an &lt;code&gt;istream_iterator&amp;lt;int&amp;gt;&lt;/code&gt; effectively converts the file into a stream of numbers.&lt;/p&gt;
&lt;p&gt;Istream iterators are &lt;a href=&quot;http://www.sgi.com/tech/stl/InputIterator.html&quot; title=&quot;InputIterator, SGI STL documentation&quot;&gt;input iterators&lt;/a&gt;. They progress through the input stream, item by item, with no repeating or rewinding allowed. Despite their limitations, the C++ standard library provides some algorithms which require nothing more than basic input iterators. For example, to count up even numbers in the file whose name is supplied on the command line we might use &lt;code&gt;std::count_if&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iterator&amp;gt;

bool is_even(int x)
{
    return x % 2 == 0;
}

int main(int argc, char * argv[])
{
    typedef std::istream_iterator&amp;lt;int&amp;gt; i_iter;
    typedef std::ostream_iterator&amp;lt;int&amp;gt; o_iter;
    std::ifstream in(argv[1]);

    std::cout &amp;lt;&amp;lt; std::count_if(i_iter(in), i_iter(), is_even) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;The next version of C++ supports lambda functions, so you&amp;#8217;ll be able to put &lt;code&gt;is_even&lt;/code&gt; right where it&amp;#8217;s used, in the &lt;code&gt;count_if()&lt;/code&gt; function call. Or, with the current version of C++, you could write:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Ouch!&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;    ....
    std::count_if(i_iter(in), i_iter(),
                 std::not1(std::bind2nd(std::modulus&amp;lt;int&amp;gt;(), 2)))

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Maybe not!&lt;/p&gt;
&lt;h3 id=&quot;find&quot;&gt;Find&lt;/h3&gt;
&lt;p&gt;The very simplest search algorithm, &lt;code&gt;std::find&lt;/code&gt;, needs nothing more than an input iterator. To determine if a number is in a file, we &lt;strong&gt;could&lt;/strong&gt; just invoke &lt;code&gt;std::find&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;typedef std::istream_iterator&amp;lt;int&amp;gt; i_iter;

bool 
is_number_in_file(char const * filename, int n)
{
    std::ifstream in(filename);
    i_iter begin(in);
    i_iter end;
    return std::find(begin, end, n) != end;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, the find algorithm advances through the numbers in the file, from start to finish, stopping as soon as it hits one equal to the supplied value, &lt;code&gt;n&lt;/code&gt;. We can expect this function to be light on memory use &amp;#8212; there will be some buffering at the lower levels of the file access, but nothing more &amp;#8212; and the function is evidently correct.&lt;/p&gt;
&lt;p&gt;It would be correct even if our file was unsorted, however. Is there any way we can do better?&lt;/p&gt;
&lt;h3 id=&quot;rewrite-the-file&quot;&gt;Rewrite the file!&lt;/h3&gt;
&lt;p&gt;In the previous article we developed a random access iterator for accessing binary files, and usable for efficient binary searches of sorted binary files. Now would be a good time to question the problem specification. Is this a one off? Or are we going to be testing the presence of more numbers in the file in future? And if so, can we convert the file to binary to save time in the long run? &lt;/p&gt;
&lt;p&gt;Although I&amp;#8217;m not going to pursue this option here, it may well be the best approach. For now, though, let&amp;#8217;s assume we have a one-off problem to solve, and that we aren&amp;#8217;t allowed to tinker with the input.&lt;/p&gt;
&lt;h3 id=&quot;adapting-iterators&quot;&gt;Adapting iterators&lt;/h3&gt;
&lt;p&gt;If we want to use &lt;code&gt;std::binary_search&lt;/code&gt; we need, as a minimum, &lt;a href=&quot;http://www.sgi.com/tech/stl/ForwardIterator.html&quot; title=&quot;ForwardIterator, SGI STL documentation&quot;&gt;forward iterators&lt;/a&gt;. Like input iterators, forward iterators advance, one step at a time. Unlike input iterators, you can copy a forward iterator and dereference or advance that copy in future, independently of the original.&lt;/p&gt;
&lt;p&gt;Forward iterators are suitable for multipass algorithms, such as &lt;code&gt;std::search&lt;/code&gt;, which looks for the first occurrence of a sequence within a sequence (a generalised &lt;code&gt;strstr&lt;/code&gt;, if you like), or &lt;code&gt;std::adjacent_find&lt;/code&gt; and &lt;code&gt;std::search_n&lt;/code&gt; which look for repeated elements; and of course &lt;code&gt;std::binary_search&lt;/code&gt;, which is our immediate interest.&lt;/p&gt;
&lt;p&gt;Wouldn&amp;#8217;t it be nice if we could convert our istream iterators into forwards iterators? Then we could plug them directly into all these algorithms.&lt;/p&gt;
&lt;p&gt;Other languages allow this. You can replicate streams in the Unix shell with &lt;code&gt;tee&lt;/code&gt;. And you can do something similar in Python, thanks to one of the standard &lt;a href=&quot;http://docs.python.org/py3k/library/itertools.html&quot;&gt;iterator tools&lt;/a&gt;. Independent iterators over the same sequence needed? &lt;tt&gt;&lt;a href=&quot;http://docs.python.org/py3k/library/itertools.html#itertools.tee
&quot;&gt;Itertools.tee&lt;/a&gt;&lt;/tt&gt; is your friend. The example below codes up adjacent find in Python.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from itertools import tee
import sys

def adjacent_find(xs):
    &amp;#x27;&amp;#x27;&amp;#x27;Does the supplied iterable contain any adjacent repeats?

    Returns True if xs contains two consecutive, equal items,
    False otherwise. 
    &amp;#x27;&amp;#x27;&amp;#x27;
    try:
        curr, next_ = tee(xs)
        next(next_)
        return any(c == n for c, n in zip(curr, next_))
    except StopIteration:
        return False

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jezuk.co.uk/mango&quot; title=&quot;Mango: iterators, algorithms, functions, for Java, by Jez Higgins&quot;&gt;&lt;img src=&quot;http://www.jezuk.co.uk/files/mango-header.png&quot; alt=&quot;Mango: iterators, algorithms, functions, for Java, by Jez Higgins&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Why, even Java has an iterator adaptors, courtesy of Jez Higgins&amp;#8217; &lt;a href=&quot;http://www.jezuk.co.uk/mango&quot; title=&quot;Mango: iterators, algorithms, functions, for Java, by Jez Higgins&quot;&gt;Mango library&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;What about C++? I couldn&amp;#8217;t find any such iterator adaptors in the standard library, but I turned up something in the standard library research and development unit, also known as &lt;a href=&quot;http://www.boost.org&quot; title=&quot;Free, peer-reviewed, portable C++ source libraries&quot;&gt;Boost&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://boost.org&quot;&gt;&lt;img src=&quot;http://www.boost.org/doc/libs/1_43_0/boost.png&quot; alt=&quot;Boost logo&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;multipass-iterator&quot;&gt;Multipass iterator&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/index.html&quot;&gt;Boost.Spirit&lt;/a&gt; is a remarkable C++ parser framework, which uses operator overloading to represent parsers directly as EBNF grammars in C++. Somewhere in its depths it tracks back, and hence must adapt input iterators into forward iterators &amp;#8212; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/spirit/support/multi_pass.html&quot;&gt;multipass iterators&lt;/a&gt;, to use its own term.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;multi_pass&lt;/code&gt; iterator will convert any input iterator into a forward iterator suitable for use with Spirit.Qi. &lt;code&gt;multi_pass&lt;/code&gt; will buffer data when needed and will discard the buffer when its contents is not needed anymore. This happens either if only one copy of the iterator exists or if no backtracking can occur.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What&amp;#8217;s good enough for parsing is more than good enough for searching. Here&amp;#8217;s a function which detects whether a number is in a file. Most of the code here just includes the right headers and defines some typedefs. By leaning on high quality support libraries we&amp;#8217;ve overcome our first issue: we no longer have to write loads of code just to call binary search!&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Boost spirit multipass iterators&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;algorithm&amp;gt;

#include &amp;lt;boost/spirit/include/support_multi_pass.hpp&amp;gt;

namespace spirit = boost::spirit;

typedef long long number;
typedef std::istream_iterator&amp;lt;number&amp;gt; in_it;
typedef spirit::multi_pass&amp;lt;in_it&amp;gt; fwd_it;

/*
  Returns true if the input number can be found in the named 
  file, false otherwise. The file must contain ordered, 
  whitespace separated numbers.
*/
bool
is_number_in_file(number n, char const * filename)
{
    std::ifstream in(filename);

    fwd_it begin = spirit::make_default_multi_pass(in_it(in));
    fwd_it end = spirit::make_default_multi_pass(in_it());

    return std::binary_search(begin, end, n);
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;not-so-fast&quot;&gt;Not so fast&lt;/h3&gt;
&lt;p&gt;If this library-based solution looks too good to be true, that&amp;#8217;s because it is! As we noted &lt;a href=&quot;https://wordaligned.org/articles/binary-search.html#tocstdbinarysearch-requirements&quot;&gt;before&lt;/a&gt;, the standard binary search algorithm may indeed work with forward iterators, but it works far better with random access iterators. There&amp;#8217;s no point reducing the number of integer comparisons to &lt;code&gt;O(log(N))&lt;/code&gt; if we&amp;#8217;re going to advance our iterators &lt;code&gt;O(N)&lt;/code&gt; times.&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s worse, these multipass iterators aren&amp;#8217;t magic. Did you read the smallprint concerning Python&amp;#8217;s &lt;tt&gt;&lt;a href=&quot;http://docs.python.org/py3k/library/itertools.html#itertools.tee&quot;&gt;tee&lt;/a&gt;&lt;/tt&gt; iterator?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This itertool may require significant auxiliary storage (depending on how much temporary data needs to be stored).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If teed iterators diverge, intervening values have to be stored somewhere, and the same appears to be true of our inscrutable multipass iterators. Huge chunks of our large input file are buffered into memory. When I ran this function to confirm the presence of a single number somewhere near the middle of a 4.4GB input file, it took over 19 minutes.&lt;/p&gt;
&lt;pre&gt;
real    19m13.675s
user    5m19.219s
sys 1m26.278s
&lt;/pre&gt;

&lt;p&gt;Much of this time was spent paging.&lt;/p&gt;
&lt;p&gt;As a comparison, testing for the same value using &lt;code&gt;find&lt;/code&gt; took just under 3 minutes.&lt;/p&gt;
&lt;pre&gt;
real    2m48.139s
user    2m21.336s
sys 0m7.252s
&lt;/pre&gt;

&lt;p&gt;You&amp;#8217;ll have noticed that we used default multipass iterators. These iterators permit multi-dimensional &lt;a href=&quot;http://www.boost.org/doc/libs/1_43_0/libs/spirit/doc/html/spirit/support/multi_pass.html&quot;&gt;customisation&lt;/a&gt;. I wasn&amp;#8217;t feeling brave enough to attempt a template storage policy class, and I very much doubt I could have beaten a simple linear find anyway; anything built on a generic input iterator is unlikely to solve our problem efficiently.&lt;/p&gt;
&lt;h3 id=&quot;better-than-find&quot;&gt;Better than find&lt;/h3&gt;
&lt;p&gt;We can beat &lt;code&gt;std::find&lt;/code&gt; with a bit of ingenuity. Standard istream iterators are useful but, in this case, not a good starting point. A better idea is to create a novel iterator which uses file seek operations to advance through the file, then fine-tunes the file position to point at a number.&lt;/p&gt;
&lt;p&gt;Consider an imagine an iterator which can be positioned at any seekable position in the file, and which we dereference to be the first number in the file which ends at or after that position. The graphic below shows a file with 11 seekable positions, 0 through 10 inclusive. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;positions 0 and 1 dereference to the number 42  &lt;/li&gt;
&lt;li&gt;positions 2, 3, 4 and 5 dereference to the number 57&lt;/li&gt;
&lt;li&gt;positions 6, 7, 8 and 9 dereference to the number 133&lt;/li&gt;
&lt;li&gt;it is an error to try and dereference position 10, at the end of the file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/text-file-iterator.png&quot; alt=&quot;Text file iterator&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now, this is a rather unusual iterator. It iterates over the numbers in the file, but each number gets repeated for every byte in the file it occupies. Despite this duality it&amp;#8217;s perfectly usable &amp;#8212; so long as we keep a clear head. Binary searches are fine.&lt;/p&gt;
&lt;p&gt;How does this version perform?&lt;/p&gt;
&lt;p&gt;Recall, a linear search for a single value in the middle of a 4.4GB took nearly 3 minutes. Running 10 binary searches through the same file took just 40 milliseconds &amp;#8212; that&amp;#8217;s a rate of 25 searches a second!&lt;/p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;Implementation&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s our weird new iterator. It should be usable on files containing whitespace separated items of any type for which the stream read &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; has been defined.&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s quite a lot of code here, but much of it is random access iterator scaffolding. The interesting functions are the private implementation details towards the end of the class.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;fstream&amp;gt;
#include &amp;lt;ios&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;stdexcept&amp;gt;

#include &amp;lt;ctype.h&amp;gt;

// File read error, thrown when low level file access fails.
class file_read_error : public std::runtime_error
{
public:
    file_read_error(std::string const &amp;amp; what)
        : std::runtime_error(what)
    {
    }
};

/*
  Here&amp;#x27;s an unusual iterator which can be used to binary search
  for whitespace-separated items in a text file.

  It masquerades as a random access iterator but a file
  is not usually a random access device. Nonetheless, file seek
  operations are quicker than stepping through the file item by
  item.

  The unusual thing is that the iterators correspond to 
  file offsets rather than items within the file.

  Here&amp;#x27;s a short example where the items are numbers.

  +---+---+---+---+---+---+---+---+---+---+
  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
  +---+---+---+---+---+---+---+---+---+---+
  |&amp;#x27;4&amp;#x27;|&amp;#x27;2&amp;#x27;|   |   |&amp;#x27;5&amp;#x27;|&amp;#x27;7&amp;#x27;|   |&amp;#x27;1&amp;#x27;|&amp;#x27;3&amp;#x27;|&amp;#x27;3&amp;#x27;|
  +---+---+---+---+---+---+---+---+---+---+

  The graphic shows a text file which contains 3 numbers,
  42, 57, 133, separated by whitespace.

  The file itself is 10 bytes long, and hence there are 11
  iterators over the file, corresponding to actual file positions
  (including the one-past-the end position). To dereference an
  iterator, we step back through the file until we reach either
  whitespace or the start of the file. Then we look forwards 
  again and read in the next item.

  In the graphic above:

   - Iterators 0 and 1 point to number 42
   - Iterators 2, 3, 4 and 5 point to number 57
   - Iterators 6, 7, 8, 9 point to number 133
   - Iterator 10 is the end, and must not be dereferenced

  Dereferencing an iterator always returns an item which is in
  the file, and all items in the file have iterators pointing to
  them, so std::binary_search based on these iterators is valid.

  The iterators also expose their underlying file positions
  directory (via the getpos() member function), and with a
  little thought we can make use of std::lower_bound() and
  std::upper_bound().
*/
template &amp;lt;typename item&amp;gt;
class text_file_item_iter
{
    typedef text_file_item_iter&amp;lt;item&amp;gt; iter;

private: // Sanity

    // Check things are OK, throwing an error on failure.
    void check(bool ok, std::string const &amp;amp; what)
    {
        if (!ok)
        {
            throw file_read_error(what);          
        }
    }

public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef item value_type;
    typedef std::streamoff difference_type;
    typedef item * pointer;
    typedef item &amp;amp; reference;

    enum start_pos { begin, end };

public: // Lifecycle
    text_file_item_iter(iter const &amp;amp; other)
        : fname(other.fname)
    {
        open();
        setpos(other.pos);
    }

    text_file_item_iter()
        : pos(-1)
    {
    }

    text_file_item_iter(std::string const &amp;amp; fname,
                        start_pos where = begin)
        : fname(fname)
        , pos(-1)
    {
        open();
        if (where == end)
        {
            seek_end();
        }
    }

    ~text_file_item_iter()
    {
        close();
    }

    iter &amp;amp; operator=(iter const &amp;amp; other)
    {
        close();
        fname = other.fname;
        open();
        setpos(other.pos);
        return *this;
    } 

public: // Comparison
        // Note: it&amp;#x27;s an error to compare iterators over different files.
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }

    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }

    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }

    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }

public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }

    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }

    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }

    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }

public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }

    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }

    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }

    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }

public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return pos - other.pos;
    }

public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }

    value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }

    // Allow direct access to the underlying stream position
    std::streampos getpos()
    {
        std::streampos pos_ = in.tellg();
        check(in, &quot;getpos failed&quot;);
        return pos_;
    }

private: // Implementation details
    void open()
    {
        in.open(fname.c_str(), std::ios::binary);
        check(in, &quot;open failed&quot;);
        pos = getpos();
    }

    void close()
    {
        if (in.is_open())
        {
            in.close();
            check(in, &quot;close failed&quot;);
        }
    }

    void advance(difference_type n)
    {
        check(in.seekg(n, std::ios_base::cur), &quot;advance failed&quot;);
        pos = getpos();
    }

    void seek_end()
    {
        check(in.seekg(0, std::ios_base::end), &quot;seek_end failed&quot;);
        chop_whitespace();
        pos = getpos();
    }

    void chop_whitespace()
    {
        do
        {
            in.unget();
        } while (isspace(in.peek()));
        in.get();
        in.clear();
    }

    void setpos(std::streampos newpos)
    {
        check(in.seekg(newpos), &quot;setpos failed&quot;);
        pos = newpos;
    }

    // Return the item at the current position
    value_type read()
    {
        item n = 0;
        // Reverse till we hit whitespace or the start of the file
        while (in &amp;amp;&amp;amp; !isspace(in.peek()))
        {
            in.unget();
        }
        in.clear();
        check(in &amp;gt;&amp;gt; n, &quot;read failed&quot;);
        return n;
    }

private: // State
    std::string fname;
    std::ifstream in;
    std::streampos pos;
};

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;hardware-used&quot;&gt;Hardware used&lt;/h3&gt;
&lt;pre&gt;
  Model Name:               MacBook
  Model Identifier:     MacBook1,1
  Processor Name:           Intel Core Duo
  Processor Speed:          2 GHz
  Number Of Processors:     1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/photobunny_earl/1008279066&quot; title=&quot;Mushroom, by photobunny&quot;&gt;&lt;img src=&quot;http://farm2.static.flickr.com/1440/1008279066_847d73c90d.jpg&quot; alt=&quot;Mushroom, by photobunny&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h3&gt;
&lt;p&gt;Initially the Boost.Spirit solution looked promising but we pushed it too hard. Suitable abstractions can remove complexity; but they can also hide it. When efficiency matters, we need a handle on what&amp;#8217;s going on.&lt;/p&gt;
&lt;p&gt;After this false start we &lt;strong&gt;did&lt;/strong&gt; find a way to create a file iterator suitable for use with the standard binary search algorithms. Use it with care, though!&lt;/p&gt;</description>
<dc:date>2010-05-26</dc:date>
<guid>https://wordaligned.org/articles/binary-search-revisited</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/binary-search-revisited</link>
<category>C++</category>
</item>

<item>
<title>Binary search returns &#8230; ?</title>
<description>&lt;p&gt;In an article inspired by Jon Bentley&amp;#8217;s classic book, &lt;a href=&quot;http://www.cs.bell-labs.com/cm/cs/pearls/&quot;&gt;Programming Pearls&lt;/a&gt;, Mike Taylor &lt;a href=&quot;http://reprog.wordpress.com/2010/04/19/are-you-one-of-the-10-percent/&quot; title=&quot;Are you one of the 10% of programmers who can write a binary search?&quot;&gt;invites his readers&lt;/a&gt; to implement the binary search algorithm. To spice things up, he requests we work:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;without reference to any existing implementation&lt;/li&gt;
&lt;li&gt;without calling any library routine, such as &lt;code&gt;bsearch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;without writing tests.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Mike Taylor doesn&amp;#8217;t formally specify the problem. He&amp;#8217;s confident his readers will know what a binary search is, and if not, the description he quotes from Programming Pearls should suffice:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Binary search solves the problem [of searching within a pre-sorted array] by keeping track of a range within the array in which T [i.e. the sought value] must be if it is anywhere in the array.  Initially, the range is the entire array.  The range is shrunk by comparing its middle element to T and discarding half the range.  The process continues until T is discovered in the array, or until the range in which it must lie is known to be empty.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So could our binary search implementation simply return a binary result, &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is in the array, &lt;code&gt;false&lt;/code&gt; otherwise? Well, Yes. And No. A binary search can provide more information, as Mike Taylor hints when he mentions &lt;code&gt;bsearch&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Jon Bentley and Mike Taylor are primarily interested in how often programmers  make a mess of what appears to be a simple assignment and in how to avoid this mess. In this article, I&amp;#8217;d like to point out that the problem specification needs attention too.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/pinprick/2547648374&quot;&gt;&lt;img src=&quot;http://farm4.static.flickr.com/3066/2547648374_587dbe8f4b_m.jpg&quot; alt=&quot;unwrapped morbier&quot;/&gt;&lt;/a&gt;
&lt;a href=&quot;http://www.flickr.com/photos/pinprick/2546825997&quot;&gt;&lt;img src=&quot;http://farm4.static.flickr.com/3083/2546825997_c28af1da65_m.jpg&quot; alt=&quot;cut morbier&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;bsearch-in-c&quot;&gt;Bsearch in C&lt;/h3&gt;
&lt;p&gt;The C library&amp;#8217;s &lt;code&gt;bsearch&lt;/code&gt; function returns the location of &lt;code&gt;T&lt;/code&gt;, if found, or a sentinel value otherwise. We might use the array index of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt; as location and sentinel. Standard C uses pointers:&lt;/p&gt;
&lt;pre&gt;
&lt;b&gt;NAME&lt;/b&gt;
    &lt;b&gt;bsearch&lt;/b&gt; -- binary search of a sorted table

&lt;b&gt;SYNOPSIS&lt;/b&gt;
    #include &amp;lt;stdlib.h&amp;gt;

    void *
    &lt;b&gt;bsearch&lt;/b&gt;(const void *key, const void *base, size_t nel, 
        size_t width,
        int (*compar) (const void *, const void *));

&lt;b&gt;DESCRIPTION&lt;/b&gt; 
    The &lt;b&gt;bsearch()&lt;/b&gt; function searches an array of `nel` objects, 
    the initial member of which is pointed to by `base`, for a member
    that matches the  object pointed to by `key`.  The size (in bytes)
    of each member of the array is specified by `width`.

    The contents of the array should be in ascending sorted order 
    according to the comparison function referenced by `compar`.  The 
    `compar` routine is expected to have two arguments which point to
    the `key` object and to an array member, in that order.  It should 
    return an integer which is less than, equal to, or greater than
    zero if the `key` object is found, respectively, to be less than,
    to match, or be greater than the array member.

&lt;b&gt;RETURN VALUES&lt;/b&gt;
    The &lt;b&gt;bsearch()&lt;/b&gt; function returns a pointer to a matching member
    of the array, or a null pointer if no match is found.  If two members
    compare as equal, which member is matched is unspecified.
&lt;/pre&gt;

&lt;p&gt;Void pointers, function pointers, raw memory &amp;#8212; generic functions in C aren&amp;#8217;t pretty. How would this function look in a language with better support for generic programming?&lt;/p&gt;
&lt;h3 id=&quot;binary-search-in-c&quot;&gt;Binary search in C++&lt;/h3&gt;
&lt;p&gt;C++ programmers can of course use &lt;code&gt;bsearch&lt;/code&gt; directly since C++ includes the standard C library. The C++ counterpart would seem to be &lt;a href=&quot;http://www.sgi.com/tech/stl/binary_search.html&quot;&gt;&lt;code&gt;std::binary_search&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At first glance &lt;code&gt;std::binary_search&lt;/code&gt; appears to be a weakened version of &lt;code&gt;bsearch&lt;/code&gt;. Like &lt;code&gt;bsearch&lt;/code&gt;, it searches for a value. Unlike &lt;code&gt;bsearch&lt;/code&gt;, it simply returns a boolean result: &lt;code&gt;true&lt;/code&gt; if the value is found, &lt;code&gt;false&lt;/code&gt; otherwise. Nonetheless, it can tell us more than &lt;code&gt;bsearch&lt;/code&gt; in some circumstances.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s return to Mike Taylor&amp;#8217;s second constraint, the one about implementing functions which already exist in standard libraries. In a &lt;a href=&quot;http://reprog.wordpress.com/2010/04/21/binary-search-redux-part-1/&quot; title=&quot;Mike Taylor discusses his binary search challenge&quot;&gt;follow up article&lt;/a&gt; he explains:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;#8230; sometimes you do need to write a binary search, and the library routines won&amp;#8217;t get the job done.  Or if they will, they&amp;#8217;re grotesquely inefficient.  For example, suppose you have a 64-bit integer, and you need to find out whether it&amp;#8217;s among the nine billion 64-bit integers that are stored in ascending order in a 72 Gb file.  The naive solution is to read the file into memory, making an array (or, heaven help us, an Array) of nine billion elements, then invoke the library search function.  And of course that just plain won&amp;#8217;t work &amp;#8212; the array won&amp;#8217;t fit in memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Agreed! We should know how our wheels work and be ready to reinvent them when necessary: but C++&amp;#8217;s &lt;code&gt;std::binary_search&lt;/code&gt; &lt;strong&gt;will&lt;/strong&gt; solve this problem efficiently. All we need is a suitable iterator over the file, in this case one which:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;increments in 8 byte steps&lt;/li&gt;
&lt;li&gt;uses file seeks for larger steps&lt;/li&gt;
&lt;li&gt;is dereferenced by reading 8 byte values from the file&lt;/li&gt;
&lt;li&gt;stores file position, for use in ordering and distance operations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I include an &lt;a href=&quot;https://wordaligned.org/articles/binary-search#tociterating-over-numbers-in-a-file&quot;&gt;implementation&lt;/a&gt; of just such an iterator towards the end of this article. My aging laptop didn&amp;#8217;t have enough disk space for a 72GB data file but I found room for a 5GB one. &lt;code&gt;Std::binary_search()&lt;/code&gt; took milliseconds to test the presence of values in this file, and the times improved dramatically on repeat runs; using a linear search, the time extended to minutes, and repeat runs showed no such improvements.&lt;/p&gt;
&lt;h3 id=&quot;stdbinary_search-requirements&quot;&gt;Std::binary_search() requirements&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s fair to suggest that creating a custom iterator just so we could use &lt;code&gt;std::binary_search&lt;/code&gt; merely moves the problem. The iterator&amp;#8217;s implementation is longer and arguably more fiddly than any custom binary search function would be. Why couldn&amp;#8217;t we use a standard &lt;a href=&quot;http://www.sgi.com/tech/stl/istream_iterator.html&quot;&gt;input stream iterator&lt;/a&gt; with the standard binary search algorithm?&lt;/p&gt;
&lt;p&gt;The reason is that &lt;code&gt;std::istream_iterator&lt;/code&gt;s are &lt;a href=&quot;http://www.sgi.com/tech/stl/InputIterator.html&quot; title=&quot;SGI STL input iterator documentation&quot;&gt;input iterators&lt;/a&gt;, suitable only for single pass algorithms. Binary search doesn&amp;#8217;t need to take any backwards steps but it does need to be able copy its iterators and advance them repeatedly. As a minimum, then, it requires &lt;a href=&quot;http://www.sgi.com/tech/stl/ForwardIterator.html&quot; title=&quot;SGI STL forwards iterator documentation&quot;&gt;forwards iterators&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note the algorithm&amp;#8217;s &lt;a href=&quot;http://www.sgi.com/tech/stl/binary_search.html&quot;&gt;complexity&lt;/a&gt;!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The number of comparisons is logarithmic: at most &lt;code&gt;log(last - first) + 2&lt;/code&gt;. If ForwardIterator is a Random Access Iterator then the number of steps through the range is also logarithmic; otherwise, the number of steps is proportional to &lt;code&gt;last - first&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the case of our large file of numbers, comparisons are cheap; there&amp;#8217;s little point minimising them if we&amp;#8217;re going to take billions of short steps through the file. This is why we created a random access file iterator&lt;a id=&quot;fn1link&quot; href=&quot;https://wordaligned.org/articles/binary-search#fn1&quot;&gt;&lt;sup&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A more subtle point is that binary search deals with equivalence rather than equality: it only requires a less-than operator (or a comparison function), and returns true if it can find an element &lt;code&gt;x&lt;/code&gt; which satisfies &lt;code&gt;!(x &amp;lt; t) &amp;amp;&amp;amp; !(t &amp;lt; x)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The point I&amp;#8217;m making is that C++ does a nice job of separating algorithms and containers, which is why the same algorithm can be used on vectors, files, arrays etc. It also carefully defines minimum requirements on the types used by algorithms&lt;a id=&quot;fn2link&quot; href=&quot;https://wordaligned.org/articles/binary-search#fn2&quot;&gt;&lt;sup&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;stdbinary_search-limitations&quot;&gt;Std::binary_search() limitations&lt;/h3&gt;
&lt;p&gt;We noted earlier that &lt;code&gt;std::binary_search&lt;/code&gt; delivers nothing more than a binary result. Is the element there or not? From the SGI STL &lt;a href=&quot;http://www.sgi.com/tech/stl/binary_search.html&quot;&gt;documentation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that this is not necessarily the information you are interested in!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Even &lt;code&gt;bsearch&lt;/code&gt; tells us where it found the match; or rather, where it found &lt;b&gt;a&lt;/b&gt; match, since there could be several. This imprecision is one of &lt;code&gt;bsearch&lt;/code&gt;&amp;#8217;s failings &amp;#8212; but it really lets us down when it can&amp;#8217;t find the element: in this case, it subdivides the range until it finds where the element would be if it were there, realises there is no match, then throws all positional information away and returns a null pointer.&lt;/p&gt;
&lt;p&gt;Suppose our large file represents a set of numbers and we want to know where our test number should go in this file, if it isn&amp;#8217;t already present? A C++ binary search algorithm can do this, but it isn&amp;#8217;t &lt;code&gt;std::binary_search&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;locating-missing-elements&quot;&gt;Locating missing elements&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/london-marathon-2008.jpg&quot; alt=&quot;London Marathon, runners crossing Tower Bridge&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s another problem binary search can solve. Suppose we want to know how many runners finished the 2010 London marathon in a time between 3 and 4 hours. Let&amp;#8217;s suppose we&amp;#8217;ve already loaded the ordered finishing times into an array.&lt;/p&gt;
&lt;p&gt;We might try using &lt;code&gt;bsearch&lt;/code&gt; to find the position of the runners who finished with a time of exactly 3 hours and with a time of exactly 4 hours. Then the answer would be the difference between these two positions.&lt;/p&gt;
&lt;p&gt;There are two problems with this approach:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;what if no one finished with a time of &lt;strong&gt;exactly&lt;/strong&gt; 3 or 4 hours? &lt;/li&gt;
&lt;li&gt;what if more than one runner finished with a time of exactly 3 or 4 hours?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the first case &lt;code&gt;bsearch&lt;/code&gt; returns a null pointer and we can&amp;#8217;t complete our calculation. In the second case, &lt;code&gt;bsearch&lt;/code&gt; makes no guarantees about which of the equally-placed runners it will find, and even if we can make our calculation, we cannot be sure it is correct.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Bsearch&lt;/code&gt; is not much use, then, but a binary search can give us our answer. &lt;/p&gt;
&lt;p&gt;Imagine we had a late result for the race, a runner who recorded a time of exactly 3 hours. What&amp;#8217;s the first position in the array at which we could place this runner, whilst maintaining the array ordering? Similarly, where&amp;#8217;s the first position at which we could insert a runner with a time of 4 hours, maintaining the array ordering. Both these positions are well defined and precise &amp;#8212; even if everyone finished the race in less than 3 hours, or even if no one ran the race &amp;#8212; and the correct answer is their difference.&lt;/p&gt;
&lt;h3 id=&quot;lower_bound&quot;&gt;Lower_bound&lt;/h3&gt;
&lt;p&gt;C++ supplies just such an algorithm. It goes by the name of &lt;a href=&quot;http://www.sgi.com/tech/stl/lower_bound.html&quot;&gt;&lt;code&gt;std::lower_bound&lt;/code&gt;&lt;/a&gt;, but really it&amp;#8217;s good old binary search. We want to find the first place our target element could go, whilst maintaining the ordering, which we do by repeatedly splitting the range.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;while the range is non-empty&lt;/li&gt;
&lt;li&gt;look at the element in the middle of the range&lt;/li&gt;
&lt;li&gt;is its value less than the target value?&lt;/li&gt;
&lt;li&gt;if so, continue looking in the top half of the range&lt;/li&gt;
&lt;li&gt;if not, continue looking in the bottom half of the range&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The while loop exits when the range has been reduced to a single point and this point is what we return. On my platform, the code itself reads a bit like:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template&amp;lt;typename fwd_it, typename t&amp;gt;
fwd_it
lower_bound(fwd_it first, fwd_it last, const t &amp;amp; val)
{
    typedef typename iterator_traits&amp;lt;fwd_it&amp;gt;::difference_type distance;

    distance len = std::distance(first, last);
    distance half;
    fwd_it middle;

    while (len &amp;gt; 0)
    {
        half = len &amp;gt;&amp;gt; 1;
        middle = first;
        std::advance(middle, half);
        if (*middle &amp;lt; val)
        {
            first = middle;
            ++first;
            len = len - half - 1;
        }
        else
            len = half;
    }
    return first;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I think this version of binary search is &lt;a href=&quot;https://wordaligned.org/articles/next-permutation.html&quot; title=&quot;Next_permutation: when C++ gets it right&quot;&gt;yet another gem from the C++ standard library&lt;/a&gt;. As Jon Bentley and Mike Taylor eloquently point out, the implementation is subtle &amp;#8212; in particular, if &lt;code&gt;(*middle &amp;lt; val)&lt;/code&gt; we must eliminate &lt;code&gt;middle&lt;/code&gt; or risk an infinite loop &amp;#8212; but by tightening the problem specification and paring back the requirements we&amp;#8217;ve created a function which is far more useful than &lt;code&gt;bsearch&lt;/code&gt; and arguably simpler to code.&lt;/p&gt;
&lt;p&gt;For comparison, here&amp;#8217;s the &lt;code&gt;bsearch&lt;/code&gt; implemented by glibc, version 2.11.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;/* Perform a binary search for KEY in BASE which has NMEMB elements
   of SIZE bytes each.  The comparisons are done by (*COMPAR)().  */
void *
bsearch (const void *key, const void *base, size_t nmemb, size_t size,
         int (*compar) (const void *, const void *))
{
  size_t l, u, idx;
  const void *p;
  int comparison;

  l = 0;
  u = nmemb;
  while (l &amp;lt; u)
    {
      idx = (l + u) / 2;
      p = (void *) (((const char *) base) + (idx * size));
      comparison = (*compar) (key, p);
      if (comparison &amp;lt; 0)
        u = idx;
      else if (comparison &amp;gt; 0)
        l = idx + 1;
      else
        return (void *) p;
    }

  return NULL;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;binary-search-variants&quot;&gt;Binary search variants&lt;/h3&gt;
&lt;p&gt;On my platform, &lt;code&gt;std::binary_search&lt;/code&gt; is built directly on &lt;code&gt;std::lower_bound&lt;/code&gt;. Here&amp;#8217;s the code.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template&amp;lt;typename fwd_it, typename t&amp;gt;
fwd_it
lower_bound(fwd_it first, fwd_it last, const t &amp;amp; val)
{
    fwd_it i = std::lower_bound(first, last, val);
    return i != last &amp;amp;&amp;amp; !(val &amp;lt; *i);
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Std::upper_bound&lt;/code&gt; searches a sorted range to find the last position an item could be inserted without changing the ordering.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Std::equal_range&lt;/code&gt; returns a pair of iterators, logically equal to &lt;code&gt;make_pair(lower_bound(...), upper_bound(...))&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;iterating-over-numbers-in-a-file&quot;&gt;Iterating over numbers in a file&lt;/h3&gt;
&lt;p&gt;The iterator class I created to use &lt;code&gt;std::binary_search&lt;/code&gt; on an file containing fixed width binary formatted numbers appears below. To determine whether the file &lt;code&gt;numbers.bin&lt;/code&gt; contains the target value &lt;code&gt;288230376151711744&lt;/code&gt;, we would write something like:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;algorithm&amp;gt;

....

    typedef binary_file_number_iter&amp;lt;long long, 8&amp;gt; iter;
    long long target = 288230376151711744LL;

    bool found = std::binary_search(iter(&quot;numbers.bin&quot;, iter::begin),
                                    iter(&quot;numbers.bin&quot;, iter::end),
                                    target);

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;To test the performance of these iterators I created a 5GB binary file packed with 8 byte numbers. These numbers were multiples of 3:&lt;/p&gt;
&lt;pre title=&quot;File contents&quot;&gt;
0, 3, 6, 9, ..., 2015231997
&lt;/pre&gt;

&lt;p&gt;I then timed how long it took to search this file for 10 interesting numbers (and to confirm the returned results were as expected).&lt;/p&gt;
&lt;pre title=&quot;Seach targets&quot;&gt;
-1, 0, 1, 2, 1007616000, 1007616001, 1007616002, 1007616003, 2015231997, 2015232000
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Binary_search()&lt;/code&gt; recorded a time of 0.308 seconds on a rather old MacBook&lt;a id=&quot;fn3link&quot; href=&quot;https://wordaligned.org/articles/binary-search#fn3&quot;&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;. Using a hand-coded linear search the run time was just over 38 minutes. That is, the binary search ran 7000 times faster on this sample.&lt;/p&gt;
&lt;p&gt;Interestingly, repeated runs of the binary search test using the same input file and the same targets ran in an average time of just 0.030 seconds, a 10-fold times speed up over the first run. Similarly repeating the linear search showed no such improvement. I&amp;#8217;m attributing this to operating system file caching, but I don&amp;#8217;t pretend to know exactly what&amp;#8217;s going on here. (My thanks to Michal Mocny for his explanation in the &lt;a href=&quot;https://wordaligned.org/articles/binary-search#comment-49972118&quot;&gt;comments&lt;/a&gt; below).&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Binary file number iterator&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#ifndef BINARY_FILE_NUMBER_ITERATOR_HPP_INCLUDED
#define BINARY_FILE_NUMBER_ITERATOR_HPP_INCLUDED

#include &amp;lt;fstream&amp;gt;
#include &amp;lt;ios&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iterator&amp;gt;
#include &amp;lt;stdexcept&amp;gt;

// File read error, thrown when low level file access fails.
class file_read_error : public std::runtime_error
{
public:
    file_read_error(std::string const &amp;amp; what)
        : std::runtime_error(what)
    {
    }
};


// This iterator class is used for numbers packed into a file
// using a fixed width binary format. Numbers must be packed
// most significant byte first.
//
// The file is not read into memory. Iterators are moved by
// file seeking and dereferenced by reading from the file.
//
// These iterators declare themselves to be random access
// iterators but a file is not usually a random access device.
// For example, advancing an iterator a large distance may well
// take longer than advancing a small distance.
template &amp;lt;typename number, int number_size&amp;gt;
class binary_file_number_iter
{
    typedef binary_file_number_iter&amp;lt;number, number_size&amp;gt; iter;

private: // Sanity
    // Check things are OK, closing the stream and throwing an error on failure.
    void check(bool ok, std::string const &amp;amp; what)
    {
        if (!ok)
        {
            close();
            throw file_read_error(what);          
        }
    }

public: // Traits typedefs, which make this class usable with
        // algorithms which need a random access iterator.
    typedef std::random_access_iterator_tag iterator_category;
    typedef number value_type;
    typedef std::streamoff difference_type;
    typedef number * pointer;
    typedef number &amp;amp; reference;

public:
    static int const number_width = number_size;

public: // Enum used to construct begin, end iterators
    enum start_pos { begin, end };

public: // Lifecycle
    binary_file_number_iter(std::string const &amp;amp; filename,
                            start_pos where = begin)
        : filename(filename)
        , pos(-1)
    {
        open();
        if (where == end)
        {
            seek_end();
        }
    }

    binary_file_number_iter()
        : pos(-1)
    {
    }

    binary_file_number_iter(iter const &amp;amp; other)
        : filename(other.filename)
    {
        open();
        setpos(other.pos);
    }

    ~binary_file_number_iter()
    {
        close();
    }

    iter &amp;amp; operator=(iter const &amp;amp; other)
    {
        close();
        filename = other.filename;
        open();
        setpos(other.pos);
        return *this;
    } 

public: // Comparison
        // Note: it is an error to compare iterators into different files.
    bool operator&amp;lt;(iter const &amp;amp; other) const
    {
        return pos &amp;lt; other.pos;
    }

    bool operator&amp;gt;(iter const &amp;amp; other) const
    {
        return pos &amp;gt; other.pos;
    }

    bool operator==(iter const &amp;amp; other) const
    {
        return pos == other.pos;
    }

    bool operator!=(iter const &amp;amp; other) const
    {
        return pos != other.pos;
    }

public: // Iteration
    iter &amp;amp; operator++()
    {
        return *this += 1;
    }

    iter &amp;amp; operator--()
    {
        return *this -= 1;
    }

    iter operator++(int)
    {
        iter tmp(*this);
        ++(*this);
        return tmp;
    }

    iter operator--(int)
    {
        iter tmp(*this);
        --(*this);
        return tmp;
    }

public: // Step
    iter &amp;amp; operator+=(difference_type n)
    {
        advance(n);
        return *this;
    }

    iter &amp;amp; operator-=(difference_type n)
    {
        advance(-n);
        return *this;
    }

    iter operator+(difference_type n)
    {
        iter result(*this);
        return result += n;
    }

    iter operator-(difference_type n)
    {
        iter result(*this);
        return result -= n;
    }

public: // Distance
    difference_type operator-(iter &amp;amp; other)
    {
        return (pos - other.pos) / number_size;
    }

public: // Access
    value_type operator*()
    {
        return (*this)[0];
    }

    value_type operator[](difference_type n)
    {
        std::streampos restore = getpos();
        advance(n);
        value_type const result = read();
        setpos(restore);
        return result;
    }

    // Allow access to the underlying stream position
    std::streampos getpos()
    {
        std::streampos s = in.tellg();
        check(in, &quot;getpos failed&quot;);
        return s;
    }
private: // Implementation details
    void open()
    {
        in.open(filename.c_str(), std::ios::binary);
        check(in, &quot;open failed&quot;);
        pos = getpos();
    }

    void close()
    {
        if (in.is_open())
        {
            in.close();
        }
    }

    void advance(difference_type n)
    {
        check(in.seekg(n * number_size, std::ios_base::cur), &quot;advance failed&quot;);
        pos = getpos();
    }

    void seek_end()
    {
        check(in.seekg(0, std::ios_base::end), &quot;seek_end failed&quot;);
        pos = getpos();
    }

    void setpos(std::streampos newpos)
    {
        check(in.seekg(newpos), &quot;setpos failed&quot;);
        pos = newpos;
    }

    value_type read()
    {
        number n = 0;
        unsigned char buf[number_size];
        check(in.read((char *)buf, number_size), &quot;read failed&quot;);

        for (int i = 0; i != number_size; ++i)
        {
            n &amp;lt;&amp;lt;= 8;
            n |= buf[i];
        }
        return n;
    }

private: // State
    std::string filename;
    std::ifstream in;
    std::streampos pos;
};

#endif // BINARY_FILE_NUMBER_ITERATOR_HPP_INCLUDED

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here are some basic tests for the binary file number iterator.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Test binary file number iterator&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;ext/algorithm&amp;gt; // For Gnu&amp;#x27;s non-standard is_sorted
#include &amp;lt;iostream&amp;gt;

#include &quot;binary_file_number_iterator.hpp&quot;

typedef binary_file_number_iter&amp;lt;long long, 8&amp;gt; iter8;
typedef binary_file_number_iter&amp;lt;int, 4&amp;gt; iter4;
typedef binary_file_number_iter&amp;lt;short, 2&amp;gt; iter2;
typedef binary_file_number_iter&amp;lt;char, 1&amp;gt; iter1;

template &amp;lt;typename fwd_it&amp;gt;
bool is_sorted(fwd_it beg, fwd_it end)
{
    return __gnu_cxx::is_sorted(beg, end);
}

char const * empty_test_file(char const * name)
{
    std::ofstream ofile;
    ofile.open(name);
    ofile.close();
    return name;
}

/*
  Create a small test file containing numbers, in ascending order,
  for number sizes 1, 2, 4 and 8 bytes.

  A hex view of the file looks like:

  0000 0000 0000 0000 0303 0303 0303 0303
  0606 0606 0606 0606 0909 0909 0909 0909
  0c0c 0c0c 0c0c 0c0c 0f0f 0f0f 0f0f 0f0f
*/
char const * basic_test_file(char const * name)
{
    std::ofstream ofile;
    ofile.open(name);
    for (unsigned char i = 0; i != 18; i += 3)
        for (unsigned j = 0; j != 8; ++j)
            ofile &amp;lt;&amp;lt; i;            
    ofile.close();
    return name;
}

void empty_file_tests()
{
    char const * empty_file = empty_test_file(&quot;empty_test_file&quot;);
    iter1 beg(empty_file, iter1::begin);
    iter1 end(empty_file, iter1::end);
    assert(beg == end);
    assert(std::lower_bound(beg, end, -1) == end);
    assert(std::upper_bound(beg, end, -1) == end);
    assert(!std::binary_search(beg, end, 0));
    assert(std::equal_range(beg, end, -1) == std::make_pair(beg, beg));
}

template &amp;lt;typename value_type&amp;gt;
value_type repeat(int v, int w)
{
    value_type result = 0;
    while (w-- != 0)
    {
        result &amp;lt;&amp;lt;= 8;
        result |= v;
    }
    return result;
}

template &amp;lt;typename iter&amp;gt;
void basic_file_tests()
{
    char const * basic_file = basic_test_file(&quot;basic_test_file&quot;);

    typedef typename iter::value_type value_t;
    typedef typename std::pair&amp;lt;iter, iter&amp;gt; range;
    int const w = iter::number_width;

    iter beg(basic_file, iter::begin);
    iter end(basic_file, iter::end);
    assert(beg &amp;lt; end);
    assert(!(beg &amp;gt; end));
    assert(!(beg == end));
    assert(beg != end);
    assert(end - beg == 48 / w);

    iter mid = beg;
    assert(mid[0] == 0);
    assert(mid[8/w] == repeat&amp;lt;value_t&amp;gt;(3, w));
    assert(*mid == 0);
    assert(*mid++ == 0);
    assert(*--mid == 0);
    assert(*(mid += 16/w) == repeat&amp;lt;value_t&amp;gt;(6, w));
    assert(mid &amp;lt; end);
    assert(mid &amp;gt; beg);

    assert(is_sorted(beg, end));
    assert(std::lower_bound(beg, mid, -1) == beg);
    assert(std::lower_bound(beg, mid, 0) == beg);
    assert(std::upper_bound(beg, mid, 0) == beg + 8/w);
    assert(std::upper_bound(beg, mid, 1) == beg + 8/w);
    assert(std::binary_search(beg, end, 0));
    assert(std::binary_search(beg, end, repeat&amp;lt;value_t&amp;gt;(0xf, w)));

    mid = beg + 8/w;
    assert(std::equal_range(beg, end, 0) == std::make_pair(beg, mid));
    assert(std::equal_range(beg, end, 1) == std::make_pair(mid, mid));
}

int main()
{
    empty_file_tests();
    basic_file_tests&amp;lt;iter1&amp;gt;();
    basic_file_tests&amp;lt;iter2&amp;gt;();
    basic_file_tests&amp;lt;iter4&amp;gt;();
    basic_file_tests&amp;lt;iter8&amp;gt;();
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;triple-fail&quot;&gt;Triple fail&lt;/h3&gt;
&lt;p&gt;In this article we&amp;#8217;ve discussed binary search:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;referring to existing implementations&lt;/li&gt;
&lt;li&gt;calling library routines, such as &lt;code&gt;std::binary_search&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;and written some tests.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Despite this indiscipline, we never even bothered to roll our own binary search: we&amp;#8217;ve tackled the exact opposite of the problem which Mike Taylor set. Programming tasks rarely start with a clear specification, and even if they do, the specification needs questioning.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;
&lt;p&gt;My thanks to &lt;a href=&quot;http://www.flickr.com/photos/pinprick/&quot;&gt;pinprick&lt;/a&gt; for the &lt;a href=&quot;http://www.flickr.com/photos/pinprick/2547648374&quot;&gt;cheese&lt;/a&gt; &lt;a href=&quot;http://www.flickr.com/photos/pinprick/2546825997&quot;&gt;photos&lt;/a&gt;, and for this delicious description.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;morbier is a soft-ripened, washed rind cheese. the tradition of bathing the rinds in salty water (or strong ale) goes back to trappist monks, who perfected the art. washing the rind makes it tougher, protecting the cheese and making it last longer. washing the rind also makes it a place where a certain bacteria, b. linens, love to hang out. while they work their magic, making the cheese inside smooth and creamy and silky, they also make the outside stinky. there isn&amp;#8217;t any good way to put it. however, most stinky cheese taste amazing, and once you realize that, you find that you love the smell of stinky cheese. stink on the outside means gold on the inside! 
&amp;#8212; &lt;a href=&quot;http://www.flickr.com/photos/pinprick/2547648374&quot;&gt;pinprick&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;How long before flickr implements scratch and sniff?&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a id=&quot;fn1&quot; href=&quot;https://wordaligned.org/articles/binary-search#fn1link&quot;&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/a&gt;: Well, something which masquerades as a random access iterator. Files are not usually random access devices, and the time taken by a seek operation may well vary with the seek offset. By supplying random access scaffolding, we at least ensure that a single, efficient, seek operation is used each time we advance the file position. &lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn2&quot; href=&quot;https://wordaligned.org/articles/binary-search#fn2link&quot;&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/a&gt;: The C++ standard describes the requirements on types in some detail. Unfortunately C++ implementations provide little support for enforcing these requirements. Violations are likely to be punished by &lt;a href=&quot;https://wordaligned.org/articles/koenigs-first-rule-of-debugging.html#a-problem-on-line-106&quot;&gt;grotesque compiler warnings&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn3&quot; href=&quot;https://wordaligned.org/articles/binary-search#fn3link&quot;&gt;[3]&lt;/a&gt;: The laptop specification:&lt;/p&gt;
&lt;pre&gt;
Hardware Overview:
  Model Name:               MacBook
  Model Identifier:     MacBook1,1
  Processor Name:       Intel Core Duo
  Processor Speed:      2 GHz
  Number Of Processors:     1
  Total Number Of Cores:    2
  L2 Cache (per processor): 2 MB
  Memory:                   2 GB
  Bus Speed:                667 MHz
&lt;/pre&gt;</description>
<dc:date>2010-05-12</dc:date>
<guid>https://wordaligned.org/articles/binary-search</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/binary-search</link>
<category>C++</category>
</item>

<item>
<title>Next permutation: When C++ gets it right</title>
<description>&lt;h3 id=&quot;the-next-number-problem&quot;&gt;The Next Number Problem&lt;/h3&gt;
&lt;p&gt;Suppose you have a fixed list of digits chosen from the range 1..9. What numbers can you make with them? You&amp;#8217;re allowed as many zeros as you want. Write the numbers in increasing order.&lt;/p&gt;
&lt;p&gt;Exactly &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=p1&quot;&gt;this puzzle&lt;/a&gt; came up in the recent &lt;a href=&quot;http://code.google.com/codejam&quot;&gt;Google Code Jam&lt;/a&gt; programming contest:&lt;/p&gt;
&lt;blockquote&gt;You are writing out a list of numbers. Your list contains all numbers with exactly &lt;strong&gt;D&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt; digits in its decimal representation which are equal to i, for each i between 1 and 9, inclusive. You are writing them out in ascending order.&lt;/p&gt;&lt;p&gt;For example, you might be writing every number with two &amp;#8216;1&amp;#8217;s and one &amp;#8216;5&amp;#8217;. Your list would begin 115, 151, 511, 1015, 1051.&lt;/p&gt;&lt;p&gt;Given N, the last number you wrote, compute what the next number in the list will be.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The competition has closed now, but if you&amp;#8217;d like to give it a go sample input files can be found on the &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=p1&quot;&gt;website&lt;/a&gt;, where you can also upload your results and have them checked.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a short section from a trial I ran on my computer. Input numbers are in the left-hand column: the corresponding output numbers are in the right-hand column.&lt;/p&gt;
&lt;pre style=&quot;font-size:150%&quot;&gt;
50110812884911623516 &amp;rarr; 50110812884911623561
82454322474161687049 &amp;rarr; 82454322474161687094
82040229261723155710 &amp;rarr; 82040229261723157015
43888989554234187388 &amp;rarr; 43888989554234187838
76080994872481480636 &amp;rarr; 76080994872481480663
31000989133449480678 &amp;rarr; 31000989133449480687
20347716554681051891 &amp;rarr; 20347716554681051918
&lt;/pre&gt;

&lt;h3 id=&quot;choice-of-algorithm&quot;&gt;Choice of Algorithm&lt;/h3&gt;
&lt;p&gt;Like many of the code jam challenges, you&amp;#8217;ll need to write a program which runs fast enough; but choosing the right algorithm is more important than choosing the right language. Typically a high-level interpreted language like Python allows me to code and test a solution far more quickly than using a low-level language like C or C++.&lt;/p&gt;
&lt;p&gt;In this particular case, though, like most &lt;a href=&quot;http://www.go-hero.net/jam/09/problems/2/2&quot;&gt;successful candidates&lt;/a&gt;, I used C++. &lt;a href=&quot;http://www.sgi.com/tech/stl/next_permutation.html&quot;&gt;Here&amp;#8217;s why&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sgi.com/tech/stl/next_permutation.html&quot;&gt;&lt;code&gt;Next_permutation&lt;/code&gt;&lt;/a&gt; transforms the range of elements &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically next greater permutation of the elements. [&amp;#8230;] If such a permutation exists, &lt;code&gt;next_permutation&lt;/code&gt; transforms &lt;code&gt;[first, last)&lt;/code&gt; into that permutation and returns true. Otherwise it transforms &lt;code&gt;[first, last)&lt;/code&gt; into the lexicographically smallest permutation and returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Although the next number problem appears to be about numbers and lexicographical ordering appears to be about words, &lt;code&gt;std::next_permutation&lt;/code&gt; is exactly what&amp;#8217;s needed here.&lt;/p&gt;
&lt;h3 id=&quot;lexicographical-ordering&quot;&gt;Lexicographical Ordering&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/thomasguest/4099819327/&quot; title=&quot;Lexicographical order by Thomas Guest, on Flickr&quot;&gt;&lt;img src=&quot;http://farm3.static.flickr.com/2449/4099819327_4063635302.jpg&quot; width=&quot;500&quot; height=&quot;216&quot; alt=&quot;Lexicographical order&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A dictionary provides the canonical example of lexicographical ordering. Words are built from characters, which can be alphabetically ordered A, B, C, &amp;#8230; , so in the dictionary words which begin with &lt;strong&gt;A&lt;/strong&gt; appear before words which begin with &lt;strong&gt;B&lt;/strong&gt;, which themselves come in front of words beginning with &lt;strong&gt;C&lt;/strong&gt;, etc. If two words start with the same letter, pop that letter from the head of the word and compare their tails, which puts AARDVARK before ANIMAL, and &amp;#8212; applying this rule recursively &amp;#8212; after &lt;a href=&quot;http://www.aardman.com/&quot; title=&quot;Bristol&#x27;s finest&quot;&gt;AARDMAN&lt;/a&gt;. Imagine there&amp;#8217;s an empty word marking position zero, before A, right at the front of the dictionary, and our recursive  definition is complete.&lt;/p&gt;
&lt;h3 id=&quot;next-permutation-in-action&quot;&gt;Next permutation in action&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a simple program which shows &lt;code&gt;next_permutation()&lt;/code&gt; in action.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int main()
{
    char xs[] = &quot;123&quot;;
    do
    {
        std::puts(xs);
    }
    while (std::next_permutation(xs, xs + sizeof(xs) - 1));
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This program outputs lexicographically ordered permutations of 1, 2 and 3. When the main function returns, the array &lt;code&gt;xs&lt;/code&gt; will have cycled round to hold the lexicographically smallest arrangement of its elements, which is &lt;code&gt;&quot;123&quot;&lt;/code&gt;. Note that we never convert the characters &lt;code&gt;&#x27;1&#x27;&lt;/code&gt;, &lt;code&gt;&#x27;2&#x27;&lt;/code&gt;, &lt;code&gt;&#x27;3&#x27;&lt;/code&gt; into the numbers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;. The values of both sets of data types appear in the same order, so all works as expected.&lt;/p&gt;
&lt;pre&gt;
123
132
213
231
312
321
&lt;/pre&gt;

&lt;p&gt;If we tweak and rerun the same program with &lt;code&gt;xs&lt;/code&gt; initialised to &lt;code&gt;&quot;AAADKRRV&quot;&lt;/code&gt; we get rather more output.&lt;/p&gt;
&lt;pre&gt;
AAADKRRV
AAADKRVR
AAADKVRR
...
AARDVARK
...
VRRKAADA
VRRKADAA
VRRKDAAA
&lt;/pre&gt;

&lt;p&gt;The sequence &lt;strong&gt;doesn&amp;#8217;t&lt;/strong&gt; start by repeating &lt;code&gt;&quot;AAADKRRV&quot;&lt;/code&gt; 6 times, once for every permutation of the 3 A&amp;#8217;s. Only strictly increasing permutations are included. And although the repeated calls to &lt;code&gt;next_permutation&lt;/code&gt; generate a series of permutations, the algorithm holds no state. Each function call works on its input range afresh.&lt;/p&gt;
&lt;p&gt;This second run of the program yields 3360 lines of output, even though there are 8! = 40320 possible permutations of 8 characters. Each unique permutation corresponds to 3! &amp;times; 2! = 12 actual permutations of the 8 characters (because there are 3 A&amp;#8217;s and 2 R&amp;#8217;s), and 40320 &amp;divide; 12 is 3360.&lt;/p&gt;
&lt;h3 id=&quot;snail-sorts-revenge&quot;&gt;Snail sort&amp;#8217;s revenge&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/tim_norris/2789759648/&quot;&gt;&lt;img src=&quot;http://farm4.static.flickr.com/3143/2789759648_ab4bfb5ea8.jpg&quot; width=&quot;500px&quot; height=&quot;333px&quot; alt=&quot;...and in last place. By Tim Norris&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As you can see, &lt;code&gt;next_permutation&lt;/code&gt; sorts an input range, one step at a time.  When &lt;code&gt;next_permutation&lt;/code&gt; eventually returns false, the range will be perfectly ordered. Hence we have &lt;code&gt;snail_sort()&lt;/code&gt;, hailed by the SGI STL &lt;a href=&quot;http://www.sgi.com/tech/stl/next_permutation.html&quot;&gt;documentation&lt;/a&gt; as the worst known deterministic sorting algorithm.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template &amp;lt;class Iter&amp;gt; 
void snail_sort(Iter first, Iter last)
{
    while (next_permutation(first, last)) {}
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Very witty, and evidence that code can be both &lt;a href=&quot;https://wordaligned.org/articles/elegance-and-efficiency.html&quot;&gt;elegant and inefficient&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In two important edge cases, though, &lt;code&gt;snail_sort&lt;/code&gt; performs on a par with super-charged &lt;code&gt;quicksort&lt;/code&gt;!&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I snail sorted an array filled with 100000000 zeros in 0.502 seconds. Running quicksort on the same array took 5.504 seconds. &lt;/li&gt;
&lt;li&gt;Starting with an array of the same size filled with the values 99999999, 99999998, 99999997, &amp;#8230; 1, 0 snail sort&amp;#8217;s 0.500 seconds trounced quicksort&amp;#8217;s 4.08 seconds.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;the-next-number-solved&quot;&gt;The Next Number, Solved&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s an outline solution to the &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=p1&quot;&gt;next number problem&lt;/a&gt;. (I&amp;#8217;ve glossed over the exact input and output file formats for clarity.) It reads numbers from standard input and writes next numbers to standard output. &lt;code&gt;Next_permutation&lt;/code&gt; does the hard work, and there&amp;#8217;s a bit of fiddling when we have to increase the number of digits by adding a zero.&lt;a id=&quot;fn1link&quot; href=&quot;https://wordaligned.org/articles/next-permutation#fn1&quot;&gt;&lt;sup&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

/*
 Given a string of digits, shift any leading &amp;#x27;0&amp;#x27;s
 past the first non-zero digit and insert an extra zero.

 Examples:

 123 -&amp;gt; 1023
 008 -&amp;gt; 8000
 034 -&amp;gt; 3004
*/
void insert_a_zero(std::string &amp;amp; number)
{
    size_t nzeros = number.find_first_not_of(&amp;#x27;0&amp;#x27;);
    number = number.substr(nzeros);
    number.insert(1, nzeros + 1, &amp;#x27;0&amp;#x27;);
}

/*
 Outline solution to the 2009 code jam Next Number problem.

 Given a string representing a decimal number, find the next
 number which can be formed from the same set of digits. Add
 another zero if necessary. Repeat for all such strings read
 from standard input.
*/
int main()
{
    std::string number;
    while (std::cin &amp;gt;&amp;gt; number)
    {
        if (!next_permutation(number.begin(), number.end()))
        {
            insert_a_zero(number);
        }
        std::cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    }
    return 0;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;implementation&quot;&gt;Implementation&lt;/h3&gt;
&lt;p&gt;Having used the C++ standard library to solve the puzzle, let&amp;#8217;s take a look at how it works. Next permutation is a clever algorithm which shuffles a collection in place. My system implements it like this&lt;a id=&quot;fn2link&quot; href=&quot;https://wordaligned.org/articles/next-permutation#fn2&quot;&gt;&lt;sup&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;

    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We start with a range delimited by a pair of bi-directional iterators, &lt;code&gt;[first, last)&lt;/code&gt;. If the range contains one item or fewer, there can be no next permutation, so leave the range as is and return &lt;code&gt;false&lt;/code&gt;. Otherwise, enter the &lt;code&gt;for&lt;/code&gt; loop with an iterator &lt;code&gt;i&lt;/code&gt; pointing at the final item in the range.&lt;/p&gt;
&lt;p&gt;At each pass through the body of this for loop we decrement &lt;code&gt;i&lt;/code&gt; by one, stepping towards the first item in the range. We are looking for one of two conditions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the value pointed to by &lt;code&gt;i&lt;/code&gt; is smaller than the one it pointed to previously&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; reaches into the first item in the range&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Put another way, we divide the range into a head and tail, where the tail is the longest possible decreasing tail of the range.&lt;/p&gt;
&lt;p&gt;If this tail is the whole range (the second condition listed above) then the whole range is in reverse order, and we have the lexicographical maximum formed from its elements. Reversing the range returns it to its lexicographical minimum, and we can return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If this tail is not the whole range, then the final item in the head of the range, the item &lt;code&gt;i&lt;/code&gt; points to, this item is smaller than at least one of the items in the tail of the range, and we can certainly generate a greater permutation by moving the item towards the end of the range. To find the next permutation, we reverse iterate from the end of the range until we find an item &lt;code&gt;*j&lt;/code&gt; bigger than &lt;code&gt;*i&lt;/code&gt; &amp;#8212; that&amp;#8217;s what the while loop does. Swapping the items pointed to by &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; ensures the head of the range is bigger than it was, and the tail of the range remains in reverse order. Finally, we reverse the tail of the range, leaving us with a permutation exactly one beyond the input permutation, and we return &lt;code&gt;true&lt;/code&gt;. &lt;/p&gt;
&lt;h3 id=&quot;whats-happening-here&quot;&gt;What&amp;#8217;s happening here?&lt;/h3&gt;
&lt;p&gt;It&amp;#8217;s clear from this paper analysis that the algorithm is of linear complexity. Essentially, it walks up and down the tail of the list, comparing and swapping. But why does it work?&lt;/p&gt;
&lt;p&gt;Let &lt;code&gt;xs&lt;/code&gt; be the range &lt;code&gt;(first, last)&lt;/code&gt;. As described above, divide this range into prefix and suffix subranges, &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, where &lt;code&gt;tail&lt;/code&gt; is the longest monotonically decreasing tail of the range.&lt;/p&gt;
&lt;p&gt;If the &lt;code&gt;head&lt;/code&gt; of the range is empty, then the range &lt;code&gt;xs&lt;/code&gt; is clearly at its lexicographical maximum. &lt;/p&gt;
&lt;p&gt;Otherwise, &lt;code&gt;tail&lt;/code&gt; is a lexicographical maximum of the elements it contains, and &lt;code&gt;xs&lt;/code&gt; is therefore the largest permutation which starts with the subrange &lt;code&gt;head&lt;/code&gt;. What will the &lt;code&gt;head&lt;/code&gt; of the next permutation be? We have to swap the final item in &lt;code&gt;head&lt;/code&gt; with the smallest item of &lt;code&gt;tail&lt;/code&gt; which exceeds it: the definition of &lt;code&gt;tail&lt;/code&gt; guarantees at least one such item exists. Now we want to permute the new &lt;code&gt;tail&lt;/code&gt; to be at a its lexicographical minimum, which is a matter of sorting it from low to high.&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;tail&lt;/code&gt; is in reverse order, finding the smallest item larger than &lt;code&gt;head[-1]&lt;/code&gt; is a matter of walking back from the end of the range to find the first such items; and once we&amp;#8217;ve swapped these items, &lt;code&gt;tail&lt;/code&gt; remains in reverse order, so a simple reversed will sort it.&lt;/p&gt;
&lt;p&gt;As an example consider finding the next permutation of:&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
8342666411
&lt;/pre&gt;

&lt;p&gt;The longest monotonically decreasing tail is &lt;code&gt;666411&lt;/code&gt;, and the corresponding head is &lt;code&gt;8342&lt;/code&gt;.&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
8342 666411
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;666411&lt;/code&gt; is, by definition, reverse-ordered, and cannot be increased by permuting its elements. To find the next permutation, we must increase the head; a matter of finding the smallest tail element larger than the head&amp;#8217;s final &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
834&lt;span style=&quot;color:#930&quot;&gt;2&lt;/span&gt; 666411
&lt;/pre&gt;

&lt;p&gt;Walking back from the end of tail, the first element greater than &lt;code&gt;2&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
834&lt;span style=&quot;color:#930&quot;&gt;2&lt;/span&gt;  666&lt;span style=&quot;color:#930&quot;&gt;4&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Swap the &lt;code&gt;2&lt;/code&gt; and the &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
834&lt;span style=&quot;color:#930&quot;&gt;4&lt;/span&gt; 666&lt;span style=&quot;color:#930&quot;&gt;2&lt;/span&gt;11
&lt;/pre&gt;

&lt;p&gt;Since head has increased, we now have a greater permutation. To reduce to the next permutation, we reverse tail, putting it into increasing order.&lt;/p&gt;
&lt;pre style=&quot;font-size:250%;&quot;&gt;
8344 112666
&lt;/pre&gt;

&lt;p&gt;Join the head and tail back together. The permutation one greater than &lt;code&gt;8342666411&lt;/code&gt; is &lt;code&gt;8344112666&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;beautiful-c&quot;&gt;Beautiful C++?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://wordaligned.org/articles/looping-forever-and-ever.html&quot;&gt;&lt;img  src=&quot;http://wordaligned.org/images/mite.jpg&quot; alt=&quot;for(;;) dust mite&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C++ has its &lt;a href=&quot;http://yosefk.com/c++fqa/defective.html&quot; title=&quot;If you are an expert in the intricacies of C++, please consider this knowledge a kind of martial art - something a real master never uses. Yossi Keinin&quot;&gt;detractors&lt;/a&gt;, who characterise it as subtle, &lt;a href=&quot;http://twitter.com/dabeaz/status/5677453478&quot; title=&quot;C++0x reminds me of blocks stacked by my toddler. Really wobbly and one block too many makes it topple. @dabeaz&quot;&gt;complex&lt;/a&gt;, and &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq.html#really-say-that&quot; title=&quot;C++ can blow your whole leg off. Bjarne Stroustrup&quot;&gt;dangerous&lt;/a&gt;; but sometimes it excels. Look once more at the C++ implementation of this algorithm.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;template&amp;lt;typename Iter&amp;gt;
bool next_permutation(Iter first, Iter last)
{
    if (first == last)
        return false;
    Iter i = first;
    ++i;
    if (i == last)
        return false;
    i = last;
    --i;

    for(;;)
    {
        Iter ii = i;
        --i;
        if (*i &amp;lt; *ii)
        {
            Iter j = last;
            while (!(*i &amp;lt; *--j))
            {}
            std::iter_swap(i, j);
            std::reverse(ii, last);
            return true;
        }
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span /&gt;With its special cases, boolean literals, multiple returns (4, count them!), disembodied and infinite loops, this code fails to exhibit conventional beauty. Yet &lt;em&gt;it is&lt;/em&gt; beautiful. All the next permutation algorithm needs are iterators which can advance forwards or backwards, step by step. And that&amp;#8217;s all this implementation uses.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m as excited as anyone by the mathematical rigour of &lt;a href=&quot;http://www.informit.com/articles/article.aspx?p=1407357&amp;amp;seqNum=3&quot; title=&quot;Great article by Andrei Alexandrescu, which questions a pure Haskell quicksort implementation&quot;&gt;functional programming&lt;/a&gt;, but sometimes computer science is about algorithms with virtually no space overhead, algorithms which loop rather than recurse. Sometimes it&amp;#8217;s about shuffling, nudging and swapping &amp;#8212; operations which map directly to the machine&amp;#8217;s most primitive operations. In such cases, C++ gets it right.&lt;/p&gt;
&lt;h3 id=&quot;permutations-in-python&quot;&gt;Permutations in Python&lt;/h3&gt;
&lt;p&gt;For the code jam, though, as mentioned earlier, having a super-fast program rarely matters. More often, it&amp;#8217;s about developing a fast enough program super-quickly.&lt;/p&gt;
&lt;p&gt;I find Python a far quicker language for developing code than C++. (Indeed, sometimes when it&amp;#8217;s obvious from the outset that a final program will need implementing in C++, I put together a working prototype using Python, which I then translate.) Could we solve the next number problem using code from the standard Python library?&lt;/p&gt;
&lt;p&gt;At a first glance, &lt;a href=&quot;http://docs.python.org/py3k/library/itertools.html#itertools.permutations&quot;&gt;itertools.permutations&lt;/a&gt; looks promising.&lt;/p&gt;
&lt;blockquote&gt;&lt;h3&gt;&lt;tt&gt;itertools.permutations(&lt;em&gt;iterable&lt;/em&gt;, &lt;em&gt;r=None&lt;/em&gt;)&lt;/tt&gt;&lt;/h3&gt;&lt;p&gt;Return successive &lt;em&gt;r&lt;/em&gt; length permutations of elements in the &lt;em&gt;iterable&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;If &lt;em&gt;r&lt;/em&gt; is not specified or is &lt;tt&gt;None&lt;/tt&gt;, then &lt;em&gt;r&lt;/em&gt; defaults to the length
of the &lt;em&gt;iterable&lt;/em&gt; and all possible full-length permutations
are generated.&lt;/p&gt;&lt;p&gt;Permutations are emitted in lexicographic sort order.  So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the permutation tuples will be produced in sorted order.&lt;/p&gt;&lt;p&gt;Elements are treated as unique based on their position, not on their value.  So if the input elements are unique, there will be no repeat values in each permutation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;However, this algorithm doesn&amp;#8217;t care about the values of the items in the iterable, and the lexicographic sort order applies to the indices of these items. So although the ordering of the generated items is well-defined:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;we get repeats, and&lt;/li&gt;
&lt;li&gt;it&amp;#8217;s not the ordering we want (in this case)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; concat = &amp;#x27;&amp;#x27;.join
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations(&amp;#x27;AAA&amp;#x27;)))
[&amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;, &amp;#x27;AAA&amp;#x27;]
&amp;gt;&amp;gt;&amp;gt; list(map(concat, permutations(&amp;#x27;231&amp;#x27;)))
[&amp;#x27;231&amp;#x27;, &amp;#x27;213&amp;#x27;, &amp;#x27;321&amp;#x27;, &amp;#x27;312&amp;#x27;, &amp;#x27;123&amp;#x27;, &amp;#x27;132&amp;#x27;]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It &lt;strong&gt;is&lt;/strong&gt; possible to code up &lt;code&gt;next_permutation&lt;/code&gt; using nothing more than the standard itertools, but it isn&amp;#8217;t advisable.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;Snail permute&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;from itertools import permutations, groupby

def next_permutation(xs):
    &quot;&quot;&quot;Calculate the next permutation of the sequence xs.

    Returns a pair (yn, xs&amp;#x27;), where yn is a boolean and xs&amp;#x27; is the 
    next permutation. If yn is True, xs&amp;#x27; will be the lexicographic 
    next permutation of xs, otherwise xs&amp;#x27; is the lexicographic 
    smallest permutation of xs.
    &quot;&quot;&quot;
    xs = tuple(xs)
    if not xs:
        return False, xs
    else:
        ps = [p for p, gp in groupby(sorted(permutations(xs)))]
        np = len(ps)
        ix = ps.index(xs) + 1
        if ix == len(ps):
            return False, ps[0]
        else:
            return True, ps[ix]

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;As it happens, a solution based on this exhaustive search would score points in the code jam since it copes with the small input set. For the large input set its factorial complexity rules it out, and we&amp;#8217;d need to implement the next permutation algorithm &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1&quot;&gt;from scratch&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a id=&quot;fn1&quot; href=&quot;https://wordaligned.org/articles/next-permutation#fn1link&quot;&gt;&lt;a href=&quot;https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/&quot;&gt;1&lt;/a&gt;&lt;/a&gt;: A more cunning &lt;a href=&quot;http://code.google.com/codejam/contest/dashboard?c=186264#s=a&amp;amp;a=1&quot;&gt;solution&lt;/a&gt; avoids the special case by pushing the extra zero to head of the string before applying &lt;code&gt;next_permutation&lt;/code&gt;, then popping it if it hasn&amp;#8217;t been moved.&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;fn2&quot; href=&quot;https://wordaligned.org/articles/next-permutation#fn2link&quot;&gt;&lt;a href=&quot;http://devcenter.wercker.com/docs/quickstarts/advanced/building-minimal-containers-with-go&quot;&gt;2&lt;/a&gt;&lt;/a&gt;: I&amp;#8217;ve tweaked the layout and parameter names for use on this site.&lt;/p&gt;</description>
<dc:date>2009-11-19</dc:date>
<guid>https://wordaligned.org/articles/next-permutation</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/next-permutation</link>
<category>C++</category>
</item>

<item>
<title>Code Rot</title>
<description>&lt;blockquote&gt;
&lt;p&gt;Those of us who have to tiptoe around non-standard or ancient compilers will know that template template parameters are off limits. &lt;/p&gt;
&lt;p&gt;&amp;#8212; &lt;a href=&quot;http://www.oxyware.com/CheckedInt.pdf&quot; title=&quot;CheckedInt: A policy-based range-checked integer, Hubert Matthews&quot;&gt;Hubert Matthews (PDF)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;dvbcodec-fail&quot;&gt;Dvbcodec Fail&lt;/h3&gt;
&lt;p&gt;Long ago, way back in 2004, I wrote an &lt;a href=&quot;http://wordaligned.org/docs/dvbcodec/index.html&quot;&gt;article&lt;/a&gt; for &lt;a href=&quot;http://accu.org/index.php/journals/241&quot; title=&quot;A Mini-project to decode a Mini-Language, Thomas Guest&quot;&gt;Overload&lt;/a&gt; describing how to use the &lt;a href=&quot;http://www.boost.org/doc/libs/1_39_0/libs/spirit/index.html&quot; title=&quot;Boost Spirit C++ parser framework&quot;&gt;Boost Spirit&lt;/a&gt; parser framework to generate C++ code which could convert structured binary data to text. I went on to republish this article on my own website, where I also included a source distribution.&lt;/p&gt;
&lt;p&gt;Much has changed since then. The C++ language may not have, but compiler and platform support for it has improved considerably. Boost survives &amp;#8212; indeed, many of its libraries will feed into the next version of C++. Overload thrives, adapting to an age when printed magazines about programming are all but extinct. My old website proved less durable: I&amp;#8217;ve changed domain name and shuffled things around more than once. But you can still find the article online if you look hard enough, and recently someone did indeed find it. He, let&amp;#8217;s call him Rick, downloaded the source code archive, &lt;a href=&quot;http://wordaligned.org/docs/dvbcodec/dvbcodec-1.0.zip&quot; title=&quot;Rotten dvbcodec source distribution&quot;&gt;dvbcodec-1.0.zip&lt;/a&gt;, extracted it, scanned the README, typed:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ make

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&amp;#8230; and discovered the code didn&amp;#8217;t even build.&lt;/p&gt;
&lt;p&gt;At this point many of us would assume (correctly) the code had not been maintained. We&amp;#8217;d delete it and write off the few minutes it took to evaluate it. Rick decided instead to contact me and let me know my code was broken. He even offered a fix for one problem.&lt;/p&gt;
&lt;h3 id=&quot;code-rot&quot;&gt;Code Rot&lt;/h3&gt;
&lt;p&gt;Sad to say, I wasn&amp;#8217;t entirely surprised. I no longer use this code. Unused code stops working. It decays.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m not talking about a compiled executable, which the compiler has tied to a particular platform, and which therefore progressively degrades as the platform advances. (I&amp;#8217;ve heard stories about device drivers for which the source code has long been lost, and which require ever more elaborate emulation shims to keep them alive.) I&amp;#8217;m talking about source code. And the decay isn&amp;#8217;t usually literal, though I suppose you might have a source listing on a mouldy printout, or an unreadable floppy disk.&lt;/p&gt;
&lt;p&gt;No, the code itself is usually a pristine copy of the original. Publishers often attach checksums to source distributions so readers can verify their download is correct. I hadn&amp;#8217;t taken this precaution with my &lt;code&gt;dvbcodec-1.0.zip&lt;/code&gt; but I&amp;#8217;m certain the version Rick downloaded was exactly the same as the one I created 5 years ago. Yet in that time it had stopped working. Why?&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;standard-c&quot;&gt;Standard C++&lt;/h3&gt;
&lt;p&gt;As already mentioned, this was C++ code. C++ is backed by an ISO standard, ratified in 1998, with corrigenda published in 2003. You might expect C++ code to improve with age, compiling and running more quickly, less likely to run out of resources.&lt;/p&gt;
&lt;p&gt;Not so. My favourite counter-example comes from a nice paper &lt;a href=&quot;http://www.oxyware.com/CheckedInt.pdf&quot; title=&quot;CheckedInt: A policy-based range-checked integer, Hubert Matthews&quot;&gt;&amp;#8220;CheckedInt: A policy-based range-checked integer&amp;#8221; (PDF)&lt;/a&gt; published by Hubert Matthews in 2004 which discusses how to use C++ templates to implement a range-checked integer. The paper includes a source code listing together with some notes to help readers forced to &amp;#8220;tiptoe around non-standard or ancient compilers&amp;#8221; (think: MSVC6). Yet when I experimented with this code in 2005 I found myself tripped up by a strict and up-to-date compiler.&lt;/p&gt;
&lt;pre&gt;
$ g++ -Wall -c checked_int.cpp
checked_int.cpp: In constructor `CheckedInt&amp;lt;low, high, ValueChecker&amp;gt;::CheckedInt(int)&#x27;:
checked_int.cpp:45: error: there are no arguments to `RangeCheck&#x27; that
depend on a template parameter, so a declaration of `RangeCheck&#x27; must
be available
checked_int.cpp:45: error: (if you use `-fpermissive&#x27;, G++ will accept
your code, but allowing the use of an undeclared name is deprecated)
&lt;/pre&gt;

&lt;p&gt;I emailed Hubert Matthews using the address included at the top of his paper. He swiftly and kindly put me straight on how to fix the problem.&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s interesting here is that this code is pure C++, just over a page of it. It has no dependencies on third party libraries. Hubert Matthews is a C++ expert and he acknowledges the help of two more experts, &lt;a href=&quot;http://erdani.org&quot; title=&quot;Author of Modern C++ and coauthor of C++ Coding Standards&quot;&gt;Andrei Alexandrescu&lt;/a&gt; and &lt;a href=&quot;http://curbralan.com&quot; title=&quot;Programming guru&quot;&gt;Kevlin Henney&lt;/a&gt;, in his paper. Yet the code fails to build using both ancient and modern compilers. In its published form it has the briefest of shelf-lives.&lt;/p&gt;
&lt;h3 id=&quot;support-rot&quot;&gt;Support Rot&lt;/h3&gt;
&lt;p&gt;Code alone is of limited use. What really matters for its ongoing health is that someone cares about it &amp;#8212; someone exercises, maintains and supports it. Hubert Matthews included an email address in his paper and I was able to contact him using that address.&lt;/p&gt;
&lt;p&gt;How well would my code shape up on this front? Putting myself in Rick&amp;#8217;s position, I unzipped the source distribution I&amp;#8217;d archived 5 years ago. I was pleased to find a README which, at the very top, provides a URL for updates, &lt;a href=&quot;http://homepage.ntlworld.com/thomas.guest&quot;&gt;http://homepage.ntlworld.com/thomas.guest&lt;/a&gt;. I was less pleased to find this URL gave me a &lt;strong&gt;404 Not Found&lt;/strong&gt; error. Similarly, when I tried emailling the project maintainer mentioned in the README, I got a &lt;strong&gt;550 Invalid recipient&lt;/strong&gt; error: the attempted delivery to &lt;a href=&quot;mailto:thomas.guest@ntlworld.com&quot;&gt;thomas.guest@ntlworld.com&lt;/a&gt; had failed permanently.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://homepage.ntlworld.com/thomas.guest&quot;&gt;&lt;img src=&quot;https://wordaligned.org/images/ntlworld-404.png&quot; alt=&quot;NTL World 404&quot; width=&quot;520px&quot; height=&quot;400px&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.w3.org/Provider/Style/URI&quot; title=&quot;Tim Berners-Lee&#x27;s classic advice on creating stable links&quot;&gt;Cool URIs don&amp;#8217;t change&lt;/a&gt; but my old NTL homepage was anything but cool; it came for free with a dial-up connection I&amp;#8217;ve happily since abandoned. Looking back, maybe I should have found a more stable location for my code. If I&amp;#8217;d set up (e.g.) a Sourceforge project then my &lt;code&gt;dvbcodec&lt;/code&gt; project might still be alive and supported, possibly even by a new maintainer.&lt;/p&gt;
&lt;h3 id=&quot;how-did-this-ever-compile&quot;&gt;How did this ever compile?&lt;/h3&gt;
&lt;p&gt;Wise hindsights wouldn&amp;#8217;t resurrect my code. If I wanted to continue I&amp;#8217;d have to go it alone. Here&amp;#8217;s what the README had to say about platform requirements.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;REQUIREMENTS and PLATFORMS&lt;/p&gt;
&lt;p&gt;To build the dvbcodec you will need Version 1.31.0 of Boost, or later.&lt;/p&gt;
&lt;p&gt;You will also need a good C++ compiler. The dvbcodec has been built and
   tested on the Windows operating system using: GCC 3.3.1, MSVC 7.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A &amp;#8220;good C++ compiler&amp;#8221;, eh? As we&amp;#8217;ve already seen, GCC 3.3.1 may be good but my platform has GCC 4.0.1 installed, which is better. If my records can be believed, this &lt;code&gt;upperCase()&lt;/code&gt; function compiled cleanly using both GCC 3.3.1 and MSVC 7.1.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;std::string
upperCase(std::string const &amp;amp; lower)
{
    std::string upper = lower;

    for (std::string&amp;lt;char&amp;gt;::iterator cc = upper.begin();
         cc != upper.end(); ++cc)
    {
        * cc = std::toupper(* cc);
    }

    return upper;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Huh? &lt;code&gt;Std::string&lt;/code&gt; is a typedef for &lt;code&gt;std::basic_string&amp;lt;char&amp;gt;&lt;/code&gt; and there&amp;#8217;s no such thing as a &lt;code&gt;std::basic_string&amp;lt;char&amp;gt;&amp;lt;char&amp;gt;::iterator&lt;/code&gt;, which is what GCC 4.0.1 says:&lt;/p&gt;
&lt;pre&gt;
stringutils.cpp:58: error: &#x27;std::string&#x27; is not a template
&lt;/pre&gt;

&lt;p&gt;The simple fix is to write &lt;code&gt;std::string::iterator&lt;/code&gt; instead of &lt;code&gt;std::string&amp;lt;char&amp;gt;::iterator&lt;/code&gt;. A better fix, suggested by Rick, is to use &lt;code&gt;std::transform()&lt;/code&gt;. I wonder why I missed this first time round?&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;std::string
upperCase(std::string const &amp;amp; lower)
{
    std::string upper = lower;
    std::transform(upper.begin(), upper.end(), upper.begin(), ::toupper);
    return upper;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id=&quot;boost-advances&quot;&gt;Boost advances&lt;/h3&gt;
&lt;p&gt;GCC has become stricter about what it accepts even though the formal specification of what it should do (the C++ standard) has stayed put. The Boost C++ libraries have more freedom to evolve, and the next round of build problems I encountered relate to Boost.Spirit&amp;#8217;s evolution. Whilst it would be possible to require dvbcodec users to build against Boost 1.31 (which can still be downloaded from the &lt;a href=&quot;http://www.boost.org&quot;&gt;Boost website&lt;/a&gt;) it wouldn&amp;#8217;t be reasonable. So I updated my machine (using Macports) to make sure I had an up to date version of Boost, 1.38 at the time of writing.&lt;/p&gt;
&lt;pre&gt;
$ sudo port upgrade boost
&lt;/pre&gt;

&lt;p&gt;Boost&amp;#8217;s various dependencies triggered an upgrade of boost-jam, gperf, libiconv, ncursesw, ncurses, gettext, zlib, bzip2, and this single command took over an hour to complete.&lt;/p&gt;
&lt;p&gt;I discovered that Boost.Spirit, the C++ parser framework on which &lt;code&gt;dvbcodec&lt;/code&gt; is based, has gone through an overhaul. According to the change log the flavour of Spirit used by &lt;code&gt;dvbcodec&lt;/code&gt; is now known respectfully as Spirit Classic. A clever use of namespaces and include path forwarding meant my &amp;#8220;classic&amp;#8221; client code would at least compile, at the expense of some deprecation warnings.&lt;/p&gt;
&lt;pre&gt;
Computing dependencies for decodeout.cpp...
Compiling decodeout.cpp...
In file included from codectypedefs.hpp:11,
                 from decodecontext.hpp:10,
                 from decodeout.cpp:8:
/opt/local/include/boost/spirit/tree/ast.hpp:18:4: warning: #warning &quot;This header is deprecated. Please use: boost/spirit/include/classic_ast.hpp&quot;
In file included from codectypedefs.hpp:12,
                 from decodecontext.hpp:10,
                 from decodeout.cpp:8:
&lt;/pre&gt;

&lt;p&gt;To suppress these warnings I included the preferred header. I then had to change namespace directives from &lt;code&gt;boost::spirit&lt;/code&gt; to &lt;code&gt;boost::spirit::classic&lt;/code&gt;. I fleetingly considered porting my code to Spirit V2, but decided against it: for even after this first round of changes, I still had a build problem.&lt;/p&gt;
&lt;h3 id=&quot;changing-behaviour&quot;&gt;Changing behaviour&lt;/h3&gt;
&lt;p&gt;Actually, this was a second level build problem. The &lt;code&gt;dvbcodec&lt;/code&gt; build has multiple phases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;it builds a program to generate code. This generator can parse binary format syntax descriptions and emit C++ code which will convert data formatted according to these descriptions&lt;/li&gt;
&lt;li&gt;it runs this generator with the available syntax descriptions as inputs&lt;/li&gt;
&lt;li&gt;it compiles the emitted C++ code into a final &lt;code&gt;dvbcodec&lt;/code&gt; executable&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://wordaligned.org/images/dvbcodec-build.png&quot; alt=&quot;Dvbcodec build process&quot;/&gt;&lt;/p&gt;
&lt;p&gt;I ran into a problem during the second phase of this process. The dvbcodec generator no longer parsed all of the supplied syntax descriptions. Specifically, I was seeing this conditional test raise an exception when trying to parse section format syntax descriptions.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;    if (!parse(section_format,
               section_grammar,
               space_p).full)
    {
        throw SectionFormatParseException(section_format);
    }

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;parse&lt;/code&gt; is &lt;code&gt;boost::spirit::classic::parse&lt;/code&gt;, which parses something &amp;#8212; the section format syntax description, passed as a string in this case &amp;#8212; according to the supplied grammar. The third parameter, &lt;code&gt;boost::spirit::classic::space_p&lt;/code&gt;, is a skip parser which tells &lt;code&gt;parse&lt;/code&gt; to skip whitespace between tokens. &lt;code&gt;Parse&lt;/code&gt; returns a &lt;code&gt;parse_info&lt;/code&gt; struct whose &lt;code&gt;full&lt;/code&gt; field is a boolean which will be set to &lt;code&gt;true&lt;/code&gt; if the input section format has been fully consumed.&lt;/p&gt;
&lt;p&gt;I soon figured out that the parse call was failing to fully consume binary syntax descriptions with trailing spaces, such as the the one shown below.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&quot; program_association_section() {&quot;
&quot;    table_id                   8&quot;
&quot;    section_syntax_indicator   1&quot;
&quot;    &amp;#x27;0&amp;#x27;                        1&quot;
....
&quot;    CRC_32                    32&quot;
&quot; }                              &quot;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;If I stripped the trailing whitespace after the closing brace before calling &lt;code&gt;parse()&lt;/code&gt; all would be fine. I wasn&amp;#8217;t fine about this fix though. The Spirit documentation is very good but it had been a while since I&amp;#8217;d read it and, as already mentioned, my code used the &amp;#8220;classic&amp;#8221; version of Spirit, in danger of becoming the &amp;#8220;legacy&amp;#8221; then &amp;#8220;deprecated&amp;#8221; and eventually the &amp;#8220;dead&amp;#8221; version. Re-reading the documentation it wasn&amp;#8217;t clear to me exactly what the correct behaviour of &lt;code&gt;parse()&lt;/code&gt; should be in this case. Should it fully consume trailing space? Had my program ever worked?&lt;/p&gt;
&lt;p&gt;I went back in time, downloading and building against Boost 1.31, and satisfied myself that my code used to work, though maybe it worked due to a bug in the old version of Spirit. Stripping trailing spaces before parsing allowed my code to work with Spirit past and present, so I curtailed my investigation and made the fix.&lt;/p&gt;
&lt;p&gt;(Interestingly, Boost 1.31 found a way to warn me I was using a compiler it didn&amp;#8217;t know about.&lt;/p&gt;
&lt;pre&gt;
boost_1_31_0/boost/config/compiler/gcc.hpp:92:7: warning: 
#warning &quot;Unknown compiler version - please run the configure tests and report the results&quot;
&lt;/pre&gt;

&lt;p&gt;I ignored this warning.)&lt;/p&gt;
&lt;h3 id=&quot;code-inaction&quot;&gt;Code inaction&lt;/h3&gt;
&lt;p&gt;Apologies for the lengthy explanation in the previous section. The point is, few software projects stand alone, and changes in any dependencies, &lt;strong&gt;including bug fixes&lt;/strong&gt;, can have knock on effects. In this instance, I consider myself lucky; &lt;code&gt;dvbcodec&lt;/code&gt;&amp;#8217;s unusual three phase build enabled me to catch a runtime error before generating the final product. Of course, to actually catch that error, I needed to at least try building my code.&lt;/p&gt;
&lt;p&gt;More simply: if you don&amp;#8217;t use your code, it rots.&lt;/p&gt;
&lt;h3 id=&quot;rotten-artefacts&quot;&gt;Rotten artefacts&lt;/h3&gt;
&lt;p&gt;It wasn&amp;#8217;t just the code which had gone off. My source distribution included documentation &amp;#8212; the plain text version of the article I&amp;#8217;d written for Overload &amp;#8212; and the Makefile had a build target to generate an HTML version of this documentation. This target depended on &lt;a href=&quot;http://www.boost.org/doc/tools/quickbook/index.html&quot; title=&quot;Quickbook, a Boost documentation tool&quot;&gt;Quickbook&lt;/a&gt;, another Boost tool. Quickbook generates Docbook XML from plain text source, and Docbook is a good starting point for HTML, PDF and other standard output formats.&lt;/p&gt;
&lt;p&gt;This is quite a sophisticated toolchain. It&amp;#8217;s also one I no longer use. Most of what I write goes straight to the web and I don&amp;#8217;t need such a fiddly process just to produce HTML. So I decided to freshen up dead links, leave the original documentation as a record, and simply cut the documentation target from the Makefile.&lt;/p&gt;
&lt;h3 id=&quot;stopping-the-rot&quot;&gt;Stopping the rot&lt;/h3&gt;
&lt;p&gt;As we&amp;#8217;ve seen, software, like other soft organic things, breaks down over time. How can we stop the rot?&lt;/p&gt;
&lt;p&gt;Freezing software to a particular executable built against a fixed set of dependencies to run on a single platform is one way &amp;#8212; and maybe some of us still have an aging Windows 95 machine, kept alive purely to run some such frozen program.&lt;/p&gt;
&lt;p&gt;A better solution is to actively tend the software and ensure it stays in shape. Exercise it regularly on a build server. Record test results. Fix faults as and when they appear. Review the architecture. Upgrade the platform and dependencies. Prune unused features, splice in new ones. This is the path taken by the Boost project, though certainly the growth far outpaces any pruning (the Boost 1.39 download is 5 times bigger than its 1.31 ancestor). Boost takes forwards and backwards compatibility seriously, hence the ongoing support for Spirit classic and the compiler version certification headers. Maintaining compatibility can be at odds with simplicity.&lt;/p&gt;
&lt;p&gt;There is another way too. Although the &lt;code&gt;dvbcodec&lt;/code&gt; project has collapsed into disrepair the idea behind it certainly hasn&amp;#8217;t. I&amp;#8217;ve taken this same idea &amp;#8212; of parsing formal syntax descriptions to generate code which handles binary formatted data &amp;#8212; and enhanced it to work more flexibly and with a wider range of inputs. Whenever I come across a new binary data structure, I paste its syntax into a text file, regenerate the code, and I can work with this structure. Unfortunately I can&amp;#8217;t show you any code (it&amp;#8217;s proprietary) but I hope I&amp;#8217;ve shown you the idea. Effectively, &lt;span /&gt;the old C++ code has been left to rot but the idea within it remains green, recoded in Python. Maybe I should find a way to humanely destroy the C++ and all links to it, but for now I&amp;#8217;ll let it degrade, an illustration of its time.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble? &amp;#8212; &lt;a href=&quot;http://www.cs.yale.edu/quotes.html&quot;&gt;Alan J. Perlis&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;
&lt;p&gt;I would like to thank to Rick Engelbrecht for reporting and helping to fix the bugs discussed in this article.&lt;/p&gt;
&lt;p&gt;This article first appeared in Overload 92, and I would like to thank the team at Overload for their expert help.&lt;/p&gt;</description>
<dc:date>2009-09-03</dc:date>
<guid>https://wordaligned.org/articles/code-rot</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/code-rot</link>
<category>C++</category>
</item>

<item>
<title>Converting integer literals in C++ and Python</title>
<description>&lt;p&gt;An integral literal in a C program can be decimal, hexadecimal or octal.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;int percent = 110;
unsigned flags = 0x80;
unsigned agent = 007;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;This snippet would be equivalent to (e.g.):&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;int percent = 0156;
unsigned flags = 128;
unsigned agent = 0x7;

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;So programmers can choose the best of these options when including numbers in their code.&lt;/p&gt;
&lt;p&gt;Python adopted this same C syntax, but has recently gone on to extend and modify it. Some Python 2.6 numbers:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;Python 2.6
&amp;gt;&amp;gt;&amp;gt; 0x80, 110, 007, 0O7, 0o7, 0b10000000
(128, 110, 7, 7, 7, 128)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;I&amp;#8217;m pleased to see support for binary literals, which are useful for (e.g.) bitmasks. I&amp;#8217;ve never really seen the point of &lt;a href=&quot;https://wordaligned.org/articles/octal-literals.html&quot;&gt;octals&lt;/a&gt;; nonetheless, they&amp;#8217;ve been enhanced for Python 3. Python 2.6 backports the new improved &lt;a href=&quot;http://www.python.org/dev/peps/pep-3127&quot;&gt;octal literal syntax&lt;/a&gt; whilst retaining support for classic C-style octals. Python 3 drops C-style octals.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;continue-reading&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;Python 3.1
&amp;gt;&amp;gt;&amp;gt; 007
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1
    007
      ^
SyntaxError: invalid token
&amp;gt;&amp;gt;&amp;gt; 0O7
7

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Now consider the compiler/interpreter writer&amp;#8217;s problem. Clearly it must be possible to take a string representing an integer literal and work out what number it represents. At a first glance, the &lt;a href=&quot;http://docs.python.org/library/functions.html#int&quot;&gt;int()&lt;/a&gt; builtin isn&amp;#8217;t quite smart enough to do the job without us supplying an explicit base for the conversion:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; int(&amp;#x27;0xff&amp;#x27;)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
ValueError: invalid literal for int() with base 10: &amp;#x27;0xff&amp;#x27;
&amp;gt;&amp;gt;&amp;gt; int(&amp;#x27;0xff&amp;#x27;, 16)
255

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We might consider reading any prefix from the literal and dispatching the string to an appropriate handler. Something like this:&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;def integer_literal_value(s):
    if s.startswith(&amp;#x27;0x&amp;#x27;):
        return int(s, 16)
    if s.startswith(&amp;#x27;0b&amp;#x27;):
        return int(s, 2)
    ...

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;Yuck! Surely there&amp;#8217;s an easier way to do something this fundamental? Well, there&amp;#8217;s always &lt;a href=&quot;http://docs.python.org/library/functions.html#eval&quot;&gt;eval()&lt;/a&gt;, which turns the interpreter on itself.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; def integer_literal_value(s): return eval(s)
... 
&amp;gt;&amp;gt;&amp;gt; v = integer_literal_value
&amp;gt;&amp;gt;&amp;gt; v(&amp;#x27;0x80&amp;#x27;), v(&amp;#x27;0o7&amp;#x27;), v(&amp;#x27;0b1010101&amp;#x27;), v(&amp;#x27;42&amp;#x27;)
(128, 7, 85, 42)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;We should have looked more carefully at the &lt;a href=&quot;http://docs.python.org/library/functions.html#int&quot;&gt;int()&lt;/a&gt; documentation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;int([x[, radix]])&lt;/strong&gt; &amp;#8230; The &lt;em&gt;radix&lt;/em&gt; parameter gives the base for the conversion (which is 10 by default) and may be any integer in the range [2, 36], or zero. If &lt;em&gt;radix&lt;/em&gt; is zero, the proper &lt;em&gt;radix&lt;/em&gt; is determined based on the contents of string; the interpretation is the same as for integer literals. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Perfect!&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from functools import partial
&amp;gt;&amp;gt;&amp;gt; integer_literal_value = partial(int, base=0)
&amp;gt;&amp;gt;&amp;gt; v = integer_literal_value
&amp;gt;&amp;gt;&amp;gt; v(&amp;#x27;0x80&amp;#x27;), v(&amp;#x27;0o7&amp;#x27;), v(&amp;#x27;0b1010101&amp;#x27;), v(&amp;#x27;42&amp;#x27;)
(128, 7, 85, 42)

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;(Notice, by the way, that &lt;em&gt;radix&lt;/em&gt; is used in the online documentation but the actual argument name is &lt;em&gt;base&lt;/em&gt;. I&amp;#8217;ll confess that before I wrote this note I hadn&amp;#8217;t spotted this use of zero as a special value for string&amp;rarr;integer conversions even though it&amp;#8217;s been available since Python 2.1)&lt;/p&gt;
&lt;p&gt;C++ also offers a way to convert integer literals into the numbers they represent, but it&amp;#8217;s not very well known. As is usual for format conversions, we use streams &amp;#8212; stringstreams typically, but here I show an example using standard input and output. The trick is to disable any numeric formatting of the input stream.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;&lt;div class=&quot;codetitle&quot;&gt;integer_literal_value.cpp&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    int x;
    std::cin.unsetf(std::ios::basefield);
    while (std::cin &amp;gt;&amp;gt; x)
    {
        std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    }
    return std::cin.eof() ? 0 : 1;
}

&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;It &lt;a href=&quot;http://www.cplusplus.com/reference/iostream/ios_base/fmtflags&quot;&gt;works by magic&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;typocode&quot;&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;$ g++ integer_literal_value.cpp -o integer_literal_value
$ echo 007 0x80 110 | ./integer_literal_value
7
128
110

&lt;/pre&gt;

&lt;/div&gt;</description>
<dc:date>2009-08-06</dc:date>
<guid>https://wordaligned.org/articles/integer-literal-values</guid>
<author>tag@wordaligned.org (Thomas Guest)</author>
<link>https://wordaligned.org/articles/integer-literal-values</link>
<category>C++</category>
</item>

</channel>
</rss>
